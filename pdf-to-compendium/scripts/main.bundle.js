/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _args__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _mappings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var _workers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12);




async function main(args) {
    try {
        let pdf_data = await (0,_workers__WEBPACK_IMPORTED_MODULE_3__.GetPdfDafa)(args.pdf_path);
        let json_schema = (0,_workers__WEBPACK_IMPORTED_MODULE_3__.JsonExtractor)(_mappings__WEBPACK_IMPORTED_MODULE_2__.GameSystem.Starfinder, pdf_data.title);
        if (json_schema === undefined) {
            console.log("schema not found");
            return;
        }
        if (args.no_schema === true) {
            await _workers__WEBPACK_IMPORTED_MODULE_3__.ImageSaver.printAllImages(args.output_path, pdf_data.images, _workers__WEBPACK_IMPORTED_MODULE_3__.ImageSaver.Extension.png);
        }
        else {
            Object.entries(json_schema.assets).forEach(async ([assetType, dictionary]) => {
                const folder = `${args.output_path}/${json_schema.name}/${assetType}`;
                await fs__WEBPACK_IMPORTED_MODULE_0___default().promises.mkdir(folder, { recursive: true });
                await _workers__WEBPACK_IMPORTED_MODULE_3__.ImageSaver.generateJNodeImages(folder, ['actor', 'token'], dictionary, pdf_data.images);
            });
        }
    }
    catch (error) {
        console.log(`Error running main: ${error}`);
    }
}
await main(_args__WEBPACK_IMPORTED_MODULE_1__.args);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),
/* 1 */
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   args: () => (/* binding */ args)
/* harmony export */ });
/* harmony import */ var argparse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var argparse__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(argparse__WEBPACK_IMPORTED_MODULE_0__);

const parser = new argparse__WEBPACK_IMPORTED_MODULE_0__.ArgumentParser({ description: "Extract some images" });
parser.add_argument('-n', '--no-schema', {
    default: 'false',
    action: "store_true",
    required: false,
    help: "If true exports all images from PDF to output folder",
});
parser.add_argument('pdf_path', {
    type: 'str',
    help: "The absolute file path to the PDF",
});
parser.add_argument('output_path', {
    type: 'str',
    help: "The output folder",
});
const args = parser.parse_args();


/***/ }),
/* 3 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Port of python's argparse module, version 3.9.0:
// https://github.com/python/cpython/blob/v3.9.0rc1/Lib/argparse.py



// Copyright (C) 2010-2020 Python Software Foundation.
// Copyright (C) 2020 argparse.js authors

/*
 * Command-line parsing library
 *
 * This module is an optparse-inspired command-line parsing library that:
 *
 *     - handles both optional and positional arguments
 *     - produces highly informative usage messages
 *     - supports parsers that dispatch to sub-parsers
 *
 * The following is a simple usage example that sums integers from the
 * command-line and writes the result to a file::
 *
 *     parser = argparse.ArgumentParser(
 *         description='sum the integers at the command line')
 *     parser.add_argument(
 *         'integers', metavar='int', nargs='+', type=int,
 *         help='an integer to be summed')
 *     parser.add_argument(
 *         '--log', default=sys.stdout, type=argparse.FileType('w'),
 *         help='the file where the sum should be written')
 *     args = parser.parse_args()
 *     args.log.write('%s' % sum(args.integers))
 *     args.log.close()
 *
 * The module contains the following public classes:
 *
 *     - ArgumentParser -- The main entry point for command-line parsing. As the
 *         example above shows, the add_argument() method is used to populate
 *         the parser with actions for optional and positional arguments. Then
 *         the parse_args() method is invoked to convert the args at the
 *         command-line into an object with attributes.
 *
 *     - ArgumentError -- The exception raised by ArgumentParser objects when
 *         there are errors with the parser's actions. Errors raised while
 *         parsing the command-line are caught by ArgumentParser and emitted
 *         as command-line messages.
 *
 *     - FileType -- A factory for defining types of files to be created. As the
 *         example above shows, instances of FileType are typically passed as
 *         the type= argument of add_argument() calls.
 *
 *     - Action -- The base class for parser actions. Typically actions are
 *         selected by passing strings like 'store_true' or 'append_const' to
 *         the action= argument of add_argument(). However, for greater
 *         customization of ArgumentParser actions, subclasses of Action may
 *         be defined and passed as the action= argument.
 *
 *     - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,
 *         ArgumentDefaultsHelpFormatter -- Formatter classes which
 *         may be passed as the formatter_class= argument to the
 *         ArgumentParser constructor. HelpFormatter is the default,
 *         RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser
 *         not to change the formatting for help text, and
 *         ArgumentDefaultsHelpFormatter adds information about argument defaults
 *         to the help.
 *
 * All other classes in this module are considered implementation details.
 * (Also note that HelpFormatter and RawDescriptionHelpFormatter are only
 * considered public as object names -- the API of the formatter objects is
 * still considered an implementation detail.)
 */

const SUPPRESS = '==SUPPRESS=='

const OPTIONAL = '?'
const ZERO_OR_MORE = '*'
const ONE_OR_MORE = '+'
const PARSER = 'A...'
const REMAINDER = '...'
const _UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'


// ==================================
// Utility functions used for porting
// ==================================
const assert = __webpack_require__(4)
const util = __webpack_require__(5)
const fs = __webpack_require__(1)
const sub = __webpack_require__(6)
const path = __webpack_require__(7)
const repr = util.inspect

function get_argv() {
    // omit first argument (which is assumed to be interpreter - `node`, `coffee`, `ts-node`, etc.)
    return process.argv.slice(1)
}

function get_terminal_size() {
    return {
        columns: +process.env.COLUMNS || process.stdout.columns || 80
    }
}

function hasattr(object, name) {
    return Object.prototype.hasOwnProperty.call(object, name)
}

function getattr(object, name, value) {
    return hasattr(object, name) ? object[name] : value
}

function setattr(object, name, value) {
    object[name] = value
}

function setdefault(object, name, value) {
    if (!hasattr(object, name)) object[name] = value
    return object[name]
}

function delattr(object, name) {
    delete object[name]
}

function range(from, to, step=1) {
    // range(10) is equivalent to range(0, 10)
    if (arguments.length === 1) [ to, from ] = [ from, 0 ]
    if (typeof from !== 'number' || typeof to !== 'number' || typeof step !== 'number') {
        throw new TypeError('argument cannot be interpreted as an integer')
    }
    if (step === 0) throw new TypeError('range() arg 3 must not be zero')

    let result = []
    if (step > 0) {
        for (let i = from; i < to; i += step) result.push(i)
    } else {
        for (let i = from; i > to; i += step) result.push(i)
    }
    return result
}

function splitlines(str, keepends = false) {
    let result
    if (!keepends) {
        result = str.split(/\r\n|[\n\r\v\f\x1c\x1d\x1e\x85\u2028\u2029]/)
    } else {
        result = []
        let parts = str.split(/(\r\n|[\n\r\v\f\x1c\x1d\x1e\x85\u2028\u2029])/)
        for (let i = 0; i < parts.length; i += 2) {
            result.push(parts[i] + (i + 1 < parts.length ? parts[i + 1] : ''))
        }
    }
    if (!result[result.length - 1]) result.pop()
    return result
}

function _string_lstrip(string, prefix_chars) {
    let idx = 0
    while (idx < string.length && prefix_chars.includes(string[idx])) idx++
    return idx ? string.slice(idx) : string
}

function _string_split(string, sep, maxsplit) {
    let result = string.split(sep)
    if (result.length > maxsplit) {
        result = result.slice(0, maxsplit).concat([ result.slice(maxsplit).join(sep) ])
    }
    return result
}

function _array_equal(array1, array2) {
    if (array1.length !== array2.length) return false
    for (let i = 0; i < array1.length; i++) {
        if (array1[i] !== array2[i]) return false
    }
    return true
}

function _array_remove(array, item) {
    let idx = array.indexOf(item)
    if (idx === -1) throw new TypeError(sub('%r not in list', item))
    array.splice(idx, 1)
}

// normalize choices to array;
// this isn't required in python because `in` and `map` operators work with anything,
// but in js dealing with multiple types here is too clunky
function _choices_to_array(choices) {
    if (choices === undefined) {
        return []
    } else if (Array.isArray(choices)) {
        return choices
    } else if (choices !== null && typeof choices[Symbol.iterator] === 'function') {
        return Array.from(choices)
    } else if (typeof choices === 'object' && choices !== null) {
        return Object.keys(choices)
    } else {
        throw new Error(sub('invalid choices value: %r', choices))
    }
}

// decorator that allows a class to be called without new
function _callable(cls) {
    let result = { // object is needed for inferred class name
        [cls.name]: function (...args) {
            let this_class = new.target === result || !new.target
            return Reflect.construct(cls, args, this_class ? cls : new.target)
        }
    }
    result[cls.name].prototype = cls.prototype
    // fix default tag for toString, e.g. [object Action] instead of [object Object]
    cls.prototype[Symbol.toStringTag] = cls.name
    return result[cls.name]
}

function _alias(object, from, to) {
    try {
        let name = object.constructor.name
        Object.defineProperty(object, from, {
            value: util.deprecate(object[to], sub('%s.%s() is renamed to %s.%s()',
                name, from, name, to)),
            enumerable: false
        })
    } catch {}
}

// decorator that allows snake_case class methods to be called with camelCase and vice versa
function _camelcase_alias(_class) {
    for (let name of Object.getOwnPropertyNames(_class.prototype)) {
        let camelcase = name.replace(/\w_[a-z]/g, s => s[0] + s[2].toUpperCase())
        if (camelcase !== name) _alias(_class.prototype, camelcase, name)
    }
    return _class
}

function _to_legacy_name(key) {
    key = key.replace(/\w_[a-z]/g, s => s[0] + s[2].toUpperCase())
    if (key === 'default') key = 'defaultValue'
    if (key === 'const') key = 'constant'
    return key
}

function _to_new_name(key) {
    if (key === 'defaultValue') key = 'default'
    if (key === 'constant') key = 'const'
    key = key.replace(/[A-Z]/g, c => '_' + c.toLowerCase())
    return key
}

// parse options
let no_default = Symbol('no_default_value')
function _parse_opts(args, descriptor) {
    function get_name() {
        let stack = new Error().stack.split('\n')
            .map(x => x.match(/^    at (.*) \(.*\)$/))
            .filter(Boolean)
            .map(m => m[1])
            .map(fn => fn.match(/[^ .]*$/)[0])

        if (stack.length && stack[0] === get_name.name) stack.shift()
        if (stack.length && stack[0] === _parse_opts.name) stack.shift()
        return stack.length ? stack[0] : ''
    }

    args = Array.from(args)
    let kwargs = {}
    let result = []
    let last_opt = args.length && args[args.length - 1]

    if (typeof last_opt === 'object' && last_opt !== null && !Array.isArray(last_opt) &&
        (!last_opt.constructor || last_opt.constructor.name === 'Object')) {
        kwargs = Object.assign({}, args.pop())
    }

    // LEGACY (v1 compatibility): camelcase
    let renames = []
    for (let key of Object.keys(descriptor)) {
        let old_name = _to_legacy_name(key)
        if (old_name !== key && (old_name in kwargs)) {
            if (key in kwargs) {
                // default and defaultValue specified at the same time, happens often in old tests
                //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key))
            } else {
                kwargs[key] = kwargs[old_name]
            }
            renames.push([ old_name, key ])
            delete kwargs[old_name]
        }
    }
    if (renames.length) {
        let name = get_name()
        deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s',
            name, renames.map(([ a, b ]) => sub('%r -> %r', a, b))))
    }
    // end

    let missing_positionals = []
    let positional_count = args.length

    for (let [ key, def ] of Object.entries(descriptor)) {
        if (key[0] === '*') {
            if (key.length > 0 && key[1] === '*') {
                // LEGACY (v1 compatibility): camelcase
                let renames = []
                for (let key of Object.keys(kwargs)) {
                    let new_name = _to_new_name(key)
                    if (new_name !== key && (key in kwargs)) {
                        if (new_name in kwargs) {
                            // default and defaultValue specified at the same time, happens often in old tests
                            //throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), new_name))
                        } else {
                            kwargs[new_name] = kwargs[key]
                        }
                        renames.push([ key, new_name ])
                        delete kwargs[key]
                    }
                }
                if (renames.length) {
                    let name = get_name()
                    deprecate('camelcase_' + name, sub('%s(): following options are renamed: %s',
                        name, renames.map(([ a, b ]) => sub('%r -> %r', a, b))))
                }
                // end
                result.push(kwargs)
                kwargs = {}
            } else {
                result.push(args)
                args = []
            }
        } else if (key in kwargs && args.length > 0) {
            throw new TypeError(sub('%s() got multiple values for argument %r', get_name(), key))
        } else if (key in kwargs) {
            result.push(kwargs[key])
            delete kwargs[key]
        } else if (args.length > 0) {
            result.push(args.shift())
        } else if (def !== no_default) {
            result.push(def)
        } else {
            missing_positionals.push(key)
        }
    }

    if (Object.keys(kwargs).length) {
        throw new TypeError(sub('%s() got an unexpected keyword argument %r',
            get_name(), Object.keys(kwargs)[0]))
    }

    if (args.length) {
        let from = Object.entries(descriptor).filter(([ k, v ]) => k[0] !== '*' && v !== no_default).length
        let to = Object.entries(descriptor).filter(([ k ]) => k[0] !== '*').length
        throw new TypeError(sub('%s() takes %s positional argument%s but %s %s given',
            get_name(),
            from === to ? sub('from %s to %s', from, to) : to,
            from === to && to === 1 ? '' : 's',
            positional_count,
            positional_count === 1 ? 'was' : 'were'))
    }

    if (missing_positionals.length) {
        let strs = missing_positionals.map(repr)
        if (strs.length > 1) strs[strs.length - 1] = 'and ' + strs[strs.length - 1]
        let str_joined = strs.join(strs.length === 2 ? '' : ', ')
        throw new TypeError(sub('%s() missing %i required positional argument%s: %s',
            get_name(), strs.length, strs.length === 1 ? '' : 's', str_joined))
    }

    return result
}

let _deprecations = {}
function deprecate(id, string) {
    _deprecations[id] = _deprecations[id] || util.deprecate(() => {}, string)
    _deprecations[id]()
}


// =============================
// Utility functions and classes
// =============================
function _AttributeHolder(cls = Object) {
    /*
     *  Abstract base class that provides __repr__.
     *
     *  The __repr__ method returns a string in the format::
     *      ClassName(attr=name, attr=name, ...)
     *  The attributes are determined either by a class-level attribute,
     *  '_kwarg_names', or by inspecting the instance __dict__.
     */

    return class _AttributeHolder extends cls {
        [util.inspect.custom]() {
            let type_name = this.constructor.name
            let arg_strings = []
            let star_args = {}
            for (let arg of this._get_args()) {
                arg_strings.push(repr(arg))
            }
            for (let [ name, value ] of this._get_kwargs()) {
                if (/^[a-z_][a-z0-9_$]*$/i.test(name)) {
                    arg_strings.push(sub('%s=%r', name, value))
                } else {
                    star_args[name] = value
                }
            }
            if (Object.keys(star_args).length) {
                arg_strings.push(sub('**%s', repr(star_args)))
            }
            return sub('%s(%s)', type_name, arg_strings.join(', '))
        }

        toString() {
            return this[util.inspect.custom]()
        }

        _get_kwargs() {
            return Object.entries(this)
        }

        _get_args() {
            return []
        }
    }
}


function _copy_items(items) {
    if (items === undefined) {
        return []
    }
    return items.slice(0)
}


// ===============
// Formatting Help
// ===============
const HelpFormatter = _camelcase_alias(_callable(class HelpFormatter {
    /*
     *  Formatter for generating usage messages and argument help strings.
     *
     *  Only the name of this class is considered a public API. All the methods
     *  provided by the class are considered an implementation detail.
     */

    constructor() {
        let [
            prog,
            indent_increment,
            max_help_position,
            width
        ] = _parse_opts(arguments, {
            prog: no_default,
            indent_increment: 2,
            max_help_position: 24,
            width: undefined
        })

        // default setting for width
        if (width === undefined) {
            width = get_terminal_size().columns
            width -= 2
        }

        this._prog = prog
        this._indent_increment = indent_increment
        this._max_help_position = Math.min(max_help_position,
                                      Math.max(width - 20, indent_increment * 2))
        this._width = width

        this._current_indent = 0
        this._level = 0
        this._action_max_length = 0

        this._root_section = this._Section(this, undefined)
        this._current_section = this._root_section

        this._whitespace_matcher = /[ \t\n\r\f\v]+/g // equivalent to python /\s+/ with ASCII flag
        this._long_break_matcher = /\n\n\n+/g
    }

    // ===============================
    // Section and indentation methods
    // ===============================
    _indent() {
        this._current_indent += this._indent_increment
        this._level += 1
    }

    _dedent() {
        this._current_indent -= this._indent_increment
        assert(this._current_indent >= 0, 'Indent decreased below 0.')
        this._level -= 1
    }

    _add_item(func, args) {
        this._current_section.items.push([ func, args ])
    }

    // ========================
    // Message building methods
    // ========================
    start_section(heading) {
        this._indent()
        let section = this._Section(this, this._current_section, heading)
        this._add_item(section.format_help.bind(section), [])
        this._current_section = section
    }

    end_section() {
        this._current_section = this._current_section.parent
        this._dedent()
    }

    add_text(text) {
        if (text !== SUPPRESS && text !== undefined) {
            this._add_item(this._format_text.bind(this), [text])
        }
    }

    add_usage(usage, actions, groups, prefix = undefined) {
        if (usage !== SUPPRESS) {
            let args = [ usage, actions, groups, prefix ]
            this._add_item(this._format_usage.bind(this), args)
        }
    }

    add_argument(action) {
        if (action.help !== SUPPRESS) {

            // find all invocations
            let invocations = [this._format_action_invocation(action)]
            for (let subaction of this._iter_indented_subactions(action)) {
                invocations.push(this._format_action_invocation(subaction))
            }

            // update the maximum item length
            let invocation_length = Math.max(...invocations.map(invocation => invocation.length))
            let action_length = invocation_length + this._current_indent
            this._action_max_length = Math.max(this._action_max_length,
                                               action_length)

            // add the item to the list
            this._add_item(this._format_action.bind(this), [action])
        }
    }

    add_arguments(actions) {
        for (let action of actions) {
            this.add_argument(action)
        }
    }

    // =======================
    // Help-formatting methods
    // =======================
    format_help() {
        let help = this._root_section.format_help()
        if (help) {
            help = help.replace(this._long_break_matcher, '\n\n')
            help = help.replace(/^\n+|\n+$/g, '') + '\n'
        }
        return help
    }

    _join_parts(part_strings) {
        return part_strings.filter(part => part && part !== SUPPRESS).join('')
    }

    _format_usage(usage, actions, groups, prefix) {
        if (prefix === undefined) {
            prefix = 'usage: '
        }

        // if usage is specified, use that
        if (usage !== undefined) {
            usage = sub(usage, { prog: this._prog })

        // if no optionals or positionals are available, usage is just prog
        } else if (usage === undefined && !actions.length) {
            usage = sub('%(prog)s', { prog: this._prog })

        // if optionals and positionals are available, calculate usage
        } else if (usage === undefined) {
            let prog = sub('%(prog)s', { prog: this._prog })

            // split optionals from positionals
            let optionals = []
            let positionals = []
            for (let action of actions) {
                if (action.option_strings.length) {
                    optionals.push(action)
                } else {
                    positionals.push(action)
                }
            }

            // build full usage string
            let action_usage = this._format_actions_usage([].concat(optionals).concat(positionals), groups)
            usage = [ prog, action_usage ].map(String).join(' ')

            // wrap the usage parts if it's too long
            let text_width = this._width - this._current_indent
            if (prefix.length + usage.length > text_width) {

                // break usage into wrappable parts
                let part_regexp = /\(.*?\)+(?=\s|$)|\[.*?\]+(?=\s|$)|\S+/g
                let opt_usage = this._format_actions_usage(optionals, groups)
                let pos_usage = this._format_actions_usage(positionals, groups)
                let opt_parts = opt_usage.match(part_regexp) || []
                let pos_parts = pos_usage.match(part_regexp) || []
                assert(opt_parts.join(' ') === opt_usage)
                assert(pos_parts.join(' ') === pos_usage)

                // helper for wrapping lines
                let get_lines = (parts, indent, prefix = undefined) => {
                    let lines = []
                    let line = []
                    let line_len
                    if (prefix !== undefined) {
                        line_len = prefix.length - 1
                    } else {
                        line_len = indent.length - 1
                    }
                    for (let part of parts) {
                        if (line_len + 1 + part.length > text_width && line) {
                            lines.push(indent + line.join(' '))
                            line = []
                            line_len = indent.length - 1
                        }
                        line.push(part)
                        line_len += part.length + 1
                    }
                    if (line.length) {
                        lines.push(indent + line.join(' '))
                    }
                    if (prefix !== undefined) {
                        lines[0] = lines[0].slice(indent.length)
                    }
                    return lines
                }

                let lines

                // if prog is short, follow it with optionals or positionals
                if (prefix.length + prog.length <= 0.75 * text_width) {
                    let indent = ' '.repeat(prefix.length + prog.length + 1)
                    if (opt_parts.length) {
                        lines = get_lines([prog].concat(opt_parts), indent, prefix)
                        lines = lines.concat(get_lines(pos_parts, indent))
                    } else if (pos_parts.length) {
                        lines = get_lines([prog].concat(pos_parts), indent, prefix)
                    } else {
                        lines = [prog]
                    }

                // if prog is long, put it on its own line
                } else {
                    let indent = ' '.repeat(prefix.length)
                    let parts = [].concat(opt_parts).concat(pos_parts)
                    lines = get_lines(parts, indent)
                    if (lines.length > 1) {
                        lines = []
                        lines = lines.concat(get_lines(opt_parts, indent))
                        lines = lines.concat(get_lines(pos_parts, indent))
                    }
                    lines = [prog].concat(lines)
                }

                // join lines into usage
                usage = lines.join('\n')
            }
        }

        // prefix with 'usage:'
        return sub('%s%s\n\n', prefix, usage)
    }

    _format_actions_usage(actions, groups) {
        // find group indices and identify actions in groups
        let group_actions = new Set()
        let inserts = {}
        for (let group of groups) {
            let start = actions.indexOf(group._group_actions[0])
            if (start === -1) {
                continue
            } else {
                let end = start + group._group_actions.length
                if (_array_equal(actions.slice(start, end), group._group_actions)) {
                    for (let action of group._group_actions) {
                        group_actions.add(action)
                    }
                    if (!group.required) {
                        if (start in inserts) {
                            inserts[start] += ' ['
                        } else {
                            inserts[start] = '['
                        }
                        if (end in inserts) {
                            inserts[end] += ']'
                        } else {
                            inserts[end] = ']'
                        }
                    } else {
                        if (start in inserts) {
                            inserts[start] += ' ('
                        } else {
                            inserts[start] = '('
                        }
                        if (end in inserts) {
                            inserts[end] += ')'
                        } else {
                            inserts[end] = ')'
                        }
                    }
                    for (let i of range(start + 1, end)) {
                        inserts[i] = '|'
                    }
                }
            }
        }

        // collect all actions format strings
        let parts = []
        for (let [ i, action ] of Object.entries(actions)) {

            // suppressed arguments are marked with None
            // remove | separators for suppressed arguments
            if (action.help === SUPPRESS) {
                parts.push(undefined)
                if (inserts[+i] === '|') {
                    delete inserts[+i]
                } else if (inserts[+i + 1] === '|') {
                    delete inserts[+i + 1]
                }

            // produce all arg strings
            } else if (!action.option_strings.length) {
                let default_value = this._get_default_metavar_for_positional(action)
                let part = this._format_args(action, default_value)

                // if it's in a group, strip the outer []
                if (group_actions.has(action)) {
                    if (part[0] === '[' && part[part.length - 1] === ']') {
                        part = part.slice(1, -1)
                    }
                }

                // add the action string to the list
                parts.push(part)

            // produce the first way to invoke the option in brackets
            } else {
                let option_string = action.option_strings[0]
                let part

                // if the Optional doesn't take a value, format is:
                //    -s or --long
                if (action.nargs === 0) {
                    part = action.format_usage()

                // if the Optional takes a value, format is:
                //    -s ARGS or --long ARGS
                } else {
                    let default_value = this._get_default_metavar_for_optional(action)
                    let args_string = this._format_args(action, default_value)
                    part = sub('%s %s', option_string, args_string)
                }

                // make it look optional if it's not required or in a group
                if (!action.required && !group_actions.has(action)) {
                    part = sub('[%s]', part)
                }

                // add the action string to the list
                parts.push(part)
            }
        }

        // insert things at the necessary indices
        for (let i of Object.keys(inserts).map(Number).sort((a, b) => b - a)) {
            parts.splice(+i, 0, inserts[+i])
        }

        // join all the action items with spaces
        let text = parts.filter(Boolean).join(' ')

        // clean up separators for mutually exclusive groups
        text = text.replace(/([\[(]) /g, '$1')
        text = text.replace(/ ([\])])/g, '$1')
        text = text.replace(/[\[(] *[\])]/g, '')
        text = text.replace(/\(([^|]*)\)/g, '$1', text)
        text = text.trim()

        // return the text
        return text
    }

    _format_text(text) {
        if (text.includes('%(prog)')) {
            text = sub(text, { prog: this._prog })
        }
        let text_width = Math.max(this._width - this._current_indent, 11)
        let indent = ' '.repeat(this._current_indent)
        return this._fill_text(text, text_width, indent) + '\n\n'
    }

    _format_action(action) {
        // determine the required width and the entry label
        let help_position = Math.min(this._action_max_length + 2,
                                     this._max_help_position)
        let help_width = Math.max(this._width - help_position, 11)
        let action_width = help_position - this._current_indent - 2
        let action_header = this._format_action_invocation(action)
        let indent_first

        // no help; start on same line and add a final newline
        if (!action.help) {
            let tup = [ this._current_indent, '', action_header ]
            action_header = sub('%*s%s\n', ...tup)

        // short action name; start on the same line and pad two spaces
        } else if (action_header.length <= action_width) {
            let tup = [ this._current_indent, '', action_width, action_header ]
            action_header = sub('%*s%-*s  ', ...tup)
            indent_first = 0

        // long action name; start on the next line
        } else {
            let tup = [ this._current_indent, '', action_header ]
            action_header = sub('%*s%s\n', ...tup)
            indent_first = help_position
        }

        // collect the pieces of the action help
        let parts = [action_header]

        // if there was help for the action, add lines of help text
        if (action.help) {
            let help_text = this._expand_help(action)
            let help_lines = this._split_lines(help_text, help_width)
            parts.push(sub('%*s%s\n', indent_first, '', help_lines[0]))
            for (let line of help_lines.slice(1)) {
                parts.push(sub('%*s%s\n', help_position, '', line))
            }

        // or add a newline if the description doesn't end with one
        } else if (!action_header.endsWith('\n')) {
            parts.push('\n')
        }

        // if there are any sub-actions, add their help as well
        for (let subaction of this._iter_indented_subactions(action)) {
            parts.push(this._format_action(subaction))
        }

        // return a single string
        return this._join_parts(parts)
    }

    _format_action_invocation(action) {
        if (!action.option_strings.length) {
            let default_value = this._get_default_metavar_for_positional(action)
            let metavar = this._metavar_formatter(action, default_value)(1)[0]
            return metavar

        } else {
            let parts = []

            // if the Optional doesn't take a value, format is:
            //    -s, --long
            if (action.nargs === 0) {
                parts = parts.concat(action.option_strings)

            // if the Optional takes a value, format is:
            //    -s ARGS, --long ARGS
            } else {
                let default_value = this._get_default_metavar_for_optional(action)
                let args_string = this._format_args(action, default_value)
                for (let option_string of action.option_strings) {
                    parts.push(sub('%s %s', option_string, args_string))
                }
            }

            return parts.join(', ')
        }
    }

    _metavar_formatter(action, default_metavar) {
        let result
        if (action.metavar !== undefined) {
            result = action.metavar
        } else if (action.choices !== undefined) {
            let choice_strs = _choices_to_array(action.choices).map(String)
            result = sub('{%s}', choice_strs.join(','))
        } else {
            result = default_metavar
        }

        function format(tuple_size) {
            if (Array.isArray(result)) {
                return result
            } else {
                return Array(tuple_size).fill(result)
            }
        }
        return format
    }

    _format_args(action, default_metavar) {
        let get_metavar = this._metavar_formatter(action, default_metavar)
        let result
        if (action.nargs === undefined) {
            result = sub('%s', ...get_metavar(1))
        } else if (action.nargs === OPTIONAL) {
            result = sub('[%s]', ...get_metavar(1))
        } else if (action.nargs === ZERO_OR_MORE) {
            let metavar = get_metavar(1)
            if (metavar.length === 2) {
                result = sub('[%s [%s ...]]', ...metavar)
            } else {
                result = sub('[%s ...]', ...metavar)
            }
        } else if (action.nargs === ONE_OR_MORE) {
            result = sub('%s [%s ...]', ...get_metavar(2))
        } else if (action.nargs === REMAINDER) {
            result = '...'
        } else if (action.nargs === PARSER) {
            result = sub('%s ...', ...get_metavar(1))
        } else if (action.nargs === SUPPRESS) {
            result = ''
        } else {
            let formats
            try {
                formats = range(action.nargs).map(() => '%s')
            } catch (err) {
                throw new TypeError('invalid nargs value')
            }
            result = sub(formats.join(' '), ...get_metavar(action.nargs))
        }
        return result
    }

    _expand_help(action) {
        let params = Object.assign({ prog: this._prog }, action)
        for (let name of Object.keys(params)) {
            if (params[name] === SUPPRESS) {
                delete params[name]
            }
        }
        for (let name of Object.keys(params)) {
            if (params[name] && params[name].name) {
                params[name] = params[name].name
            }
        }
        if (params.choices !== undefined) {
            let choices_str = _choices_to_array(params.choices).map(String).join(', ')
            params.choices = choices_str
        }
        // LEGACY (v1 compatibility): camelcase
        for (let key of Object.keys(params)) {
            let old_name = _to_legacy_name(key)
            if (old_name !== key) {
                params[old_name] = params[key]
            }
        }
        // end
        return sub(this._get_help_string(action), params)
    }

    * _iter_indented_subactions(action) {
        if (typeof action._get_subactions === 'function') {
            this._indent()
            yield* action._get_subactions()
            this._dedent()
        }
    }

    _split_lines(text, width) {
        text = text.replace(this._whitespace_matcher, ' ').trim()
        // The textwrap module is used only for formatting help.
        // Delay its import for speeding up the common usage of argparse.
        let textwrap = __webpack_require__(8)
        return textwrap.wrap(text, { width })
    }

    _fill_text(text, width, indent) {
        text = text.replace(this._whitespace_matcher, ' ').trim()
        let textwrap = __webpack_require__(8)
        return textwrap.fill(text, { width,
                                     initial_indent: indent,
                                     subsequent_indent: indent })
    }

    _get_help_string(action) {
        return action.help
    }

    _get_default_metavar_for_optional(action) {
        return action.dest.toUpperCase()
    }

    _get_default_metavar_for_positional(action) {
        return action.dest
    }
}))

HelpFormatter.prototype._Section = _callable(class _Section {

    constructor(formatter, parent, heading = undefined) {
        this.formatter = formatter
        this.parent = parent
        this.heading = heading
        this.items = []
    }

    format_help() {
        // format the indented section
        if (this.parent !== undefined) {
            this.formatter._indent()
        }
        let item_help = this.formatter._join_parts(this.items.map(([ func, args ]) => func.apply(null, args)))
        if (this.parent !== undefined) {
            this.formatter._dedent()
        }

        // return nothing if the section was empty
        if (!item_help) {
            return ''
        }

        // add the heading if the section was non-empty
        let heading
        if (this.heading !== SUPPRESS && this.heading !== undefined) {
            let current_indent = this.formatter._current_indent
            heading = sub('%*s%s:\n', current_indent, '', this.heading)
        } else {
            heading = ''
        }

        // join the section-initial newline, the heading and the help
        return this.formatter._join_parts(['\n', heading, item_help, '\n'])
    }
})


const RawDescriptionHelpFormatter = _camelcase_alias(_callable(class RawDescriptionHelpFormatter extends HelpFormatter {
    /*
     *  Help message formatter which retains any formatting in descriptions.
     *
     *  Only the name of this class is considered a public API. All the methods
     *  provided by the class are considered an implementation detail.
     */

    _fill_text(text, width, indent) {
        return splitlines(text, true).map(line => indent + line).join('')
    }
}))


const RawTextHelpFormatter = _camelcase_alias(_callable(class RawTextHelpFormatter extends RawDescriptionHelpFormatter {
    /*
     *  Help message formatter which retains formatting of all help text.
     *
     *  Only the name of this class is considered a public API. All the methods
     *  provided by the class are considered an implementation detail.
     */

    _split_lines(text/*, width*/) {
        return splitlines(text)
    }
}))


const ArgumentDefaultsHelpFormatter = _camelcase_alias(_callable(class ArgumentDefaultsHelpFormatter extends HelpFormatter {
    /*
     *  Help message formatter which adds default values to argument help.
     *
     *  Only the name of this class is considered a public API. All the methods
     *  provided by the class are considered an implementation detail.
     */

    _get_help_string(action) {
        let help = action.help
        // LEGACY (v1 compatibility): additional check for defaultValue needed
        if (!action.help.includes('%(default)') && !action.help.includes('%(defaultValue)')) {
            if (action.default !== SUPPRESS) {
                let defaulting_nargs = [OPTIONAL, ZERO_OR_MORE]
                if (action.option_strings.length || defaulting_nargs.includes(action.nargs)) {
                    help += ' (default: %(default)s)'
                }
            }
        }
        return help
    }
}))


const MetavarTypeHelpFormatter = _camelcase_alias(_callable(class MetavarTypeHelpFormatter extends HelpFormatter {
    /*
     *  Help message formatter which uses the argument 'type' as the default
     *  metavar value (instead of the argument 'dest')
     *
     *  Only the name of this class is considered a public API. All the methods
     *  provided by the class are considered an implementation detail.
     */

    _get_default_metavar_for_optional(action) {
        return typeof action.type === 'function' ? action.type.name : action.type
    }

    _get_default_metavar_for_positional(action) {
        return typeof action.type === 'function' ? action.type.name : action.type
    }
}))


// =====================
// Options and Arguments
// =====================
function _get_action_name(argument) {
    if (argument === undefined) {
        return undefined
    } else if (argument.option_strings.length) {
        return argument.option_strings.join('/')
    } else if (![ undefined, SUPPRESS ].includes(argument.metavar)) {
        return argument.metavar
    } else if (![ undefined, SUPPRESS ].includes(argument.dest)) {
        return argument.dest
    } else {
        return undefined
    }
}


const ArgumentError = _callable(class ArgumentError extends Error {
    /*
     *  An error from creating or using an argument (optional or positional).
     *
     *  The string value of this exception is the message, augmented with
     *  information about the argument that caused it.
     */

    constructor(argument, message) {
        super()
        this.name = 'ArgumentError'
        this._argument_name = _get_action_name(argument)
        this._message = message
        this.message = this.str()
    }

    str() {
        let format
        if (this._argument_name === undefined) {
            format = '%(message)s'
        } else {
            format = 'argument %(argument_name)s: %(message)s'
        }
        return sub(format, { message: this._message,
                             argument_name: this._argument_name })
    }
})


const ArgumentTypeError = _callable(class ArgumentTypeError extends Error {
    /*
     * An error from trying to convert a command line string to a type.
     */

    constructor(message) {
        super(message)
        this.name = 'ArgumentTypeError'
    }
})


// ==============
// Action classes
// ==============
const Action = _camelcase_alias(_callable(class Action extends _AttributeHolder(Function) {
    /*
     *  Information about how to convert command line strings to Python objects.
     *
     *  Action objects are used by an ArgumentParser to represent the information
     *  needed to parse a single argument from one or more strings from the
     *  command line. The keyword arguments to the Action constructor are also
     *  all attributes of Action instances.
     *
     *  Keyword Arguments:
     *
     *      - option_strings -- A list of command-line option strings which
     *          should be associated with this action.
     *
     *      - dest -- The name of the attribute to hold the created object(s)
     *
     *      - nargs -- The number of command-line arguments that should be
     *          consumed. By default, one argument will be consumed and a single
     *          value will be produced.  Other values include:
     *              - N (an integer) consumes N arguments (and produces a list)
     *              - '?' consumes zero or one arguments
     *              - '*' consumes zero or more arguments (and produces a list)
     *              - '+' consumes one or more arguments (and produces a list)
     *          Note that the difference between the default and nargs=1 is that
     *          with the default, a single value will be produced, while with
     *          nargs=1, a list containing a single value will be produced.
     *
     *      - const -- The value to be produced if the option is specified and the
     *          option uses an action that takes no values.
     *
     *      - default -- The value to be produced if the option is not specified.
     *
     *      - type -- A callable that accepts a single string argument, and
     *          returns the converted value.  The standard Python types str, int,
     *          float, and complex are useful examples of such callables.  If None,
     *          str is used.
     *
     *      - choices -- A container of values that should be allowed. If not None,
     *          after a command-line argument has been converted to the appropriate
     *          type, an exception will be raised if it is not a member of this
     *          collection.
     *
     *      - required -- True if the action must always be specified at the
     *          command line. This is only meaningful for optional command-line
     *          arguments.
     *
     *      - help -- The help string describing the argument.
     *
     *      - metavar -- The name to be used for the option's argument with the
     *          help string. If None, the 'dest' value will be used as the name.
     */

    constructor() {
        let [
            option_strings,
            dest,
            nargs,
            const_value,
            default_value,
            type,
            choices,
            required,
            help,
            metavar
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            nargs: undefined,
            const: undefined,
            default: undefined,
            type: undefined,
            choices: undefined,
            required: false,
            help: undefined,
            metavar: undefined
        })

        // when this class is called as a function, redirect it to .call() method of itself
        super('return arguments.callee.call.apply(arguments.callee, arguments)')

        this.option_strings = option_strings
        this.dest = dest
        this.nargs = nargs
        this.const = const_value
        this.default = default_value
        this.type = type
        this.choices = choices
        this.required = required
        this.help = help
        this.metavar = metavar
    }

    _get_kwargs() {
        let names = [
            'option_strings',
            'dest',
            'nargs',
            'const',
            'default',
            'type',
            'choices',
            'help',
            'metavar'
        ]
        return names.map(name => [ name, getattr(this, name) ])
    }

    format_usage() {
        return this.option_strings[0]
    }

    call(/*parser, namespace, values, option_string = undefined*/) {
        throw new Error('.call() not defined')
    }
}))


const BooleanOptionalAction = _camelcase_alias(_callable(class BooleanOptionalAction extends Action {

    constructor() {
        let [
            option_strings,
            dest,
            default_value,
            type,
            choices,
            required,
            help,
            metavar
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            default: undefined,
            type: undefined,
            choices: undefined,
            required: false,
            help: undefined,
            metavar: undefined
        })

        let _option_strings = []
        for (let option_string of option_strings) {
            _option_strings.push(option_string)

            if (option_string.startsWith('--')) {
                option_string = '--no-' + option_string.slice(2)
                _option_strings.push(option_string)
            }
        }

        if (help !== undefined && default_value !== undefined) {
            help += ` (default: ${default_value})`
        }

        super({
            option_strings: _option_strings,
            dest,
            nargs: 0,
            default: default_value,
            type,
            choices,
            required,
            help,
            metavar
        })
    }

    call(parser, namespace, values, option_string = undefined) {
        if (this.option_strings.includes(option_string)) {
            setattr(namespace, this.dest, !option_string.startsWith('--no-'))
        }
    }

    format_usage() {
        return this.option_strings.join(' | ')
    }
}))


const _StoreAction = _callable(class _StoreAction extends Action {

    constructor() {
        let [
            option_strings,
            dest,
            nargs,
            const_value,
            default_value,
            type,
            choices,
            required,
            help,
            metavar
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            nargs: undefined,
            const: undefined,
            default: undefined,
            type: undefined,
            choices: undefined,
            required: false,
            help: undefined,
            metavar: undefined
        })

        if (nargs === 0) {
            throw new TypeError('nargs for store actions must be != 0; if you ' +
                        'have nothing to store, actions such as store ' +
                        'true or store const may be more appropriate')
        }
        if (const_value !== undefined && nargs !== OPTIONAL) {
            throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL))
        }
        super({
            option_strings,
            dest,
            nargs,
            const: const_value,
            default: default_value,
            type,
            choices,
            required,
            help,
            metavar
        })
    }

    call(parser, namespace, values/*, option_string = undefined*/) {
        setattr(namespace, this.dest, values)
    }
})


const _StoreConstAction = _callable(class _StoreConstAction extends Action {

    constructor() {
        let [
            option_strings,
            dest,
            const_value,
            default_value,
            required,
            help
            //, metavar
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            const: no_default,
            default: undefined,
            required: false,
            help: undefined,
            metavar: undefined
        })

        super({
            option_strings,
            dest,
            nargs: 0,
            const: const_value,
            default: default_value,
            required,
            help
        })
    }

    call(parser, namespace/*, values, option_string = undefined*/) {
        setattr(namespace, this.dest, this.const)
    }
})


const _StoreTrueAction = _callable(class _StoreTrueAction extends _StoreConstAction {

    constructor() {
        let [
            option_strings,
            dest,
            default_value,
            required,
            help
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            default: false,
            required: false,
            help: undefined
        })

        super({
            option_strings,
            dest,
            const: true,
            default: default_value,
            required,
            help
        })
    }
})


const _StoreFalseAction = _callable(class _StoreFalseAction extends _StoreConstAction {

    constructor() {
        let [
            option_strings,
            dest,
            default_value,
            required,
            help
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            default: true,
            required: false,
            help: undefined
        })

        super({
            option_strings,
            dest,
            const: false,
            default: default_value,
            required,
            help
        })
    }
})


const _AppendAction = _callable(class _AppendAction extends Action {

    constructor() {
        let [
            option_strings,
            dest,
            nargs,
            const_value,
            default_value,
            type,
            choices,
            required,
            help,
            metavar
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            nargs: undefined,
            const: undefined,
            default: undefined,
            type: undefined,
            choices: undefined,
            required: false,
            help: undefined,
            metavar: undefined
        })

        if (nargs === 0) {
            throw new TypeError('nargs for append actions must be != 0; if arg ' +
                        'strings are not supplying the value to append, ' +
                        'the append const action may be more appropriate')
        }
        if (const_value !== undefined && nargs !== OPTIONAL) {
            throw new TypeError(sub('nargs must be %r to supply const', OPTIONAL))
        }
        super({
            option_strings,
            dest,
            nargs,
            const: const_value,
            default: default_value,
            type,
            choices,
            required,
            help,
            metavar
        })
    }

    call(parser, namespace, values/*, option_string = undefined*/) {
        let items = getattr(namespace, this.dest, undefined)
        items = _copy_items(items)
        items.push(values)
        setattr(namespace, this.dest, items)
    }
})


const _AppendConstAction = _callable(class _AppendConstAction extends Action {

    constructor() {
        let [
            option_strings,
            dest,
            const_value,
            default_value,
            required,
            help,
            metavar
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            const: no_default,
            default: undefined,
            required: false,
            help: undefined,
            metavar: undefined
        })

        super({
            option_strings,
            dest,
            nargs: 0,
            const: const_value,
            default: default_value,
            required,
            help,
            metavar
        })
    }

    call(parser, namespace/*, values, option_string = undefined*/) {
        let items = getattr(namespace, this.dest, undefined)
        items = _copy_items(items)
        items.push(this.const)
        setattr(namespace, this.dest, items)
    }
})


const _CountAction = _callable(class _CountAction extends Action {

    constructor() {
        let [
            option_strings,
            dest,
            default_value,
            required,
            help
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: no_default,
            default: undefined,
            required: false,
            help: undefined
        })

        super({
            option_strings,
            dest,
            nargs: 0,
            default: default_value,
            required,
            help
        })
    }

    call(parser, namespace/*, values, option_string = undefined*/) {
        let count = getattr(namespace, this.dest, undefined)
        if (count === undefined) {
            count = 0
        }
        setattr(namespace, this.dest, count + 1)
    }
})


const _HelpAction = _callable(class _HelpAction extends Action {

    constructor() {
        let [
            option_strings,
            dest,
            default_value,
            help
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            dest: SUPPRESS,
            default: SUPPRESS,
            help: undefined
        })

        super({
            option_strings,
            dest,
            default: default_value,
            nargs: 0,
            help
        })
    }

    call(parser/*, namespace, values, option_string = undefined*/) {
        parser.print_help()
        parser.exit()
    }
})


const _VersionAction = _callable(class _VersionAction extends Action {

    constructor() {
        let [
            option_strings,
            version,
            dest,
            default_value,
            help
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            version: undefined,
            dest: SUPPRESS,
            default: SUPPRESS,
            help: "show program's version number and exit"
        })

        super({
            option_strings,
            dest,
            default: default_value,
            nargs: 0,
            help
        })
        this.version = version
    }

    call(parser/*, namespace, values, option_string = undefined*/) {
        let version = this.version
        if (version === undefined) {
            version = parser.version
        }
        let formatter = parser._get_formatter()
        formatter.add_text(version)
        parser._print_message(formatter.format_help(), process.stdout)
        parser.exit()
    }
})


const _SubParsersAction = _camelcase_alias(_callable(class _SubParsersAction extends Action {

    constructor() {
        let [
            option_strings,
            prog,
            parser_class,
            dest,
            required,
            help,
            metavar
        ] = _parse_opts(arguments, {
            option_strings: no_default,
            prog: no_default,
            parser_class: no_default,
            dest: SUPPRESS,
            required: false,
            help: undefined,
            metavar: undefined
        })

        let name_parser_map = {}

        super({
            option_strings,
            dest,
            nargs: PARSER,
            choices: name_parser_map,
            required,
            help,
            metavar
        })

        this._prog_prefix = prog
        this._parser_class = parser_class
        this._name_parser_map = name_parser_map
        this._choices_actions = []
    }

    add_parser() {
        let [
            name,
            kwargs
        ] = _parse_opts(arguments, {
            name: no_default,
            '**kwargs': no_default
        })

        // set prog from the existing prefix
        if (kwargs.prog === undefined) {
            kwargs.prog = sub('%s %s', this._prog_prefix, name)
        }

        let aliases = getattr(kwargs, 'aliases', [])
        delete kwargs.aliases

        // create a pseudo-action to hold the choice help
        if ('help' in kwargs) {
            let help = kwargs.help
            delete kwargs.help
            let choice_action = this._ChoicesPseudoAction(name, aliases, help)
            this._choices_actions.push(choice_action)
        }

        // create the parser and add it to the map
        let parser = new this._parser_class(kwargs)
        this._name_parser_map[name] = parser

        // make parser available under aliases also
        for (let alias of aliases) {
            this._name_parser_map[alias] = parser
        }

        return parser
    }

    _get_subactions() {
        return this._choices_actions
    }

    call(parser, namespace, values/*, option_string = undefined*/) {
        let parser_name = values[0]
        let arg_strings = values.slice(1)

        // set the parser name if requested
        if (this.dest !== SUPPRESS) {
            setattr(namespace, this.dest, parser_name)
        }

        // select the parser
        if (hasattr(this._name_parser_map, parser_name)) {
            parser = this._name_parser_map[parser_name]
        } else {
            let args = {parser_name,
                        choices: this._name_parser_map.join(', ')}
            let msg = sub('unknown parser %(parser_name)r (choices: %(choices)s)', args)
            throw new ArgumentError(this, msg)
        }

        // parse all the remaining options into the namespace
        // store any unrecognized options on the object, so that the top
        // level parser can decide what to do with them

        // In case this subparser defines new defaults, we parse them
        // in a new namespace object and then update the original
        // namespace for the relevant parts.
        let subnamespace
        [ subnamespace, arg_strings ] = parser.parse_known_args(arg_strings, undefined)
        for (let [ key, value ] of Object.entries(subnamespace)) {
            setattr(namespace, key, value)
        }

        if (arg_strings.length) {
            setdefault(namespace, _UNRECOGNIZED_ARGS_ATTR, [])
            getattr(namespace, _UNRECOGNIZED_ARGS_ATTR).push(...arg_strings)
        }
    }
}))


_SubParsersAction.prototype._ChoicesPseudoAction = _callable(class _ChoicesPseudoAction extends Action {
    constructor(name, aliases, help) {
        let metavar = name, dest = name
        if (aliases.length) {
            metavar += sub(' (%s)', aliases.join(', '))
        }
        super({ option_strings: [], dest, help, metavar })
    }
})


const _ExtendAction = _callable(class _ExtendAction extends _AppendAction {
    call(parser, namespace, values/*, option_string = undefined*/) {
        let items = getattr(namespace, this.dest, undefined)
        items = _copy_items(items)
        items = items.concat(values)
        setattr(namespace, this.dest, items)
    }
})


// ==============
// Type classes
// ==============
const FileType = _callable(class FileType extends Function {
    /*
     *  Factory for creating file object types
     *
     *  Instances of FileType are typically passed as type= arguments to the
     *  ArgumentParser add_argument() method.
     *
     *  Keyword Arguments:
     *      - mode -- A string indicating how the file is to be opened. Accepts the
     *          same values as the builtin open() function.
     *      - bufsize -- The file's desired buffer size. Accepts the same values as
     *          the builtin open() function.
     *      - encoding -- The file's encoding. Accepts the same values as the
     *          builtin open() function.
     *      - errors -- A string indicating how encoding and decoding errors are to
     *          be handled. Accepts the same value as the builtin open() function.
     */

    constructor() {
        let [
            flags,
            encoding,
            mode,
            autoClose,
            emitClose,
            start,
            end,
            highWaterMark,
            fs
        ] = _parse_opts(arguments, {
            flags: 'r',
            encoding: undefined,
            mode: undefined, // 0o666
            autoClose: undefined, // true
            emitClose: undefined, // false
            start: undefined, // 0
            end: undefined, // Infinity
            highWaterMark: undefined, // 64 * 1024
            fs: undefined
        })

        // when this class is called as a function, redirect it to .call() method of itself
        super('return arguments.callee.call.apply(arguments.callee, arguments)')

        Object.defineProperty(this, 'name', {
            get() {
                return sub('FileType(%r)', flags)
            }
        })
        this._flags = flags
        this._options = {}
        if (encoding !== undefined) this._options.encoding = encoding
        if (mode !== undefined) this._options.mode = mode
        if (autoClose !== undefined) this._options.autoClose = autoClose
        if (emitClose !== undefined) this._options.emitClose = emitClose
        if (start !== undefined) this._options.start = start
        if (end !== undefined) this._options.end = end
        if (highWaterMark !== undefined) this._options.highWaterMark = highWaterMark
        if (fs !== undefined) this._options.fs = fs
    }

    call(string) {
        // the special argument "-" means sys.std{in,out}
        if (string === '-') {
            if (this._flags.includes('r')) {
                return process.stdin
            } else if (this._flags.includes('w')) {
                return process.stdout
            } else {
                let msg = sub('argument "-" with mode %r', this._flags)
                throw new TypeError(msg)
            }
        }

        // all other arguments are used as file names
        let fd
        try {
            fd = fs.openSync(string, this._flags, this._options.mode)
        } catch (e) {
            let args = { filename: string, error: e.message }
            let message = "can't open '%(filename)s': %(error)s"
            throw new ArgumentTypeError(sub(message, args))
        }

        let options = Object.assign({ fd, flags: this._flags }, this._options)
        if (this._flags.includes('r')) {
            return fs.createReadStream(undefined, options)
        } else if (this._flags.includes('w')) {
            return fs.createWriteStream(undefined, options)
        } else {
            let msg = sub('argument "%s" with mode %r', string, this._flags)
            throw new TypeError(msg)
        }
    }

    [util.inspect.custom]() {
        let args = [ this._flags ]
        let kwargs = Object.entries(this._options).map(([ k, v ]) => {
            if (k === 'mode') v = { value: v, [util.inspect.custom]() { return '0o' + this.value.toString(8) } }
            return [ k, v ]
        })
        let args_str = []
                .concat(args.filter(arg => arg !== -1).map(repr))
                .concat(kwargs.filter(([/*kw*/, arg]) => arg !== undefined)
                    .map(([kw, arg]) => sub('%s=%r', kw, arg)))
                .join(', ')
        return sub('%s(%s)', this.constructor.name, args_str)
    }

    toString() {
        return this[util.inspect.custom]()
    }
})

// ===========================
// Optional and Positional Parsing
// ===========================
const Namespace = _callable(class Namespace extends _AttributeHolder() {
    /*
     *  Simple object for storing attributes.
     *
     *  Implements equality by attribute names and values, and provides a simple
     *  string representation.
     */

    constructor(options = {}) {
        super()
        Object.assign(this, options)
    }
})

// unset string tag to mimic plain object
Namespace.prototype[Symbol.toStringTag] = undefined


const _ActionsContainer = _camelcase_alias(_callable(class _ActionsContainer {

    constructor() {
        let [
            description,
            prefix_chars,
            argument_default,
            conflict_handler
        ] = _parse_opts(arguments, {
            description: no_default,
            prefix_chars: no_default,
            argument_default: no_default,
            conflict_handler: no_default
        })

        this.description = description
        this.argument_default = argument_default
        this.prefix_chars = prefix_chars
        this.conflict_handler = conflict_handler

        // set up registries
        this._registries = {}

        // register actions
        this.register('action', undefined, _StoreAction)
        this.register('action', 'store', _StoreAction)
        this.register('action', 'store_const', _StoreConstAction)
        this.register('action', 'store_true', _StoreTrueAction)
        this.register('action', 'store_false', _StoreFalseAction)
        this.register('action', 'append', _AppendAction)
        this.register('action', 'append_const', _AppendConstAction)
        this.register('action', 'count', _CountAction)
        this.register('action', 'help', _HelpAction)
        this.register('action', 'version', _VersionAction)
        this.register('action', 'parsers', _SubParsersAction)
        this.register('action', 'extend', _ExtendAction)
        // LEGACY (v1 compatibility): camelcase variants
        ;[ 'storeConst', 'storeTrue', 'storeFalse', 'appendConst' ].forEach(old_name => {
            let new_name = _to_new_name(old_name)
            this.register('action', old_name, util.deprecate(this._registry_get('action', new_name),
                sub('{action: "%s"} is renamed to {action: "%s"}', old_name, new_name)))
        })
        // end

        // raise an exception if the conflict handler is invalid
        this._get_handler()

        // action storage
        this._actions = []
        this._option_string_actions = {}

        // groups
        this._action_groups = []
        this._mutually_exclusive_groups = []

        // defaults storage
        this._defaults = {}

        // determines whether an "option" looks like a negative number
        this._negative_number_matcher = /^-\d+$|^-\d*\.\d+$/

        // whether or not there are any optionals that look like negative
        // numbers -- uses a list so it can be shared and edited
        this._has_negative_number_optionals = []
    }

    // ====================
    // Registration methods
    // ====================
    register(registry_name, value, object) {
        let registry = setdefault(this._registries, registry_name, {})
        registry[value] = object
    }

    _registry_get(registry_name, value, default_value = undefined) {
        return getattr(this._registries[registry_name], value, default_value)
    }

    // ==================================
    // Namespace default accessor methods
    // ==================================
    set_defaults(kwargs) {
        Object.assign(this._defaults, kwargs)

        // if these defaults match any existing arguments, replace
        // the previous default on the object with the new one
        for (let action of this._actions) {
            if (action.dest in kwargs) {
                action.default = kwargs[action.dest]
            }
        }
    }

    get_default(dest) {
        for (let action of this._actions) {
            if (action.dest === dest && action.default !== undefined) {
                return action.default
            }
        }
        return this._defaults[dest]
    }


    // =======================
    // Adding argument actions
    // =======================
    add_argument() {
        /*
         *  add_argument(dest, ..., name=value, ...)
         *  add_argument(option_string, option_string, ..., name=value, ...)
         */
        let [
            args,
            kwargs
        ] = _parse_opts(arguments, {
            '*args': no_default,
            '**kwargs': no_default
        })
        // LEGACY (v1 compatibility), old-style add_argument([ args ], { options })
        if (args.length === 1 && Array.isArray(args[0])) {
            args = args[0]
            deprecate('argument-array',
                sub('use add_argument(%(args)s, {...}) instead of add_argument([ %(args)s ], { ... })', {
                    args: args.map(repr).join(', ')
                }))
        }
        // end

        // if no positional args are supplied or only one is supplied and
        // it doesn't look like an option string, parse a positional
        // argument
        let chars = this.prefix_chars
        if (!args.length || args.length === 1 && !chars.includes(args[0][0])) {
            if (args.length && 'dest' in kwargs) {
                throw new TypeError('dest supplied twice for positional argument')
            }
            kwargs = this._get_positional_kwargs(...args, kwargs)

        // otherwise, we're adding an optional argument
        } else {
            kwargs = this._get_optional_kwargs(...args, kwargs)
        }

        // if no default was supplied, use the parser-level default
        if (!('default' in kwargs)) {
            let dest = kwargs.dest
            if (dest in this._defaults) {
                kwargs.default = this._defaults[dest]
            } else if (this.argument_default !== undefined) {
                kwargs.default = this.argument_default
            }
        }

        // create the action object, and add it to the parser
        let action_class = this._pop_action_class(kwargs)
        if (typeof action_class !== 'function') {
            throw new TypeError(sub('unknown action "%s"', action_class))
        }
        // eslint-disable-next-line new-cap
        let action = new action_class(kwargs)

        // raise an error if the action type is not callable
        let type_func = this._registry_get('type', action.type, action.type)
        if (typeof type_func !== 'function') {
            throw new TypeError(sub('%r is not callable', type_func))
        }

        if (type_func === FileType) {
            throw new TypeError(sub('%r is a FileType class object, instance of it' +
                                    ' must be passed', type_func))
        }

        // raise an error if the metavar does not match the type
        if ('_get_formatter' in this) {
            try {
                this._get_formatter()._format_args(action, undefined)
            } catch (err) {
                // check for 'invalid nargs value' is an artifact of TypeError and ValueError in js being the same
                if (err instanceof TypeError && err.message !== 'invalid nargs value') {
                    throw new TypeError('length of metavar tuple does not match nargs')
                } else {
                    throw err
                }
            }
        }

        return this._add_action(action)
    }

    add_argument_group() {
        let group = _ArgumentGroup(this, ...arguments)
        this._action_groups.push(group)
        return group
    }

    add_mutually_exclusive_group() {
        // eslint-disable-next-line no-use-before-define
        let group = _MutuallyExclusiveGroup(this, ...arguments)
        this._mutually_exclusive_groups.push(group)
        return group
    }

    _add_action(action) {
        // resolve any conflicts
        this._check_conflict(action)

        // add to actions list
        this._actions.push(action)
        action.container = this

        // index the action by any option strings it has
        for (let option_string of action.option_strings) {
            this._option_string_actions[option_string] = action
        }

        // set the flag if any option strings look like negative numbers
        for (let option_string of action.option_strings) {
            if (this._negative_number_matcher.test(option_string)) {
                if (!this._has_negative_number_optionals.length) {
                    this._has_negative_number_optionals.push(true)
                }
            }
        }

        // return the created action
        return action
    }

    _remove_action(action) {
        _array_remove(this._actions, action)
    }

    _add_container_actions(container) {
        // collect groups by titles
        let title_group_map = {}
        for (let group of this._action_groups) {
            if (group.title in title_group_map) {
                let msg = 'cannot merge actions - two groups are named %r'
                throw new TypeError(sub(msg, group.title))
            }
            title_group_map[group.title] = group
        }

        // map each action to its group
        let group_map = new Map()
        for (let group of container._action_groups) {

            // if a group with the title exists, use that, otherwise
            // create a new group matching the container's group
            if (!(group.title in title_group_map)) {
                title_group_map[group.title] = this.add_argument_group({
                    title: group.title,
                    description: group.description,
                    conflict_handler: group.conflict_handler
                })
            }

            // map the actions to their new group
            for (let action of group._group_actions) {
                group_map.set(action, title_group_map[group.title])
            }
        }

        // add container's mutually exclusive groups
        // NOTE: if add_mutually_exclusive_group ever gains title= and
        // description= then this code will need to be expanded as above
        for (let group of container._mutually_exclusive_groups) {
            let mutex_group = this.add_mutually_exclusive_group({
                required: group.required
            })

            // map the actions to their new mutex group
            for (let action of group._group_actions) {
                group_map.set(action, mutex_group)
            }
        }

        // add all actions to this container or their group
        for (let action of container._actions) {
            group_map.get(action)._add_action(action)
        }
    }

    _get_positional_kwargs() {
        let [
            dest,
            kwargs
        ] = _parse_opts(arguments, {
            dest: no_default,
            '**kwargs': no_default
        })

        // make sure required is not specified
        if ('required' in kwargs) {
            let msg = "'required' is an invalid argument for positionals"
            throw new TypeError(msg)
        }

        // mark positional arguments as required if at least one is
        // always required
        if (![OPTIONAL, ZERO_OR_MORE].includes(kwargs.nargs)) {
            kwargs.required = true
        }
        if (kwargs.nargs === ZERO_OR_MORE && !('default' in kwargs)) {
            kwargs.required = true
        }

        // return the keyword arguments with no option strings
        return Object.assign(kwargs, { dest, option_strings: [] })
    }

    _get_optional_kwargs() {
        let [
            args,
            kwargs
        ] = _parse_opts(arguments, {
            '*args': no_default,
            '**kwargs': no_default
        })

        // determine short and long option strings
        let option_strings = []
        let long_option_strings = []
        let option_string
        for (option_string of args) {
            // error on strings that don't start with an appropriate prefix
            if (!this.prefix_chars.includes(option_string[0])) {
                let args = {option: option_string,
                            prefix_chars: this.prefix_chars}
                let msg = 'invalid option string %(option)r: ' +
                          'must start with a character %(prefix_chars)r'
                throw new TypeError(sub(msg, args))
            }

            // strings starting with two prefix characters are long options
            option_strings.push(option_string)
            if (option_string.length > 1 && this.prefix_chars.includes(option_string[1])) {
                long_option_strings.push(option_string)
            }
        }

        // infer destination, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'
        let dest = kwargs.dest
        delete kwargs.dest
        if (dest === undefined) {
            let dest_option_string
            if (long_option_strings.length) {
                dest_option_string = long_option_strings[0]
            } else {
                dest_option_string = option_strings[0]
            }
            dest = _string_lstrip(dest_option_string, this.prefix_chars)
            if (!dest) {
                let msg = 'dest= is required for options like %r'
                throw new TypeError(sub(msg, option_string))
            }
            dest = dest.replace(/-/g, '_')
        }

        // return the updated keyword arguments
        return Object.assign(kwargs, { dest, option_strings })
    }

    _pop_action_class(kwargs, default_value = undefined) {
        let action = getattr(kwargs, 'action', default_value)
        delete kwargs.action
        return this._registry_get('action', action, action)
    }

    _get_handler() {
        // determine function from conflict handler string
        let handler_func_name = sub('_handle_conflict_%s', this.conflict_handler)
        if (typeof this[handler_func_name] === 'function') {
            return this[handler_func_name]
        } else {
            let msg = 'invalid conflict_resolution value: %r'
            throw new TypeError(sub(msg, this.conflict_handler))
        }
    }

    _check_conflict(action) {

        // find all options that conflict with this option
        let confl_optionals = []
        for (let option_string of action.option_strings) {
            if (hasattr(this._option_string_actions, option_string)) {
                let confl_optional = this._option_string_actions[option_string]
                confl_optionals.push([ option_string, confl_optional ])
            }
        }

        // resolve any conflicts
        if (confl_optionals.length) {
            let conflict_handler = this._get_handler()
            conflict_handler.call(this, action, confl_optionals)
        }
    }

    _handle_conflict_error(action, conflicting_actions) {
        let message = conflicting_actions.length === 1 ?
            'conflicting option string: %s' :
            'conflicting option strings: %s'
        let conflict_string = conflicting_actions.map(([ option_string/*, action*/ ]) => option_string).join(', ')
        throw new ArgumentError(action, sub(message, conflict_string))
    }

    _handle_conflict_resolve(action, conflicting_actions) {

        // remove all conflicting options
        for (let [ option_string, action ] of conflicting_actions) {

            // remove the conflicting option
            _array_remove(action.option_strings, option_string)
            delete this._option_string_actions[option_string]

            // if the option now has no option string, remove it from the
            // container holding it
            if (!action.option_strings.length) {
                action.container._remove_action(action)
            }
        }
    }
}))


const _ArgumentGroup = _callable(class _ArgumentGroup extends _ActionsContainer {

    constructor() {
        let [
            container,
            title,
            description,
            kwargs
        ] = _parse_opts(arguments, {
            container: no_default,
            title: undefined,
            description: undefined,
            '**kwargs': no_default
        })

        // add any missing keyword arguments by checking the container
        setdefault(kwargs, 'conflict_handler', container.conflict_handler)
        setdefault(kwargs, 'prefix_chars', container.prefix_chars)
        setdefault(kwargs, 'argument_default', container.argument_default)
        super(Object.assign({ description }, kwargs))

        // group attributes
        this.title = title
        this._group_actions = []

        // share most attributes with the container
        this._registries = container._registries
        this._actions = container._actions
        this._option_string_actions = container._option_string_actions
        this._defaults = container._defaults
        this._has_negative_number_optionals =
            container._has_negative_number_optionals
        this._mutually_exclusive_groups = container._mutually_exclusive_groups
    }

    _add_action(action) {
        action = super._add_action(action)
        this._group_actions.push(action)
        return action
    }

    _remove_action(action) {
        super._remove_action(action)
        _array_remove(this._group_actions, action)
    }
})


const _MutuallyExclusiveGroup = _callable(class _MutuallyExclusiveGroup extends _ArgumentGroup {

    constructor() {
        let [
            container,
            required
        ] = _parse_opts(arguments, {
            container: no_default,
            required: false
        })

        super(container)
        this.required = required
        this._container = container
    }

    _add_action(action) {
        if (action.required) {
            let msg = 'mutually exclusive arguments must be optional'
            throw new TypeError(msg)
        }
        action = this._container._add_action(action)
        this._group_actions.push(action)
        return action
    }

    _remove_action(action) {
        this._container._remove_action(action)
        _array_remove(this._group_actions, action)
    }
})


const ArgumentParser = _camelcase_alias(_callable(class ArgumentParser extends _AttributeHolder(_ActionsContainer) {
    /*
     *  Object for parsing command line strings into Python objects.
     *
     *  Keyword Arguments:
     *      - prog -- The name of the program (default: sys.argv[0])
     *      - usage -- A usage message (default: auto-generated from arguments)
     *      - description -- A description of what the program does
     *      - epilog -- Text following the argument descriptions
     *      - parents -- Parsers whose arguments should be copied into this one
     *      - formatter_class -- HelpFormatter class for printing help messages
     *      - prefix_chars -- Characters that prefix optional arguments
     *      - fromfile_prefix_chars -- Characters that prefix files containing
     *          additional arguments
     *      - argument_default -- The default value for all arguments
     *      - conflict_handler -- String indicating how to handle conflicts
     *      - add_help -- Add a -h/-help option
     *      - allow_abbrev -- Allow long options to be abbreviated unambiguously
     *      - exit_on_error -- Determines whether or not ArgumentParser exits with
     *          error info when an error occurs
     */

    constructor() {
        let [
            prog,
            usage,
            description,
            epilog,
            parents,
            formatter_class,
            prefix_chars,
            fromfile_prefix_chars,
            argument_default,
            conflict_handler,
            add_help,
            allow_abbrev,
            exit_on_error,
            debug, // LEGACY (v1 compatibility), debug mode
            version // LEGACY (v1 compatibility), version
        ] = _parse_opts(arguments, {
            prog: undefined,
            usage: undefined,
            description: undefined,
            epilog: undefined,
            parents: [],
            formatter_class: HelpFormatter,
            prefix_chars: '-',
            fromfile_prefix_chars: undefined,
            argument_default: undefined,
            conflict_handler: 'error',
            add_help: true,
            allow_abbrev: true,
            exit_on_error: true,
            debug: undefined, // LEGACY (v1 compatibility), debug mode
            version: undefined // LEGACY (v1 compatibility), version
        })

        // LEGACY (v1 compatibility)
        if (debug !== undefined) {
            deprecate('debug',
                'The "debug" argument to ArgumentParser is deprecated. Please ' +
                'override ArgumentParser.exit function instead.'
            )
        }

        if (version !== undefined) {
            deprecate('version',
                'The "version" argument to ArgumentParser is deprecated. Please use ' +
                "add_argument(..., { action: 'version', version: 'N', ... }) instead."
            )
        }
        // end

        super({
            description,
            prefix_chars,
            argument_default,
            conflict_handler
        })

        // default setting for prog
        if (prog === undefined) {
            prog = path.basename(get_argv()[0] || '')
        }

        this.prog = prog
        this.usage = usage
        this.epilog = epilog
        this.formatter_class = formatter_class
        this.fromfile_prefix_chars = fromfile_prefix_chars
        this.add_help = add_help
        this.allow_abbrev = allow_abbrev
        this.exit_on_error = exit_on_error
        // LEGACY (v1 compatibility), debug mode
        this.debug = debug
        // end

        this._positionals = this.add_argument_group('positional arguments')
        this._optionals = this.add_argument_group('optional arguments')
        this._subparsers = undefined

        // register types
        function identity(string) {
            return string
        }
        this.register('type', undefined, identity)
        this.register('type', null, identity)
        this.register('type', 'auto', identity)
        this.register('type', 'int', function (x) {
            let result = Number(x)
            if (!Number.isInteger(result)) {
                throw new TypeError(sub('could not convert string to int: %r', x))
            }
            return result
        })
        this.register('type', 'float', function (x) {
            let result = Number(x)
            if (isNaN(result)) {
                throw new TypeError(sub('could not convert string to float: %r', x))
            }
            return result
        })
        this.register('type', 'str', String)
        // LEGACY (v1 compatibility): custom types
        this.register('type', 'string',
            util.deprecate(String, 'use {type:"str"} or {type:String} instead of {type:"string"}'))
        // end

        // add help argument if necessary
        // (using explicit default to override global argument_default)
        let default_prefix = prefix_chars.includes('-') ? '-' : prefix_chars[0]
        if (this.add_help) {
            this.add_argument(
                default_prefix + 'h',
                default_prefix.repeat(2) + 'help',
                {
                    action: 'help',
                    default: SUPPRESS,
                    help: 'show this help message and exit'
                }
            )
        }
        // LEGACY (v1 compatibility), version
        if (version) {
            this.add_argument(
                default_prefix + 'v',
                default_prefix.repeat(2) + 'version',
                {
                    action: 'version',
                    default: SUPPRESS,
                    version: this.version,
                    help: "show program's version number and exit"
                }
            )
        }
        // end

        // add parent arguments and defaults
        for (let parent of parents) {
            this._add_container_actions(parent)
            Object.assign(this._defaults, parent._defaults)
        }
    }

    // =======================
    // Pretty __repr__ methods
    // =======================
    _get_kwargs() {
        let names = [
            'prog',
            'usage',
            'description',
            'formatter_class',
            'conflict_handler',
            'add_help'
        ]
        return names.map(name => [ name, getattr(this, name) ])
    }

    // ==================================
    // Optional/Positional adding methods
    // ==================================
    add_subparsers() {
        let [
            kwargs
        ] = _parse_opts(arguments, {
            '**kwargs': no_default
        })

        if (this._subparsers !== undefined) {
            this.error('cannot have multiple subparser arguments')
        }

        // add the parser class to the arguments if it's not present
        setdefault(kwargs, 'parser_class', this.constructor)

        if ('title' in kwargs || 'description' in kwargs) {
            let title = getattr(kwargs, 'title', 'subcommands')
            let description = getattr(kwargs, 'description', undefined)
            delete kwargs.title
            delete kwargs.description
            this._subparsers = this.add_argument_group(title, description)
        } else {
            this._subparsers = this._positionals
        }

        // prog defaults to the usage message of this parser, skipping
        // optional arguments and with no "usage:" prefix
        if (kwargs.prog === undefined) {
            let formatter = this._get_formatter()
            let positionals = this._get_positional_actions()
            let groups = this._mutually_exclusive_groups
            formatter.add_usage(this.usage, positionals, groups, '')
            kwargs.prog = formatter.format_help().trim()
        }

        // create the parsers action and add it to the positionals list
        let parsers_class = this._pop_action_class(kwargs, 'parsers')
        // eslint-disable-next-line new-cap
        let action = new parsers_class(Object.assign({ option_strings: [] }, kwargs))
        this._subparsers._add_action(action)

        // return the created parsers action
        return action
    }

    _add_action(action) {
        if (action.option_strings.length) {
            this._optionals._add_action(action)
        } else {
            this._positionals._add_action(action)
        }
        return action
    }

    _get_optional_actions() {
        return this._actions.filter(action => action.option_strings.length)
    }

    _get_positional_actions() {
        return this._actions.filter(action => !action.option_strings.length)
    }

    // =====================================
    // Command line argument parsing methods
    // =====================================
    parse_args(args = undefined, namespace = undefined) {
        let argv
        [ args, argv ] = this.parse_known_args(args, namespace)
        if (argv && argv.length > 0) {
            let msg = 'unrecognized arguments: %s'
            this.error(sub(msg, argv.join(' ')))
        }
        return args
    }

    parse_known_args(args = undefined, namespace = undefined) {
        if (args === undefined) {
            args = get_argv().slice(1)
        }

        // default Namespace built from parser defaults
        if (namespace === undefined) {
            namespace = new Namespace()
        }

        // add any action defaults that aren't present
        for (let action of this._actions) {
            if (action.dest !== SUPPRESS) {
                if (!hasattr(namespace, action.dest)) {
                    if (action.default !== SUPPRESS) {
                        setattr(namespace, action.dest, action.default)
                    }
                }
            }
        }

        // add any parser defaults that aren't present
        for (let dest of Object.keys(this._defaults)) {
            if (!hasattr(namespace, dest)) {
                setattr(namespace, dest, this._defaults[dest])
            }
        }

        // parse the arguments and exit if there are any errors
        if (this.exit_on_error) {
            try {
                [ namespace, args ] = this._parse_known_args(args, namespace)
            } catch (err) {
                if (err instanceof ArgumentError) {
                    this.error(err.message)
                } else {
                    throw err
                }
            }
        } else {
            [ namespace, args ] = this._parse_known_args(args, namespace)
        }

        if (hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR)) {
            args = args.concat(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR))
            delattr(namespace, _UNRECOGNIZED_ARGS_ATTR)
        }

        return [ namespace, args ]
    }

    _parse_known_args(arg_strings, namespace) {
        // replace arg strings that are file references
        if (this.fromfile_prefix_chars !== undefined) {
            arg_strings = this._read_args_from_files(arg_strings)
        }

        // map all mutually exclusive arguments to the other arguments
        // they can't occur with
        let action_conflicts = new Map()
        for (let mutex_group of this._mutually_exclusive_groups) {
            let group_actions = mutex_group._group_actions
            for (let [ i, mutex_action ] of Object.entries(mutex_group._group_actions)) {
                let conflicts = action_conflicts.get(mutex_action) || []
                conflicts = conflicts.concat(group_actions.slice(0, +i))
                conflicts = conflicts.concat(group_actions.slice(+i + 1))
                action_conflicts.set(mutex_action, conflicts)
            }
        }

        // find all option indices, and determine the arg_string_pattern
        // which has an 'O' if there is an option at an index,
        // an 'A' if there is an argument, or a '-' if there is a '--'
        let option_string_indices = {}
        let arg_string_pattern_parts = []
        let arg_strings_iter = Object.entries(arg_strings)[Symbol.iterator]()
        for (let [ i, arg_string ] of arg_strings_iter) {

            // all args after -- are non-options
            if (arg_string === '--') {
                arg_string_pattern_parts.push('-')
                for ([ i, arg_string ] of arg_strings_iter) {
                    arg_string_pattern_parts.push('A')
                }

            // otherwise, add the arg to the arg strings
            // and note the index if it was an option
            } else {
                let option_tuple = this._parse_optional(arg_string)
                let pattern
                if (option_tuple === undefined) {
                    pattern = 'A'
                } else {
                    option_string_indices[i] = option_tuple
                    pattern = 'O'
                }
                arg_string_pattern_parts.push(pattern)
            }
        }

        // join the pieces together to form the pattern
        let arg_strings_pattern = arg_string_pattern_parts.join('')

        // converts arg strings to the appropriate and then takes the action
        let seen_actions = new Set()
        let seen_non_default_actions = new Set()
        let extras

        let take_action = (action, argument_strings, option_string = undefined) => {
            seen_actions.add(action)
            let argument_values = this._get_values(action, argument_strings)

            // error if this argument is not allowed with other previously
            // seen arguments, assuming that actions that use the default
            // value don't really count as "present"
            if (argument_values !== action.default) {
                seen_non_default_actions.add(action)
                for (let conflict_action of action_conflicts.get(action) || []) {
                    if (seen_non_default_actions.has(conflict_action)) {
                        let msg = 'not allowed with argument %s'
                        let action_name = _get_action_name(conflict_action)
                        throw new ArgumentError(action, sub(msg, action_name))
                    }
                }
            }

            // take the action if we didn't receive a SUPPRESS value
            // (e.g. from a default)
            if (argument_values !== SUPPRESS) {
                action(this, namespace, argument_values, option_string)
            }
        }

        // function to convert arg_strings into an optional action
        let consume_optional = start_index => {

            // get the optional identified at this index
            let option_tuple = option_string_indices[start_index]
            let [ action, option_string, explicit_arg ] = option_tuple

            // identify additional optionals in the same arg string
            // (e.g. -xyz is the same as -x -y -z if no args are required)
            let action_tuples = []
            let stop
            for (;;) {

                // if we found no optional action, skip it
                if (action === undefined) {
                    extras.push(arg_strings[start_index])
                    return start_index + 1
                }

                // if there is an explicit argument, try to match the
                // optional's string arguments to only this
                if (explicit_arg !== undefined) {
                    let arg_count = this._match_argument(action, 'A')

                    // if the action is a single-dash option and takes no
                    // arguments, try to parse more single-dash options out
                    // of the tail of the option string
                    let chars = this.prefix_chars
                    if (arg_count === 0 && !chars.includes(option_string[1])) {
                        action_tuples.push([ action, [], option_string ])
                        let char = option_string[0]
                        option_string = char + explicit_arg[0]
                        let new_explicit_arg = explicit_arg.slice(1) || undefined
                        let optionals_map = this._option_string_actions
                        if (hasattr(optionals_map, option_string)) {
                            action = optionals_map[option_string]
                            explicit_arg = new_explicit_arg
                        } else {
                            let msg = 'ignored explicit argument %r'
                            throw new ArgumentError(action, sub(msg, explicit_arg))
                        }

                    // if the action expect exactly one argument, we've
                    // successfully matched the option; exit the loop
                    } else if (arg_count === 1) {
                        stop = start_index + 1
                        let args = [ explicit_arg ]
                        action_tuples.push([ action, args, option_string ])
                        break

                    // error if a double-dash option did not use the
                    // explicit argument
                    } else {
                        let msg = 'ignored explicit argument %r'
                        throw new ArgumentError(action, sub(msg, explicit_arg))
                    }

                // if there is no explicit argument, try to match the
                // optional's string arguments with the following strings
                // if successful, exit the loop
                } else {
                    let start = start_index + 1
                    let selected_patterns = arg_strings_pattern.slice(start)
                    let arg_count = this._match_argument(action, selected_patterns)
                    stop = start + arg_count
                    let args = arg_strings.slice(start, stop)
                    action_tuples.push([ action, args, option_string ])
                    break
                }
            }

            // add the Optional to the list and return the index at which
            // the Optional's string args stopped
            assert(action_tuples.length)
            for (let [ action, args, option_string ] of action_tuples) {
                take_action(action, args, option_string)
            }
            return stop
        }

        // the list of Positionals left to be parsed; this is modified
        // by consume_positionals()
        let positionals = this._get_positional_actions()

        // function to convert arg_strings into positional actions
        let consume_positionals = start_index => {
            // match as many Positionals as possible
            let selected_pattern = arg_strings_pattern.slice(start_index)
            let arg_counts = this._match_arguments_partial(positionals, selected_pattern)

            // slice off the appropriate arg strings for each Positional
            // and add the Positional and its args to the list
            for (let i = 0; i < positionals.length && i < arg_counts.length; i++) {
                let action = positionals[i]
                let arg_count = arg_counts[i]
                let args = arg_strings.slice(start_index, start_index + arg_count)
                start_index += arg_count
                take_action(action, args)
            }

            // slice off the Positionals that we just parsed and return the
            // index at which the Positionals' string args stopped
            positionals = positionals.slice(arg_counts.length)
            return start_index
        }

        // consume Positionals and Optionals alternately, until we have
        // passed the last option string
        extras = []
        let start_index = 0
        let max_option_string_index = Math.max(-1, ...Object.keys(option_string_indices).map(Number))
        while (start_index <= max_option_string_index) {

            // consume any Positionals preceding the next option
            let next_option_string_index = Math.min(
                // eslint-disable-next-line no-loop-func
                ...Object.keys(option_string_indices).map(Number).filter(index => index >= start_index)
            )
            if (start_index !== next_option_string_index) {
                let positionals_end_index = consume_positionals(start_index)

                // only try to parse the next optional if we didn't consume
                // the option string during the positionals parsing
                if (positionals_end_index > start_index) {
                    start_index = positionals_end_index
                    continue
                } else {
                    start_index = positionals_end_index
                }
            }

            // if we consumed all the positionals we could and we're not
            // at the index of an option string, there were extra arguments
            if (!(start_index in option_string_indices)) {
                let strings = arg_strings.slice(start_index, next_option_string_index)
                extras = extras.concat(strings)
                start_index = next_option_string_index
            }

            // consume the next optional and any arguments for it
            start_index = consume_optional(start_index)
        }

        // consume any positionals following the last Optional
        let stop_index = consume_positionals(start_index)

        // if we didn't consume all the argument strings, there were extras
        extras = extras.concat(arg_strings.slice(stop_index))

        // make sure all required actions were present and also convert
        // action defaults which were not given as arguments
        let required_actions = []
        for (let action of this._actions) {
            if (!seen_actions.has(action)) {
                if (action.required) {
                    required_actions.push(_get_action_name(action))
                } else {
                    // Convert action default now instead of doing it before
                    // parsing arguments to avoid calling convert functions
                    // twice (which may fail) if the argument was given, but
                    // only if it was defined already in the namespace
                    if (action.default !== undefined &&
                        typeof action.default === 'string' &&
                        hasattr(namespace, action.dest) &&
                        action.default === getattr(namespace, action.dest)) {
                        setattr(namespace, action.dest,
                                this._get_value(action, action.default))
                    }
                }
            }
        }

        if (required_actions.length) {
            this.error(sub('the following arguments are required: %s',
                       required_actions.join(', ')))
        }

        // make sure all required groups had one option present
        for (let group of this._mutually_exclusive_groups) {
            if (group.required) {
                let no_actions_used = true
                for (let action of group._group_actions) {
                    if (seen_non_default_actions.has(action)) {
                        no_actions_used = false
                        break
                    }
                }

                // if no actions were used, report the error
                if (no_actions_used) {
                    let names = group._group_actions
                        .filter(action => action.help !== SUPPRESS)
                        .map(action => _get_action_name(action))
                    let msg = 'one of the arguments %s is required'
                    this.error(sub(msg, names.join(' ')))
                }
            }
        }

        // return the updated namespace and the extra arguments
        return [ namespace, extras ]
    }

    _read_args_from_files(arg_strings) {
        // expand arguments referencing files
        let new_arg_strings = []
        for (let arg_string of arg_strings) {

            // for regular arguments, just add them back into the list
            if (!arg_string || !this.fromfile_prefix_chars.includes(arg_string[0])) {
                new_arg_strings.push(arg_string)

            // replace arguments referencing files with the file content
            } else {
                try {
                    let args_file = fs.readFileSync(arg_string.slice(1), 'utf8')
                    let arg_strings = []
                    for (let arg_line of splitlines(args_file)) {
                        for (let arg of this.convert_arg_line_to_args(arg_line)) {
                            arg_strings.push(arg)
                        }
                    }
                    arg_strings = this._read_args_from_files(arg_strings)
                    new_arg_strings = new_arg_strings.concat(arg_strings)
                } catch (err) {
                    this.error(err.message)
                }
            }
        }

        // return the modified argument list
        return new_arg_strings
    }

    convert_arg_line_to_args(arg_line) {
        return [arg_line]
    }

    _match_argument(action, arg_strings_pattern) {
        // match the pattern for this action to the arg strings
        let nargs_pattern = this._get_nargs_pattern(action)
        let match = arg_strings_pattern.match(new RegExp('^' + nargs_pattern))

        // raise an exception if we weren't able to find a match
        if (match === null) {
            let nargs_errors = {
                undefined: 'expected one argument',
                [OPTIONAL]: 'expected at most one argument',
                [ONE_OR_MORE]: 'expected at least one argument'
            }
            let msg = nargs_errors[action.nargs]
            if (msg === undefined) {
                msg = sub(action.nargs === 1 ? 'expected %s argument' : 'expected %s arguments', action.nargs)
            }
            throw new ArgumentError(action, msg)
        }

        // return the number of arguments matched
        return match[1].length
    }

    _match_arguments_partial(actions, arg_strings_pattern) {
        // progressively shorten the actions list by slicing off the
        // final actions until we find a match
        let result = []
        for (let i of range(actions.length, 0, -1)) {
            let actions_slice = actions.slice(0, i)
            let pattern = actions_slice.map(action => this._get_nargs_pattern(action)).join('')
            let match = arg_strings_pattern.match(new RegExp('^' + pattern))
            if (match !== null) {
                result = result.concat(match.slice(1).map(string => string.length))
                break
            }
        }

        // return the list of arg string counts
        return result
    }

    _parse_optional(arg_string) {
        // if it's an empty string, it was meant to be a positional
        if (!arg_string) {
            return undefined
        }

        // if it doesn't start with a prefix, it was meant to be positional
        if (!this.prefix_chars.includes(arg_string[0])) {
            return undefined
        }

        // if the option string is present in the parser, return the action
        if (arg_string in this._option_string_actions) {
            let action = this._option_string_actions[arg_string]
            return [ action, arg_string, undefined ]
        }

        // if it's just a single character, it was meant to be positional
        if (arg_string.length === 1) {
            return undefined
        }

        // if the option string before the "=" is present, return the action
        if (arg_string.includes('=')) {
            let [ option_string, explicit_arg ] = _string_split(arg_string, '=', 1)
            if (option_string in this._option_string_actions) {
                let action = this._option_string_actions[option_string]
                return [ action, option_string, explicit_arg ]
            }
        }

        // search through all possible prefixes of the option string
        // and all actions in the parser for possible interpretations
        let option_tuples = this._get_option_tuples(arg_string)

        // if multiple actions match, the option string was ambiguous
        if (option_tuples.length > 1) {
            let options = option_tuples.map(([ /*action*/, option_string/*, explicit_arg*/ ]) => option_string).join(', ')
            let args = {option: arg_string, matches: options}
            let msg = 'ambiguous option: %(option)s could match %(matches)s'
            this.error(sub(msg, args))

        // if exactly one action matched, this segmentation is good,
        // so return the parsed action
        } else if (option_tuples.length === 1) {
            let [ option_tuple ] = option_tuples
            return option_tuple
        }

        // if it was not found as an option, but it looks like a negative
        // number, it was meant to be positional
        // unless there are negative-number-like options
        if (this._negative_number_matcher.test(arg_string)) {
            if (!this._has_negative_number_optionals.length) {
                return undefined
            }
        }

        // if it contains a space, it was meant to be a positional
        if (arg_string.includes(' ')) {
            return undefined
        }

        // it was meant to be an optional but there is no such option
        // in this parser (though it might be a valid option in a subparser)
        return [ undefined, arg_string, undefined ]
    }

    _get_option_tuples(option_string) {
        let result = []

        // option strings starting with two prefix characters are only
        // split at the '='
        let chars = this.prefix_chars
        if (chars.includes(option_string[0]) && chars.includes(option_string[1])) {
            if (this.allow_abbrev) {
                let option_prefix, explicit_arg
                if (option_string.includes('=')) {
                    [ option_prefix, explicit_arg ] = _string_split(option_string, '=', 1)
                } else {
                    option_prefix = option_string
                    explicit_arg = undefined
                }
                for (let option_string of Object.keys(this._option_string_actions)) {
                    if (option_string.startsWith(option_prefix)) {
                        let action = this._option_string_actions[option_string]
                        let tup = [ action, option_string, explicit_arg ]
                        result.push(tup)
                    }
                }
            }

        // single character options can be concatenated with their arguments
        // but multiple character options always have to have their argument
        // separate
        } else if (chars.includes(option_string[0]) && !chars.includes(option_string[1])) {
            let option_prefix = option_string
            let explicit_arg = undefined
            let short_option_prefix = option_string.slice(0, 2)
            let short_explicit_arg = option_string.slice(2)

            for (let option_string of Object.keys(this._option_string_actions)) {
                if (option_string === short_option_prefix) {
                    let action = this._option_string_actions[option_string]
                    let tup = [ action, option_string, short_explicit_arg ]
                    result.push(tup)
                } else if (option_string.startsWith(option_prefix)) {
                    let action = this._option_string_actions[option_string]
                    let tup = [ action, option_string, explicit_arg ]
                    result.push(tup)
                }
            }

        // shouldn't ever get here
        } else {
            this.error(sub('unexpected option string: %s', option_string))
        }

        // return the collected option tuples
        return result
    }

    _get_nargs_pattern(action) {
        // in all examples below, we have to allow for '--' args
        // which are represented as '-' in the pattern
        let nargs = action.nargs
        let nargs_pattern

        // the default (None) is assumed to be a single argument
        if (nargs === undefined) {
            nargs_pattern = '(-*A-*)'

        // allow zero or one arguments
        } else if (nargs === OPTIONAL) {
            nargs_pattern = '(-*A?-*)'

        // allow zero or more arguments
        } else if (nargs === ZERO_OR_MORE) {
            nargs_pattern = '(-*[A-]*)'

        // allow one or more arguments
        } else if (nargs === ONE_OR_MORE) {
            nargs_pattern = '(-*A[A-]*)'

        // allow any number of options or arguments
        } else if (nargs === REMAINDER) {
            nargs_pattern = '([-AO]*)'

        // allow one argument followed by any number of options or arguments
        } else if (nargs === PARSER) {
            nargs_pattern = '(-*A[-AO]*)'

        // suppress action, like nargs=0
        } else if (nargs === SUPPRESS) {
            nargs_pattern = '(-*-*)'

        // all others should be integers
        } else {
            nargs_pattern = sub('(-*%s-*)', 'A'.repeat(nargs).split('').join('-*'))
        }

        // if this is an optional action, -- is not allowed
        if (action.option_strings.length) {
            nargs_pattern = nargs_pattern.replace(/-\*/g, '')
            nargs_pattern = nargs_pattern.replace(/-/g, '')
        }

        // return the pattern
        return nargs_pattern
    }

    // ========================
    // Alt command line argument parsing, allowing free intermix
    // ========================

    parse_intermixed_args(args = undefined, namespace = undefined) {
        let argv
        [ args, argv ] = this.parse_known_intermixed_args(args, namespace)
        if (argv.length) {
            let msg = 'unrecognized arguments: %s'
            this.error(sub(msg, argv.join(' ')))
        }
        return args
    }

    parse_known_intermixed_args(args = undefined, namespace = undefined) {
        // returns a namespace and list of extras
        //
        // positional can be freely intermixed with optionals.  optionals are
        // first parsed with all positional arguments deactivated.  The 'extras'
        // are then parsed.  If the parser definition is incompatible with the
        // intermixed assumptions (e.g. use of REMAINDER, subparsers) a
        // TypeError is raised.
        //
        // positionals are 'deactivated' by setting nargs and default to
        // SUPPRESS.  This blocks the addition of that positional to the
        // namespace

        let extras
        let positionals = this._get_positional_actions()
        let a = positionals.filter(action => [ PARSER, REMAINDER ].includes(action.nargs))
        if (a.length) {
            throw new TypeError(sub('parse_intermixed_args: positional arg' +
                                    ' with nargs=%s', a[0].nargs))
        }

        for (let group of this._mutually_exclusive_groups) {
            for (let action of group._group_actions) {
                if (positionals.includes(action)) {
                    throw new TypeError('parse_intermixed_args: positional in' +
                                        ' mutuallyExclusiveGroup')
                }
            }
        }

        let save_usage
        try {
            save_usage = this.usage
            let remaining_args
            try {
                if (this.usage === undefined) {
                    // capture the full usage for use in error messages
                    this.usage = this.format_usage().slice(7)
                }
                for (let action of positionals) {
                    // deactivate positionals
                    action.save_nargs = action.nargs
                    // action.nargs = 0
                    action.nargs = SUPPRESS
                    action.save_default = action.default
                    action.default = SUPPRESS
                }
                [ namespace, remaining_args ] = this.parse_known_args(args,
                                                                      namespace)
                for (let action of positionals) {
                    // remove the empty positional values from namespace
                    let attr = getattr(namespace, action.dest)
                    if (Array.isArray(attr) && attr.length === 0) {
                        // eslint-disable-next-line no-console
                        console.warn(sub('Do not expect %s in %s', action.dest, namespace))
                        delattr(namespace, action.dest)
                    }
                }
            } finally {
                // restore nargs and usage before exiting
                for (let action of positionals) {
                    action.nargs = action.save_nargs
                    action.default = action.save_default
                }
            }
            let optionals = this._get_optional_actions()
            try {
                // parse positionals.  optionals aren't normally required, but
                // they could be, so make sure they aren't.
                for (let action of optionals) {
                    action.save_required = action.required
                    action.required = false
                }
                for (let group of this._mutually_exclusive_groups) {
                    group.save_required = group.required
                    group.required = false
                }
                [ namespace, extras ] = this.parse_known_args(remaining_args,
                                                              namespace)
            } finally {
                // restore parser values before exiting
                for (let action of optionals) {
                    action.required = action.save_required
                }
                for (let group of this._mutually_exclusive_groups) {
                    group.required = group.save_required
                }
            }
        } finally {
            this.usage = save_usage
        }
        return [ namespace, extras ]
    }

    // ========================
    // Value conversion methods
    // ========================
    _get_values(action, arg_strings) {
        // for everything but PARSER, REMAINDER args, strip out first '--'
        if (![PARSER, REMAINDER].includes(action.nargs)) {
            try {
                _array_remove(arg_strings, '--')
            } catch (err) {}
        }

        let value
        // optional argument produces a default when not present
        if (!arg_strings.length && action.nargs === OPTIONAL) {
            if (action.option_strings.length) {
                value = action.const
            } else {
                value = action.default
            }
            if (typeof value === 'string') {
                value = this._get_value(action, value)
                this._check_value(action, value)
            }

        // when nargs='*' on a positional, if there were no command-line
        // args, use the default if it is anything other than None
        } else if (!arg_strings.length && action.nargs === ZERO_OR_MORE &&
              !action.option_strings.length) {
            if (action.default !== undefined) {
                value = action.default
            } else {
                value = arg_strings
            }
            this._check_value(action, value)

        // single argument or optional argument produces a single value
        } else if (arg_strings.length === 1 && [undefined, OPTIONAL].includes(action.nargs)) {
            let arg_string = arg_strings[0]
            value = this._get_value(action, arg_string)
            this._check_value(action, value)

        // REMAINDER arguments convert all values, checking none
        } else if (action.nargs === REMAINDER) {
            value = arg_strings.map(v => this._get_value(action, v))

        // PARSER arguments convert all values, but check only the first
        } else if (action.nargs === PARSER) {
            value = arg_strings.map(v => this._get_value(action, v))
            this._check_value(action, value[0])

        // SUPPRESS argument does not put anything in the namespace
        } else if (action.nargs === SUPPRESS) {
            value = SUPPRESS

        // all other types of nargs produce a list
        } else {
            value = arg_strings.map(v => this._get_value(action, v))
            for (let v of value) {
                this._check_value(action, v)
            }
        }

        // return the converted value
        return value
    }

    _get_value(action, arg_string) {
        let type_func = this._registry_get('type', action.type, action.type)
        if (typeof type_func !== 'function') {
            let msg = '%r is not callable'
            throw new ArgumentError(action, sub(msg, type_func))
        }

        // convert the value to the appropriate type
        let result
        try {
            try {
                result = type_func(arg_string)
            } catch (err) {
                // Dear TC39, why would you ever consider making es6 classes not callable?
                // We had one universal interface, [[Call]], which worked for anything
                // (with familiar this-instanceof guard for classes). Now we have two.
                if (err instanceof TypeError &&
                    /Class constructor .* cannot be invoked without 'new'/.test(err.message)) {
                    // eslint-disable-next-line new-cap
                    result = new type_func(arg_string)
                } else {
                    throw err
                }
            }

        } catch (err) {
            // ArgumentTypeErrors indicate errors
            if (err instanceof ArgumentTypeError) {
                //let name = getattr(action.type, 'name', repr(action.type))
                let msg = err.message
                throw new ArgumentError(action, msg)

            // TypeErrors or ValueErrors also indicate errors
            } else if (err instanceof TypeError) {
                let name = getattr(action.type, 'name', repr(action.type))
                let args = {type: name, value: arg_string}
                let msg = 'invalid %(type)s value: %(value)r'
                throw new ArgumentError(action, sub(msg, args))
            } else {
                throw err
            }
        }

        // return the converted value
        return result
    }

    _check_value(action, value) {
        // converted value must be one of the choices (if specified)
        if (action.choices !== undefined && !_choices_to_array(action.choices).includes(value)) {
            let args = {value,
                        choices: _choices_to_array(action.choices).map(repr).join(', ')}
            let msg = 'invalid choice: %(value)r (choose from %(choices)s)'
            throw new ArgumentError(action, sub(msg, args))
        }
    }

    // =======================
    // Help-formatting methods
    // =======================
    format_usage() {
        let formatter = this._get_formatter()
        formatter.add_usage(this.usage, this._actions,
                            this._mutually_exclusive_groups)
        return formatter.format_help()
    }

    format_help() {
        let formatter = this._get_formatter()

        // usage
        formatter.add_usage(this.usage, this._actions,
                            this._mutually_exclusive_groups)

        // description
        formatter.add_text(this.description)

        // positionals, optionals and user-defined groups
        for (let action_group of this._action_groups) {
            formatter.start_section(action_group.title)
            formatter.add_text(action_group.description)
            formatter.add_arguments(action_group._group_actions)
            formatter.end_section()
        }

        // epilog
        formatter.add_text(this.epilog)

        // determine help from format above
        return formatter.format_help()
    }

    _get_formatter() {
        // eslint-disable-next-line new-cap
        return new this.formatter_class({ prog: this.prog })
    }

    // =====================
    // Help-printing methods
    // =====================
    print_usage(file = undefined) {
        if (file === undefined) file = process.stdout
        this._print_message(this.format_usage(), file)
    }

    print_help(file = undefined) {
        if (file === undefined) file = process.stdout
        this._print_message(this.format_help(), file)
    }

    _print_message(message, file = undefined) {
        if (message) {
            if (file === undefined) file = process.stderr
            file.write(message)
        }
    }

    // ===============
    // Exiting methods
    // ===============
    exit(status = 0, message = undefined) {
        if (message) {
            this._print_message(message, process.stderr)
        }
        process.exit(status)
    }

    error(message) {
        /*
         *  error(message: string)
         *
         *  Prints a usage message incorporating the message to stderr and
         *  exits.
         *
         *  If you override this in a subclass, it should not return -- it
         *  should either exit or raise an exception.
         */

        // LEGACY (v1 compatibility), debug mode
        if (this.debug === true) throw new Error(message)
        // end
        this.print_usage(process.stderr)
        let args = {prog: this.prog, message: message}
        this.exit(2, sub('%(prog)s: error: %(message)s\n', args))
    }
}))


module.exports = {
    ArgumentParser,
    ArgumentError,
    ArgumentTypeError,
    BooleanOptionalAction,
    FileType,
    HelpFormatter,
    ArgumentDefaultsHelpFormatter,
    RawDescriptionHelpFormatter,
    RawTextHelpFormatter,
    MetavarTypeHelpFormatter,
    Namespace,
    Action,
    ONE_OR_MORE,
    OPTIONAL,
    PARSER,
    REMAINDER,
    SUPPRESS,
    ZERO_OR_MORE
}

// LEGACY (v1 compatibility), Const alias
Object.defineProperty(module.exports, "Const", ({
    get() {
        let result = {}
        Object.entries({ ONE_OR_MORE, OPTIONAL, PARSER, REMAINDER, SUPPRESS, ZERO_OR_MORE }).forEach(([ n, v ]) => {
            Object.defineProperty(result, n, {
                get() {
                    deprecate(n, sub('use argparse.%s instead of argparse.Const.%s', n, n))
                    return v
                }
            })
        })
        Object.entries({ _UNRECOGNIZED_ARGS_ATTR }).forEach(([ n, v ]) => {
            Object.defineProperty(result, n, {
                get() {
                    deprecate(n, sub('argparse.Const.%s is an internal symbol and will no longer be available', n))
                    return v
                }
            })
        })
        return result
    },
    enumerable: false
}))
// end


/***/ }),
/* 4 */
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),
/* 5 */
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),
/* 6 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Limited implementation of python % string operator, supports only %s and %r for now
// (other formats are not used here, but may appear in custom templates)



const { inspect } = __webpack_require__(5)


module.exports = function sub(pattern, ...values) {
    let regex = /%(?:(%)|(-)?(\*)?(?:\((\w+)\))?([A-Za-z]))/g

    let result = pattern.replace(regex, function (_, is_literal, is_left_align, is_padded, name, format) {
        if (is_literal) return '%'

        let padded_count = 0
        if (is_padded) {
            if (values.length === 0) throw new TypeError('not enough arguments for format string')
            padded_count = values.shift()
            if (!Number.isInteger(padded_count)) throw new TypeError('* wants int')
        }

        let str
        if (name !== undefined) {
            let dict = values[0]
            if (typeof dict !== 'object' || dict === null) throw new TypeError('format requires a mapping')
            if (!(name in dict)) throw new TypeError(`no such key: '${name}'`)
            str = dict[name]
        } else {
            if (values.length === 0) throw new TypeError('not enough arguments for format string')
            str = values.shift()
        }

        switch (format) {
            case 's':
                str = String(str)
                break
            case 'r':
                str = inspect(str)
                break
            case 'd':
            case 'i':
                if (typeof str !== 'number') {
                    throw new TypeError(`%${format} format: a number is required, not ${typeof str}`)
                }
                str = String(str.toFixed(0))
                break
            default:
                throw new TypeError(`unsupported format character '${format}'`)
        }

        if (padded_count > 0) {
            return is_left_align ? str.padEnd(padded_count) : str.padStart(padded_count)
        } else {
            return str
        }
    })

    if (values.length) {
        if (values.length === 1 && typeof values[0] === 'object' && values[0] !== null) {
            // mapping
        } else {
            throw new TypeError('not all arguments converted during string formatting')
        }
    }

    return result
}


/***/ }),
/* 7 */
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),
/* 8 */
/***/ ((module) => {

"use strict";
// Partial port of python's argparse module, version 3.9.0 (only wrap and fill functions):
// https://github.com/python/cpython/blob/v3.9.0b4/Lib/textwrap.py



/*
 * Text wrapping and filling.
 */

// Copyright (C) 1999-2001 Gregory P. Ward.
// Copyright (C) 2002, 2003 Python Software Foundation.
// Copyright (C) 2020 argparse.js authors
// Originally written by Greg Ward <gward@python.net>

// Hardcode the recognized whitespace characters to the US-ASCII
// whitespace characters.  The main reason for doing this is that
// some Unicode spaces (like \u00a0) are non-breaking whitespaces.
//
// This less funky little regex just split on recognized spaces. E.g.
//   "Hello there -- you goof-ball, use the -b option!"
// splits into
//   Hello/ /there/ /--/ /you/ /goof-ball,/ /use/ /the/ /-b/ /option!/
const wordsep_simple_re = /([\t\n\x0b\x0c\r ]+)/

class TextWrapper {
    /*
     *  Object for wrapping/filling text.  The public interface consists of
     *  the wrap() and fill() methods; the other methods are just there for
     *  subclasses to override in order to tweak the default behaviour.
     *  If you want to completely replace the main wrapping algorithm,
     *  you'll probably have to override _wrap_chunks().
     *
     *  Several instance attributes control various aspects of wrapping:
     *    width (default: 70)
     *      the maximum width of wrapped lines (unless break_long_words
     *      is false)
     *    initial_indent (default: "")
     *      string that will be prepended to the first line of wrapped
     *      output.  Counts towards the line's width.
     *    subsequent_indent (default: "")
     *      string that will be prepended to all lines save the first
     *      of wrapped output; also counts towards each line's width.
     *    expand_tabs (default: true)
     *      Expand tabs in input text to spaces before further processing.
     *      Each tab will become 0 .. 'tabsize' spaces, depending on its position
     *      in its line.  If false, each tab is treated as a single character.
     *    tabsize (default: 8)
     *      Expand tabs in input text to 0 .. 'tabsize' spaces, unless
     *      'expand_tabs' is false.
     *    replace_whitespace (default: true)
     *      Replace all whitespace characters in the input text by spaces
     *      after tab expansion.  Note that if expand_tabs is false and
     *      replace_whitespace is true, every tab will be converted to a
     *      single space!
     *    fix_sentence_endings (default: false)
     *      Ensure that sentence-ending punctuation is always followed
     *      by two spaces.  Off by default because the algorithm is
     *      (unavoidably) imperfect.
     *    break_long_words (default: true)
     *      Break words longer than 'width'.  If false, those words will not
     *      be broken, and some lines might be longer than 'width'.
     *    break_on_hyphens (default: true)
     *      Allow breaking hyphenated words. If true, wrapping will occur
     *      preferably on whitespaces and right after hyphens part of
     *      compound words.
     *    drop_whitespace (default: true)
     *      Drop leading and trailing whitespace from lines.
     *    max_lines (default: None)
     *      Truncate wrapped lines.
     *    placeholder (default: ' [...]')
     *      Append to the last line of truncated text.
     */

    constructor(options = {}) {
        let {
            width = 70,
            initial_indent = '',
            subsequent_indent = '',
            expand_tabs = true,
            replace_whitespace = true,
            fix_sentence_endings = false,
            break_long_words = true,
            drop_whitespace = true,
            break_on_hyphens = true,
            tabsize = 8,
            max_lines = undefined,
            placeholder=' [...]'
        } = options

        this.width = width
        this.initial_indent = initial_indent
        this.subsequent_indent = subsequent_indent
        this.expand_tabs = expand_tabs
        this.replace_whitespace = replace_whitespace
        this.fix_sentence_endings = fix_sentence_endings
        this.break_long_words = break_long_words
        this.drop_whitespace = drop_whitespace
        this.break_on_hyphens = break_on_hyphens
        this.tabsize = tabsize
        this.max_lines = max_lines
        this.placeholder = placeholder
    }


    // -- Private methods -----------------------------------------------
    // (possibly useful for subclasses to override)

    _munge_whitespace(text) {
        /*
         *  _munge_whitespace(text : string) -> string
         *
         *  Munge whitespace in text: expand tabs and convert all other
         *  whitespace characters to spaces.  Eg. " foo\\tbar\\n\\nbaz"
         *  becomes " foo    bar  baz".
         */
        if (this.expand_tabs) {
            text = text.replace(/\t/g, ' '.repeat(this.tabsize)) // not strictly correct in js
        }
        if (this.replace_whitespace) {
            text = text.replace(/[\t\n\x0b\x0c\r]/g, ' ')
        }
        return text
    }

    _split(text) {
        /*
         *  _split(text : string) -> [string]
         *
         *  Split the text to wrap into indivisible chunks.  Chunks are
         *  not quite the same as words; see _wrap_chunks() for full
         *  details.  As an example, the text
         *    Look, goof-ball -- use the -b option!
         *  breaks into the following chunks:
         *    'Look,', ' ', 'goof-', 'ball', ' ', '--', ' ',
         *    'use', ' ', 'the', ' ', '-b', ' ', 'option!'
         *  if break_on_hyphens is True, or in:
         *    'Look,', ' ', 'goof-ball', ' ', '--', ' ',
         *    'use', ' ', 'the', ' ', '-b', ' ', option!'
         *  otherwise.
         */
        let chunks = text.split(wordsep_simple_re)
        chunks = chunks.filter(Boolean)
        return chunks
    }

    _handle_long_word(reversed_chunks, cur_line, cur_len, width) {
        /*
         *  _handle_long_word(chunks : [string],
         *                    cur_line : [string],
         *                    cur_len : int, width : int)
         *
         *  Handle a chunk of text (most likely a word, not whitespace) that
         *  is too long to fit in any line.
         */
        // Figure out when indent is larger than the specified width, and make
        // sure at least one character is stripped off on every pass
        let space_left
        if (width < 1) {
            space_left = 1
        } else {
            space_left = width - cur_len
        }

        // If we're allowed to break long words, then do so: put as much
        // of the next chunk onto the current line as will fit.
        if (this.break_long_words) {
            cur_line.push(reversed_chunks[reversed_chunks.length - 1].slice(0, space_left))
            reversed_chunks[reversed_chunks.length - 1] = reversed_chunks[reversed_chunks.length - 1].slice(space_left)

        // Otherwise, we have to preserve the long word intact.  Only add
        // it to the current line if there's nothing already there --
        // that minimizes how much we violate the width constraint.
        } else if (!cur_line) {
            cur_line.push(...reversed_chunks.pop())
        }

        // If we're not allowed to break long words, and there's already
        // text on the current line, do nothing.  Next time through the
        // main loop of _wrap_chunks(), we'll wind up here again, but
        // cur_len will be zero, so the next line will be entirely
        // devoted to the long word that we can't handle right now.
    }

    _wrap_chunks(chunks) {
        /*
         *  _wrap_chunks(chunks : [string]) -> [string]
         *
         *  Wrap a sequence of text chunks and return a list of lines of
         *  length 'self.width' or less.  (If 'break_long_words' is false,
         *  some lines may be longer than this.)  Chunks correspond roughly
         *  to words and the whitespace between them: each chunk is
         *  indivisible (modulo 'break_long_words'), but a line break can
         *  come between any two chunks.  Chunks should not have internal
         *  whitespace; ie. a chunk is either all whitespace or a "word".
         *  Whitespace chunks will be removed from the beginning and end of
         *  lines, but apart from that whitespace is preserved.
         */
        let lines = []
        let indent
        if (this.width <= 0) {
            throw Error(`invalid width ${this.width} (must be > 0)`)
        }
        if (this.max_lines !== undefined) {
            if (this.max_lines > 1) {
                indent = this.subsequent_indent
            } else {
                indent = this.initial_indent
            }
            if (indent.length + this.placeholder.trimStart().length > this.width) {
                throw Error('placeholder too large for max width')
            }
        }

        // Arrange in reverse order so items can be efficiently popped
        // from a stack of chucks.
        chunks = chunks.reverse()

        while (chunks.length > 0) {

            // Start the list of chunks that will make up the current line.
            // cur_len is just the length of all the chunks in cur_line.
            let cur_line = []
            let cur_len = 0

            // Figure out which static string will prefix this line.
            let indent
            if (lines) {
                indent = this.subsequent_indent
            } else {
                indent = this.initial_indent
            }

            // Maximum width for this line.
            let width = this.width - indent.length

            // First chunk on line is whitespace -- drop it, unless this
            // is the very beginning of the text (ie. no lines started yet).
            if (this.drop_whitespace && chunks[chunks.length - 1].trim() === '' && lines.length > 0) {
                chunks.pop()
            }

            while (chunks.length > 0) {
                let l = chunks[chunks.length - 1].length

                // Can at least squeeze this chunk onto the current line.
                if (cur_len + l <= width) {
                    cur_line.push(chunks.pop())
                    cur_len += l

                // Nope, this line is full.
                } else {
                    break
                }
            }

            // The current line is full, and the next chunk is too big to
            // fit on *any* line (not just this one).
            if (chunks.length && chunks[chunks.length - 1].length > width) {
                this._handle_long_word(chunks, cur_line, cur_len, width)
                cur_len = cur_line.map(l => l.length).reduce((a, b) => a + b, 0)
            }

            // If the last chunk on this line is all whitespace, drop it.
            if (this.drop_whitespace && cur_line.length > 0 && cur_line[cur_line.length - 1].trim() === '') {
                cur_len -= cur_line[cur_line.length - 1].length
                cur_line.pop()
            }

            if (cur_line) {
                if (this.max_lines === undefined ||
                    lines.length + 1 < this.max_lines ||
                    (chunks.length === 0 ||
                     this.drop_whitespace &&
                     chunks.length === 1 &&
                     !chunks[0].trim()) && cur_len <= width) {
                    // Convert current line back to a string and store it in
                    // list of all lines (return value).
                    lines.push(indent + cur_line.join(''))
                } else {
                    let had_break = false
                    while (cur_line) {
                        if (cur_line[cur_line.length - 1].trim() &&
                            cur_len + this.placeholder.length <= width) {
                            cur_line.push(this.placeholder)
                            lines.push(indent + cur_line.join(''))
                            had_break = true
                            break
                        }
                        cur_len -= cur_line[-1].length
                        cur_line.pop()
                    }
                    if (!had_break) {
                        if (lines) {
                            let prev_line = lines[lines.length - 1].trimEnd()
                            if (prev_line.length + this.placeholder.length <=
                                    this.width) {
                                lines[lines.length - 1] = prev_line + this.placeholder
                                break
                            }
                        }
                        lines.push(indent + this.placeholder.lstrip())
                    }
                    break
                }
            }
        }

        return lines
    }

    _split_chunks(text) {
        text = this._munge_whitespace(text)
        return this._split(text)
    }

    // -- Public interface ----------------------------------------------

    wrap(text) {
        /*
         *  wrap(text : string) -> [string]
         *
         *  Reformat the single paragraph in 'text' so it fits in lines of
         *  no more than 'self.width' columns, and return a list of wrapped
         *  lines.  Tabs in 'text' are expanded with string.expandtabs(),
         *  and all other whitespace characters (including newline) are
         *  converted to space.
         */
        let chunks = this._split_chunks(text)
        // not implemented in js
        //if (this.fix_sentence_endings) {
        //    this._fix_sentence_endings(chunks)
        //}
        return this._wrap_chunks(chunks)
    }

    fill(text) {
        /*
         *  fill(text : string) -> string
         *
         *  Reformat the single paragraph in 'text' to fit in lines of no
         *  more than 'self.width' columns, and return a new string
         *  containing the entire wrapped paragraph.
         */
        return this.wrap(text).join('\n')
    }
}


// -- Convenience interface ---------------------------------------------

function wrap(text, options = {}) {
    /*
     *  Wrap a single paragraph of text, returning a list of wrapped lines.
     *
     *  Reformat the single paragraph in 'text' so it fits in lines of no
     *  more than 'width' columns, and return a list of wrapped lines.  By
     *  default, tabs in 'text' are expanded with string.expandtabs(), and
     *  all other whitespace characters (including newline) are converted to
     *  space.  See TextWrapper class for available keyword args to customize
     *  wrapping behaviour.
     */
    let { width = 70, ...kwargs } = options
    let w = new TextWrapper(Object.assign({ width }, kwargs))
    return w.wrap(text)
}

function fill(text, options = {}) {
    /*
     *  Fill a single paragraph of text, returning a new string.
     *
     *  Reformat the single paragraph in 'text' to fit in lines of no more
     *  than 'width' columns, and return a new string containing the entire
     *  wrapped paragraph.  As with wrap(), tabs are expanded and other
     *  whitespace characters converted to space.  See TextWrapper class for
     *  available keyword args to customize wrapping behaviour.
     */
    let { width = 70, ...kwargs } = options
    let w = new TextWrapper(Object.assign({ width }, kwargs))
    return w.fill(text)
}

// -- Loosely related functionality -------------------------------------

let _whitespace_only_re = /^[ \t]+$/mg
let _leading_whitespace_re = /(^[ \t]*)(?:[^ \t\n])/mg

function dedent(text) {
    /*
     *  Remove any common leading whitespace from every line in `text`.
     *
     *  This can be used to make triple-quoted strings line up with the left
     *  edge of the display, while still presenting them in the source code
     *  in indented form.
     *
     *  Note that tabs and spaces are both treated as whitespace, but they
     *  are not equal: the lines "  hello" and "\\thello" are
     *  considered to have no common leading whitespace.
     *
     *  Entirely blank lines are normalized to a newline character.
     */
    // Look for the longest leading string of spaces and tabs common to
    // all lines.
    let margin = undefined
    text = text.replace(_whitespace_only_re, '')
    let indents = text.match(_leading_whitespace_re) || []
    for (let indent of indents) {
        indent = indent.slice(0, -1)

        if (margin === undefined) {
            margin = indent

        // Current line more deeply indented than previous winner:
        // no change (previous winner is still on top).
        } else if (indent.startsWith(margin)) {
            // pass

        // Current line consistent with and no deeper than previous winner:
        // it's the new winner.
        } else if (margin.startsWith(indent)) {
            margin = indent

        // Find the largest common whitespace between current line and previous
        // winner.
        } else {
            for (let i = 0; i < margin.length && i < indent.length; i++) {
                if (margin[i] !== indent[i]) {
                    margin = margin.slice(0, i)
                    break
                }
            }
        }
    }

    if (margin) {
        text = text.replace(new RegExp('^' + margin, 'mg'), '')
    }
    return text
}

module.exports = { wrap, fill, dedent }


/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GameSystem: () => (/* reexport safe */ _json_map__WEBPACK_IMPORTED_MODULE_1__.GameSystem),
/* harmony export */   ImageMap: () => (/* reexport safe */ _image_map__WEBPACK_IMPORTED_MODULE_0__.ImageMap)
/* harmony export */ });
/* harmony import */ var _image_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var _json_map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);




/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ImageMap: () => (/* binding */ ImageMap)
/* harmony export */ });
class ImageMap {
    name;
    width;
    height;
    data;
    bytes;
    constructor(name, width, height, data) {
        this.name = name;
        this.width = width;
        this.height = height;
        this.data = data;
        this.bytes = data.length;
    }
    channels() {
        let channels = 1;
        let c = this.bytes / this.width / this.height;
        if (c > 4) {
            channels = 4;
        }
        else if (c < 1) {
            channels = 1;
        }
        else {
            channels = c;
        }
        return channels;
    }
    ;
}


/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GameSystem: () => (/* binding */ GameSystem)
/* harmony export */ });
var GameSystem;
(function (GameSystem) {
    GameSystem[GameSystem["DnD5e"] = 0] = "DnD5e";
    GameSystem[GameSystem["Pathfinder"] = 1] = "Pathfinder";
    GameSystem[GameSystem["Patfhinder2e"] = 2] = "Patfhinder2e";
    GameSystem[GameSystem["Starfinder"] = 3] = "Starfinder";
})(GameSystem || (GameSystem = {}));
let testJson = {
    name: 'test',
    title: 'test',
    author: 'test',
    creation_date: 'test',
    assets: []
};


/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GetPdfDafa: () => (/* reexport safe */ _pdf_extractor__WEBPACK_IMPORTED_MODULE_1__.GetPdfDafa),
/* harmony export */   ImageSaver: () => (/* reexport module object */ _image_saver__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   JsonExtractor: () => (/* reexport safe */ _json_extractor__WEBPACK_IMPORTED_MODULE_0__.JsonExtractor)
/* harmony export */ });
/* harmony import */ var _json_extractor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var _pdf_extractor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18);
/* harmony import */ var _image_saver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(45);





/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JsonExtractor: () => (/* binding */ JsonExtractor)
/* harmony export */ });
/* harmony import */ var _mappings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/* harmony import */ var _schemas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);


function JsonExtractor(system, docName) {
    switch (system) {
        case _mappings__WEBPACK_IMPORTED_MODULE_0__.GameSystem.Starfinder:
            return starfinderFactory(docName);
        case _mappings__WEBPACK_IMPORTED_MODULE_0__.GameSystem.DnD5e:
        case _mappings__WEBPACK_IMPORTED_MODULE_0__.GameSystem.Pathfinder:
        case _mappings__WEBPACK_IMPORTED_MODULE_0__.GameSystem.Patfhinder2e:
        default:
            return undefined;
    }
}
function starfinderFactory(docName) {
    return _schemas__WEBPACK_IMPORTED_MODULE_1__.StarfinderList.find(schema => schema.title === docName);
}


/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StarfinderList: () => (/* binding */ StarfinderList)
/* harmony export */ });
/* harmony import */ var _sfrpg_alien_archive_1_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _sfrpg_alien_archive_2_json__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16);
/* harmony import */ var _sfrpg_alien_archive_3_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);



const StarfinderList = [
    _sfrpg_alien_archive_1_json__WEBPACK_IMPORTED_MODULE_0__,
    _sfrpg_alien_archive_2_json__WEBPACK_IMPORTED_MODULE_1__,
    _sfrpg_alien_archive_3_json__WEBPACK_IMPORTED_MODULE_2__,
];


/***/ }),
/* 15 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"$schema":"../pdf_schema.json","name":"alien_archives_1","title":"PZO7105E.pdf","author":"Copyright 2017 Paizo Inc.","creation_date":"D:20170808175333-07\'-00\'","assets":{"alien_archives":{"Aeon Guard":{"id":"WZvgJseACvlCNqrT","orig":"img_p7_7","icon":"img_p8_9"},"Aeon Guard Specialist":{"id":"g8RVg32DwUoYvkWe","orig":"img_p7_7","icon":"img_p8_9"},"Ahav":{"id":"FTn1x9aRTBNAq5Kq","orig":"img_p9_2","icon":"img_p10_4"},"Anacite Laborer":{"id":"QdINalLf6rRRL8OS","orig":"img_p11_3","icon":"img_p12_2"},"Anacite Wingbot":{"id":"oCTQI68v9Alt2pfP","orig":"img_p12_1"},"Barachius":{"id":"tdFDm4Hw5sdtjPId","orig":"img_p13_1","icon":"img_p14_2"},"Apari":{"id":"mpchkkvbiKHoLdto","orig":"img_p15_1","icon":"img_p16_1"},"Apari Constituent":{"id":"ijWFbXqDk7sqKN5T","orig":"img_p16_3"},"Assembly Ooze":{"id":"zjktKO2wLiLrAsyY","orig":"img_p17_1","icon":"img_p18_1"},"Asteray":{"id":"Ntsjeawqk6QzSlOE","orig":"img_p19_2","icon":"img_p20_1","additional":["img_p20_2"]},"Barathu":{"id":"tM35G3YiwebUP7qb","orig":"img_p22_3"},"Barathu (Early Stage)":{"id":"hxQsdQUyjDEFHO0i","orig":"img_p21_1","icon":"img_p22_1"},"Bloodbrother":{"id":"MjO5gIWQAbjsVCGp","orig":"img_p23_1","icon":"img_p24_1"},"Bryrvath":{"id":"7FZHTF7AnSiRmgVO","orig":"img_p25_2","icon":"img_p26_1"},"Caypin":{"id":"Nk06Qs43IKHAKz3H","orig":"img_p27_1","icon":"img_p28_1","additional":["img_p20_2"]},"Contemplative":{"id":"UDM8QKhEOIUnaEj7","orig":"img_p29_1","icon":"img_p30_1"},"Contemplative Mentor":{"id":"t6h5sj3nM7OVRfaM","orig":"img_p30_3"},"Crest-Eater":{"id":"PaKThmRGLYWWX2bC","orig":"img_p31_1","icon":"img_p32_1"},"Deh-Nolo":{"id":"4l9FGozKp56cDILa","orig":"img_p33_1","icon":"img_p34_1","additional":["img_p34_3"]},"Devil, Endbringer Devil (Dhalochar)":{"id":"NGfNlBJ8MUjkwDFB","orig":"img_p35_1","icon":"img_p36_2"},"Draelik":{"id":"RIprzWBQsM77aJqB","orig":"img_p37_2","icon":"img_p38_1"},"Dragon (Chromatic), Young Adult Blue Dragon":{"id":"bIMg9b9x1df3xrc5","orig":"img_p39_1","icon":"img_p40_1"},"Dragonkin":{"id":"EWYDjeqj2wKrSlRf","orig":"img_p41_1","icon":"img_p42_1","additional":["img_p42_3"]},"Drow, Drow Enforcer":{"id":"IDdI8ud0W2H6Zwtq","orig":"img_p43_1","icon":"img_p44_4"},"Drow, Drow Noble Arms Dealer":{"id":"vd2ir0oiOm468fHd","orig":"img_p44_5"},"Electrovore":{"id":"7RvBrqrxj0lU8HDn","orig":"img_p45_1","icon":"img_p46_3"},"Elemental, Tiny Elemental":{"id":"1wFa1VLmqsIRYzts","orig":"img_p47_3","icon":"img_p48_3"},"Elemental, Medium Elemental":{"id":"y49fGxezprkoqPCX","orig":"img_p48_2"},"Ellicoth":{"id":"cOnSbV6DtFw0cMVZ","orig":"img_p49_1","icon":"img_p50_2"},"Formian Worker":{"id":"jDiSlxkeRmHB7KVl","orig":"img_p52_3","icon":"img_p52_1"},"Formian Warrior":{"id":"Zo1eabjvHjbxKLhV","orig":"img_p51_1"},"Frujai Colony":{"id":"D1yOmDSe3AvfgmeT","orig":"img_p53_1","icon":"img_p54_1"},"Frujai Soldier":{"id":"QKApkamFbqDOvlFw","orig":"img_p54_2"},"Goblin Zaperator, Space":{"id":"rYqcQSfW9JNZvrgu","orig":"img_p55_1","icon":"img_p56_1","additional":["img_p56_3"]},"Goblin Honchohead, Space":{"id":"o2yiClN2r7hePI1r","orig":"img_p55_1","icon":"img_p56_1"},"Gray":{"id":"iGyssnNyuKkLUoe3","orig":"img_p57_1","icon":"img_p58_1"},"Haan":{"id":"JGy9KPW4TDCVGVRm","orig":"img_p59_1","icon":"img_p60_1"},"Haan Combat Pilot":{"id":"ATVLMtL1ytPHWA5Q","orig":"img_p60_3"},"Hallajin":{"id":"5VTsS5lNTvOi9Qm1","orig":"img_p61_1","icon":"img_p62_2","additional":["img_p62_3"]},"Hesper":{"id":"LxY10hWgykJ1mHPR","orig":"img_p63_1","icon":"img_p64_1","additional":["img_p64_2"]},"Ikeshti Brood-Minder":{"id":"qorX15hHEV5fnEmR","orig":"img_p65_1","icon":"img_p66_1"},"Ikeshti Rivener":{"id":"pbG9jF39GJMJNAVI","orig":"img_p66_3"},"Inevitable, Anhamut":{"id":"ZKgodvTA0JrdvAw2","orig":"img_p67_1","icon":"img_p68_1","additional":["img_p68_3"]},"Kalo Sharkhunter":{"id":"lYX7TqpyqYGuEseQ","orig":"img_p70_3","icon":"img_p70_1"},"Kalo Deepspeaker":{"id":"o8ROezUgr2CPYuse","orig":"img_p69_1"},"Ksarik":{"id":"cotdeRcSwXSWmRnz","orig":"img_p71_1","icon":"img_p72_1"},"Kyokor":{"id":"OskZ4ZdcAm3Mky2k","orig":"img_p73_1","icon":"img_p74_1"},"Maraquoi Hunter":{"id":"nwBkawW3ovzllcw8","orig":"img_p75_1","icon":"img_p76_2"},"Maraquoi Shaman":{"id":"z1UoKhNtCSHMdYH6","orig":"img_p76_3"},"Marooned One":{"id":"9oyzluBAgOQVTkdU","orig":"img_p77_2","icon":"img_p78_1","additional":["img_p78_3"]},"Mountain Eel":{"id":"Mr6efnQ3BwDjRXd6","orig":"img_p79_1","icon":"img_p80_2","additional":["img_p80_1"]},"Necrovite":{"id":"ljSw5nhGM96SAqpw","orig":"img_p81_1","icon":"img_p82_1"},"Nihili":{"id":"1HX0TcrpW7wsPHG1","orig":"img_p83_1","icon":"img_p84_1"},"Nihili Captain":{"id":"J5pekj8xf6gFexm8","orig":"img_p83_1","icon":"img_p84_1"},"Nuar Enforcer":{"id":"K9j2qI3vSHyBDTaw","orig":"img_p87_1","icon":"img_p88_2","additional":["img_p88_3"]},"Nuar Specialist":{"id":"VAP4WgYWhIVjrZ95","orig":"img_p87_1","icon":"img_p88_2","additional":["img_p88_3"]},"Oma":{"id":"UJdN6AgYHWhq7o7S","orig":"img_p89_3","icon":"img_p90_3"},"Orocoran":{"id":"qf76Avpdu38Ogwf9","orig":"img_p91_1","icon":"img_p92_1"},"Orocoran Ichor Lord":{"id":"68Zh2g0gInpBEmdh","orig":"img_p92_2"},"Reptoid":{"id":"4qnbAsjt5tYVJ3PQ","orig":"img_p94_3"},"Reptoid Master":{"id":"ObcDKO4FCjAq6CrG","orig":"img_p93_1","icon":"img_p94_2"},"Robot (Security), Patrol-Class":{"id":"DWUaxunk0vwLCmQ8","orig":"img_p96_3"},"Robot (Security), Observer-Class":{"id":"oqthkU2Ix5TLLWHt","orig":"img_p95_1","icon":"img_p96_1"},"Ryphorian Technician":{"id":"dip7t11VYLzcu19k","orig":"img_p97_1","icon":"img_p98_2"},"Ryphorian Skyfire Pilot":{"id":"XFBxFNz0W1LT7ONr","orig":"img_p98_3"},"Sarcesian Sniper":{"id":"eaFja8SMFehmeRWK","orig":"img_p99_1","icon":"img_p100_1"},"Sarcesian Cybercommando":{"id":"hPoSxp2DVmtBqdag","orig":"img_p99_1","icon":"img_p100_1"},"Scavenger Slime":{"id":"J93HimYHpTa3qFVu","orig":"img_p101_1","icon":"img_p102_1"},"Sharpwing":{"id":"R1B6IJ7A9PKWRbfM","orig":"img_p103_1","icon":"img_p104_1"},"Shobhad":{"id":"WBwkX9oEraWtEQzs","orig":"img_p105_1","icon":"img_p106_2"},"Shobhad Warleader":{"id":"YgIEtjj2hEErVfwL","orig":"img_p106_3"},"Skittermander Whelp":{"id":"xir7197v8MgibmU9","orig":"img_p107_1"},"Skittermander":{"id":"p1G9Jk04tqB4cI1X","orig":"img_p108_3","icon":"img_p108_2"},"Surnoch":{"id":"pdmOr9NEQHgYJDFK","orig":"img_p109_1","icon":"img_p110_2"},"The Swarm, Corrovox":{"id":"2qbiJSmMCDVdaRrR","orig":"img_p111_1","icon":"img_p112_1"},"The Swarm, Thresher Lord":{"id":"SEPRMVRjQlBTGdnj","orig":"img_p112_2"},"Symbiend":{"id":"CO2YirHMuhfZgEDK","orig":"img_p113_1","icon":"img_p114_1"},"Damoritosh\'s Arm Host":{"id":"LP6hXmgEC0WG94K9","orig":"img_p114_2"},"Undead Minion, Cybernetic Zombie":{"id":"Lm6T2ReFaBXLoXbB","orig":"img_p115_1","icon":"img_p116_1"},"Urog":{"id":"JbEglOaLQboHa0TG","orig":"img_p117_1","icon":"img_p118_2","additional":["img_p118_3"]},"Verthani Aether Pilot":{"id":"oYtsrRPplxH4Zl34","orig":"img_p120_3"},"Verthani Pure One":{"id":"vHkWZbvEzuJRnJGp","orig":"img_p119_1","icon":"img_p120_2"},"Void Hag":{"id":"jqjSEiKtCg5rZwuP","orig":"img_p121_1","icon":"img_p122_1","additional":["img_p122_2"]},"Witchwyrd":{"id":"DxpOpmviBiLLNN2U","orig":"img_p123_1","icon":"img_p124_2"},"Wrikreechee":{"id":"lrnpQylZEgTvDZqE","orig":"img_p125_1","icon":"img_p126_2","additional":["img_p126_3"]}},"archetype_features":{},"archetypes":{},"equipment":{"Barachius helm":{"id":"zhwtcYRlSM1bCvkk","orig":"img_p13_1"},"Bloodbrother serum":{"id":"igzMXZrMGVeXVcLl","orig":"img_p24_2"},"Aura goggles":{"id":"aY5SzYd5RW0feC9X","orig":"img_p26_3"},"Bone cestus, measured":{"id":"EiIXu4PUYfHQMtzq","orig":"img_p32_2"},"Shadowstaff, Standard (ranged)":{"id":"bo4Zjh3U33RkLVqZ","orig":"img_p38_2"},"Lesser Shadowstaff (ranged)":{"id":"98FOgPPDdLainh1A","orig":"img_p38_2"},"Electrovore glove, tempest":{"id":"9Pc6ENEnpZU2s0No","orig":"img_p46_4"},"Adaptive serum, Mk 1":{"id":"1sS9DH3TBSnI6TQQ","orig":"img_p72_2"},"Adaptive serum, Mk 2":{"id":"ZC2SF1K3DCnGKAMy","orig":"img_p72_2"},"Adaptive serum, Mk 3":{"id":"8gYz7Fujm9xb2ANW","orig":"img_p72_2"},"Kyokor plating I":{"id":"BwOYoxphrQWz1el3","orig":"img_p74_2"},"Kyokor plating II":{"id":"pGK9e40KS7PYrM62","orig":"img_p74_2"},"Kyokor plating III":{"id":"SGOqDqiroXGLzkm6","orig":"img_p74_2"},"Kyokor plating IV":{"id":"VWWXOfwuP8nT9kB0","orig":"img_p74_2"},"Kyokor plating V":{"id":"4tMbnx3q5pENCj8l","orig":"img_p74_2"},"Eoxian Wrackstaff":{"id":"ecCdoxwqOvfNp6Am","orig":"img_p82_2"},"Diasporan rifle, advanced":{"id":"2nWb4IAYcbW8mOth","orig":"img_p100_3"},"Diasporan rifle, ultra":{"id":"8re7PxUQQ7eBQVgS","orig":"img_p100_3"},"Diasporan rifle, tactical":{"id":"r65YZS2ZmQvGSAPJ","orig":"img_p100_3"},"Diasporan rifle, elite":{"id":"yN9wOQPIOelIrbvP","orig":"img_p100_3"},"Diasporan rifle, imperial":{"id":"z5cRUOkx9pdhHKeo","orig":"img_p100_3"},"Ocucloak processor":{"id":"zWtsejTYzWNU0TCF","orig":"img_p104_2"},"Acid lancer, melter-class":{"id":"TaKCOSKUR2gCJgf2","orig":"img_p110_1"},"Acid lancer, corroder-class":{"id":"py6EBDtgKQnZMsVl","orig":"img_p110_1"},"Acid lancer, disintegrator-class":{"id":"tRFj98ItL181cFhO","orig":"img_p110_1"},"Acid lancer, liquefier-class":{"id":"zZwrA4SusXXoAYRu","orig":"img_p110_1"}},"starship_components":{"Oma":{"id":"11iDFArwuDhvzFxI","orig":"img_p90_2"}},"starships":{"Endbringer Devil":{"id":"kayep1LyosKKAaIH","orig":"img_p36_1"},"Novaspawn":{"id":"AH3k7fEglnjueg0M","orig":"img_p85_1","icon":"img_p86_2","additional":["img_p86_1"]}}}}');

/***/ }),
/* 16 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"$schema":"../pdf_schema.json","name":"alien_archives_2","title":"Alien Archive 2","author":"Copyright 2017 Paizo Inc.","creation_date":"","assets":{}}');

/***/ }),
/* 17 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"$schema":"../pdf_schema.json","name":"alien_archives_3","title":"Alien Archive 3","author":"Copyright 2017 Paizo Inc.","creation_date":"","assets":{}}');

/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GetPdfDafa: () => (/* binding */ GetPdfDafa)
/* harmony export */ });
/* harmony import */ var pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(19);
/* harmony import */ var pdfjs_dist__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _mappings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);


class PdfData {
    title;
    author;
    creationDate;
    images;
    constructor(title, author, creationDate) {
        this.title = title;
        this.author = author;
        this.creationDate = creationDate;
        this.images = [];
    }
}
pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.GlobalWorkerOptions.workerSrc =
    "../../node_modules/pdfjs-dist/build/pdf.worker.js";
async function GetPdfDafa(path) {
    let pdf = await (0,pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.getDocument)(path).promise;
    const metadata = await pdf.getMetadata();
    let pdf_data = new PdfData(metadata.info['Title'], metadata.info['Author'], metadata.info['CreationDate']);
    const totalNumPages = pdf.numPages;
    for (let currentPage = 1; currentPage <= totalNumPages; currentPage += 1) {
        const images = getPageImages(currentPage, pdf);
        pdf_data.images.push(...await images);
    }
    return await pdf_data;
}
async function getPageImages(pageNum, pdf) {
    const images = [];
    try {
        const pdfPage = await pdf.getPage(pageNum);
        const operatorList = await pdfPage.getOperatorList();
        const validObjectTypes = [
            pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.paintJpegXObject,
            pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.paintImageXObject,
            pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.OPS.paintInlineImageXObject
        ];
        operatorList.fnArray
            .forEach((element, idx) => {
            if (validObjectTypes.includes(element)) {
                const imageName = operatorList.argsArray[idx][0];
                console.log('page', pageNum, 'imageName', imageName);
                pdfPage.objs.get(imageName, async (image) => {
                    const { width, height, _kind } = image;
                    images.push(new _mappings__WEBPACK_IMPORTED_MODULE_1__.ImageMap(imageName, width, height, image.data));
                });
            }
        });
    }
    catch (error) {
        console.log(error);
    }
    return images;
}


/***/ }),
/* 19 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2022 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */

(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(globalThis, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.UNSUPPORTED_FEATURES = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.LINE_FACTOR = exports.LINE_DESCENT_FACTOR = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationEditorType = exports.AnnotationEditorPrefix = exports.AnnotationEditorParamsType = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;
exports.arrayByteLength = arrayByteLength;
exports.arraysToBytes = arraysToBytes;
exports.assert = assert;
exports.bytesToString = bytesToString;
exports.createPromiseCapability = createPromiseCapability;
exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
exports.escapeString = escapeString;
exports.getModificationDate = getModificationDate;
exports.getVerbosityLevel = getVerbosityLevel;
exports.info = info;
exports.isArrayBuffer = isArrayBuffer;
exports.isArrayEqual = isArrayEqual;
exports.isAscii = isAscii;
exports.objectFromMap = objectFromMap;
exports.objectSize = objectSize;
exports.setVerbosityLevel = setVerbosityLevel;
exports.shadow = shadow;
exports.string32 = string32;
exports.stringToBytes = stringToBytes;
exports.stringToPDFString = stringToPDFString;
exports.stringToUTF16BEString = stringToUTF16BEString;
exports.stringToUTF8String = stringToUTF8String;
exports.unreachable = unreachable;
exports.utf8StringToString = utf8StringToString;
exports.warn = warn;

__w_pdfjs_require__(2);

const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
const LINE_FACTOR = 1.35;
exports.LINE_FACTOR = LINE_FACTOR;
const LINE_DESCENT_FACTOR = 0.35;
exports.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;
const RenderingIntentFlag = {
  ANY: 0x01,
  DISPLAY: 0x02,
  PRINT: 0x04,
  ANNOTATIONS_FORMS: 0x10,
  ANNOTATIONS_STORAGE: 0x20,
  ANNOTATIONS_DISABLE: 0x40,
  OPLIST: 0x100
};
exports.RenderingIntentFlag = RenderingIntentFlag;
const AnnotationMode = {
  DISABLE: 0,
  ENABLE: 1,
  ENABLE_FORMS: 2,
  ENABLE_STORAGE: 3
};
exports.AnnotationMode = AnnotationMode;
const AnnotationEditorPrefix = "pdfjs_internal_editor_";
exports.AnnotationEditorPrefix = AnnotationEditorPrefix;
const AnnotationEditorType = {
  DISABLE: -1,
  NONE: 0,
  FREETEXT: 3,
  INK: 15
};
exports.AnnotationEditorType = AnnotationEditorType;
const AnnotationEditorParamsType = {
  FREETEXT_SIZE: 1,
  FREETEXT_COLOR: 2,
  FREETEXT_OPACITY: 3,
  INK_COLOR: 11,
  INK_THICKNESS: 12,
  INK_OPACITY: 13
};
exports.AnnotationEditorParamsType = AnnotationEditorParamsType;
const PermissionFlag = {
  PRINT: 0x04,
  MODIFY_CONTENTS: 0x08,
  COPY: 0x10,
  MODIFY_ANNOTATIONS: 0x20,
  FILL_INTERACTIVE_FORMS: 0x100,
  COPY_FOR_ACCESSIBILITY: 0x200,
  ASSEMBLE: 0x400,
  PRINT_HIGH_QUALITY: 0x800
};
exports.PermissionFlag = PermissionFlag;
const TextRenderingMode = {
  FILL: 0,
  STROKE: 1,
  FILL_STROKE: 2,
  INVISIBLE: 3,
  FILL_ADD_TO_PATH: 4,
  STROKE_ADD_TO_PATH: 5,
  FILL_STROKE_ADD_TO_PATH: 6,
  ADD_TO_PATH: 7,
  FILL_STROKE_MASK: 3,
  ADD_TO_PATH_FLAG: 4
};
exports.TextRenderingMode = TextRenderingMode;
const ImageKind = {
  GRAYSCALE_1BPP: 1,
  RGB_24BPP: 2,
  RGBA_32BPP: 3
};
exports.ImageKind = ImageKind;
const AnnotationType = {
  TEXT: 1,
  LINK: 2,
  FREETEXT: 3,
  LINE: 4,
  SQUARE: 5,
  CIRCLE: 6,
  POLYGON: 7,
  POLYLINE: 8,
  HIGHLIGHT: 9,
  UNDERLINE: 10,
  SQUIGGLY: 11,
  STRIKEOUT: 12,
  STAMP: 13,
  CARET: 14,
  INK: 15,
  POPUP: 16,
  FILEATTACHMENT: 17,
  SOUND: 18,
  MOVIE: 19,
  WIDGET: 20,
  SCREEN: 21,
  PRINTERMARK: 22,
  TRAPNET: 23,
  WATERMARK: 24,
  THREED: 25,
  REDACT: 26
};
exports.AnnotationType = AnnotationType;
const AnnotationStateModelType = {
  MARKED: "Marked",
  REVIEW: "Review"
};
exports.AnnotationStateModelType = AnnotationStateModelType;
const AnnotationMarkedState = {
  MARKED: "Marked",
  UNMARKED: "Unmarked"
};
exports.AnnotationMarkedState = AnnotationMarkedState;
const AnnotationReviewState = {
  ACCEPTED: "Accepted",
  REJECTED: "Rejected",
  CANCELLED: "Cancelled",
  COMPLETED: "Completed",
  NONE: "None"
};
exports.AnnotationReviewState = AnnotationReviewState;
const AnnotationReplyType = {
  GROUP: "Group",
  REPLY: "R"
};
exports.AnnotationReplyType = AnnotationReplyType;
const AnnotationFlag = {
  INVISIBLE: 0x01,
  HIDDEN: 0x02,
  PRINT: 0x04,
  NOZOOM: 0x08,
  NOROTATE: 0x10,
  NOVIEW: 0x20,
  READONLY: 0x40,
  LOCKED: 0x80,
  TOGGLENOVIEW: 0x100,
  LOCKEDCONTENTS: 0x200
};
exports.AnnotationFlag = AnnotationFlag;
const AnnotationFieldFlag = {
  READONLY: 0x0000001,
  REQUIRED: 0x0000002,
  NOEXPORT: 0x0000004,
  MULTILINE: 0x0001000,
  PASSWORD: 0x0002000,
  NOTOGGLETOOFF: 0x0004000,
  RADIO: 0x0008000,
  PUSHBUTTON: 0x0010000,
  COMBO: 0x0020000,
  EDIT: 0x0040000,
  SORT: 0x0080000,
  FILESELECT: 0x0100000,
  MULTISELECT: 0x0200000,
  DONOTSPELLCHECK: 0x0400000,
  DONOTSCROLL: 0x0800000,
  COMB: 0x1000000,
  RICHTEXT: 0x2000000,
  RADIOSINUNISON: 0x2000000,
  COMMITONSELCHANGE: 0x4000000
};
exports.AnnotationFieldFlag = AnnotationFieldFlag;
const AnnotationBorderStyleType = {
  SOLID: 1,
  DASHED: 2,
  BEVELED: 3,
  INSET: 4,
  UNDERLINE: 5
};
exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
const AnnotationActionEventType = {
  E: "Mouse Enter",
  X: "Mouse Exit",
  D: "Mouse Down",
  U: "Mouse Up",
  Fo: "Focus",
  Bl: "Blur",
  PO: "PageOpen",
  PC: "PageClose",
  PV: "PageVisible",
  PI: "PageInvisible",
  K: "Keystroke",
  F: "Format",
  V: "Validate",
  C: "Calculate"
};
exports.AnnotationActionEventType = AnnotationActionEventType;
const DocumentActionEventType = {
  WC: "WillClose",
  WS: "WillSave",
  DS: "DidSave",
  WP: "WillPrint",
  DP: "DidPrint"
};
exports.DocumentActionEventType = DocumentActionEventType;
const PageActionEventType = {
  O: "PageOpen",
  C: "PageClose"
};
exports.PageActionEventType = PageActionEventType;
const StreamType = {
  UNKNOWN: "UNKNOWN",
  FLATE: "FLATE",
  LZW: "LZW",
  DCT: "DCT",
  JPX: "JPX",
  JBIG: "JBIG",
  A85: "A85",
  AHX: "AHX",
  CCF: "CCF",
  RLX: "RLX"
};
exports.StreamType = StreamType;
const FontType = {
  UNKNOWN: "UNKNOWN",
  TYPE1: "TYPE1",
  TYPE1STANDARD: "TYPE1STANDARD",
  TYPE1C: "TYPE1C",
  CIDFONTTYPE0: "CIDFONTTYPE0",
  CIDFONTTYPE0C: "CIDFONTTYPE0C",
  TRUETYPE: "TRUETYPE",
  CIDFONTTYPE2: "CIDFONTTYPE2",
  TYPE3: "TYPE3",
  OPENTYPE: "OPENTYPE",
  TYPE0: "TYPE0",
  MMTYPE1: "MMTYPE1"
};
exports.FontType = FontType;
const VerbosityLevel = {
  ERRORS: 0,
  WARNINGS: 1,
  INFOS: 5
};
exports.VerbosityLevel = VerbosityLevel;
const CMapCompressionType = {
  NONE: 0,
  BINARY: 1,
  STREAM: 2
};
exports.CMapCompressionType = CMapCompressionType;
const OPS = {
  dependency: 1,
  setLineWidth: 2,
  setLineCap: 3,
  setLineJoin: 4,
  setMiterLimit: 5,
  setDash: 6,
  setRenderingIntent: 7,
  setFlatness: 8,
  setGState: 9,
  save: 10,
  restore: 11,
  transform: 12,
  moveTo: 13,
  lineTo: 14,
  curveTo: 15,
  curveTo2: 16,
  curveTo3: 17,
  closePath: 18,
  rectangle: 19,
  stroke: 20,
  closeStroke: 21,
  fill: 22,
  eoFill: 23,
  fillStroke: 24,
  eoFillStroke: 25,
  closeFillStroke: 26,
  closeEOFillStroke: 27,
  endPath: 28,
  clip: 29,
  eoClip: 30,
  beginText: 31,
  endText: 32,
  setCharSpacing: 33,
  setWordSpacing: 34,
  setHScale: 35,
  setLeading: 36,
  setFont: 37,
  setTextRenderingMode: 38,
  setTextRise: 39,
  moveText: 40,
  setLeadingMoveText: 41,
  setTextMatrix: 42,
  nextLine: 43,
  showText: 44,
  showSpacedText: 45,
  nextLineShowText: 46,
  nextLineSetSpacingShowText: 47,
  setCharWidth: 48,
  setCharWidthAndBounds: 49,
  setStrokeColorSpace: 50,
  setFillColorSpace: 51,
  setStrokeColor: 52,
  setStrokeColorN: 53,
  setFillColor: 54,
  setFillColorN: 55,
  setStrokeGray: 56,
  setFillGray: 57,
  setStrokeRGBColor: 58,
  setFillRGBColor: 59,
  setStrokeCMYKColor: 60,
  setFillCMYKColor: 61,
  shadingFill: 62,
  beginInlineImage: 63,
  beginImageData: 64,
  endInlineImage: 65,
  paintXObject: 66,
  markPoint: 67,
  markPointProps: 68,
  beginMarkedContent: 69,
  beginMarkedContentProps: 70,
  endMarkedContent: 71,
  beginCompat: 72,
  endCompat: 73,
  paintFormXObjectBegin: 74,
  paintFormXObjectEnd: 75,
  beginGroup: 76,
  endGroup: 77,
  beginAnnotations: 78,
  endAnnotations: 79,
  beginAnnotation: 80,
  endAnnotation: 81,
  paintJpegXObject: 82,
  paintImageMaskXObject: 83,
  paintImageMaskXObjectGroup: 84,
  paintImageXObject: 85,
  paintInlineImageXObject: 86,
  paintInlineImageXObjectGroup: 87,
  paintImageXObjectRepeat: 88,
  paintImageMaskXObjectRepeat: 89,
  paintSolidColorImageMask: 90,
  constructPath: 91
};
exports.OPS = OPS;
const UNSUPPORTED_FEATURES = {
  unknown: "unknown",
  forms: "forms",
  javaScript: "javaScript",
  signatures: "signatures",
  smask: "smask",
  shadingPattern: "shadingPattern",
  font: "font",
  errorTilingPattern: "errorTilingPattern",
  errorExtGState: "errorExtGState",
  errorXObject: "errorXObject",
  errorFontLoadType3: "errorFontLoadType3",
  errorFontState: "errorFontState",
  errorFontMissing: "errorFontMissing",
  errorFontTranslate: "errorFontTranslate",
  errorColorSpace: "errorColorSpace",
  errorOperatorList: "errorOperatorList",
  errorFontToUnicode: "errorFontToUnicode",
  errorFontLoadNative: "errorFontLoadNative",
  errorFontBuildPath: "errorFontBuildPath",
  errorFontGetPath: "errorFontGetPath",
  errorMarkedContent: "errorMarkedContent",
  errorContentSubStream: "errorContentSubStream"
};
exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
const PasswordResponses = {
  NEED_PASSWORD: 1,
  INCORRECT_PASSWORD: 2
};
exports.PasswordResponses = PasswordResponses;
let verbosity = VerbosityLevel.WARNINGS;

function setVerbosityLevel(level) {
  if (Number.isInteger(level)) {
    verbosity = level;
  }
}

function getVerbosityLevel() {
  return verbosity;
}

function info(msg) {
  if (verbosity >= VerbosityLevel.INFOS) {
    console.log(`Info: ${msg}`);
  }
}

function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.log(`Warning: ${msg}`);
  }
}

function unreachable(msg) {
  throw new Error(msg);
}

function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}

function _isValidProtocol(url) {
  if (!url) {
    return false;
  }

  switch (url.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return true;

    default:
      return false;
  }
}

function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
  if (!url) {
    return null;
  }

  try {
    if (options && typeof url === "string") {
      if (options.addDefaultProtocol && url.startsWith("www.")) {
        const dots = url.match(/\./g);

        if (dots && dots.length >= 2) {
          url = `http://${url}`;
        }
      }

      if (options.tryConvertEncoding) {
        try {
          url = stringToUTF8String(url);
        } catch (ex) {}
      }
    }

    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);

    if (_isValidProtocol(absoluteUrl)) {
      return absoluteUrl;
    }
  } catch (ex) {}

  return null;
}

function shadow(obj, prop, value) {
  Object.defineProperty(obj, prop, {
    value,
    enumerable: true,
    configurable: true,
    writable: false
  });
  return value;
}

const BaseException = function BaseExceptionClosure() {
  function BaseException(message, name) {
    if (this.constructor === BaseException) {
      unreachable("Cannot initialize BaseException.");
    }

    this.message = message;
    this.name = name;
  }

  BaseException.prototype = new Error();
  BaseException.constructor = BaseException;
  return BaseException;
}();

exports.BaseException = BaseException;

class PasswordException extends BaseException {
  constructor(msg, code) {
    super(msg, "PasswordException");
    this.code = code;
  }

}

exports.PasswordException = PasswordException;

class UnknownErrorException extends BaseException {
  constructor(msg, details) {
    super(msg, "UnknownErrorException");
    this.details = details;
  }

}

exports.UnknownErrorException = UnknownErrorException;

class InvalidPDFException extends BaseException {
  constructor(msg) {
    super(msg, "InvalidPDFException");
  }

}

exports.InvalidPDFException = InvalidPDFException;

class MissingPDFException extends BaseException {
  constructor(msg) {
    super(msg, "MissingPDFException");
  }

}

exports.MissingPDFException = MissingPDFException;

class UnexpectedResponseException extends BaseException {
  constructor(msg, status) {
    super(msg, "UnexpectedResponseException");
    this.status = status;
  }

}

exports.UnexpectedResponseException = UnexpectedResponseException;

class FormatError extends BaseException {
  constructor(msg) {
    super(msg, "FormatError");
  }

}

exports.FormatError = FormatError;

class AbortException extends BaseException {
  constructor(msg) {
    super(msg, "AbortException");
  }

}

exports.AbortException = AbortException;

function bytesToString(bytes) {
  if (typeof bytes !== "object" || bytes === null || bytes.length === undefined) {
    unreachable("Invalid argument for bytesToString");
  }

  const length = bytes.length;
  const MAX_ARGUMENT_COUNT = 8192;

  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }

  const strBuf = [];

  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    const chunk = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk));
  }

  return strBuf.join("");
}

function stringToBytes(str) {
  if (typeof str !== "string") {
    unreachable("Invalid argument for stringToBytes");
  }

  const length = str.length;
  const bytes = new Uint8Array(length);

  for (let i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 0xff;
  }

  return bytes;
}

function arrayByteLength(arr) {
  if (arr.length !== undefined) {
    return arr.length;
  }

  if (arr.byteLength !== undefined) {
    return arr.byteLength;
  }

  unreachable("Invalid argument for arrayByteLength");
}

function arraysToBytes(arr) {
  const length = arr.length;

  if (length === 1 && arr[0] instanceof Uint8Array) {
    return arr[0];
  }

  let resultLength = 0;

  for (let i = 0; i < length; i++) {
    resultLength += arrayByteLength(arr[i]);
  }

  let pos = 0;
  const data = new Uint8Array(resultLength);

  for (let i = 0; i < length; i++) {
    let item = arr[i];

    if (!(item instanceof Uint8Array)) {
      if (typeof item === "string") {
        item = stringToBytes(item);
      } else {
        item = new Uint8Array(item);
      }
    }

    const itemLength = item.byteLength;
    data.set(item, pos);
    pos += itemLength;
  }

  return data;
}

function string32(value) {
  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
}

function objectSize(obj) {
  return Object.keys(obj).length;
}

function objectFromMap(map) {
  const obj = Object.create(null);

  for (const [key, value] of map) {
    obj[key] = value;
  }

  return obj;
}

function isLittleEndian() {
  const buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}

function isEvalSupported() {
  try {
    new Function("");
    return true;
  } catch (e) {
    return false;
  }
}

class FeatureTest {
  static get isLittleEndian() {
    return shadow(this, "isLittleEndian", isLittleEndian());
  }

  static get isEvalSupported() {
    return shadow(this, "isEvalSupported", isEvalSupported());
  }

  static get isOffscreenCanvasSupported() {
    return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
  }

}

exports.FeatureTest = FeatureTest;
const hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, "0"));

class Util {
  static makeHexColor(r, g, b) {
    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
  }

  static scaleMinMax(transform, minMax) {
    let temp;

    if (transform[0]) {
      if (transform[0] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[1];
        minMax[1] = temp;
      }

      minMax[0] *= transform[0];
      minMax[1] *= transform[0];

      if (transform[3] < 0) {
        temp = minMax[2];
        minMax[2] = minMax[3];
        minMax[3] = temp;
      }

      minMax[2] *= transform[3];
      minMax[3] *= transform[3];
    } else {
      temp = minMax[0];
      minMax[0] = minMax[2];
      minMax[2] = temp;
      temp = minMax[1];
      minMax[1] = minMax[3];
      minMax[3] = temp;

      if (transform[1] < 0) {
        temp = minMax[2];
        minMax[2] = minMax[3];
        minMax[3] = temp;
      }

      minMax[2] *= transform[1];
      minMax[3] *= transform[1];

      if (transform[2] < 0) {
        temp = minMax[0];
        minMax[0] = minMax[1];
        minMax[1] = temp;
      }

      minMax[0] *= transform[2];
      minMax[1] *= transform[2];
    }

    minMax[0] += transform[4];
    minMax[1] += transform[4];
    minMax[2] += transform[5];
    minMax[3] += transform[5];
  }

  static transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  }

  static applyTransform(p, m) {
    const xt = p[0] * m[0] + p[1] * m[2] + m[4];
    const yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  }

  static applyInverseTransform(p, m) {
    const d = m[0] * m[3] - m[1] * m[2];
    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  }

  static getAxialAlignedBoundingBox(r, m) {
    const p1 = Util.applyTransform(r, m);
    const p2 = Util.applyTransform(r.slice(2, 4), m);
    const p3 = Util.applyTransform([r[0], r[3]], m);
    const p4 = Util.applyTransform([r[2], r[1]], m);
    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
  }

  static inverseTransform(m) {
    const d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  }

  static apply3dTransform(m, v) {
    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
  }

  static singularValueDecompose2dScale(m) {
    const transpose = [m[0], m[2], m[1], m[3]];
    const a = m[0] * transpose[0] + m[1] * transpose[2];
    const b = m[0] * transpose[1] + m[1] * transpose[3];
    const c = m[2] * transpose[0] + m[3] * transpose[2];
    const d = m[2] * transpose[1] + m[3] * transpose[3];
    const first = (a + d) / 2;
    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;
    const sx = first + second || 1;
    const sy = first - second || 1;
    return [Math.sqrt(sx), Math.sqrt(sy)];
  }

  static normalizeRect(rect) {
    const r = rect.slice(0);

    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }

    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }

    return r;
  }

  static intersect(rect1, rect2) {
    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));

    if (xLow > xHigh) {
      return null;
    }

    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));

    if (yLow > yHigh) {
      return null;
    }

    return [xLow, yLow, xHigh, yHigh];
  }

  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {
    const tvalues = [],
          bounds = [[], []];
    let a, b, c, t, t1, t2, b2ac, sqrtb2ac;

    for (let i = 0; i < 2; ++i) {
      if (i === 0) {
        b = 6 * x0 - 12 * x1 + 6 * x2;
        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
        c = 3 * x1 - 3 * x0;
      } else {
        b = 6 * y0 - 12 * y1 + 6 * y2;
        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
        c = 3 * y1 - 3 * y0;
      }

      if (Math.abs(a) < 1e-12) {
        if (Math.abs(b) < 1e-12) {
          continue;
        }

        t = -c / b;

        if (0 < t && t < 1) {
          tvalues.push(t);
        }

        continue;
      }

      b2ac = b * b - 4 * c * a;
      sqrtb2ac = Math.sqrt(b2ac);

      if (b2ac < 0) {
        continue;
      }

      t1 = (-b + sqrtb2ac) / (2 * a);

      if (0 < t1 && t1 < 1) {
        tvalues.push(t1);
      }

      t2 = (-b - sqrtb2ac) / (2 * a);

      if (0 < t2 && t2 < 1) {
        tvalues.push(t2);
      }
    }

    let j = tvalues.length,
        mt;
    const jlen = j;

    while (j--) {
      t = tvalues[j];
      mt = 1 - t;
      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
    }

    bounds[0][jlen] = x0;
    bounds[1][jlen] = y0;
    bounds[0][jlen + 1] = x3;
    bounds[1][jlen + 1] = y3;
    bounds[0].length = bounds[1].length = jlen + 2;
    return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];
  }

}

exports.Util = Util;
const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];

function stringToPDFString(str) {
  if (str[0] >= "\xEF") {
    let encoding;

    if (str[0] === "\xFE" && str[1] === "\xFF") {
      encoding = "utf-16be";
    } else if (str[0] === "\xFF" && str[1] === "\xFE") {
      encoding = "utf-16le";
    } else if (str[0] === "\xEF" && str[1] === "\xBB" && str[2] === "\xBF") {
      encoding = "utf-8";
    }

    if (encoding) {
      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = stringToBytes(str);
        return decoder.decode(buffer);
      } catch (ex) {
        warn(`stringToPDFString: "${ex}".`);
      }
    }
  }

  const strBuf = [];

  for (let i = 0, ii = str.length; i < ii; i++) {
    const code = PDFStringTranslateTable[str.charCodeAt(i)];
    strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
  }

  return strBuf.join("");
}

function escapeString(str) {
  return str.replace(/([()\\\n\r])/g, match => {
    if (match === "\n") {
      return "\\n";
    } else if (match === "\r") {
      return "\\r";
    }

    return `\\${match}`;
  });
}

function isAscii(str) {
  return /^[\x00-\x7F]*$/.test(str);
}

function stringToUTF16BEString(str) {
  const buf = ["\xFE\xFF"];

  for (let i = 0, ii = str.length; i < ii; i++) {
    const char = str.charCodeAt(i);
    buf.push(String.fromCharCode(char >> 8 & 0xff), String.fromCharCode(char & 0xff));
  }

  return buf.join("");
}

function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}

function utf8StringToString(str) {
  return unescape(encodeURIComponent(str));
}

function isArrayBuffer(v) {
  return typeof v === "object" && v !== null && v.byteLength !== undefined;
}

function isArrayEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  for (let i = 0, ii = arr1.length; i < ii; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
}

function getModificationDate(date = new Date()) {
  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
  return buffer.join("");
}

function createPromiseCapability() {
  const capability = Object.create(null);
  let isSettled = false;
  Object.defineProperty(capability, "settled", {
    get() {
      return isSettled;
    }

  });
  capability.promise = new Promise(function (resolve, reject) {
    capability.resolve = function (data) {
      isSettled = true;
      resolve(data);
    };

    capability.reject = function (reason) {
      isSettled = true;
      reject(reason);
    };
  });
  return capability;
}

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {



var _is_node = __w_pdfjs_require__(3);

;

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isNodeJS = void 0;
const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
exports.isNodeJS = isNodeJS;

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.build = exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;
exports.getDocument = getDocument;
exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
exports.version = void 0;

var _util = __w_pdfjs_require__(1);

var _annotation_storage = __w_pdfjs_require__(5);

var _display_utils = __w_pdfjs_require__(8);

var _font_loader = __w_pdfjs_require__(11);

var _canvas = __w_pdfjs_require__(12);

var _worker_options = __w_pdfjs_require__(15);

var _is_node = __w_pdfjs_require__(3);

var _message_handler = __w_pdfjs_require__(16);

var _metadata = __w_pdfjs_require__(17);

var _optional_content_config = __w_pdfjs_require__(18);

var _transport_stream = __w_pdfjs_require__(19);

var _xfa_text = __w_pdfjs_require__(20);

const DEFAULT_RANGE_CHUNK_SIZE = 65536;
const RENDERING_CANCELLED_TIMEOUT = 100;
let DefaultCanvasFactory = _display_utils.DOMCanvasFactory;
exports.DefaultCanvasFactory = DefaultCanvasFactory;
let DefaultCMapReaderFactory = _display_utils.DOMCMapReaderFactory;
exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
let DefaultStandardFontDataFactory = _display_utils.DOMStandardFontDataFactory;
exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;

if (_is_node.isNodeJS) {
  const {
    NodeCanvasFactory,
    NodeCMapReaderFactory,
    NodeStandardFontDataFactory
  } = __w_pdfjs_require__(21);

  exports.DefaultCanvasFactory = DefaultCanvasFactory = NodeCanvasFactory;
  exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory = NodeCMapReaderFactory;
  exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory = NodeStandardFontDataFactory;
}

let createPDFNetworkStream;

function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
  createPDFNetworkStream = pdfNetworkStreamFactory;
}

function getDocument(src) {
  const task = new PDFDocumentLoadingTask();
  let source;

  if (typeof src === "string" || src instanceof URL) {
    source = {
      url: src
    };
  } else if ((0, _util.isArrayBuffer)(src)) {
    source = {
      data: src
    };
  } else if (src instanceof PDFDataRangeTransport) {
    source = {
      range: src
    };
  } else {
    if (typeof src !== "object") {
      throw new Error("Invalid parameter in getDocument, " + "need either string, URL, TypedArray, or parameter object.");
    }

    if (!src.url && !src.data && !src.range) {
      throw new Error("Invalid parameter object: need either .data, .range or .url");
    }

    source = src;
  }

  const params = Object.create(null);
  let rangeTransport = null,
      worker = null;

  for (const key in source) {
    const value = source[key];

    switch (key) {
      case "url":
        if (typeof window !== "undefined") {
          try {
            params[key] = new URL(value, window.location).href;
            continue;
          } catch (ex) {
            (0, _util.warn)(`Cannot create valid URL: "${ex}".`);
          }
        } else if (typeof value === "string" || value instanceof URL) {
          params[key] = value.toString();
          continue;
        }

        throw new Error("Invalid PDF url data: " + "either string or URL-object is expected in the url property.");

      case "range":
        rangeTransport = value;
        continue;

      case "worker":
        worker = value;
        continue;

      case "data":
        if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value instanceof Buffer) {
          params[key] = new Uint8Array(value);
        } else if (value instanceof Uint8Array) {
          break;
        } else if (typeof value === "string") {
          params[key] = (0, _util.stringToBytes)(value);
        } else if (typeof value === "object" && value !== null && !isNaN(value.length)) {
          params[key] = new Uint8Array(value);
        } else if ((0, _util.isArrayBuffer)(value)) {
          params[key] = new Uint8Array(value);
        } else {
          throw new Error("Invalid PDF binary data: either TypedArray, " + "string, or array-like object is expected in the data property.");
        }

        continue;
    }

    params[key] = value;
  }

  params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
  params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;
  params.ignoreErrors = params.stopAtErrors !== true;
  params.fontExtraProperties = params.fontExtraProperties === true;
  params.pdfBug = params.pdfBug === true;
  params.enableXfa = params.enableXfa === true;

  if (!Number.isInteger(params.rangeChunkSize) || params.rangeChunkSize < 1) {
    params.rangeChunkSize = DEFAULT_RANGE_CHUNK_SIZE;
  }

  if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
    params.docBaseUrl = null;
  }

  if (!Number.isInteger(params.maxImageSize) || params.maxImageSize < -1) {
    params.maxImageSize = -1;
  }

  if (typeof params.cMapUrl !== "string") {
    params.cMapUrl = null;
  }

  if (typeof params.standardFontDataUrl !== "string") {
    params.standardFontDataUrl = null;
  }

  if (typeof params.useWorkerFetch !== "boolean") {
    params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;
  }

  if (typeof params.isEvalSupported !== "boolean") {
    params.isEvalSupported = true;
  }

  if (typeof params.disableFontFace !== "boolean") {
    params.disableFontFace = _is_node.isNodeJS;
  }

  if (typeof params.useSystemFonts !== "boolean") {
    params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;
  }

  if (typeof params.ownerDocument !== "object" || params.ownerDocument === null) {
    params.ownerDocument = globalThis.document;
  }

  if (typeof params.disableRange !== "boolean") {
    params.disableRange = false;
  }

  if (typeof params.disableStream !== "boolean") {
    params.disableStream = false;
  }

  if (typeof params.disableAutoFetch !== "boolean") {
    params.disableAutoFetch = false;
  }

  (0, _util.setVerbosityLevel)(params.verbosity);

  if (!worker) {
    const workerParams = {
      verbosity: params.verbosity,
      port: _worker_options.GlobalWorkerOptions.workerPort
    };
    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
    task._worker = worker;
  }

  const docId = task.docId;
  worker.promise.then(function () {
    if (task.destroyed) {
      throw new Error("Loading aborted");
    }

    const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);

    const networkStreamPromise = new Promise(function (resolve) {
      let networkStream;

      if (rangeTransport) {
        networkStream = new _transport_stream.PDFDataTransportStream({
          length: params.length,
          initialData: params.initialData,
          progressiveDone: params.progressiveDone,
          contentDispositionFilename: params.contentDispositionFilename,
          disableRange: params.disableRange,
          disableStream: params.disableStream
        }, rangeTransport);
      } else if (!params.data) {
        networkStream = createPDFNetworkStream({
          url: params.url,
          length: params.length,
          httpHeaders: params.httpHeaders,
          withCredentials: params.withCredentials,
          rangeChunkSize: params.rangeChunkSize,
          disableRange: params.disableRange,
          disableStream: params.disableStream
        });
      }

      resolve(networkStream);
    });
    return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) {
      if (task.destroyed) {
        throw new Error("Loading aborted");
      }

      const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);
      const transport = new WorkerTransport(messageHandler, task, networkStream, params);
      task._transport = transport;
      messageHandler.send("Ready", null);
    });
  }).catch(task._capability.reject);
  return task;
}

async function _fetchDocument(worker, source, pdfDataRangeTransport, docId) {
  if (worker.destroyed) {
    throw new Error("Worker was destroyed");
  }

  if (pdfDataRangeTransport) {
    source.length = pdfDataRangeTransport.length;
    source.initialData = pdfDataRangeTransport.initialData;
    source.progressiveDone = pdfDataRangeTransport.progressiveDone;
    source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
  }

  const workerId = await worker.messageHandler.sendWithPromise("GetDocRequest", {
    docId,
    apiVersion: '2.16.105',
    source: {
      data: source.data,
      url: source.url,
      password: source.password,
      disableAutoFetch: source.disableAutoFetch,
      rangeChunkSize: source.rangeChunkSize,
      length: source.length
    },
    maxImageSize: source.maxImageSize,
    disableFontFace: source.disableFontFace,
    docBaseUrl: source.docBaseUrl,
    ignoreErrors: source.ignoreErrors,
    isEvalSupported: source.isEvalSupported,
    fontExtraProperties: source.fontExtraProperties,
    enableXfa: source.enableXfa,
    useSystemFonts: source.useSystemFonts,
    cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,
    standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null
  });

  if (source.data) {
    source.data = null;
  }

  if (worker.destroyed) {
    throw new Error("Worker was destroyed");
  }

  return workerId;
}

class PDFDocumentLoadingTask {
  static #docId = 0;

  constructor() {
    this._capability = (0, _util.createPromiseCapability)();
    this._transport = null;
    this._worker = null;
    this.docId = `d${PDFDocumentLoadingTask.#docId++}`;
    this.destroyed = false;
    this.onPassword = null;
    this.onProgress = null;
    this.onUnsupportedFeature = null;
  }

  get promise() {
    return this._capability.promise;
  }

  async destroy() {
    this.destroyed = true;
    await this._transport?.destroy();
    this._transport = null;

    if (this._worker) {
      this._worker.destroy();

      this._worker = null;
    }
  }

}

exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;

class PDFDataRangeTransport {
  constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
    this.length = length;
    this.initialData = initialData;
    this.progressiveDone = progressiveDone;
    this.contentDispositionFilename = contentDispositionFilename;
    this._rangeListeners = [];
    this._progressListeners = [];
    this._progressiveReadListeners = [];
    this._progressiveDoneListeners = [];
    this._readyCapability = (0, _util.createPromiseCapability)();
  }

  addRangeListener(listener) {
    this._rangeListeners.push(listener);
  }

  addProgressListener(listener) {
    this._progressListeners.push(listener);
  }

  addProgressiveReadListener(listener) {
    this._progressiveReadListeners.push(listener);
  }

  addProgressiveDoneListener(listener) {
    this._progressiveDoneListeners.push(listener);
  }

  onDataRange(begin, chunk) {
    for (const listener of this._rangeListeners) {
      listener(begin, chunk);
    }
  }

  onDataProgress(loaded, total) {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressListeners) {
        listener(loaded, total);
      }
    });
  }

  onDataProgressiveRead(chunk) {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressiveReadListeners) {
        listener(chunk);
      }
    });
  }

  onDataProgressiveDone() {
    this._readyCapability.promise.then(() => {
      for (const listener of this._progressiveDoneListeners) {
        listener();
      }
    });
  }

  transportReady() {
    this._readyCapability.resolve();
  }

  requestDataRange(begin, end) {
    (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
  }

  abort() {}

}

exports.PDFDataRangeTransport = PDFDataRangeTransport;

class PDFDocumentProxy {
  constructor(pdfInfo, transport) {
    this._pdfInfo = pdfInfo;
    this._transport = transport;
    Object.defineProperty(this, "fingerprint", {
      get() {
        (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, " + "please use `PDFDocumentProxy.fingerprints` instead.");
        return this.fingerprints[0];
      }

    });
    Object.defineProperty(this, "getStats", {
      value: async () => {
        (0, _display_utils.deprecated)("`PDFDocumentProxy.getStats`, " + "please use the `PDFDocumentProxy.stats`-getter instead.");
        return this.stats || {
          streamTypes: {},
          fontTypes: {}
        };
      }
    });
  }

  get annotationStorage() {
    return this._transport.annotationStorage;
  }

  get numPages() {
    return this._pdfInfo.numPages;
  }

  get fingerprints() {
    return this._pdfInfo.fingerprints;
  }

  get stats() {
    return this._transport.stats;
  }

  get isPureXfa() {
    return !!this._transport._htmlForXfa;
  }

  get allXfaHtml() {
    return this._transport._htmlForXfa;
  }

  getPage(pageNumber) {
    return this._transport.getPage(pageNumber);
  }

  getPageIndex(ref) {
    return this._transport.getPageIndex(ref);
  }

  getDestinations() {
    return this._transport.getDestinations();
  }

  getDestination(id) {
    return this._transport.getDestination(id);
  }

  getPageLabels() {
    return this._transport.getPageLabels();
  }

  getPageLayout() {
    return this._transport.getPageLayout();
  }

  getPageMode() {
    return this._transport.getPageMode();
  }

  getViewerPreferences() {
    return this._transport.getViewerPreferences();
  }

  getOpenAction() {
    return this._transport.getOpenAction();
  }

  getAttachments() {
    return this._transport.getAttachments();
  }

  getJavaScript() {
    return this._transport.getJavaScript();
  }

  getJSActions() {
    return this._transport.getDocJSActions();
  }

  getOutline() {
    return this._transport.getOutline();
  }

  getOptionalContentConfig() {
    return this._transport.getOptionalContentConfig();
  }

  getPermissions() {
    return this._transport.getPermissions();
  }

  getMetadata() {
    return this._transport.getMetadata();
  }

  getMarkInfo() {
    return this._transport.getMarkInfo();
  }

  getData() {
    return this._transport.getData();
  }

  getDownloadInfo() {
    return this._transport.downloadInfoCapability.promise;
  }

  cleanup(keepLoadedFonts = false) {
    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
  }

  destroy() {
    return this.loadingTask.destroy();
  }

  get loadingParams() {
    return this._transport.loadingParams;
  }

  get loadingTask() {
    return this._transport.loadingTask;
  }

  saveDocument() {
    if (this._transport.annotationStorage.size <= 0) {
      (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, " + "please use the getData-method instead.");
    }

    return this._transport.saveDocument();
  }

  getFieldObjects() {
    return this._transport.getFieldObjects();
  }

  hasJSActions() {
    return this._transport.hasJSActions();
  }

  getCalculationOrderIds() {
    return this._transport.getCalculationOrderIds();
  }

}

exports.PDFDocumentProxy = PDFDocumentProxy;

class PDFPageProxy {
  constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) {
    this._pageIndex = pageIndex;
    this._pageInfo = pageInfo;
    this._ownerDocument = ownerDocument;
    this._transport = transport;
    this._stats = pdfBug ? new _display_utils.StatTimer() : null;
    this._pdfBug = pdfBug;
    this.commonObjs = transport.commonObjs;
    this.objs = new PDFObjects();
    this._bitmaps = new Set();
    this.cleanupAfterRender = false;
    this.pendingCleanup = false;
    this._intentStates = new Map();
    this._annotationPromises = new Map();
    this.destroyed = false;
  }

  get pageNumber() {
    return this._pageIndex + 1;
  }

  get rotate() {
    return this._pageInfo.rotate;
  }

  get ref() {
    return this._pageInfo.ref;
  }

  get userUnit() {
    return this._pageInfo.userUnit;
  }

  get view() {
    return this._pageInfo.view;
  }

  getViewport({
    scale,
    rotation = this.rotate,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  } = {}) {
    return new _display_utils.PageViewport({
      viewBox: this.view,
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }

  getAnnotations({
    intent = "display"
  } = {}) {
    const intentArgs = this._transport.getRenderingIntent(intent);

    let promise = this._annotationPromises.get(intentArgs.cacheKey);

    if (!promise) {
      promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);

      this._annotationPromises.set(intentArgs.cacheKey, promise);

      promise = promise.then(annotations => {
        for (const annotation of annotations) {
          if (annotation.titleObj !== undefined) {
            Object.defineProperty(annotation, "title", {
              get() {
                (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead.");
                return annotation.titleObj.str;
              }

            });
          }

          if (annotation.contentsObj !== undefined) {
            Object.defineProperty(annotation, "contents", {
              get() {
                (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead.");
                return annotation.contentsObj.str;
              }

            });
          }
        }

        return annotations;
      });
    }

    return promise;
  }

  getJSActions() {
    return this._jsActionsPromise ||= this._transport.getPageJSActions(this._pageIndex);
  }

  async getXfa() {
    return this._transport._htmlForXfa?.children[this._pageIndex] || null;
  }

  render({
    canvasContext,
    viewport,
    intent = "display",
    annotationMode = _util.AnnotationMode.ENABLE,
    transform = null,
    imageLayer = null,
    canvasFactory = null,
    background = null,
    optionalContentConfigPromise = null,
    annotationCanvasMap = null,
    pageColors = null,
    printAnnotationStorage = null
  }) {
    if (arguments[0]?.renderInteractiveForms !== undefined) {
      (0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, " + "please use the `annotationMode`-option instead.");

      if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {
        annotationMode = _util.AnnotationMode.ENABLE_FORMS;
      }
    }

    if (arguments[0]?.includeAnnotationStorage !== undefined) {
      (0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, " + "please use the `annotationMode`-option instead.");

      if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {
        annotationMode = _util.AnnotationMode.ENABLE_STORAGE;
      }
    }

    if (this._stats) {
      this._stats.time("Overall");
    }

    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);

    this.pendingCleanup = false;

    if (!optionalContentConfigPromise) {
      optionalContentConfigPromise = this._transport.getOptionalContentConfig();
    }

    let intentState = this._intentStates.get(intentArgs.cacheKey);

    if (!intentState) {
      intentState = Object.create(null);

      this._intentStates.set(intentArgs.cacheKey, intentState);
    }

    if (intentState.streamReaderCancelTimeout) {
      clearTimeout(intentState.streamReaderCancelTimeout);
      intentState.streamReaderCancelTimeout = null;
    }

    const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
      ownerDocument: this._ownerDocument
    });
    const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);

    if (!intentState.displayReadyCapability) {
      intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };

      if (this._stats) {
        this._stats.time("Page Request");
      }

      this._pumpOperatorList(intentArgs);
    }

    const complete = error => {
      intentState.renderTasks.delete(internalRenderTask);

      if (this.cleanupAfterRender || intentPrint) {
        this.pendingCleanup = true;
      }

      this._tryCleanup();

      if (error) {
        internalRenderTask.capability.reject(error);

        this._abortOperatorList({
          intentState,
          reason: error instanceof Error ? error : new Error(error)
        });
      } else {
        internalRenderTask.capability.resolve();
      }

      if (this._stats) {
        this._stats.timeEnd("Rendering");

        this._stats.timeEnd("Overall");
      }
    };

    const internalRenderTask = new InternalRenderTask({
      callback: complete,
      params: {
        canvasContext,
        viewport,
        transform,
        imageLayer,
        background
      },
      objs: this.objs,
      commonObjs: this.commonObjs,
      annotationCanvasMap,
      operatorList: intentState.operatorList,
      pageIndex: this._pageIndex,
      canvasFactory: canvasFactoryInstance,
      useRequestAnimationFrame: !intentPrint,
      pdfBug: this._pdfBug,
      pageColors
    });
    (intentState.renderTasks ||= new Set()).add(internalRenderTask);
    const renderTask = internalRenderTask.task;
    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
      if (this.pendingCleanup) {
        complete();
        return;
      }

      if (this._stats) {
        this._stats.time("Rendering");
      }

      internalRenderTask.initializeGraphics({
        transparency,
        optionalContentConfig
      });
      internalRenderTask.operatorListChanged();
    }).catch(complete);
    return renderTask;
  }

  getOperatorList({
    intent = "display",
    annotationMode = _util.AnnotationMode.ENABLE,
    printAnnotationStorage = null
  } = {}) {
    function operatorListChanged() {
      if (intentState.operatorList.lastChunk) {
        intentState.opListReadCapability.resolve(intentState.operatorList);
        intentState.renderTasks.delete(opListTask);
      }
    }

    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);

    let intentState = this._intentStates.get(intentArgs.cacheKey);

    if (!intentState) {
      intentState = Object.create(null);

      this._intentStates.set(intentArgs.cacheKey, intentState);
    }

    let opListTask;

    if (!intentState.opListReadCapability) {
      opListTask = Object.create(null);
      opListTask.operatorListChanged = operatorListChanged;
      intentState.opListReadCapability = (0, _util.createPromiseCapability)();
      (intentState.renderTasks ||= new Set()).add(opListTask);
      intentState.operatorList = {
        fnArray: [],
        argsArray: [],
        lastChunk: false,
        separateAnnots: null
      };

      if (this._stats) {
        this._stats.time("Page Request");
      }

      this._pumpOperatorList(intentArgs);
    }

    return intentState.opListReadCapability.promise;
  }

  streamTextContent({
    disableCombineTextItems = false,
    includeMarkedContent = false
  } = {}) {
    const TEXT_CONTENT_CHUNK_SIZE = 100;
    return this._transport.messageHandler.sendWithStream("GetTextContent", {
      pageIndex: this._pageIndex,
      combineTextItems: disableCombineTextItems !== true,
      includeMarkedContent: includeMarkedContent === true
    }, {
      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,

      size(textContent) {
        return textContent.items.length;
      }

    });
  }

  getTextContent(params = {}) {
    if (this._transport._htmlForXfa) {
      return this.getXfa().then(xfa => {
        return _xfa_text.XfaText.textContent(xfa);
      });
    }

    const readableStream = this.streamTextContent(params);
    return new Promise(function (resolve, reject) {
      function pump() {
        reader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            resolve(textContent);
            return;
          }

          Object.assign(textContent.styles, value.styles);
          textContent.items.push(...value.items);
          pump();
        }, reject);
      }

      const reader = readableStream.getReader();
      const textContent = {
        items: [],
        styles: Object.create(null)
      };
      pump();
    });
  }

  getStructTree() {
    return this._structTreePromise ||= this._transport.getStructTree(this._pageIndex);
  }

  _destroy() {
    this.destroyed = true;
    const waitOn = [];

    for (const intentState of this._intentStates.values()) {
      this._abortOperatorList({
        intentState,
        reason: new Error("Page was destroyed."),
        force: true
      });

      if (intentState.opListReadCapability) {
        continue;
      }

      for (const internalRenderTask of intentState.renderTasks) {
        waitOn.push(internalRenderTask.completed);
        internalRenderTask.cancel();
      }
    }

    this.objs.clear();

    for (const bitmap of this._bitmaps) {
      bitmap.close();
    }

    this._bitmaps.clear();

    this._annotationPromises.clear();

    this._jsActionsPromise = null;
    this._structTreePromise = null;
    this.pendingCleanup = false;
    return Promise.all(waitOn);
  }

  cleanup(resetStats = false) {
    this.pendingCleanup = true;
    return this._tryCleanup(resetStats);
  }

  _tryCleanup(resetStats = false) {
    if (!this.pendingCleanup) {
      return false;
    }

    for (const {
      renderTasks,
      operatorList
    } of this._intentStates.values()) {
      if (renderTasks.size > 0 || !operatorList.lastChunk) {
        return false;
      }
    }

    this._intentStates.clear();

    this.objs.clear();

    this._annotationPromises.clear();

    this._jsActionsPromise = null;
    this._structTreePromise = null;

    if (resetStats && this._stats) {
      this._stats = new _display_utils.StatTimer();
    }

    for (const bitmap of this._bitmaps) {
      bitmap.close();
    }

    this._bitmaps.clear();

    this.pendingCleanup = false;
    return true;
  }

  _startRenderPage(transparency, cacheKey) {
    const intentState = this._intentStates.get(cacheKey);

    if (!intentState) {
      return;
    }

    if (this._stats) {
      this._stats.timeEnd("Page Request");
    }

    if (intentState.displayReadyCapability) {
      intentState.displayReadyCapability.resolve(transparency);
    }
  }

  _renderPageChunk(operatorListChunk, intentState) {
    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
    }

    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
    intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;

    for (const internalRenderTask of intentState.renderTasks) {
      internalRenderTask.operatorListChanged();
    }

    if (operatorListChunk.lastChunk) {
      this._tryCleanup();
    }
  }

  _pumpOperatorList({
    renderingIntent,
    cacheKey,
    annotationStorageMap
  }) {
    const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
      pageIndex: this._pageIndex,
      intent: renderingIntent,
      cacheKey,
      annotationStorage: annotationStorageMap
    });

    const reader = readableStream.getReader();

    const intentState = this._intentStates.get(cacheKey);

    intentState.streamReader = reader;

    const pump = () => {
      reader.read().then(({
        value,
        done
      }) => {
        if (done) {
          intentState.streamReader = null;
          return;
        }

        if (this._transport.destroyed) {
          return;
        }

        this._renderPageChunk(value, intentState);

        pump();
      }, reason => {
        intentState.streamReader = null;

        if (this._transport.destroyed) {
          return;
        }

        if (intentState.operatorList) {
          intentState.operatorList.lastChunk = true;

          for (const internalRenderTask of intentState.renderTasks) {
            internalRenderTask.operatorListChanged();
          }

          this._tryCleanup();
        }

        if (intentState.displayReadyCapability) {
          intentState.displayReadyCapability.reject(reason);
        } else if (intentState.opListReadCapability) {
          intentState.opListReadCapability.reject(reason);
        } else {
          throw reason;
        }
      });
    };

    pump();
  }

  _abortOperatorList({
    intentState,
    reason,
    force = false
  }) {
    if (!intentState.streamReader) {
      return;
    }

    if (!force) {
      if (intentState.renderTasks.size > 0) {
        return;
      }

      if (reason instanceof _display_utils.RenderingCancelledException) {
        intentState.streamReaderCancelTimeout = setTimeout(() => {
          this._abortOperatorList({
            intentState,
            reason,
            force: true
          });

          intentState.streamReaderCancelTimeout = null;
        }, RENDERING_CANCELLED_TIMEOUT);
        return;
      }
    }

    intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {});
    intentState.streamReader = null;

    if (this._transport.destroyed) {
      return;
    }

    for (const [curCacheKey, curIntentState] of this._intentStates) {
      if (curIntentState === intentState) {
        this._intentStates.delete(curCacheKey);

        break;
      }
    }

    this.cleanup();
  }

  get stats() {
    return this._stats;
  }

}

exports.PDFPageProxy = PDFPageProxy;

class LoopbackPort {
  constructor() {
    this._listeners = [];
    this._deferred = Promise.resolve();
  }

  postMessage(obj, transfers) {
    const event = {
      data: structuredClone(obj, transfers)
    };

    this._deferred.then(() => {
      for (const listener of this._listeners) {
        listener.call(this, event);
      }
    });
  }

  addEventListener(name, listener) {
    this._listeners.push(listener);
  }

  removeEventListener(name, listener) {
    const i = this._listeners.indexOf(listener);

    this._listeners.splice(i, 1);
  }

  terminate() {
    this._listeners.length = 0;
  }

}

exports.LoopbackPort = LoopbackPort;
const PDFWorkerUtil = {
  isWorkerDisabled: false,
  fallbackWorkerSrc: null,
  fakeWorkerId: 0
};
exports.PDFWorkerUtil = PDFWorkerUtil;
{
  if (_is_node.isNodeJS && "function" === "function") {
    PDFWorkerUtil.isWorkerDisabled = true;
    PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
  } else if (typeof document === "object") {
    const pdfjsFilePath = document?.currentScript?.src;

    if (pdfjsFilePath) {
      PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
    }
  }

  PDFWorkerUtil.isSameOrigin = function (baseUrl, otherUrl) {
    let base;

    try {
      base = new URL(baseUrl);

      if (!base.origin || base.origin === "null") {
        return false;
      }
    } catch (e) {
      return false;
    }

    const other = new URL(otherUrl, base);
    return base.origin === other.origin;
  };

  PDFWorkerUtil.createCDNWrapper = function (url) {
    const wrapper = `importScripts("${url}");`;
    return URL.createObjectURL(new Blob([wrapper]));
  };
}

class PDFWorker {
  static #workerPorts = new WeakMap();

  constructor({
    name = null,
    port = null,
    verbosity = (0, _util.getVerbosityLevel)()
  } = {}) {
    if (port && PDFWorker.#workerPorts.has(port)) {
      throw new Error("Cannot use more than one PDFWorker per port.");
    }

    this.name = name;
    this.destroyed = false;
    this.verbosity = verbosity;
    this._readyCapability = (0, _util.createPromiseCapability)();
    this._port = null;
    this._webWorker = null;
    this._messageHandler = null;

    if (port) {
      PDFWorker.#workerPorts.set(port, this);

      this._initializeFromPort(port);

      return;
    }

    this._initialize();
  }

  get promise() {
    return this._readyCapability.promise;
  }

  get port() {
    return this._port;
  }

  get messageHandler() {
    return this._messageHandler;
  }

  _initializeFromPort(port) {
    this._port = port;
    this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);

    this._messageHandler.on("ready", function () {});

    this._readyCapability.resolve();
  }

  _initialize() {
    if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {
      let {
        workerSrc
      } = PDFWorker;

      try {
        if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {
          workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
        }

        const worker = new Worker(workerSrc);
        const messageHandler = new _message_handler.MessageHandler("main", "worker", worker);

        const terminateEarly = () => {
          worker.removeEventListener("error", onWorkerError);
          messageHandler.destroy();
          worker.terminate();

          if (this.destroyed) {
            this._readyCapability.reject(new Error("Worker was destroyed"));
          } else {
            this._setupFakeWorker();
          }
        };

        const onWorkerError = () => {
          if (!this._webWorker) {
            terminateEarly();
          }
        };

        worker.addEventListener("error", onWorkerError);
        messageHandler.on("test", data => {
          worker.removeEventListener("error", onWorkerError);

          if (this.destroyed) {
            terminateEarly();
            return;
          }

          if (data) {
            this._messageHandler = messageHandler;
            this._port = worker;
            this._webWorker = worker;

            this._readyCapability.resolve();

            messageHandler.send("configure", {
              verbosity: this.verbosity
            });
          } else {
            this._setupFakeWorker();

            messageHandler.destroy();
            worker.terminate();
          }
        });
        messageHandler.on("ready", data => {
          worker.removeEventListener("error", onWorkerError);

          if (this.destroyed) {
            terminateEarly();
            return;
          }

          try {
            sendTest();
          } catch (e) {
            this._setupFakeWorker();
          }
        });

        const sendTest = () => {
          const testObj = new Uint8Array();
          messageHandler.send("test", testObj, [testObj.buffer]);
        };

        sendTest();
        return;
      } catch (e) {
        (0, _util.info)("The worker has been disabled.");
      }
    }

    this._setupFakeWorker();
  }

  _setupFakeWorker() {
    if (!PDFWorkerUtil.isWorkerDisabled) {
      (0, _util.warn)("Setting up fake worker.");
      PDFWorkerUtil.isWorkerDisabled = true;
    }

    PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {
      if (this.destroyed) {
        this._readyCapability.reject(new Error("Worker was destroyed"));

        return;
      }

      const port = new LoopbackPort();
      this._port = port;
      const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;
      const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
      WorkerMessageHandler.setup(workerHandler, port);
      const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
      this._messageHandler = messageHandler;

      this._readyCapability.resolve();

      messageHandler.send("configure", {
        verbosity: this.verbosity
      });
    }).catch(reason => {
      this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
    });
  }

  destroy() {
    this.destroyed = true;

    if (this._webWorker) {
      this._webWorker.terminate();

      this._webWorker = null;
    }

    PDFWorker.#workerPorts.delete(this._port);
    this._port = null;

    if (this._messageHandler) {
      this._messageHandler.destroy();

      this._messageHandler = null;
    }
  }

  static fromPort(params) {
    if (!params?.port) {
      throw new Error("PDFWorker.fromPort - invalid method signature.");
    }

    if (this.#workerPorts.has(params.port)) {
      return this.#workerPorts.get(params.port);
    }

    return new PDFWorker(params);
  }

  static get workerSrc() {
    if (_worker_options.GlobalWorkerOptions.workerSrc) {
      return _worker_options.GlobalWorkerOptions.workerSrc;
    }

    if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
      if (!_is_node.isNodeJS) {
        (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
      }

      return PDFWorkerUtil.fallbackWorkerSrc;
    }

    throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
  }

  static get _mainThreadWorkerMessageHandler() {
    try {
      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
    } catch (ex) {
      return null;
    }
  }

  static get _setupFakeWorkerGlobal() {
    const loader = async () => {
      const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;

      if (mainWorkerMessageHandler) {
        return mainWorkerMessageHandler;
      }

      if (_is_node.isNodeJS && "function" === "function") {
        const worker = eval("require")(this.workerSrc);
        return worker.WorkerMessageHandler;
      }

      await (0, _display_utils.loadScript)(this.workerSrc);
      return window.pdfjsWorker.WorkerMessageHandler;
    };

    return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
  }

}

exports.PDFWorker = PDFWorker;
{
  PDFWorker.getWorkerSrc = function () {
    (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.");
    return this.workerSrc;
  };
}

class WorkerTransport {
  #docStats = null;
  #pageCache = new Map();
  #pagePromises = new Map();
  #metadataPromise = null;

  constructor(messageHandler, loadingTask, networkStream, params) {
    this.messageHandler = messageHandler;
    this.loadingTask = loadingTask;
    this.commonObjs = new PDFObjects();
    this.fontLoader = new _font_loader.FontLoader({
      docId: loadingTask.docId,
      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
      ownerDocument: params.ownerDocument,
      styleElement: params.styleElement
    });
    this._params = params;

    if (!params.useWorkerFetch) {
      this.CMapReaderFactory = new params.CMapReaderFactory({
        baseUrl: params.cMapUrl,
        isCompressed: params.cMapPacked
      });
      this.StandardFontDataFactory = new params.StandardFontDataFactory({
        baseUrl: params.standardFontDataUrl
      });
    }

    this.destroyed = false;
    this.destroyCapability = null;
    this._passwordCapability = null;
    this._networkStream = networkStream;
    this._fullReader = null;
    this._lastProgress = null;
    this.downloadInfoCapability = (0, _util.createPromiseCapability)();
    this.setupMessageHandler();
  }

  get annotationStorage() {
    return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
  }

  get stats() {
    return this.#docStats;
  }

  getRenderingIntent(intent, annotationMode = _util.AnnotationMode.ENABLE, printAnnotationStorage = null, isOpList = false) {
    let renderingIntent = _util.RenderingIntentFlag.DISPLAY;
    let annotationMap = null;

    switch (intent) {
      case "any":
        renderingIntent = _util.RenderingIntentFlag.ANY;
        break;

      case "display":
        break;

      case "print":
        renderingIntent = _util.RenderingIntentFlag.PRINT;
        break;

      default:
        (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);
    }

    switch (annotationMode) {
      case _util.AnnotationMode.DISABLE:
        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
        break;

      case _util.AnnotationMode.ENABLE:
        break;

      case _util.AnnotationMode.ENABLE_FORMS:
        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
        break;

      case _util.AnnotationMode.ENABLE_STORAGE:
        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
        const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
        annotationMap = annotationStorage.serializable;
        break;

      default:
        (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
    }

    if (isOpList) {
      renderingIntent += _util.RenderingIntentFlag.OPLIST;
    }

    return {
      renderingIntent,
      cacheKey: `${renderingIntent}_${_annotation_storage.AnnotationStorage.getHash(annotationMap)}`,
      annotationStorageMap: annotationMap
    };
  }

  destroy() {
    if (this.destroyCapability) {
      return this.destroyCapability.promise;
    }

    this.destroyed = true;
    this.destroyCapability = (0, _util.createPromiseCapability)();

    if (this._passwordCapability) {
      this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
    }

    const waitOn = [];

    for (const page of this.#pageCache.values()) {
      waitOn.push(page._destroy());
    }

    this.#pageCache.clear();
    this.#pagePromises.clear();

    if (this.hasOwnProperty("annotationStorage")) {
      this.annotationStorage.resetModified();
    }

    const terminated = this.messageHandler.sendWithPromise("Terminate", null);
    waitOn.push(terminated);
    Promise.all(waitOn).then(() => {
      this.commonObjs.clear();
      this.fontLoader.clear();
      this.#metadataPromise = null;
      this._getFieldObjectsPromise = null;
      this._hasJSActionsPromise = null;

      if (this._networkStream) {
        this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
      }

      if (this.messageHandler) {
        this.messageHandler.destroy();
        this.messageHandler = null;
      }

      this.destroyCapability.resolve();
    }, this.destroyCapability.reject);
    return this.destroyCapability.promise;
  }

  setupMessageHandler() {
    const {
      messageHandler,
      loadingTask
    } = this;
    messageHandler.on("GetReader", (data, sink) => {
      (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available.");
      this._fullReader = this._networkStream.getFullReader();

      this._fullReader.onProgress = evt => {
        this._lastProgress = {
          loaded: evt.loaded,
          total: evt.total
        };
      };

      sink.onPull = () => {
        this._fullReader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }

          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch(reason => {
          sink.error(reason);
        });
      };

      sink.onCancel = reason => {
        this._fullReader.cancel(reason);

        sink.ready.catch(readyReason => {
          if (this.destroyed) {
            return;
          }

          throw readyReason;
        });
      };
    });
    messageHandler.on("ReaderHeadersReady", data => {
      const headersCapability = (0, _util.createPromiseCapability)();
      const fullReader = this._fullReader;
      fullReader.headersReady.then(() => {
        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
          if (this._lastProgress) {
            loadingTask.onProgress?.(this._lastProgress);
          }

          fullReader.onProgress = evt => {
            loadingTask.onProgress?.({
              loaded: evt.loaded,
              total: evt.total
            });
          };
        }

        headersCapability.resolve({
          isStreamingSupported: fullReader.isStreamingSupported,
          isRangeSupported: fullReader.isRangeSupported,
          contentLength: fullReader.contentLength
        });
      }, headersCapability.reject);
      return headersCapability.promise;
    });
    messageHandler.on("GetRangeReader", (data, sink) => {
      (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");

      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);

      if (!rangeReader) {
        sink.close();
        return;
      }

      sink.onPull = () => {
        rangeReader.read().then(function ({
          value,
          done
        }) {
          if (done) {
            sink.close();
            return;
          }

          (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
          sink.enqueue(new Uint8Array(value), 1, [value]);
        }).catch(reason => {
          sink.error(reason);
        });
      };

      sink.onCancel = reason => {
        rangeReader.cancel(reason);
        sink.ready.catch(readyReason => {
          if (this.destroyed) {
            return;
          }

          throw readyReason;
        });
      };
    });
    messageHandler.on("GetDoc", ({
      pdfInfo
    }) => {
      this._numPages = pdfInfo.numPages;
      this._htmlForXfa = pdfInfo.htmlForXfa;
      delete pdfInfo.htmlForXfa;

      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
    });
    messageHandler.on("DocException", function (ex) {
      let reason;

      switch (ex.name) {
        case "PasswordException":
          reason = new _util.PasswordException(ex.message, ex.code);
          break;

        case "InvalidPDFException":
          reason = new _util.InvalidPDFException(ex.message);
          break;

        case "MissingPDFException":
          reason = new _util.MissingPDFException(ex.message);
          break;

        case "UnexpectedResponseException":
          reason = new _util.UnexpectedResponseException(ex.message, ex.status);
          break;

        case "UnknownErrorException":
          reason = new _util.UnknownErrorException(ex.message, ex.details);
          break;

        default:
          (0, _util.unreachable)("DocException - expected a valid Error.");
      }

      loadingTask._capability.reject(reason);
    });
    messageHandler.on("PasswordRequest", exception => {
      this._passwordCapability = (0, _util.createPromiseCapability)();

      if (loadingTask.onPassword) {
        const updatePassword = password => {
          if (password instanceof Error) {
            this._passwordCapability.reject(password);
          } else {
            this._passwordCapability.resolve({
              password
            });
          }
        };

        try {
          loadingTask.onPassword(updatePassword, exception.code);
        } catch (ex) {
          this._passwordCapability.reject(ex);
        }
      } else {
        this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
      }

      return this._passwordCapability.promise;
    });
    messageHandler.on("DataLoaded", data => {
      loadingTask.onProgress?.({
        loaded: data.length,
        total: data.length
      });
      this.downloadInfoCapability.resolve(data);
    });
    messageHandler.on("StartRenderPage", data => {
      if (this.destroyed) {
        return;
      }

      const page = this.#pageCache.get(data.pageIndex);

      page._startRenderPage(data.transparency, data.cacheKey);
    });
    messageHandler.on("commonobj", ([id, type, exportedData]) => {
      if (this.destroyed) {
        return;
      }

      if (this.commonObjs.has(id)) {
        return;
      }

      switch (type) {
        case "Font":
          const params = this._params;

          if ("error" in exportedData) {
            const exportedError = exportedData.error;
            (0, _util.warn)(`Error during font loading: ${exportedError}`);
            this.commonObjs.resolve(id, exportedError);
            break;
          }

          let fontRegistry = null;

          if (params.pdfBug && globalThis.FontInspector?.enabled) {
            fontRegistry = {
              registerFont(font, url) {
                globalThis.FontInspector.fontAdded(font, url);
              }

            };
          }

          const font = new _font_loader.FontFaceObject(exportedData, {
            isEvalSupported: params.isEvalSupported,
            disableFontFace: params.disableFontFace,
            ignoreErrors: params.ignoreErrors,
            onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
            fontRegistry
          });
          this.fontLoader.bind(font).catch(reason => {
            return messageHandler.sendWithPromise("FontFallback", {
              id
            });
          }).finally(() => {
            if (!params.fontExtraProperties && font.data) {
              font.data = null;
            }

            this.commonObjs.resolve(id, font);
          });
          break;

        case "FontPath":
        case "Image":
          this.commonObjs.resolve(id, exportedData);
          break;

        default:
          throw new Error(`Got unknown common object type ${type}`);
      }
    });
    messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
      if (this.destroyed) {
        return;
      }

      const pageProxy = this.#pageCache.get(pageIndex);

      if (pageProxy.objs.has(id)) {
        return;
      }

      switch (type) {
        case "Image":
          pageProxy.objs.resolve(id, imageData);
          const MAX_IMAGE_SIZE_TO_STORE = 8000000;

          if (imageData) {
            let length;

            if (imageData.bitmap) {
              const {
                bitmap,
                width,
                height
              } = imageData;
              length = width * height * 4;

              pageProxy._bitmaps.add(bitmap);
            } else {
              length = imageData.data?.length || 0;
            }

            if (length > MAX_IMAGE_SIZE_TO_STORE) {
              pageProxy.cleanupAfterRender = true;
            }
          }

          break;

        case "Pattern":
          pageProxy.objs.resolve(id, imageData);
          break;

        default:
          throw new Error(`Got unknown object type ${type}`);
      }
    });
    messageHandler.on("DocProgress", data => {
      if (this.destroyed) {
        return;
      }

      loadingTask.onProgress?.({
        loaded: data.loaded,
        total: data.total
      });
    });
    messageHandler.on("DocStats", data => {
      if (this.destroyed) {
        return;
      }

      this.#docStats = Object.freeze({
        streamTypes: Object.freeze(data.streamTypes),
        fontTypes: Object.freeze(data.fontTypes)
      });
    });
    messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
    messageHandler.on("FetchBuiltInCMap", data => {
      if (this.destroyed) {
        return Promise.reject(new Error("Worker was destroyed."));
      }

      if (!this.CMapReaderFactory) {
        return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
      }

      return this.CMapReaderFactory.fetch(data);
    });
    messageHandler.on("FetchStandardFontData", data => {
      if (this.destroyed) {
        return Promise.reject(new Error("Worker was destroyed."));
      }

      if (!this.StandardFontDataFactory) {
        return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
      }

      return this.StandardFontDataFactory.fetch(data);
    });
  }

  _onUnsupportedFeature({
    featureId
  }) {
    if (this.destroyed) {
      return;
    }

    this.loadingTask.onUnsupportedFeature?.(featureId);
  }

  getData() {
    return this.messageHandler.sendWithPromise("GetData", null);
  }

  getPage(pageNumber) {
    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
      return Promise.reject(new Error("Invalid page request."));
    }

    const pageIndex = pageNumber - 1,
          cachedPromise = this.#pagePromises.get(pageIndex);

    if (cachedPromise) {
      return cachedPromise;
    }

    const promise = this.messageHandler.sendWithPromise("GetPage", {
      pageIndex
    }).then(pageInfo => {
      if (this.destroyed) {
        throw new Error("Transport destroyed");
      }

      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug);
      this.#pageCache.set(pageIndex, page);
      return page;
    });
    this.#pagePromises.set(pageIndex, promise);
    return promise;
  }

  getPageIndex(ref) {
    if (typeof ref !== "object" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {
      return Promise.reject(new Error("Invalid pageIndex request."));
    }

    return this.messageHandler.sendWithPromise("GetPageIndex", {
      num: ref.num,
      gen: ref.gen
    });
  }

  getAnnotations(pageIndex, intent) {
    return this.messageHandler.sendWithPromise("GetAnnotations", {
      pageIndex,
      intent
    });
  }

  saveDocument() {
    return this.messageHandler.sendWithPromise("SaveDocument", {
      isPureXfa: !!this._htmlForXfa,
      numPages: this._numPages,
      annotationStorage: this.annotationStorage.serializable,
      filename: this._fullReader?.filename ?? null
    }).finally(() => {
      this.annotationStorage.resetModified();
    });
  }

  getFieldObjects() {
    return this._getFieldObjectsPromise ||= this.messageHandler.sendWithPromise("GetFieldObjects", null);
  }

  hasJSActions() {
    return this._hasJSActionsPromise ||= this.messageHandler.sendWithPromise("HasJSActions", null);
  }

  getCalculationOrderIds() {
    return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
  }

  getDestinations() {
    return this.messageHandler.sendWithPromise("GetDestinations", null);
  }

  getDestination(id) {
    if (typeof id !== "string") {
      return Promise.reject(new Error("Invalid destination request."));
    }

    return this.messageHandler.sendWithPromise("GetDestination", {
      id
    });
  }

  getPageLabels() {
    return this.messageHandler.sendWithPromise("GetPageLabels", null);
  }

  getPageLayout() {
    return this.messageHandler.sendWithPromise("GetPageLayout", null);
  }

  getPageMode() {
    return this.messageHandler.sendWithPromise("GetPageMode", null);
  }

  getViewerPreferences() {
    return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
  }

  getOpenAction() {
    return this.messageHandler.sendWithPromise("GetOpenAction", null);
  }

  getAttachments() {
    return this.messageHandler.sendWithPromise("GetAttachments", null);
  }

  getJavaScript() {
    return this.messageHandler.sendWithPromise("GetJavaScript", null);
  }

  getDocJSActions() {
    return this.messageHandler.sendWithPromise("GetDocJSActions", null);
  }

  getPageJSActions(pageIndex) {
    return this.messageHandler.sendWithPromise("GetPageJSActions", {
      pageIndex
    });
  }

  getStructTree(pageIndex) {
    return this.messageHandler.sendWithPromise("GetStructTree", {
      pageIndex
    });
  }

  getOutline() {
    return this.messageHandler.sendWithPromise("GetOutline", null);
  }

  getOptionalContentConfig() {
    return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(results => {
      return new _optional_content_config.OptionalContentConfig(results);
    });
  }

  getPermissions() {
    return this.messageHandler.sendWithPromise("GetPermissions", null);
  }

  getMetadata() {
    return this.#metadataPromise ||= this.messageHandler.sendWithPromise("GetMetadata", null).then(results => {
      return {
        info: results[0],
        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
        contentDispositionFilename: this._fullReader?.filename ?? null,
        contentLength: this._fullReader?.contentLength ?? null
      };
    });
  }

  getMarkInfo() {
    return this.messageHandler.sendWithPromise("GetMarkInfo", null);
  }

  async startCleanup(keepLoadedFonts = false) {
    await this.messageHandler.sendWithPromise("Cleanup", null);

    if (this.destroyed) {
      return;
    }

    for (const page of this.#pageCache.values()) {
      const cleanupSuccessful = page.cleanup();

      if (!cleanupSuccessful) {
        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
      }
    }

    this.commonObjs.clear();

    if (!keepLoadedFonts) {
      this.fontLoader.clear();
    }

    this.#metadataPromise = null;
    this._getFieldObjectsPromise = null;
    this._hasJSActionsPromise = null;
  }

  get loadingParams() {
    const params = this._params;
    return (0, _util.shadow)(this, "loadingParams", {
      disableAutoFetch: params.disableAutoFetch,
      enableXfa: params.enableXfa
    });
  }

}

class PDFObjects {
  #objs = Object.create(null);

  #ensureObj(objId) {
    const obj = this.#objs[objId];

    if (obj) {
      return obj;
    }

    return this.#objs[objId] = {
      capability: (0, _util.createPromiseCapability)(),
      data: null
    };
  }

  get(objId, callback = null) {
    if (callback) {
      const obj = this.#ensureObj(objId);
      obj.capability.promise.then(() => callback(obj.data));
      return null;
    }

    const obj = this.#objs[objId];

    if (!obj?.capability.settled) {
      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
    }

    return obj.data;
  }

  has(objId) {
    const obj = this.#objs[objId];
    return obj?.capability.settled || false;
  }

  resolve(objId, data = null) {
    const obj = this.#ensureObj(objId);
    obj.data = data;
    obj.capability.resolve();
  }

  clear() {
    this.#objs = Object.create(null);
  }

}

class RenderTask {
  #internalRenderTask = null;

  constructor(internalRenderTask) {
    this.#internalRenderTask = internalRenderTask;
    this.onContinue = null;
  }

  get promise() {
    return this.#internalRenderTask.capability.promise;
  }

  cancel() {
    this.#internalRenderTask.cancel();
  }

  get separateAnnots() {
    const {
      separateAnnots
    } = this.#internalRenderTask.operatorList;

    if (!separateAnnots) {
      return false;
    }

    const {
      annotationCanvasMap
    } = this.#internalRenderTask;
    return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;
  }

}

exports.RenderTask = RenderTask;

class InternalRenderTask {
  static #canvasInUse = new WeakSet();

  constructor({
    callback,
    params,
    objs,
    commonObjs,
    annotationCanvasMap,
    operatorList,
    pageIndex,
    canvasFactory,
    useRequestAnimationFrame = false,
    pdfBug = false,
    pageColors = null
  }) {
    this.callback = callback;
    this.params = params;
    this.objs = objs;
    this.commonObjs = commonObjs;
    this.annotationCanvasMap = annotationCanvasMap;
    this.operatorListIdx = null;
    this.operatorList = operatorList;
    this._pageIndex = pageIndex;
    this.canvasFactory = canvasFactory;
    this._pdfBug = pdfBug;
    this.pageColors = pageColors;
    this.running = false;
    this.graphicsReadyCallback = null;
    this.graphicsReady = false;
    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
    this.cancelled = false;
    this.capability = (0, _util.createPromiseCapability)();
    this.task = new RenderTask(this);
    this._cancelBound = this.cancel.bind(this);
    this._continueBound = this._continue.bind(this);
    this._scheduleNextBound = this._scheduleNext.bind(this);
    this._nextBound = this._next.bind(this);
    this._canvas = params.canvasContext.canvas;
  }

  get completed() {
    return this.capability.promise.catch(function () {});
  }

  initializeGraphics({
    transparency = false,
    optionalContentConfig
  }) {
    if (this.cancelled) {
      return;
    }

    if (this._canvas) {
      if (InternalRenderTask.#canvasInUse.has(this._canvas)) {
        throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");
      }

      InternalRenderTask.#canvasInUse.add(this._canvas);
    }

    if (this._pdfBug && globalThis.StepperManager?.enabled) {
      this.stepper = globalThis.StepperManager.create(this._pageIndex);
      this.stepper.init(this.operatorList);
      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
    }

    const {
      canvasContext,
      viewport,
      transform,
      imageLayer,
      background
    } = this.params;
    this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig, this.annotationCanvasMap, this.pageColors);
    this.gfx.beginDrawing({
      transform,
      viewport,
      transparency,
      background
    });
    this.operatorListIdx = 0;
    this.graphicsReady = true;

    if (this.graphicsReadyCallback) {
      this.graphicsReadyCallback();
    }
  }

  cancel(error = null) {
    this.running = false;
    this.cancelled = true;

    if (this.gfx) {
      this.gfx.endDrawing();
    }

    if (this._canvas) {
      InternalRenderTask.#canvasInUse.delete(this._canvas);
    }

    this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas"));
  }

  operatorListChanged() {
    if (!this.graphicsReady) {
      if (!this.graphicsReadyCallback) {
        this.graphicsReadyCallback = this._continueBound;
      }

      return;
    }

    if (this.stepper) {
      this.stepper.updateOperatorList(this.operatorList);
    }

    if (this.running) {
      return;
    }

    this._continue();
  }

  _continue() {
    this.running = true;

    if (this.cancelled) {
      return;
    }

    if (this.task.onContinue) {
      this.task.onContinue(this._scheduleNextBound);
    } else {
      this._scheduleNext();
    }
  }

  _scheduleNext() {
    if (this._useRequestAnimationFrame) {
      window.requestAnimationFrame(() => {
        this._nextBound().catch(this._cancelBound);
      });
    } else {
      Promise.resolve().then(this._nextBound).catch(this._cancelBound);
    }
  }

  async _next() {
    if (this.cancelled) {
      return;
    }

    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);

    if (this.operatorListIdx === this.operatorList.argsArray.length) {
      this.running = false;

      if (this.operatorList.lastChunk) {
        this.gfx.endDrawing();

        if (this._canvas) {
          InternalRenderTask.#canvasInUse.delete(this._canvas);
        }

        this.callback();
      }
    }
  }

}

const version = '2.16.105';
exports.version = version;
const build = '172ccdbe5';
exports.build = build;

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PrintAnnotationStorage = exports.AnnotationStorage = void 0;

var _util = __w_pdfjs_require__(1);

var _editor = __w_pdfjs_require__(6);

var _murmurhash = __w_pdfjs_require__(10);

class AnnotationStorage {
  constructor() {
    this._storage = new Map();
    this._modified = false;
    this.onSetModified = null;
    this.onResetModified = null;
    this.onAnnotationEditor = null;
  }

  getValue(key, defaultValue) {
    const value = this._storage.get(key);

    if (value === undefined) {
      return defaultValue;
    }

    return Object.assign(defaultValue, value);
  }

  getRawValue(key) {
    return this._storage.get(key);
  }

  remove(key) {
    this._storage.delete(key);

    if (this._storage.size === 0) {
      this.resetModified();
    }

    if (typeof this.onAnnotationEditor === "function") {
      for (const value of this._storage.values()) {
        if (value instanceof _editor.AnnotationEditor) {
          return;
        }
      }

      this.onAnnotationEditor(null);
    }
  }

  setValue(key, value) {
    const obj = this._storage.get(key);

    let modified = false;

    if (obj !== undefined) {
      for (const [entry, val] of Object.entries(value)) {
        if (obj[entry] !== val) {
          modified = true;
          obj[entry] = val;
        }
      }
    } else {
      modified = true;

      this._storage.set(key, value);
    }

    if (modified) {
      this.#setModified();
    }

    if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === "function") {
      this.onAnnotationEditor(value.constructor._type);
    }
  }

  has(key) {
    return this._storage.has(key);
  }

  getAll() {
    return this._storage.size > 0 ? (0, _util.objectFromMap)(this._storage) : null;
  }

  get size() {
    return this._storage.size;
  }

  #setModified() {
    if (!this._modified) {
      this._modified = true;

      if (typeof this.onSetModified === "function") {
        this.onSetModified();
      }
    }
  }

  resetModified() {
    if (this._modified) {
      this._modified = false;

      if (typeof this.onResetModified === "function") {
        this.onResetModified();
      }
    }
  }

  get print() {
    return new PrintAnnotationStorage(this);
  }

  get serializable() {
    if (this._storage.size === 0) {
      return null;
    }

    const clone = new Map();

    for (const [key, val] of this._storage) {
      const serialized = val instanceof _editor.AnnotationEditor ? val.serialize() : val;

      if (serialized) {
        clone.set(key, serialized);
      }
    }

    return clone;
  }

  static getHash(map) {
    if (!map) {
      return "";
    }

    const hash = new _murmurhash.MurmurHash3_64();

    for (const [key, val] of map) {
      hash.update(`${key}:${JSON.stringify(val)}`);
    }

    return hash.hexdigest();
  }

}

exports.AnnotationStorage = AnnotationStorage;

class PrintAnnotationStorage extends AnnotationStorage {
  #serializable = null;

  constructor(parent) {
    super();
    this.#serializable = structuredClone(parent.serializable);
  }

  get print() {
    (0, _util.unreachable)("Should not call PrintAnnotationStorage.print");
  }

  get serializable() {
    return this.#serializable;
  }

}

exports.PrintAnnotationStorage = PrintAnnotationStorage;

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AnnotationEditor = void 0;

var _tools = __w_pdfjs_require__(7);

var _util = __w_pdfjs_require__(1);

class AnnotationEditor {
  #boundFocusin = this.focusin.bind(this);
  #boundFocusout = this.focusout.bind(this);
  #hasBeenSelected = false;
  #isEditing = false;
  #isInEditMode = false;
  #zIndex = AnnotationEditor._zIndex++;
  static _colorManager = new _tools.ColorManager();
  static _zIndex = 1;

  constructor(parameters) {
    if (this.constructor === AnnotationEditor) {
      (0, _util.unreachable)("Cannot initialize AnnotationEditor.");
    }

    this.parent = parameters.parent;
    this.id = parameters.id;
    this.width = this.height = null;
    this.pageIndex = parameters.parent.pageIndex;
    this.name = parameters.name;
    this.div = null;
    const [width, height] = this.parent.viewportBaseDimensions;
    this.x = parameters.x / width;
    this.y = parameters.y / height;
    this.rotation = this.parent.viewport.rotation;
    this.isAttachedToDOM = false;
  }

  static get _defaultLineColor() {
    return (0, _util.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
  }

  setInBackground() {
    this.div.style.zIndex = 0;
  }

  setInForeground() {
    this.div.style.zIndex = this.#zIndex;
  }

  focusin(event) {
    if (!this.#hasBeenSelected) {
      this.parent.setSelected(this);
    } else {
      this.#hasBeenSelected = false;
    }
  }

  focusout(event) {
    if (!this.isAttachedToDOM) {
      return;
    }

    const target = event.relatedTarget;

    if (target?.closest(`#${this.id}`)) {
      return;
    }

    event.preventDefault();

    if (!this.parent.isMultipleSelection) {
      this.commitOrRemove();
    }
  }

  commitOrRemove() {
    if (this.isEmpty()) {
      this.remove();
    } else {
      this.commit();
    }
  }

  commit() {
    this.parent.addToAnnotationStorage(this);
  }

  dragstart(event) {
    const rect = this.parent.div.getBoundingClientRect();
    this.startX = event.clientX - rect.x;
    this.startY = event.clientY - rect.y;
    event.dataTransfer.setData("text/plain", this.id);
    event.dataTransfer.effectAllowed = "move";
  }

  setAt(x, y, tx, ty) {
    const [width, height] = this.parent.viewportBaseDimensions;
    [tx, ty] = this.screenToPageTranslation(tx, ty);
    this.x = (x + tx) / width;
    this.y = (y + ty) / height;
    this.div.style.left = `${100 * this.x}%`;
    this.div.style.top = `${100 * this.y}%`;
  }

  translate(x, y) {
    const [width, height] = this.parent.viewportBaseDimensions;
    [x, y] = this.screenToPageTranslation(x, y);
    this.x += x / width;
    this.y += y / height;
    this.div.style.left = `${100 * this.x}%`;
    this.div.style.top = `${100 * this.y}%`;
  }

  screenToPageTranslation(x, y) {
    const {
      rotation
    } = this.parent.viewport;

    switch (rotation) {
      case 90:
        return [y, -x];

      case 180:
        return [-x, -y];

      case 270:
        return [-y, x];

      default:
        return [x, y];
    }
  }

  setDims(width, height) {
    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
    this.div.style.width = `${100 * width / parentWidth}%`;
    this.div.style.height = `${100 * height / parentHeight}%`;
  }

  getInitialTranslation() {
    return [0, 0];
  }

  render() {
    this.div = document.createElement("div");
    this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
    this.div.className = this.name;
    this.div.setAttribute("id", this.id);
    this.div.setAttribute("tabIndex", 0);
    this.setInForeground();
    this.div.addEventListener("focusin", this.#boundFocusin);
    this.div.addEventListener("focusout", this.#boundFocusout);
    const [tx, ty] = this.getInitialTranslation();
    this.translate(tx, ty);
    (0, _tools.bindEvents)(this, this.div, ["dragstart", "pointerdown"]);
    return this.div;
  }

  pointerdown(event) {
    const isMac = _tools.KeyboardManager.platform.isMac;

    if (event.button !== 0 || event.ctrlKey && isMac) {
      event.preventDefault();
      return;
    }

    if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
      this.parent.toggleSelected(this);
    } else {
      this.parent.setSelected(this);
    }

    this.#hasBeenSelected = true;
  }

  getRect(tx, ty) {
    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
    const [pageWidth, pageHeight] = this.parent.pageDimensions;
    const shiftX = pageWidth * tx / parentWidth;
    const shiftY = pageHeight * ty / parentHeight;
    const x = this.x * pageWidth;
    const y = this.y * pageHeight;
    const width = this.width * pageWidth;
    const height = this.height * pageHeight;

    switch (this.rotation) {
      case 0:
        return [x + shiftX, pageHeight - y - shiftY - height, x + shiftX + width, pageHeight - y - shiftY];

      case 90:
        return [x + shiftY, pageHeight - y + shiftX, x + shiftY + height, pageHeight - y + shiftX + width];

      case 180:
        return [x - shiftX - width, pageHeight - y + shiftY, x - shiftX, pageHeight - y + shiftY + height];

      case 270:
        return [x - shiftY - height, pageHeight - y - shiftX - width, x - shiftY, pageHeight - y - shiftX];

      default:
        throw new Error("Invalid rotation");
    }
  }

  getRectInCurrentCoords(rect, pageHeight) {
    const [x1, y1, x2, y2] = rect;
    const width = x2 - x1;
    const height = y2 - y1;

    switch (this.rotation) {
      case 0:
        return [x1, pageHeight - y2, width, height];

      case 90:
        return [x1, pageHeight - y1, height, width];

      case 180:
        return [x2, pageHeight - y1, width, height];

      case 270:
        return [x2, pageHeight - y2, height, width];

      default:
        throw new Error("Invalid rotation");
    }
  }

  onceAdded() {}

  isEmpty() {
    return false;
  }

  enableEditMode() {
    this.#isInEditMode = true;
  }

  disableEditMode() {
    this.#isInEditMode = false;
  }

  isInEditMode() {
    return this.#isInEditMode;
  }

  shouldGetKeyboardEvents() {
    return false;
  }

  needsToBeRebuilt() {
    return this.div && !this.isAttachedToDOM;
  }

  rebuild() {
    this.div?.addEventListener("focusin", this.#boundFocusin);
  }

  serialize() {
    (0, _util.unreachable)("An editor must be serializable");
  }

  static deserialize(data, parent) {
    const editor = new this.prototype.constructor({
      parent,
      id: parent.getNextId()
    });
    editor.rotation = data.rotation;
    const [pageWidth, pageHeight] = parent.pageDimensions;
    const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
    editor.x = x / pageWidth;
    editor.y = y / pageHeight;
    editor.width = width / pageWidth;
    editor.height = height / pageHeight;
    return editor;
  }

  remove() {
    this.div.removeEventListener("focusin", this.#boundFocusin);
    this.div.removeEventListener("focusout", this.#boundFocusout);

    if (!this.isEmpty()) {
      this.commit();
    }

    this.parent.remove(this);
  }

  select() {
    this.div?.classList.add("selectedEditor");
  }

  unselect() {
    this.div?.classList.remove("selectedEditor");
  }

  updateParams(type, value) {}

  disableEditing() {}

  enableEditing() {}

  get propertiesToUpdate() {
    return {};
  }

  get contentDiv() {
    return this.div;
  }

  get isEditing() {
    return this.#isEditing;
  }

  set isEditing(value) {
    this.#isEditing = value;

    if (value) {
      this.parent.setSelected(this);
      this.parent.setActiveEditor(this);
    } else {
      this.parent.setActiveEditor(null);
    }
  }

}

exports.AnnotationEditor = AnnotationEditor;

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.KeyboardManager = exports.CommandManager = exports.ColorManager = exports.AnnotationEditorUIManager = void 0;
exports.bindEvents = bindEvents;
exports.opacityToHex = opacityToHex;

var _util = __w_pdfjs_require__(1);

var _display_utils = __w_pdfjs_require__(8);

function bindEvents(obj, element, names) {
  for (const name of names) {
    element.addEventListener(name, obj[name].bind(obj));
  }
}

function opacityToHex(opacity) {
  return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, "0");
}

class IdManager {
  #id = 0;

  getId() {
    return `${_util.AnnotationEditorPrefix}${this.#id++}`;
  }

}

class CommandManager {
  #commands = [];
  #locked = false;
  #maxSize;
  #position = -1;

  constructor(maxSize = 128) {
    this.#maxSize = maxSize;
  }

  add({
    cmd,
    undo,
    mustExec,
    type = NaN,
    overwriteIfSameType = false,
    keepUndo = false
  }) {
    if (mustExec) {
      cmd();
    }

    if (this.#locked) {
      return;
    }

    const save = {
      cmd,
      undo,
      type
    };

    if (this.#position === -1) {
      if (this.#commands.length > 0) {
        this.#commands.length = 0;
      }

      this.#position = 0;
      this.#commands.push(save);
      return;
    }

    if (overwriteIfSameType && this.#commands[this.#position].type === type) {
      if (keepUndo) {
        save.undo = this.#commands[this.#position].undo;
      }

      this.#commands[this.#position] = save;
      return;
    }

    const next = this.#position + 1;

    if (next === this.#maxSize) {
      this.#commands.splice(0, 1);
    } else {
      this.#position = next;

      if (next < this.#commands.length) {
        this.#commands.splice(next);
      }
    }

    this.#commands.push(save);
  }

  undo() {
    if (this.#position === -1) {
      return;
    }

    this.#locked = true;
    this.#commands[this.#position].undo();
    this.#locked = false;
    this.#position -= 1;
  }

  redo() {
    if (this.#position < this.#commands.length - 1) {
      this.#position += 1;
      this.#locked = true;
      this.#commands[this.#position].cmd();
      this.#locked = false;
    }
  }

  hasSomethingToUndo() {
    return this.#position !== -1;
  }

  hasSomethingToRedo() {
    return this.#position < this.#commands.length - 1;
  }

  destroy() {
    this.#commands = null;
  }

}

exports.CommandManager = CommandManager;

class KeyboardManager {
  constructor(callbacks) {
    this.buffer = [];
    this.callbacks = new Map();
    this.allKeys = new Set();
    const isMac = KeyboardManager.platform.isMac;

    for (const [keys, callback] of callbacks) {
      for (const key of keys) {
        const isMacKey = key.startsWith("mac+");

        if (isMac && isMacKey) {
          this.callbacks.set(key.slice(4), callback);
          this.allKeys.add(key.split("+").at(-1));
        } else if (!isMac && !isMacKey) {
          this.callbacks.set(key, callback);
          this.allKeys.add(key.split("+").at(-1));
        }
      }
    }
  }

  static get platform() {
    const platform = typeof navigator !== "undefined" ? navigator.platform : "";
    return (0, _util.shadow)(this, "platform", {
      isWin: platform.includes("Win"),
      isMac: platform.includes("Mac")
    });
  }

  #serialize(event) {
    if (event.altKey) {
      this.buffer.push("alt");
    }

    if (event.ctrlKey) {
      this.buffer.push("ctrl");
    }

    if (event.metaKey) {
      this.buffer.push("meta");
    }

    if (event.shiftKey) {
      this.buffer.push("shift");
    }

    this.buffer.push(event.key);
    const str = this.buffer.join("+");
    this.buffer.length = 0;
    return str;
  }

  exec(self, event) {
    if (!this.allKeys.has(event.key)) {
      return;
    }

    const callback = this.callbacks.get(this.#serialize(event));

    if (!callback) {
      return;
    }

    callback.bind(self)();
    event.stopPropagation();
    event.preventDefault();
  }

}

exports.KeyboardManager = KeyboardManager;

class ClipboardManager {
  #elements = null;

  copy(element) {
    if (!element) {
      return;
    }

    if (Array.isArray(element)) {
      this.#elements = element.map(el => el.serialize());
    } else {
      this.#elements = [element.serialize()];
    }

    this.#elements = this.#elements.filter(el => !!el);

    if (this.#elements.length === 0) {
      this.#elements = null;
    }
  }

  paste() {
    return this.#elements;
  }

  isEmpty() {
    return this.#elements === null;
  }

  destroy() {
    this.#elements = null;
  }

}

class ColorManager {
  static _colorsMapping = new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]);

  get _colors() {
    const colors = new Map([["CanvasText", null], ["Canvas", null]]);
    (0, _display_utils.getColorValues)(colors);
    return (0, _util.shadow)(this, "_colors", colors);
  }

  convert(color) {
    const rgb = (0, _display_utils.getRGB)(color);

    if (!window.matchMedia("(forced-colors: active)").matches) {
      return rgb;
    }

    for (const [name, RGB] of this._colors) {
      if (RGB.every((x, i) => x === rgb[i])) {
        return ColorManager._colorsMapping.get(name);
      }
    }

    return rgb;
  }

  getHexCode(name) {
    const rgb = this._colors.get(name);

    if (!rgb) {
      return name;
    }

    return _util.Util.makeHexColor(...rgb);
  }

}

exports.ColorManager = ColorManager;

class AnnotationEditorUIManager {
  #activeEditor = null;
  #allEditors = new Map();
  #allLayers = new Map();
  #clipboardManager = new ClipboardManager();
  #commandManager = new CommandManager();
  #currentPageIndex = 0;
  #editorTypes = null;
  #eventBus = null;
  #idManager = new IdManager();
  #isEnabled = false;
  #mode = _util.AnnotationEditorType.NONE;
  #selectedEditors = new Set();
  #boundKeydown = this.keydown.bind(this);
  #boundOnEditingAction = this.onEditingAction.bind(this);
  #boundOnPageChanging = this.onPageChanging.bind(this);
  #previousStates = {
    isEditing: false,
    isEmpty: true,
    hasEmptyClipboard: true,
    hasSomethingToUndo: false,
    hasSomethingToRedo: false,
    hasSelectedEditor: false
  };
  #container = null;
  static _keyboardManager = new KeyboardManager([[["ctrl+a", "mac+meta+a"], AnnotationEditorUIManager.prototype.selectAll], [["ctrl+c", "mac+meta+c"], AnnotationEditorUIManager.prototype.copy], [["ctrl+v", "mac+meta+v"], AnnotationEditorUIManager.prototype.paste], [["ctrl+x", "mac+meta+x"], AnnotationEditorUIManager.prototype.cut], [["ctrl+z", "mac+meta+z"], AnnotationEditorUIManager.prototype.undo], [["ctrl+y", "ctrl+shift+Z", "mac+meta+shift+Z"], AnnotationEditorUIManager.prototype.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete"], AnnotationEditorUIManager.prototype.delete], [["Escape", "mac+Escape"], AnnotationEditorUIManager.prototype.unselectAll]]);

  constructor(container, eventBus) {
    this.#container = container;
    this.#eventBus = eventBus;

    this.#eventBus._on("editingaction", this.#boundOnEditingAction);

    this.#eventBus._on("pagechanging", this.#boundOnPageChanging);
  }

  destroy() {
    this.#removeKeyboardManager();

    this.#eventBus._off("editingaction", this.#boundOnEditingAction);

    this.#eventBus._off("pagechanging", this.#boundOnPageChanging);

    for (const layer of this.#allLayers.values()) {
      layer.destroy();
    }

    this.#allLayers.clear();
    this.#allEditors.clear();
    this.#activeEditor = null;
    this.#selectedEditors.clear();
    this.#clipboardManager.destroy();
    this.#commandManager.destroy();
  }

  onPageChanging({
    pageNumber
  }) {
    this.#currentPageIndex = pageNumber - 1;
  }

  focusMainContainer() {
    this.#container.focus();
  }

  #addKeyboardManager() {
    this.#container.addEventListener("keydown", this.#boundKeydown);
  }

  #removeKeyboardManager() {
    this.#container.removeEventListener("keydown", this.#boundKeydown);
  }

  keydown(event) {
    if (!this.getActive()?.shouldGetKeyboardEvents()) {
      AnnotationEditorUIManager._keyboardManager.exec(this, event);
    }
  }

  onEditingAction(details) {
    if (["undo", "redo", "cut", "copy", "paste", "delete", "selectAll"].includes(details.name)) {
      this[details.name]();
    }
  }

  #dispatchUpdateStates(details) {
    const hasChanged = Object.entries(details).some(([key, value]) => this.#previousStates[key] !== value);

    if (hasChanged) {
      this.#eventBus.dispatch("annotationeditorstateschanged", {
        source: this,
        details: Object.assign(this.#previousStates, details)
      });
    }
  }

  #dispatchUpdateUI(details) {
    this.#eventBus.dispatch("annotationeditorparamschanged", {
      source: this,
      details
    });
  }

  setEditingState(isEditing) {
    if (isEditing) {
      this.#addKeyboardManager();
      this.#dispatchUpdateStates({
        isEditing: this.#mode !== _util.AnnotationEditorType.NONE,
        isEmpty: this.#isEmpty(),
        hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
        hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
        hasSelectedEditor: false,
        hasEmptyClipboard: this.#clipboardManager.isEmpty()
      });
    } else {
      this.#removeKeyboardManager();
      this.#dispatchUpdateStates({
        isEditing: false
      });
    }
  }

  registerEditorTypes(types) {
    this.#editorTypes = types;

    for (const editorType of this.#editorTypes) {
      this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
    }
  }

  getId() {
    return this.#idManager.getId();
  }

  addLayer(layer) {
    this.#allLayers.set(layer.pageIndex, layer);

    if (this.#isEnabled) {
      layer.enable();
    } else {
      layer.disable();
    }
  }

  removeLayer(layer) {
    this.#allLayers.delete(layer.pageIndex);
  }

  updateMode(mode) {
    this.#mode = mode;

    if (mode === _util.AnnotationEditorType.NONE) {
      this.setEditingState(false);
      this.#disableAll();
    } else {
      this.setEditingState(true);
      this.#enableAll();

      for (const layer of this.#allLayers.values()) {
        layer.updateMode(mode);
      }
    }
  }

  updateToolbar(mode) {
    if (mode === this.#mode) {
      return;
    }

    this.#eventBus.dispatch("switchannotationeditormode", {
      source: this,
      mode
    });
  }

  updateParams(type, value) {
    for (const editor of this.#selectedEditors) {
      editor.updateParams(type, value);
    }

    for (const editorType of this.#editorTypes) {
      editorType.updateDefaultParams(type, value);
    }
  }

  #enableAll() {
    if (!this.#isEnabled) {
      this.#isEnabled = true;

      for (const layer of this.#allLayers.values()) {
        layer.enable();
      }
    }
  }

  #disableAll() {
    this.unselectAll();

    if (this.#isEnabled) {
      this.#isEnabled = false;

      for (const layer of this.#allLayers.values()) {
        layer.disable();
      }
    }
  }

  getEditors(pageIndex) {
    const editors = [];

    for (const editor of this.#allEditors.values()) {
      if (editor.pageIndex === pageIndex) {
        editors.push(editor);
      }
    }

    return editors;
  }

  getEditor(id) {
    return this.#allEditors.get(id);
  }

  addEditor(editor) {
    this.#allEditors.set(editor.id, editor);
  }

  removeEditor(editor) {
    this.#allEditors.delete(editor.id);
    this.unselect(editor);
  }

  #addEditorToLayer(editor) {
    const layer = this.#allLayers.get(editor.pageIndex);

    if (layer) {
      layer.addOrRebuild(editor);
    } else {
      this.addEditor(editor);
    }
  }

  setActiveEditor(editor) {
    if (this.#activeEditor === editor) {
      return;
    }

    this.#activeEditor = editor;

    if (editor) {
      this.#dispatchUpdateUI(editor.propertiesToUpdate);
    }
  }

  toggleSelected(editor) {
    if (this.#selectedEditors.has(editor)) {
      this.#selectedEditors.delete(editor);
      editor.unselect();
      this.#dispatchUpdateStates({
        hasSelectedEditor: this.hasSelection
      });
      return;
    }

    this.#selectedEditors.add(editor);
    editor.select();
    this.#dispatchUpdateUI(editor.propertiesToUpdate);
    this.#dispatchUpdateStates({
      hasSelectedEditor: true
    });
  }

  setSelected(editor) {
    for (const ed of this.#selectedEditors) {
      if (ed !== editor) {
        ed.unselect();
      }
    }

    this.#selectedEditors.clear();
    this.#selectedEditors.add(editor);
    editor.select();
    this.#dispatchUpdateUI(editor.propertiesToUpdate);
    this.#dispatchUpdateStates({
      hasSelectedEditor: true
    });
  }

  isSelected(editor) {
    return this.#selectedEditors.has(editor);
  }

  unselect(editor) {
    editor.unselect();
    this.#selectedEditors.delete(editor);
    this.#dispatchUpdateStates({
      hasSelectedEditor: this.hasSelection
    });
  }

  get hasSelection() {
    return this.#selectedEditors.size !== 0;
  }

  undo() {
    this.#commandManager.undo();
    this.#dispatchUpdateStates({
      hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
      hasSomethingToRedo: true,
      isEmpty: this.#isEmpty()
    });
  }

  redo() {
    this.#commandManager.redo();
    this.#dispatchUpdateStates({
      hasSomethingToUndo: true,
      hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
      isEmpty: this.#isEmpty()
    });
  }

  addCommands(params) {
    this.#commandManager.add(params);
    this.#dispatchUpdateStates({
      hasSomethingToUndo: true,
      hasSomethingToRedo: false,
      isEmpty: this.#isEmpty()
    });
  }

  #isEmpty() {
    if (this.#allEditors.size === 0) {
      return true;
    }

    if (this.#allEditors.size === 1) {
      for (const editor of this.#allEditors.values()) {
        return editor.isEmpty();
      }
    }

    return false;
  }

  delete() {
    if (this.#activeEditor) {
      this.#activeEditor.commitOrRemove();
    }

    if (!this.hasSelection) {
      return;
    }

    const editors = [...this.#selectedEditors];

    const cmd = () => {
      for (const editor of editors) {
        editor.remove();
      }
    };

    const undo = () => {
      for (const editor of editors) {
        this.#addEditorToLayer(editor);
      }
    };

    this.addCommands({
      cmd,
      undo,
      mustExec: true
    });
  }

  copy() {
    if (this.#activeEditor) {
      this.#activeEditor.commitOrRemove();
    }

    if (this.hasSelection) {
      const editors = [];

      for (const editor of this.#selectedEditors) {
        if (!editor.isEmpty()) {
          editors.push(editor);
        }
      }

      if (editors.length === 0) {
        return;
      }

      this.#clipboardManager.copy(editors);
      this.#dispatchUpdateStates({
        hasEmptyClipboard: false
      });
    }
  }

  cut() {
    this.copy();
    this.delete();
  }

  paste() {
    if (this.#clipboardManager.isEmpty()) {
      return;
    }

    this.unselectAll();
    const layer = this.#allLayers.get(this.#currentPageIndex);
    const newEditors = this.#clipboardManager.paste().map(data => layer.deserialize(data));

    const cmd = () => {
      for (const editor of newEditors) {
        this.#addEditorToLayer(editor);
      }

      this.#selectEditors(newEditors);
    };

    const undo = () => {
      for (const editor of newEditors) {
        editor.remove();
      }
    };

    this.addCommands({
      cmd,
      undo,
      mustExec: true
    });
  }

  #selectEditors(editors) {
    this.#selectedEditors.clear();

    for (const editor of editors) {
      if (editor.isEmpty()) {
        continue;
      }

      this.#selectedEditors.add(editor);
      editor.select();
    }

    this.#dispatchUpdateStates({
      hasSelectedEditor: true
    });
  }

  selectAll() {
    for (const editor of this.#selectedEditors) {
      editor.commit();
    }

    this.#selectEditors(this.#allEditors.values());
  }

  unselectAll() {
    if (this.#activeEditor) {
      this.#activeEditor.commitOrRemove();
      return;
    }

    if (this.#selectEditors.size === 0) {
      return;
    }

    for (const editor of this.#selectedEditors) {
      editor.unselect();
    }

    this.#selectedEditors.clear();
    this.#dispatchUpdateStates({
      hasSelectedEditor: false
    });
  }

  isActive(editor) {
    return this.#activeEditor === editor;
  }

  getActive() {
    return this.#activeEditor;
  }

  getMode() {
    return this.#mode;
  }

}

exports.AnnotationEditorUIManager = AnnotationEditorUIManager;

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = exports.AnnotationPrefix = void 0;
exports.deprecated = deprecated;
exports.getColorValues = getColorValues;
exports.getCurrentTransform = getCurrentTransform;
exports.getCurrentTransformInverse = getCurrentTransformInverse;
exports.getFilenameFromUrl = getFilenameFromUrl;
exports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
exports.getRGB = getRGB;
exports.getXfaPageViewport = getXfaPageViewport;
exports.isDataScheme = isDataScheme;
exports.isPdfFile = isPdfFile;
exports.isValidFetchUrl = isValidFetchUrl;
exports.loadScript = loadScript;

var _base_factory = __w_pdfjs_require__(9);

var _util = __w_pdfjs_require__(1);

const SVG_NS = "http://www.w3.org/2000/svg";
const AnnotationPrefix = "pdfjs_internal_id_";
exports.AnnotationPrefix = AnnotationPrefix;

class PixelsPerInch {
  static CSS = 96.0;
  static PDF = 72.0;
  static PDF_TO_CSS_UNITS = this.CSS / this.PDF;
}

exports.PixelsPerInch = PixelsPerInch;

class DOMCanvasFactory extends _base_factory.BaseCanvasFactory {
  constructor({
    ownerDocument = globalThis.document
  } = {}) {
    super();
    this._document = ownerDocument;
  }

  _createCanvas(width, height) {
    const canvas = this._document.createElement("canvas");

    canvas.width = width;
    canvas.height = height;
    return canvas;
  }

}

exports.DOMCanvasFactory = DOMCanvasFactory;

async function fetchData(url, asTypedArray = false) {
  if (isValidFetchUrl(url, document.baseURI)) {
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(response.statusText);
    }

    return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util.stringToBytes)(await response.text());
  }

  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest();
    request.open("GET", url, true);

    if (asTypedArray) {
      request.responseType = "arraybuffer";
    }

    request.onreadystatechange = () => {
      if (request.readyState !== XMLHttpRequest.DONE) {
        return;
      }

      if (request.status === 200 || request.status === 0) {
        let data;

        if (asTypedArray && request.response) {
          data = new Uint8Array(request.response);
        } else if (!asTypedArray && request.responseText) {
          data = (0, _util.stringToBytes)(request.responseText);
        }

        if (data) {
          resolve(data);
          return;
        }
      }

      reject(new Error(request.statusText));
    };

    request.send(null);
  });
}

class DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
  _fetchData(url, compressionType) {
    return fetchData(url, this.isCompressed).then(data => {
      return {
        cMapData: data,
        compressionType
      };
    });
  }

}

exports.DOMCMapReaderFactory = DOMCMapReaderFactory;

class DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
  _fetchData(url) {
    return fetchData(url, true);
  }

}

exports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;

class DOMSVGFactory extends _base_factory.BaseSVGFactory {
  _createSVG(type) {
    return document.createElementNS(SVG_NS, type);
  }

}

exports.DOMSVGFactory = DOMSVGFactory;

class PageViewport {
  constructor({
    viewBox,
    scale,
    rotation,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  }) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    const centerX = (viewBox[2] + viewBox[0]) / 2;
    const centerY = (viewBox[3] + viewBox[1]) / 2;
    let rotateA, rotateB, rotateC, rotateD;
    rotation %= 360;

    if (rotation < 0) {
      rotation += 360;
    }

    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;

      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;

      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;

      case 0:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;

      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }

    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }

    let offsetCanvasX, offsetCanvasY;
    let width, height;

    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
    }

    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
    this.width = width;
    this.height = height;
  }

  clone({
    scale = this.scale,
    rotation = this.rotation,
    offsetX = this.offsetX,
    offsetY = this.offsetY,
    dontFlip = false
  } = {}) {
    return new PageViewport({
      viewBox: this.viewBox.slice(),
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }

  convertToViewportPoint(x, y) {
    return _util.Util.applyTransform([x, y], this.transform);
  }

  convertToViewportRectangle(rect) {
    const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);

    const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);

    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
  }

  convertToPdfPoint(x, y) {
    return _util.Util.applyInverseTransform([x, y], this.transform);
  }

}

exports.PageViewport = PageViewport;

class RenderingCancelledException extends _util.BaseException {
  constructor(msg, type) {
    super(msg, "RenderingCancelledException");
    this.type = type;
  }

}

exports.RenderingCancelledException = RenderingCancelledException;

function isDataScheme(url) {
  const ii = url.length;
  let i = 0;

  while (i < ii && url[i].trim() === "") {
    i++;
  }

  return url.substring(i, i + 5).toLowerCase() === "data:";
}

function isPdfFile(filename) {
  return typeof filename === "string" && /\.pdf$/i.test(filename);
}

function getFilenameFromUrl(url) {
  const anchor = url.indexOf("#");
  const query = url.indexOf("?");
  const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
  return url.substring(url.lastIndexOf("/", end) + 1, end);
}

function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
  if (typeof url !== "string") {
    return defaultFilename;
  }

  if (isDataScheme(url)) {
    (0, _util.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
    return defaultFilename;
  }

  const reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
  const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
  const splitURI = reURI.exec(url);
  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);

  if (suggestedFilename) {
    suggestedFilename = suggestedFilename[0];

    if (suggestedFilename.includes("%")) {
      try {
        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
      } catch (ex) {}
    }
  }

  return suggestedFilename || defaultFilename;
}

class StatTimer {
  constructor() {
    this.started = Object.create(null);
    this.times = [];
  }

  time(name) {
    if (name in this.started) {
      (0, _util.warn)(`Timer is already running for ${name}`);
    }

    this.started[name] = Date.now();
  }

  timeEnd(name) {
    if (!(name in this.started)) {
      (0, _util.warn)(`Timer has not been started for ${name}`);
    }

    this.times.push({
      name,
      start: this.started[name],
      end: Date.now()
    });
    delete this.started[name];
  }

  toString() {
    const outBuf = [];
    let longest = 0;

    for (const time of this.times) {
      const name = time.name;

      if (name.length > longest) {
        longest = name.length;
      }
    }

    for (const time of this.times) {
      const duration = time.end - time.start;
      outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\n`);
    }

    return outBuf.join("");
  }

}

exports.StatTimer = StatTimer;

function isValidFetchUrl(url, baseUrl) {
  try {
    const {
      protocol
    } = baseUrl ? new URL(url, baseUrl) : new URL(url);
    return protocol === "http:" || protocol === "https:";
  } catch (ex) {
    return false;
  }
}

function loadScript(src, removeScriptElement = false) {
  return new Promise((resolve, reject) => {
    const script = document.createElement("script");
    script.src = src;

    script.onload = function (evt) {
      if (removeScriptElement) {
        script.remove();
      }

      resolve(evt);
    };

    script.onerror = function () {
      reject(new Error(`Cannot load script at: ${script.src}`));
    };

    (document.head || document.documentElement).append(script);
  });
}

function deprecated(details) {
  console.log("Deprecated API usage: " + details);
}

let pdfDateStringRegex;

class PDFDateString {
  static toDateObject(input) {
    if (!input || typeof input !== "string") {
      return null;
    }

    if (!pdfDateStringRegex) {
      pdfDateStringRegex = new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?");
    }

    const matches = pdfDateStringRegex.exec(input);

    if (!matches) {
      return null;
    }

    const year = parseInt(matches[1], 10);
    let month = parseInt(matches[2], 10);
    month = month >= 1 && month <= 12 ? month - 1 : 0;
    let day = parseInt(matches[3], 10);
    day = day >= 1 && day <= 31 ? day : 1;
    let hour = parseInt(matches[4], 10);
    hour = hour >= 0 && hour <= 23 ? hour : 0;
    let minute = parseInt(matches[5], 10);
    minute = minute >= 0 && minute <= 59 ? minute : 0;
    let second = parseInt(matches[6], 10);
    second = second >= 0 && second <= 59 ? second : 0;
    const universalTimeRelation = matches[7] || "Z";
    let offsetHour = parseInt(matches[8], 10);
    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
    let offsetMinute = parseInt(matches[9], 10) || 0;
    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;

    if (universalTimeRelation === "-") {
      hour += offsetHour;
      minute += offsetMinute;
    } else if (universalTimeRelation === "+") {
      hour -= offsetHour;
      minute -= offsetMinute;
    }

    return new Date(Date.UTC(year, month, day, hour, minute, second));
  }

}

exports.PDFDateString = PDFDateString;

function getXfaPageViewport(xfaPage, {
  scale = 1,
  rotation = 0
}) {
  const {
    width,
    height
  } = xfaPage.attributes.style;
  const viewBox = [0, 0, parseInt(width), parseInt(height)];
  return new PageViewport({
    viewBox,
    scale,
    rotation
  });
}

function getRGB(color) {
  if (color.startsWith("#")) {
    const colorRGB = parseInt(color.slice(1), 16);
    return [(colorRGB & 0xff0000) >> 16, (colorRGB & 0x00ff00) >> 8, colorRGB & 0x0000ff];
  }

  if (color.startsWith("rgb(")) {
    return color.slice(4, -1).split(",").map(x => parseInt(x));
  }

  if (color.startsWith("rgba(")) {
    return color.slice(5, -1).split(",").map(x => parseInt(x)).slice(0, 3);
  }

  (0, _util.warn)(`Not a valid color format: "${color}"`);
  return [0, 0, 0];
}

function getColorValues(colors) {
  const span = document.createElement("span");
  span.style.visibility = "hidden";
  document.body.append(span);

  for (const name of colors.keys()) {
    span.style.color = name;
    const computedColor = window.getComputedStyle(span).color;
    colors.set(name, getRGB(computedColor));
  }

  span.remove();
}

function getCurrentTransform(ctx) {
  const {
    a,
    b,
    c,
    d,
    e,
    f
  } = ctx.getTransform();
  return [a, b, c, d, e, f];
}

function getCurrentTransformInverse(ctx) {
  const {
    a,
    b,
    c,
    d,
    e,
    f
  } = ctx.getTransform().invertSelf();
  return [a, b, c, d, e, f];
}

/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;

var _util = __w_pdfjs_require__(1);

class BaseCanvasFactory {
  constructor() {
    if (this.constructor === BaseCanvasFactory) {
      (0, _util.unreachable)("Cannot initialize BaseCanvasFactory.");
    }
  }

  create(width, height) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }

    const canvas = this._createCanvas(width, height);

    return {
      canvas,
      context: canvas.getContext("2d")
    };
  }

  reset(canvasAndContext, width, height) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }

    if (width <= 0 || height <= 0) {
      throw new Error("Invalid canvas size");
    }

    canvasAndContext.canvas.width = width;
    canvasAndContext.canvas.height = height;
  }

  destroy(canvasAndContext) {
    if (!canvasAndContext.canvas) {
      throw new Error("Canvas is not specified");
    }

    canvasAndContext.canvas.width = 0;
    canvasAndContext.canvas.height = 0;
    canvasAndContext.canvas = null;
    canvasAndContext.context = null;
  }

  _createCanvas(width, height) {
    (0, _util.unreachable)("Abstract method `_createCanvas` called.");
  }

}

exports.BaseCanvasFactory = BaseCanvasFactory;

class BaseCMapReaderFactory {
  constructor({
    baseUrl = null,
    isCompressed = false
  }) {
    if (this.constructor === BaseCMapReaderFactory) {
      (0, _util.unreachable)("Cannot initialize BaseCMapReaderFactory.");
    }

    this.baseUrl = baseUrl;
    this.isCompressed = isCompressed;
  }

  async fetch({
    name
  }) {
    if (!this.baseUrl) {
      throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.');
    }

    if (!name) {
      throw new Error("CMap name must be specified.");
    }

    const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
    const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;
    return this._fetchData(url, compressionType).catch(reason => {
      throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
    });
  }

  _fetchData(url, compressionType) {
    (0, _util.unreachable)("Abstract method `_fetchData` called.");
  }

}

exports.BaseCMapReaderFactory = BaseCMapReaderFactory;

class BaseStandardFontDataFactory {
  constructor({
    baseUrl = null
  }) {
    if (this.constructor === BaseStandardFontDataFactory) {
      (0, _util.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
    }

    this.baseUrl = baseUrl;
  }

  async fetch({
    filename
  }) {
    if (!this.baseUrl) {
      throw new Error('The standard font "baseUrl" parameter must be specified, ensure that ' + 'the "standardFontDataUrl" API parameter is provided.');
    }

    if (!filename) {
      throw new Error("Font filename must be specified.");
    }

    const url = `${this.baseUrl}${filename}`;
    return this._fetchData(url).catch(reason => {
      throw new Error(`Unable to load font data at: ${url}`);
    });
  }

  _fetchData(url) {
    (0, _util.unreachable)("Abstract method `_fetchData` called.");
  }

}

exports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;

class BaseSVGFactory {
  constructor() {
    if (this.constructor === BaseSVGFactory) {
      (0, _util.unreachable)("Cannot initialize BaseSVGFactory.");
    }
  }

  create(width, height, skipDimensions = false) {
    if (width <= 0 || height <= 0) {
      throw new Error("Invalid SVG dimensions");
    }

    const svg = this._createSVG("svg:svg");

    svg.setAttribute("version", "1.1");

    if (!skipDimensions) {
      svg.setAttribute("width", `${width}px`);
      svg.setAttribute("height", `${height}px`);
    }

    svg.setAttribute("preserveAspectRatio", "none");
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    return svg;
  }

  createElement(type) {
    if (typeof type !== "string") {
      throw new Error("Invalid SVG element type");
    }

    return this._createSVG(type);
  }

  _createSVG(type) {
    (0, _util.unreachable)("Abstract method `_createSVG` called.");
  }

}

exports.BaseSVGFactory = BaseSVGFactory;

/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MurmurHash3_64 = void 0;

var _util = __w_pdfjs_require__(1);

const SEED = 0xc3d2e1f0;
const MASK_HIGH = 0xffff0000;
const MASK_LOW = 0xffff;

class MurmurHash3_64 {
  constructor(seed) {
    this.h1 = seed ? seed & 0xffffffff : SEED;
    this.h2 = seed ? seed & 0xffffffff : SEED;
  }

  update(input) {
    let data, length;

    if (typeof input === "string") {
      data = new Uint8Array(input.length * 2);
      length = 0;

      for (let i = 0, ii = input.length; i < ii; i++) {
        const code = input.charCodeAt(i);

        if (code <= 0xff) {
          data[length++] = code;
        } else {
          data[length++] = code >>> 8;
          data[length++] = code & 0xff;
        }
      }
    } else if ((0, _util.isArrayBuffer)(input)) {
      data = input.slice();
      length = data.byteLength;
    } else {
      throw new Error("Wrong data format in MurmurHash3_64_update. " + "Input must be a string or array.");
    }

    const blockCounts = length >> 2;
    const tailLength = length - blockCounts * 4;
    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
    let k1 = 0,
        k2 = 0;
    let h1 = this.h1,
        h2 = this.h2;
    const C1 = 0xcc9e2d51,
          C2 = 0x1b873593;
    const C1_LOW = C1 & MASK_LOW,
          C2_LOW = C2 & MASK_LOW;

    for (let i = 0; i < blockCounts; i++) {
      if (i & 1) {
        k1 = dataUint32[i];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
        h1 ^= k1;
        h1 = h1 << 13 | h1 >>> 19;
        h1 = h1 * 5 + 0xe6546b64;
      } else {
        k2 = dataUint32[i];
        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
        k2 = k2 << 15 | k2 >>> 17;
        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
        h2 ^= k2;
        h2 = h2 << 13 | h2 >>> 19;
        h2 = h2 * 5 + 0xe6546b64;
      }
    }

    k1 = 0;

    switch (tailLength) {
      case 3:
        k1 ^= data[blockCounts * 4 + 2] << 16;

      case 2:
        k1 ^= data[blockCounts * 4 + 1] << 8;

      case 1:
        k1 ^= data[blockCounts * 4];
        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;

        if (blockCounts & 1) {
          h1 ^= k1;
        } else {
          h2 ^= k1;
        }

    }

    this.h1 = h1;
    this.h2 = h2;
  }

  hexdigest() {
    let h1 = this.h1,
        h2 = this.h2;
    h1 ^= h2 >>> 1;
    h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;
    h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;
    h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;
    h1 ^= h2 >>> 1;
    const hex1 = (h1 >>> 0).toString(16),
          hex2 = (h2 >>> 0).toString(16);
    return hex1.padStart(8, "0") + hex2.padStart(8, "0");
  }

}

exports.MurmurHash3_64 = MurmurHash3_64;

/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FontLoader = exports.FontFaceObject = void 0;

var _util = __w_pdfjs_require__(1);

class BaseFontLoader {
  constructor({
    docId,
    onUnsupportedFeature,
    ownerDocument = globalThis.document,
    styleElement = null
  }) {
    if (this.constructor === BaseFontLoader) {
      (0, _util.unreachable)("Cannot initialize BaseFontLoader.");
    }

    this.docId = docId;
    this._onUnsupportedFeature = onUnsupportedFeature;
    this._document = ownerDocument;
    this.nativeFontFaces = [];
    this.styleElement = null;
  }

  addNativeFontFace(nativeFontFace) {
    this.nativeFontFaces.push(nativeFontFace);

    this._document.fonts.add(nativeFontFace);
  }

  insertRule(rule) {
    let styleElement = this.styleElement;

    if (!styleElement) {
      styleElement = this.styleElement = this._document.createElement("style");
      styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`;

      this._document.documentElement.getElementsByTagName("head")[0].append(styleElement);
    }

    const styleSheet = styleElement.sheet;
    styleSheet.insertRule(rule, styleSheet.cssRules.length);
  }

  clear() {
    for (const nativeFontFace of this.nativeFontFaces) {
      this._document.fonts.delete(nativeFontFace);
    }

    this.nativeFontFaces.length = 0;

    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }

  async bind(font) {
    if (font.attached || font.missingFile) {
      return;
    }

    font.attached = true;

    if (this.isFontLoadingAPISupported) {
      const nativeFontFace = font.createNativeFontFace();

      if (nativeFontFace) {
        this.addNativeFontFace(nativeFontFace);

        try {
          await nativeFontFace.loaded;
        } catch (ex) {
          this._onUnsupportedFeature({
            featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative
          });

          (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
          font.disableFontFace = true;
          throw ex;
        }
      }

      return;
    }

    const rule = font.createFontFaceRule();

    if (rule) {
      this.insertRule(rule);

      if (this.isSyncFontLoadingSupported) {
        return;
      }

      await new Promise(resolve => {
        const request = this._queueLoadingCallback(resolve);

        this._prepareFontLoadEvent([rule], [font], request);
      });
    }
  }

  _queueLoadingCallback(callback) {
    (0, _util.unreachable)("Abstract method `_queueLoadingCallback`.");
  }

  get isFontLoadingAPISupported() {
    const hasFonts = !!this._document?.fonts;
    return (0, _util.shadow)(this, "isFontLoadingAPISupported", hasFonts);
  }

  get isSyncFontLoadingSupported() {
    (0, _util.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
  }

  get _loadTestFont() {
    (0, _util.unreachable)("Abstract method `_loadTestFont`.");
  }

  _prepareFontLoadEvent(rules, fontsToLoad, request) {
    (0, _util.unreachable)("Abstract method `_prepareFontLoadEvent`.");
  }

}

let FontLoader;
exports.FontLoader = FontLoader;
{
  exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader {
    constructor(params) {
      super(params);
      this.loadingContext = {
        requests: [],
        nextRequestId: 0
      };
      this.loadTestFontId = 0;
    }

    get isSyncFontLoadingSupported() {
      let supported = false;

      if (typeof navigator === "undefined") {
        supported = true;
      } else {
        const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);

        if (m?.[1] >= 14) {
          supported = true;
        }
      }

      return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported);
    }

    _queueLoadingCallback(callback) {
      function completeRequest() {
        (0, _util.assert)(!request.done, "completeRequest() cannot be called twice.");
        request.done = true;

        while (context.requests.length > 0 && context.requests[0].done) {
          const otherRequest = context.requests.shift();
          setTimeout(otherRequest.callback, 0);
        }
      }

      const context = this.loadingContext;
      const request = {
        id: `pdfjs-font-loading-${context.nextRequestId++}`,
        done: false,
        complete: completeRequest,
        callback
      };
      context.requests.push(request);
      return request;
    }

    get _loadTestFont() {
      const getLoadTestFont = function () {
        return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
      };

      return (0, _util.shadow)(this, "_loadTestFont", getLoadTestFont());
    }

    _prepareFontLoadEvent(rules, fonts, request) {
      function int32(data, offset) {
        return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
      }

      function spliceString(s, offset, remove, insert) {
        const chunk1 = s.substring(0, offset);
        const chunk2 = s.substring(offset + remove);
        return chunk1 + insert + chunk2;
      }

      let i, ii;

      const canvas = this._document.createElement("canvas");

      canvas.width = 1;
      canvas.height = 1;
      const ctx = canvas.getContext("2d");
      let called = 0;

      function isFontReady(name, callback) {
        called++;

        if (called > 30) {
          (0, _util.warn)("Load test font never loaded.");
          callback();
          return;
        }

        ctx.font = "30px " + name;
        ctx.fillText(".", 0, 20);
        const imageData = ctx.getImageData(0, 0, 1, 1);

        if (imageData.data[3] > 0) {
          callback();
          return;
        }

        setTimeout(isFontReady.bind(null, name, callback));
      }

      const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
      let data = this._loadTestFont;
      const COMMENT_OFFSET = 976;
      data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
      const CFF_CHECKSUM_OFFSET = 16;
      const XXXX_VALUE = 0x58585858;
      let checksum = int32(data, CFF_CHECKSUM_OFFSET);

      for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
        checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
      }

      if (i < loadTestFontId.length) {
        checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
      }

      data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
      const url = `url(data:font/opentype;base64,${btoa(data)});`;
      const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
      this.insertRule(rule);
      const names = [];

      for (const font of fonts) {
        names.push(font.loadedName);
      }

      names.push(loadTestFontId);

      const div = this._document.createElement("div");

      div.style.visibility = "hidden";
      div.style.width = div.style.height = "10px";
      div.style.position = "absolute";
      div.style.top = div.style.left = "0px";

      for (const name of names) {
        const span = this._document.createElement("span");

        span.textContent = "Hi";
        span.style.fontFamily = name;
        div.append(span);
      }

      this._document.body.append(div);

      isFontReady(loadTestFontId, () => {
        div.remove();
        request.complete();
      });
    }

  };
}

class FontFaceObject {
  constructor(translatedData, {
    isEvalSupported = true,
    disableFontFace = false,
    ignoreErrors = false,
    onUnsupportedFeature,
    fontRegistry = null
  }) {
    this.compiledGlyphs = Object.create(null);

    for (const i in translatedData) {
      this[i] = translatedData[i];
    }

    this.isEvalSupported = isEvalSupported !== false;
    this.disableFontFace = disableFontFace === true;
    this.ignoreErrors = ignoreErrors === true;
    this._onUnsupportedFeature = onUnsupportedFeature;
    this.fontRegistry = fontRegistry;
  }

  createNativeFontFace() {
    if (!this.data || this.disableFontFace) {
      return null;
    }

    let nativeFontFace;

    if (!this.cssFontInfo) {
      nativeFontFace = new FontFace(this.loadedName, this.data, {});
    } else {
      const css = {
        weight: this.cssFontInfo.fontWeight
      };

      if (this.cssFontInfo.italicAngle) {
        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
      }

      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
    }

    if (this.fontRegistry) {
      this.fontRegistry.registerFont(this);
    }

    return nativeFontFace;
  }

  createFontFaceRule() {
    if (!this.data || this.disableFontFace) {
      return null;
    }

    const data = (0, _util.bytesToString)(this.data);
    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;
    let rule;

    if (!this.cssFontInfo) {
      rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
    } else {
      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;

      if (this.cssFontInfo.italicAngle) {
        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
      }

      rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
    }

    if (this.fontRegistry) {
      this.fontRegistry.registerFont(this, url);
    }

    return rule;
  }

  getPathGenerator(objs, character) {
    if (this.compiledGlyphs[character] !== undefined) {
      return this.compiledGlyphs[character];
    }

    let cmds;

    try {
      cmds = objs.get(this.loadedName + "_path_" + character);
    } catch (ex) {
      if (!this.ignoreErrors) {
        throw ex;
      }

      this._onUnsupportedFeature({
        featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath
      });

      (0, _util.warn)(`getPathGenerator - ignoring character: "${ex}".`);
      return this.compiledGlyphs[character] = function (c, size) {};
    }

    if (this.isEvalSupported && _util.FeatureTest.isEvalSupported) {
      const jsBuf = [];

      for (const current of cmds) {
        const args = current.args !== undefined ? current.args.join(",") : "";
        jsBuf.push("c.", current.cmd, "(", args, ");\n");
      }

      return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
    }

    return this.compiledGlyphs[character] = function (c, size) {
      for (const current of cmds) {
        if (current.cmd === "scale") {
          current.args = [size, -size];
        }

        c[current.cmd].apply(c, current.args);
      }
    };
  }

}

exports.FontFaceObject = FontFaceObject;

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.CanvasGraphics = void 0;

var _display_utils = __w_pdfjs_require__(8);

var _util = __w_pdfjs_require__(1);

var _pattern_helper = __w_pdfjs_require__(13);

var _image_utils = __w_pdfjs_require__(14);

var _is_node = __w_pdfjs_require__(3);

const MIN_FONT_SIZE = 16;
const MAX_FONT_SIZE = 100;
const MAX_GROUP_SIZE = 4096;
const EXECUTION_TIME = 15;
const EXECUTION_STEPS = 10;
const MAX_SIZE_TO_COMPILE = _is_node.isNodeJS && typeof Path2D === "undefined" ? -1 : 1000;
const FULL_CHUNK_HEIGHT = 16;

function mirrorContextOperations(ctx, destCtx) {
  if (ctx._removeMirroring) {
    throw new Error("Context is already forwarding operations.");
  }

  ctx.__originalSave = ctx.save;
  ctx.__originalRestore = ctx.restore;
  ctx.__originalRotate = ctx.rotate;
  ctx.__originalScale = ctx.scale;
  ctx.__originalTranslate = ctx.translate;
  ctx.__originalTransform = ctx.transform;
  ctx.__originalSetTransform = ctx.setTransform;
  ctx.__originalResetTransform = ctx.resetTransform;
  ctx.__originalClip = ctx.clip;
  ctx.__originalMoveTo = ctx.moveTo;
  ctx.__originalLineTo = ctx.lineTo;
  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
  ctx.__originalRect = ctx.rect;
  ctx.__originalClosePath = ctx.closePath;
  ctx.__originalBeginPath = ctx.beginPath;

  ctx._removeMirroring = () => {
    ctx.save = ctx.__originalSave;
    ctx.restore = ctx.__originalRestore;
    ctx.rotate = ctx.__originalRotate;
    ctx.scale = ctx.__originalScale;
    ctx.translate = ctx.__originalTranslate;
    ctx.transform = ctx.__originalTransform;
    ctx.setTransform = ctx.__originalSetTransform;
    ctx.resetTransform = ctx.__originalResetTransform;
    ctx.clip = ctx.__originalClip;
    ctx.moveTo = ctx.__originalMoveTo;
    ctx.lineTo = ctx.__originalLineTo;
    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
    ctx.rect = ctx.__originalRect;
    ctx.closePath = ctx.__originalClosePath;
    ctx.beginPath = ctx.__originalBeginPath;
    delete ctx._removeMirroring;
  };

  ctx.save = function ctxSave() {
    destCtx.save();

    this.__originalSave();
  };

  ctx.restore = function ctxRestore() {
    destCtx.restore();

    this.__originalRestore();
  };

  ctx.translate = function ctxTranslate(x, y) {
    destCtx.translate(x, y);

    this.__originalTranslate(x, y);
  };

  ctx.scale = function ctxScale(x, y) {
    destCtx.scale(x, y);

    this.__originalScale(x, y);
  };

  ctx.transform = function ctxTransform(a, b, c, d, e, f) {
    destCtx.transform(a, b, c, d, e, f);

    this.__originalTransform(a, b, c, d, e, f);
  };

  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
    destCtx.setTransform(a, b, c, d, e, f);

    this.__originalSetTransform(a, b, c, d, e, f);
  };

  ctx.resetTransform = function ctxResetTransform() {
    destCtx.resetTransform();

    this.__originalResetTransform();
  };

  ctx.rotate = function ctxRotate(angle) {
    destCtx.rotate(angle);

    this.__originalRotate(angle);
  };

  ctx.clip = function ctxRotate(rule) {
    destCtx.clip(rule);

    this.__originalClip(rule);
  };

  ctx.moveTo = function (x, y) {
    destCtx.moveTo(x, y);

    this.__originalMoveTo(x, y);
  };

  ctx.lineTo = function (x, y) {
    destCtx.lineTo(x, y);

    this.__originalLineTo(x, y);
  };

  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);

    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  };

  ctx.rect = function (x, y, width, height) {
    destCtx.rect(x, y, width, height);

    this.__originalRect(x, y, width, height);
  };

  ctx.closePath = function () {
    destCtx.closePath();

    this.__originalClosePath();
  };

  ctx.beginPath = function () {
    destCtx.beginPath();

    this.__originalBeginPath();
  };
}

class CachedCanvases {
  constructor(canvasFactory) {
    this.canvasFactory = canvasFactory;
    this.cache = Object.create(null);
  }

  getCanvas(id, width, height) {
    let canvasEntry;

    if (this.cache[id] !== undefined) {
      canvasEntry = this.cache[id];
      this.canvasFactory.reset(canvasEntry, width, height);
    } else {
      canvasEntry = this.canvasFactory.create(width, height);
      this.cache[id] = canvasEntry;
    }

    return canvasEntry;
  }

  delete(id) {
    delete this.cache[id];
  }

  clear() {
    for (const id in this.cache) {
      const canvasEntry = this.cache[id];
      this.canvasFactory.destroy(canvasEntry);
      delete this.cache[id];
    }
  }

}

function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
  const [a, b, c, d, tx, ty] = (0, _display_utils.getCurrentTransform)(ctx);

  if (b === 0 && c === 0) {
    const tlX = destX * a + tx;
    const rTlX = Math.round(tlX);
    const tlY = destY * d + ty;
    const rTlY = Math.round(tlY);
    const brX = (destX + destW) * a + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destY + destH) * d + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
    ctx.setTransform(a, b, c, d, tx, ty);
    return [rWidth, rHeight];
  }

  if (a === 0 && d === 0) {
    const tlX = destY * c + tx;
    const rTlX = Math.round(tlX);
    const tlY = destX * b + ty;
    const rTlY = Math.round(tlY);
    const brX = (destY + destH) * c + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destX + destW) * b + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
    ctx.setTransform(a, b, c, d, tx, ty);
    return [rHeight, rWidth];
  }

  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
  const scaleX = Math.hypot(a, b);
  const scaleY = Math.hypot(c, d);
  return [scaleX * destW, scaleY * destH];
}

function compileType3Glyph(imgData) {
  const {
    width,
    height
  } = imgData;

  if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {
    return null;
  }

  const POINT_TO_PROCESS_LIMIT = 1000;
  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
  const width1 = width + 1;
  let points = new Uint8Array(width1 * (height + 1));
  let i, j, j0;
  const lineSize = width + 7 & ~7;
  let data = new Uint8Array(lineSize * height),
      pos = 0;

  for (const elem of imgData.data) {
    let mask = 128;

    while (mask > 0) {
      data[pos++] = elem & mask ? 0 : 255;
      mask >>= 1;
    }
  }

  let count = 0;
  pos = 0;

  if (data[pos] !== 0) {
    points[0] = 1;
    ++count;
  }

  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j] = data[pos] ? 2 : 1;
      ++count;
    }

    pos++;
  }

  if (data[pos] !== 0) {
    points[j] = 2;
    ++count;
  }

  for (i = 1; i < height; i++) {
    pos = i * lineSize;
    j0 = i * width1;

    if (data[pos - lineSize] !== data[pos]) {
      points[j0] = data[pos] ? 1 : 8;
      ++count;
    }

    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);

    for (j = 1; j < width; j++) {
      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);

      if (POINT_TYPES[sum]) {
        points[j0 + j] = POINT_TYPES[sum];
        ++count;
      }

      pos++;
    }

    if (data[pos - lineSize] !== data[pos]) {
      points[j0 + j] = data[pos] ? 2 : 4;
      ++count;
    }

    if (count > POINT_TO_PROCESS_LIMIT) {
      return null;
    }
  }

  pos = lineSize * (height - 1);
  j0 = i * width1;

  if (data[pos] !== 0) {
    points[j0] = 8;
    ++count;
  }

  for (j = 1; j < width; j++) {
    if (data[pos] !== data[pos + 1]) {
      points[j0 + j] = data[pos] ? 4 : 8;
      ++count;
    }

    pos++;
  }

  if (data[pos] !== 0) {
    points[j0 + j] = 4;
    ++count;
  }

  if (count > POINT_TO_PROCESS_LIMIT) {
    return null;
  }

  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
  const path = new Path2D();

  for (i = 0; count && i <= height; i++) {
    let p = i * width1;
    const end = p + width;

    while (p < end && !points[p]) {
      p++;
    }

    if (p === end) {
      continue;
    }

    path.moveTo(p % width1, i);
    const p0 = p;
    let type = points[p];

    do {
      const step = steps[type];

      do {
        p += step;
      } while (!points[p]);

      const pp = points[p];

      if (pp !== 5 && pp !== 10) {
        type = pp;
        points[p] = 0;
      } else {
        type = pp & 0x33 * type >> 4;
        points[p] &= type >> 2 | type << 2;
      }

      path.lineTo(p % width1, p / width1 | 0);

      if (!points[p]) {
        --count;
      }
    } while (p0 !== p);

    --i;
  }

  data = null;
  points = null;

  const drawOutline = function (c) {
    c.save();
    c.scale(1 / width, -1 / height);
    c.translate(0, -height);
    c.fill(path);
    c.beginPath();
    c.restore();
  };

  return drawOutline;
}

class CanvasExtraState {
  constructor(width, height) {
    this.alphaIsShape = false;
    this.fontSize = 0;
    this.fontSizeScale = 1;
    this.textMatrix = _util.IDENTITY_MATRIX;
    this.textMatrixScale = 1;
    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
    this.leading = 0;
    this.x = 0;
    this.y = 0;
    this.lineX = 0;
    this.lineY = 0;
    this.charSpacing = 0;
    this.wordSpacing = 0;
    this.textHScale = 1;
    this.textRenderingMode = _util.TextRenderingMode.FILL;
    this.textRise = 0;
    this.fillColor = "#000000";
    this.strokeColor = "#000000";
    this.patternFill = false;
    this.fillAlpha = 1;
    this.strokeAlpha = 1;
    this.lineWidth = 1;
    this.activeSMask = null;
    this.transferMaps = null;
    this.startNewPathAndClipBox([0, 0, width, height]);
  }

  clone() {
    const clone = Object.create(this);
    clone.clipBox = this.clipBox.slice();
    return clone;
  }

  setCurrentPoint(x, y) {
    this.x = x;
    this.y = y;
  }

  updatePathMinMax(transform, x, y) {
    [x, y] = _util.Util.applyTransform([x, y], transform);
    this.minX = Math.min(this.minX, x);
    this.minY = Math.min(this.minY, y);
    this.maxX = Math.max(this.maxX, x);
    this.maxY = Math.max(this.maxY, y);
  }

  updateRectMinMax(transform, rect) {
    const p1 = _util.Util.applyTransform(rect, transform);

    const p2 = _util.Util.applyTransform(rect.slice(2), transform);

    this.minX = Math.min(this.minX, p1[0], p2[0]);
    this.minY = Math.min(this.minY, p1[1], p2[1]);
    this.maxX = Math.max(this.maxX, p1[0], p2[0]);
    this.maxY = Math.max(this.maxY, p1[1], p2[1]);
  }

  updateScalingPathMinMax(transform, minMax) {
    _util.Util.scaleMinMax(transform, minMax);

    this.minX = Math.min(this.minX, minMax[0]);
    this.maxX = Math.max(this.maxX, minMax[1]);
    this.minY = Math.min(this.minY, minMax[2]);
    this.maxY = Math.max(this.maxY, minMax[3]);
  }

  updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
    const box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);

    if (minMax) {
      minMax[0] = Math.min(minMax[0], box[0], box[2]);
      minMax[1] = Math.max(minMax[1], box[0], box[2]);
      minMax[2] = Math.min(minMax[2], box[1], box[3]);
      minMax[3] = Math.max(minMax[3], box[1], box[3]);
      return;
    }

    this.updateRectMinMax(transform, box);
  }

  getPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
    const box = [this.minX, this.minY, this.maxX, this.maxY];

    if (pathType === _pattern_helper.PathType.STROKE) {
      if (!transform) {
        (0, _util.unreachable)("Stroke bounding box must include transform.");
      }

      const scale = _util.Util.singularValueDecompose2dScale(transform);

      const xStrokePad = scale[0] * this.lineWidth / 2;
      const yStrokePad = scale[1] * this.lineWidth / 2;
      box[0] -= xStrokePad;
      box[1] -= yStrokePad;
      box[2] += xStrokePad;
      box[3] += yStrokePad;
    }

    return box;
  }

  updateClipFromPath() {
    const intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());

    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
  }

  isEmptyClip() {
    return this.minX === Infinity;
  }

  startNewPathAndClipBox(box) {
    this.clipBox = box;
    this.minX = Infinity;
    this.minY = Infinity;
    this.maxX = 0;
    this.maxY = 0;
  }

  getClippedPathBoundingBox(pathType = _pattern_helper.PathType.FILL, transform = null) {
    return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
  }

}

function putBinaryImageData(ctx, imgData, transferMaps = null) {
  if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
    ctx.putImageData(imgData, 0, 0);
    return;
  }

  const height = imgData.height,
        width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0,
      destPos;
  const src = imgData.data;
  const dest = chunkImgData.data;
  let i, j, thisChunkHeight, elemsInThisChunk;
  let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;

  if (transferMaps) {
    switch (transferMaps.length) {
      case 1:
        transferMapRed = transferMaps[0];
        transferMapGreen = transferMaps[0];
        transferMapBlue = transferMaps[0];
        transferMapGray = transferMaps[0];
        break;

      case 4:
        transferMapRed = transferMaps[0];
        transferMapGreen = transferMaps[1];
        transferMapBlue = transferMaps[2];
        transferMapGray = transferMaps[3];
        break;
    }
  }

  if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
    const srcLength = src.byteLength;
    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
    const dest32DataLength = dest32.length;
    const fullSrcDiff = width + 7 >> 3;
    let white = 0xffffffff;
    let black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;

    if (transferMapGray) {
      if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {
        [white, black] = [black, white];
      }
    }

    for (i = 0; i < totalChunks; i++) {
      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
      destPos = 0;

      for (j = 0; j < thisChunkHeight; j++) {
        const srcDiff = srcLength - srcPos;
        let k = 0;
        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
        const kEndUnrolled = kEnd & ~7;
        let mask = 0;
        let srcByte = 0;

        for (; k < kEndUnrolled; k += 8) {
          srcByte = src[srcPos++];
          dest32[destPos++] = srcByte & 128 ? white : black;
          dest32[destPos++] = srcByte & 64 ? white : black;
          dest32[destPos++] = srcByte & 32 ? white : black;
          dest32[destPos++] = srcByte & 16 ? white : black;
          dest32[destPos++] = srcByte & 8 ? white : black;
          dest32[destPos++] = srcByte & 4 ? white : black;
          dest32[destPos++] = srcByte & 2 ? white : black;
          dest32[destPos++] = srcByte & 1 ? white : black;
        }

        for (; k < kEnd; k++) {
          if (mask === 0) {
            srcByte = src[srcPos++];
            mask = 128;
          }

          dest32[destPos++] = srcByte & mask ? white : black;
          mask >>= 1;
        }
      }

      while (destPos < dest32DataLength) {
        dest32[destPos++] = 0;
      }

      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
    j = 0;
    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;

    for (i = 0; i < fullChunks; i++) {
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      srcPos += elemsInThisChunk;

      if (hasTransferMaps) {
        for (let k = 0; k < elemsInThisChunk; k += 4) {
          if (transferMapRed) {
            dest[k + 0] = transferMapRed[dest[k + 0]];
          }

          if (transferMapGreen) {
            dest[k + 1] = transferMapGreen[dest[k + 1]];
          }

          if (transferMapBlue) {
            dest[k + 2] = transferMapBlue[dest[k + 2]];
          }
        }
      }

      ctx.putImageData(chunkImgData, 0, j);
      j += FULL_CHUNK_HEIGHT;
    }

    if (i < totalChunks) {
      elemsInThisChunk = width * partialChunkHeight * 4;
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));

      if (hasTransferMaps) {
        for (let k = 0; k < elemsInThisChunk; k += 4) {
          if (transferMapRed) {
            dest[k + 0] = transferMapRed[dest[k + 0]];
          }

          if (transferMapGreen) {
            dest[k + 1] = transferMapGreen[dest[k + 1]];
          }

          if (transferMapBlue) {
            dest[k + 2] = transferMapBlue[dest[k + 2]];
          }
        }
      }

      ctx.putImageData(chunkImgData, 0, j);
    }
  } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
    const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
    thisChunkHeight = FULL_CHUNK_HEIGHT;
    elemsInThisChunk = width * thisChunkHeight;

    for (i = 0; i < totalChunks; i++) {
      if (i >= fullChunks) {
        thisChunkHeight = partialChunkHeight;
        elemsInThisChunk = width * thisChunkHeight;
      }

      destPos = 0;

      for (j = elemsInThisChunk; j--;) {
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = 255;
      }

      if (hasTransferMaps) {
        for (let k = 0; k < destPos; k += 4) {
          if (transferMapRed) {
            dest[k + 0] = transferMapRed[dest[k + 0]];
          }

          if (transferMapGreen) {
            dest[k + 1] = transferMapGreen[dest[k + 1]];
          }

          if (transferMapBlue) {
            dest[k + 2] = transferMapBlue[dest[k + 2]];
          }
        }
      }

      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else {
    throw new Error(`bad image kind: ${imgData.kind}`);
  }
}

function putBinaryImageMask(ctx, imgData) {
  if (imgData.bitmap) {
    ctx.drawImage(imgData.bitmap, 0, 0);
    return;
  }

  const height = imgData.height,
        width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0;
  const src = imgData.data;
  const dest = chunkImgData.data;

  for (let i = 0; i < totalChunks; i++) {
    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
    ({
      srcPos
    } = (0, _image_utils.applyMaskImageData)({
      src,
      srcPos,
      dest,
      width,
      height: thisChunkHeight
    }));
    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
  }
}

function copyCtxState(sourceCtx, destCtx) {
  const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];

  for (let i = 0, ii = properties.length; i < ii; i++) {
    const property = properties[i];

    if (sourceCtx[property] !== undefined) {
      destCtx[property] = sourceCtx[property];
    }
  }

  if (sourceCtx.setLineDash !== undefined) {
    destCtx.setLineDash(sourceCtx.getLineDash());
    destCtx.lineDashOffset = sourceCtx.lineDashOffset;
  }
}

function resetCtxToDefault(ctx, foregroundColor) {
  ctx.strokeStyle = ctx.fillStyle = foregroundColor || "#000000";
  ctx.fillRule = "nonzero";
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;
  ctx.lineCap = "butt";
  ctx.lineJoin = "miter";
  ctx.miterLimit = 10;
  ctx.globalCompositeOperation = "source-over";
  ctx.font = "10px sans-serif";

  if (ctx.setLineDash !== undefined) {
    ctx.setLineDash([]);
    ctx.lineDashOffset = 0;
  }
}

function composeSMaskBackdrop(bytes, r0, g0, b0) {
  const length = bytes.length;

  for (let i = 3; i < length; i += 4) {
    const alpha = bytes[i];

    if (alpha === 0) {
      bytes[i - 3] = r0;
      bytes[i - 2] = g0;
      bytes[i - 1] = b0;
    } else if (alpha < 255) {
      const alpha_ = 255 - alpha;
      bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
      bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
      bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
    }
  }
}

function composeSMaskAlpha(maskData, layerData, transferMap) {
  const length = maskData.length;
  const scale = 1 / 255;

  for (let i = 3; i < length; i += 4) {
    const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
    layerData[i] = layerData[i] * alpha * scale | 0;
  }
}

function composeSMaskLuminosity(maskData, layerData, transferMap) {
  const length = maskData.length;

  for (let i = 3; i < length; i += 4) {
    const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
    layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
  }
}

function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
  const hasBackdrop = !!backdrop;
  const r0 = hasBackdrop ? backdrop[0] : 0;
  const g0 = hasBackdrop ? backdrop[1] : 0;
  const b0 = hasBackdrop ? backdrop[2] : 0;
  let composeFn;

  if (subtype === "Luminosity") {
    composeFn = composeSMaskLuminosity;
  } else {
    composeFn = composeSMaskAlpha;
  }

  const PIXELS_TO_PROCESS = 1048576;
  const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));

  for (let row = 0; row < height; row += chunkSize) {
    const chunkHeight = Math.min(chunkSize, height - row);
    const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);
    const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);

    if (hasBackdrop) {
      composeSMaskBackdrop(maskData.data, r0, g0, b0);
    }

    composeFn(maskData.data, layerData.data, transferMap);
    layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);
  }
}

function composeSMask(ctx, smask, layerCtx, layerBox) {
  const layerOffsetX = layerBox[0];
  const layerOffsetY = layerBox[1];
  const layerWidth = layerBox[2] - layerOffsetX;
  const layerHeight = layerBox[3] - layerOffsetY;

  if (layerWidth === 0 || layerHeight === 0) {
    return;
  }

  genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
  ctx.save();
  ctx.globalAlpha = 1;
  ctx.globalCompositeOperation = "source-over";
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.drawImage(layerCtx.canvas, 0, 0);
  ctx.restore();
}

function getImageSmoothingEnabled(transform, interpolate) {
  const scale = _util.Util.singularValueDecompose2dScale(transform);

  scale[0] = Math.fround(scale[0]);
  scale[1] = Math.fround(scale[1]);
  const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);

  if (interpolate !== undefined) {
    return interpolate;
  } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
    return true;
  }

  return false;
}

const LINE_CAP_STYLES = ["butt", "round", "square"];
const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
const NORMAL_CLIP = {};
const EO_CLIP = {};

class CanvasGraphics {
  constructor(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig, annotationCanvasMap, pageColors) {
    this.ctx = canvasCtx;
    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.stateStack = [];
    this.pendingClip = null;
    this.pendingEOFill = false;
    this.res = null;
    this.xobjs = null;
    this.commonObjs = commonObjs;
    this.objs = objs;
    this.canvasFactory = canvasFactory;
    this.imageLayer = imageLayer;
    this.groupStack = [];
    this.processingType3 = null;
    this.baseTransform = null;
    this.baseTransformStack = [];
    this.groupLevel = 0;
    this.smaskStack = [];
    this.smaskCounter = 0;
    this.tempSMask = null;
    this.suspendedCtx = null;
    this.contentVisible = true;
    this.markedContentStack = [];
    this.optionalContentConfig = optionalContentConfig;
    this.cachedCanvases = new CachedCanvases(this.canvasFactory);
    this.cachedPatterns = new Map();
    this.annotationCanvasMap = annotationCanvasMap;
    this.viewportScale = 1;
    this.outputScaleX = 1;
    this.outputScaleY = 1;
    this.backgroundColor = pageColors?.background || null;
    this.foregroundColor = pageColors?.foreground || null;
    this._cachedScaleForStroking = null;
    this._cachedGetSinglePixelWidth = null;
    this._cachedBitmapsMap = new Map();
  }

  getObject(data, fallback = null) {
    if (typeof data === "string") {
      return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
    }

    return fallback;
  }

  beginDrawing({
    transform,
    viewport,
    transparency = false,
    background = null
  }) {
    const width = this.ctx.canvas.width;
    const height = this.ctx.canvas.height;
    const defaultBackgroundColor = background || "#ffffff";
    this.ctx.save();

    if (this.foregroundColor && this.backgroundColor) {
      this.ctx.fillStyle = this.foregroundColor;
      const fg = this.foregroundColor = this.ctx.fillStyle;
      this.ctx.fillStyle = this.backgroundColor;
      const bg = this.backgroundColor = this.ctx.fillStyle;
      let isValidDefaultBg = true;
      let defaultBg = defaultBackgroundColor;
      this.ctx.fillStyle = defaultBackgroundColor;
      defaultBg = this.ctx.fillStyle;
      isValidDefaultBg = typeof defaultBg === "string" && /^#[0-9A-Fa-f]{6}$/.test(defaultBg);

      if (fg === "#000000" && bg === "#ffffff" || fg === bg || !isValidDefaultBg) {
        this.foregroundColor = this.backgroundColor = null;
      } else {
        const [rB, gB, bB] = (0, _display_utils.getRGB)(defaultBg);

        const newComp = x => {
          x /= 255;
          return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
        };

        const lumB = Math.round(0.2126 * newComp(rB) + 0.7152 * newComp(gB) + 0.0722 * newComp(bB));

        this.selectColor = (r, g, b) => {
          const lumC = 0.2126 * newComp(r) + 0.7152 * newComp(g) + 0.0722 * newComp(b);
          return Math.round(lumC) === lumB ? bg : fg;
        };
      }
    }

    this.ctx.fillStyle = this.backgroundColor || defaultBackgroundColor;
    this.ctx.fillRect(0, 0, width, height);
    this.ctx.restore();

    if (transparency) {
      const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
      this.compositeCtx = this.ctx;
      this.transparentCanvas = transparentCanvas.canvas;
      this.ctx = transparentCanvas.context;
      this.ctx.save();
      this.ctx.transform(...(0, _display_utils.getCurrentTransform)(this.compositeCtx));
    }

    this.ctx.save();
    resetCtxToDefault(this.ctx, this.foregroundColor);

    if (transform) {
      this.ctx.transform(...transform);
      this.outputScaleX = transform[0];
      this.outputScaleY = transform[0];
    }

    this.ctx.transform(...viewport.transform);
    this.viewportScale = viewport.scale;
    this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);

    if (this.imageLayer) {
      (0, _display_utils.deprecated)("The `imageLayer` functionality will be removed in the future.");
      this.imageLayer.beginLayout();
    }
  }

  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
    const argsArray = operatorList.argsArray;
    const fnArray = operatorList.fnArray;
    let i = executionStartIdx || 0;
    const argsArrayLen = argsArray.length;

    if (argsArrayLen === i) {
      return i;
    }

    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
    let steps = 0;
    const commonObjs = this.commonObjs;
    const objs = this.objs;
    let fnId;

    while (true) {
      if (stepper !== undefined && i === stepper.nextBreakPoint) {
        stepper.breakIt(i, continueCallback);
        return i;
      }

      fnId = fnArray[i];

      if (fnId !== _util.OPS.dependency) {
        this[fnId].apply(this, argsArray[i]);
      } else {
        for (const depObjId of argsArray[i]) {
          const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;

          if (!objsPool.has(depObjId)) {
            objsPool.get(depObjId, continueCallback);
            return i;
          }
        }
      }

      i++;

      if (i === argsArrayLen) {
        return i;
      }

      if (chunkOperations && ++steps > EXECUTION_STEPS) {
        if (Date.now() > endTime) {
          continueCallback();
          return i;
        }

        steps = 0;
      }
    }
  }

  #restoreInitialState() {
    while (this.stateStack.length || this.inSMaskMode) {
      this.restore();
    }

    this.ctx.restore();

    if (this.transparentCanvas) {
      this.ctx = this.compositeCtx;
      this.ctx.save();
      this.ctx.setTransform(1, 0, 0, 1, 0, 0);
      this.ctx.drawImage(this.transparentCanvas, 0, 0);
      this.ctx.restore();
      this.transparentCanvas = null;
    }
  }

  endDrawing() {
    this.#restoreInitialState();
    this.cachedCanvases.clear();
    this.cachedPatterns.clear();

    for (const cache of this._cachedBitmapsMap.values()) {
      for (const canvas of cache.values()) {
        if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
          canvas.width = canvas.height = 0;
        }
      }

      cache.clear();
    }

    this._cachedBitmapsMap.clear();

    if (this.imageLayer) {
      this.imageLayer.endLayout();
    }
  }

  _scaleImage(img, inverseTransform) {
    const width = img.width;
    const height = img.height;
    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
    let paintWidth = width,
        paintHeight = height;
    let tmpCanvasId = "prescale1";
    let tmpCanvas, tmpCtx;

    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
      let newWidth = paintWidth,
          newHeight = paintHeight;

      if (widthScale > 2 && paintWidth > 1) {
        newWidth = Math.ceil(paintWidth / 2);
        widthScale /= paintWidth / newWidth;
      }

      if (heightScale > 2 && paintHeight > 1) {
        newHeight = Math.ceil(paintHeight / 2);
        heightScale /= paintHeight / newHeight;
      }

      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
      tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, newWidth, newHeight);
      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
      img = tmpCanvas.canvas;
      paintWidth = newWidth;
      paintHeight = newHeight;
      tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
    }

    return {
      img,
      paintWidth,
      paintHeight
    };
  }

  _createMaskCanvas(img) {
    const ctx = this.ctx;
    const {
      width,
      height
    } = img;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);
    let cache, cacheKey, scaled, maskCanvas;

    if ((img.bitmap || img.data) && img.count > 1) {
      const mainKey = img.bitmap || img.data.buffer;
      const withoutTranslation = currentTransform.slice(0, 4);
      cacheKey = JSON.stringify(isPatternFill ? withoutTranslation : [withoutTranslation, fillColor]);
      cache = this._cachedBitmapsMap.get(mainKey);

      if (!cache) {
        cache = new Map();

        this._cachedBitmapsMap.set(mainKey, cache);
      }

      const cachedImage = cache.get(cacheKey);

      if (cachedImage && !isPatternFill) {
        const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
        const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
        return {
          canvas: cachedImage,
          offsetX,
          offsetY
        };
      }

      scaled = cachedImage;
    }

    if (!scaled) {
      maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      putBinaryImageMask(maskCanvas.context, img);
    }

    let maskToCanvas = _util.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);

    maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);

    const cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);

    const cord2 = _util.Util.applyTransform([width, height], maskToCanvas);

    const rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);

    const drawnWidth = Math.round(rect[2] - rect[0]) || 1;
    const drawnHeight = Math.round(rect[3] - rect[1]) || 1;
    const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
    const fillCtx = fillCanvas.context;
    const offsetX = Math.min(cord1[0], cord2[0]);
    const offsetY = Math.min(cord1[1], cord2[1]);
    fillCtx.translate(-offsetX, -offsetY);
    fillCtx.transform(...maskToCanvas);

    if (!scaled) {
      scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils.getCurrentTransformInverse)(fillCtx));
      scaled = scaled.img;

      if (cache && isPatternFill) {
        cache.set(cacheKey, scaled);
      }
    }

    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(fillCtx), img.interpolate);
    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
    fillCtx.globalCompositeOperation = "source-in";

    const inverse = _util.Util.transform((0, _display_utils.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);

    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;
    fillCtx.fillRect(0, 0, width, height);

    if (cache && !isPatternFill) {
      this.cachedCanvases.delete("fillCanvas");
      cache.set(cacheKey, fillCanvas.canvas);
    }

    return {
      canvas: fillCanvas.canvas,
      offsetX: Math.round(offsetX),
      offsetY: Math.round(offsetY)
    };
  }

  setLineWidth(width) {
    if (width !== this.current.lineWidth) {
      this._cachedScaleForStroking = null;
    }

    this.current.lineWidth = width;
    this.ctx.lineWidth = width;
  }

  setLineCap(style) {
    this.ctx.lineCap = LINE_CAP_STYLES[style];
  }

  setLineJoin(style) {
    this.ctx.lineJoin = LINE_JOIN_STYLES[style];
  }

  setMiterLimit(limit) {
    this.ctx.miterLimit = limit;
  }

  setDash(dashArray, dashPhase) {
    const ctx = this.ctx;

    if (ctx.setLineDash !== undefined) {
      ctx.setLineDash(dashArray);
      ctx.lineDashOffset = dashPhase;
    }
  }

  setRenderingIntent(intent) {}

  setFlatness(flatness) {}

  setGState(states) {
    for (let i = 0, ii = states.length; i < ii; i++) {
      const state = states[i];
      const key = state[0];
      const value = state[1];

      switch (key) {
        case "LW":
          this.setLineWidth(value);
          break;

        case "LC":
          this.setLineCap(value);
          break;

        case "LJ":
          this.setLineJoin(value);
          break;

        case "ML":
          this.setMiterLimit(value);
          break;

        case "D":
          this.setDash(value[0], value[1]);
          break;

        case "RI":
          this.setRenderingIntent(value);
          break;

        case "FL":
          this.setFlatness(value);
          break;

        case "Font":
          this.setFont(value[0], value[1]);
          break;

        case "CA":
          this.current.strokeAlpha = state[1];
          break;

        case "ca":
          this.current.fillAlpha = state[1];
          this.ctx.globalAlpha = state[1];
          break;

        case "BM":
          this.ctx.globalCompositeOperation = value;
          break;

        case "SMask":
          this.current.activeSMask = value ? this.tempSMask : null;
          this.tempSMask = null;
          this.checkSMaskState();
          break;

        case "TR":
          this.current.transferMaps = value;
      }
    }
  }

  get inSMaskMode() {
    return !!this.suspendedCtx;
  }

  checkSMaskState() {
    const inSMaskMode = this.inSMaskMode;

    if (this.current.activeSMask && !inSMaskMode) {
      this.beginSMaskMode();
    } else if (!this.current.activeSMask && inSMaskMode) {
      this.endSMaskMode();
    }
  }

  beginSMaskMode() {
    if (this.inSMaskMode) {
      throw new Error("beginSMaskMode called while already in smask mode");
    }

    const drawnWidth = this.ctx.canvas.width;
    const drawnHeight = this.ctx.canvas.height;
    const cacheId = "smaskGroupAt" + this.groupLevel;
    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    this.suspendedCtx = this.ctx;
    this.ctx = scratchCanvas.context;
    const ctx = this.ctx;
    ctx.setTransform(...(0, _display_utils.getCurrentTransform)(this.suspendedCtx));
    copyCtxState(this.suspendedCtx, ctx);
    mirrorContextOperations(ctx, this.suspendedCtx);
    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
  }

  endSMaskMode() {
    if (!this.inSMaskMode) {
      throw new Error("endSMaskMode called while not in smask mode");
    }

    this.ctx._removeMirroring();

    copyCtxState(this.ctx, this.suspendedCtx);
    this.ctx = this.suspendedCtx;
    this.suspendedCtx = null;
  }

  compose(dirtyBox) {
    if (!this.current.activeSMask) {
      return;
    }

    if (!dirtyBox) {
      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
    } else {
      dirtyBox[0] = Math.floor(dirtyBox[0]);
      dirtyBox[1] = Math.floor(dirtyBox[1]);
      dirtyBox[2] = Math.ceil(dirtyBox[2]);
      dirtyBox[3] = Math.ceil(dirtyBox[3]);
    }

    const smask = this.current.activeSMask;
    const suspendedCtx = this.suspendedCtx;
    composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
    this.ctx.save();
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
    this.ctx.restore();
  }

  save() {
    if (this.inSMaskMode) {
      copyCtxState(this.ctx, this.suspendedCtx);
      this.suspendedCtx.save();
    } else {
      this.ctx.save();
    }

    const old = this.current;
    this.stateStack.push(old);
    this.current = old.clone();
  }

  restore() {
    if (this.stateStack.length === 0 && this.inSMaskMode) {
      this.endSMaskMode();
    }

    if (this.stateStack.length !== 0) {
      this.current = this.stateStack.pop();

      if (this.inSMaskMode) {
        this.suspendedCtx.restore();
        copyCtxState(this.suspendedCtx, this.ctx);
      } else {
        this.ctx.restore();
      }

      this.checkSMaskState();
      this.pendingClip = null;
      this._cachedScaleForStroking = null;
      this._cachedGetSinglePixelWidth = null;
    }
  }

  transform(a, b, c, d, e, f) {
    this.ctx.transform(a, b, c, d, e, f);
    this._cachedScaleForStroking = null;
    this._cachedGetSinglePixelWidth = null;
  }

  constructPath(ops, args, minMax) {
    const ctx = this.ctx;
    const current = this.current;
    let x = current.x,
        y = current.y;
    let startX, startY;
    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);
    const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;
    const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;

    for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {
      switch (ops[i] | 0) {
        case _util.OPS.rectangle:
          x = args[j++];
          y = args[j++];
          const width = args[j++];
          const height = args[j++];
          const xw = x + width;
          const yh = y + height;
          ctx.moveTo(x, y);

          if (width === 0 || height === 0) {
            ctx.lineTo(xw, yh);
          } else {
            ctx.lineTo(xw, y);
            ctx.lineTo(xw, yh);
            ctx.lineTo(x, yh);
          }

          if (!isScalingMatrix) {
            current.updateRectMinMax(currentTransform, [x, y, xw, yh]);
          }

          ctx.closePath();
          break;

        case _util.OPS.moveTo:
          x = args[j++];
          y = args[j++];
          ctx.moveTo(x, y);

          if (!isScalingMatrix) {
            current.updatePathMinMax(currentTransform, x, y);
          }

          break;

        case _util.OPS.lineTo:
          x = args[j++];
          y = args[j++];
          ctx.lineTo(x, y);

          if (!isScalingMatrix) {
            current.updatePathMinMax(currentTransform, x, y);
          }

          break;

        case _util.OPS.curveTo:
          startX = x;
          startY = y;
          x = args[j + 4];
          y = args[j + 5];
          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);
          j += 6;
          break;

        case _util.OPS.curveTo2:
          startX = x;
          startY = y;
          ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
          current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);
          x = args[j + 2];
          y = args[j + 3];
          j += 4;
          break;

        case _util.OPS.curveTo3:
          startX = x;
          startY = y;
          x = args[j + 2];
          y = args[j + 3];
          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);
          j += 4;
          break;

        case _util.OPS.closePath:
          ctx.closePath();
          break;
      }
    }

    if (isScalingMatrix) {
      current.updateScalingPathMinMax(currentTransform, minMaxForBezier);
    }

    current.setCurrentPoint(x, y);
  }

  closePath() {
    this.ctx.closePath();
  }

  stroke(consumePath) {
    consumePath = typeof consumePath !== "undefined" ? consumePath : true;
    const ctx = this.ctx;
    const strokeColor = this.current.strokeColor;
    ctx.globalAlpha = this.current.strokeAlpha;

    if (this.contentVisible) {
      if (typeof strokeColor === "object" && strokeColor?.getPattern) {
        ctx.save();
        ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);
        this.rescaleAndStroke(false);
        ctx.restore();
      } else {
        this.rescaleAndStroke(true);
      }
    }

    if (consumePath) {
      this.consumePath(this.current.getClippedPathBoundingBox());
    }

    ctx.globalAlpha = this.current.fillAlpha;
  }

  closeStroke() {
    this.closePath();
    this.stroke();
  }

  fill(consumePath) {
    consumePath = typeof consumePath !== "undefined" ? consumePath : true;
    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;
    let needRestore = false;

    if (isPatternFill) {
      ctx.save();
      ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
      needRestore = true;
    }

    const intersect = this.current.getClippedPathBoundingBox();

    if (this.contentVisible && intersect !== null) {
      if (this.pendingEOFill) {
        ctx.fill("evenodd");
        this.pendingEOFill = false;
      } else {
        ctx.fill();
      }
    }

    if (needRestore) {
      ctx.restore();
    }

    if (consumePath) {
      this.consumePath(intersect);
    }
  }

  eoFill() {
    this.pendingEOFill = true;
    this.fill();
  }

  fillStroke() {
    this.fill(false);
    this.stroke(false);
    this.consumePath();
  }

  eoFillStroke() {
    this.pendingEOFill = true;
    this.fillStroke();
  }

  closeFillStroke() {
    this.closePath();
    this.fillStroke();
  }

  closeEOFillStroke() {
    this.pendingEOFill = true;
    this.closePath();
    this.fillStroke();
  }

  endPath() {
    this.consumePath();
  }

  clip() {
    this.pendingClip = NORMAL_CLIP;
  }

  eoClip() {
    this.pendingClip = EO_CLIP;
  }

  beginText() {
    this.current.textMatrix = _util.IDENTITY_MATRIX;
    this.current.textMatrixScale = 1;
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
  }

  endText() {
    const paths = this.pendingTextPaths;
    const ctx = this.ctx;

    if (paths === undefined) {
      ctx.beginPath();
      return;
    }

    ctx.save();
    ctx.beginPath();

    for (const path of paths) {
      ctx.setTransform(...path.transform);
      ctx.translate(path.x, path.y);
      path.addToPath(ctx, path.fontSize);
    }

    ctx.restore();
    ctx.clip();
    ctx.beginPath();
    delete this.pendingTextPaths;
  }

  setCharSpacing(spacing) {
    this.current.charSpacing = spacing;
  }

  setWordSpacing(spacing) {
    this.current.wordSpacing = spacing;
  }

  setHScale(scale) {
    this.current.textHScale = scale / 100;
  }

  setLeading(leading) {
    this.current.leading = -leading;
  }

  setFont(fontRefName, size) {
    const fontObj = this.commonObjs.get(fontRefName);
    const current = this.current;

    if (!fontObj) {
      throw new Error(`Can't find font for ${fontRefName}`);
    }

    current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;

    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
      (0, _util.warn)("Invalid font matrix for font " + fontRefName);
    }

    if (size < 0) {
      size = -size;
      current.fontDirection = -1;
    } else {
      current.fontDirection = 1;
    }

    this.current.font = fontObj;
    this.current.fontSize = size;

    if (fontObj.isType3Font) {
      return;
    }

    const name = fontObj.loadedName || "sans-serif";
    let bold = "normal";

    if (fontObj.black) {
      bold = "900";
    } else if (fontObj.bold) {
      bold = "bold";
    }

    const italic = fontObj.italic ? "italic" : "normal";
    const typeface = `"${name}", ${fontObj.fallbackName}`;
    let browserFontSize = size;

    if (size < MIN_FONT_SIZE) {
      browserFontSize = MIN_FONT_SIZE;
    } else if (size > MAX_FONT_SIZE) {
      browserFontSize = MAX_FONT_SIZE;
    }

    this.current.fontSizeScale = size / browserFontSize;
    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
  }

  setTextRenderingMode(mode) {
    this.current.textRenderingMode = mode;
  }

  setTextRise(rise) {
    this.current.textRise = rise;
  }

  moveText(x, y) {
    this.current.x = this.current.lineX += x;
    this.current.y = this.current.lineY += y;
  }

  setLeadingMoveText(x, y) {
    this.setLeading(-y);
    this.moveText(x, y);
  }

  setTextMatrix(a, b, c, d, e, f) {
    this.current.textMatrix = [a, b, c, d, e, f];
    this.current.textMatrixScale = Math.hypot(a, b);
    this.current.x = this.current.lineX = 0;
    this.current.y = this.current.lineY = 0;
  }

  nextLine() {
    this.moveText(0, this.current.leading);
  }

  paintChar(character, x, y, patternTransform) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const textRenderingMode = current.textRenderingMode;
    const fontSize = current.fontSize / current.fontSizeScale;
    const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
    const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
    const patternFill = current.patternFill && !font.missingFile;
    let addToPath;

    if (font.disableFontFace || isAddToPathSet || patternFill) {
      addToPath = font.getPathGenerator(this.commonObjs, character);
    }

    if (font.disableFontFace || patternFill) {
      ctx.save();
      ctx.translate(x, y);
      ctx.beginPath();
      addToPath(ctx, fontSize);

      if (patternTransform) {
        ctx.setTransform(...patternTransform);
      }

      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        ctx.fill();
      }

      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        ctx.stroke();
      }

      ctx.restore();
    } else {
      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        ctx.fillText(character, x, y);
      }

      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        ctx.strokeText(character, x, y);
      }
    }

    if (isAddToPathSet) {
      const paths = this.pendingTextPaths || (this.pendingTextPaths = []);
      paths.push({
        transform: (0, _display_utils.getCurrentTransform)(ctx),
        x,
        y,
        fontSize,
        addToPath
      });
    }
  }

  get isFontSubpixelAAEnabled() {
    const {
      context: ctx
    } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
    ctx.scale(1.5, 1);
    ctx.fillText("I", 0, 10);
    const data = ctx.getImageData(0, 0, 10, 10).data;
    let enabled = false;

    for (let i = 3; i < data.length; i += 4) {
      if (data[i] > 0 && data[i] < 255) {
        enabled = true;
        break;
      }
    }

    return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled);
  }

  showText(glyphs) {
    const current = this.current;
    const font = current.font;

    if (font.isType3Font) {
      return this.showType3Text(glyphs);
    }

    const fontSize = current.fontSize;

    if (fontSize === 0) {
      return undefined;
    }

    const ctx = this.ctx;
    const fontSizeScale = current.fontSizeScale;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const fontDirection = current.fontDirection;
    const textHScale = current.textHScale * fontDirection;
    const glyphsLength = glyphs.length;
    const vertical = font.vertical;
    const spacingDir = vertical ? 1 : -1;
    const defaultVMetrics = font.defaultVMetrics;
    const widthAdvanceScale = fontSize * current.fontMatrix[0];
    const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
    ctx.save();
    ctx.transform(...current.textMatrix);
    ctx.translate(current.x, current.y + current.textRise);

    if (fontDirection > 0) {
      ctx.scale(textHScale, -1);
    } else {
      ctx.scale(textHScale, 1);
    }

    let patternTransform;

    if (current.patternFill) {
      ctx.save();
      const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);
      patternTransform = (0, _display_utils.getCurrentTransform)(ctx);
      ctx.restore();
      ctx.fillStyle = pattern;
    }

    let lineWidth = current.lineWidth;
    const scale = current.textMatrixScale;

    if (scale === 0 || lineWidth === 0) {
      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        lineWidth = this.getSinglePixelWidth();
      }
    } else {
      lineWidth /= scale;
    }

    if (fontSizeScale !== 1.0) {
      ctx.scale(fontSizeScale, fontSizeScale);
      lineWidth /= fontSizeScale;
    }

    ctx.lineWidth = lineWidth;
    let x = 0,
        i;

    for (i = 0; i < glyphsLength; ++i) {
      const glyph = glyphs[i];

      if (typeof glyph === "number") {
        x += spacingDir * glyph * fontSize / 1000;
        continue;
      }

      let restoreNeeded = false;
      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const character = glyph.fontChar;
      const accent = glyph.accent;
      let scaledX, scaledY;
      let width = glyph.width;

      if (vertical) {
        const vmetric = glyph.vmetric || defaultVMetrics;
        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
        const vy = vmetric[2] * widthAdvanceScale;
        width = vmetric ? -vmetric[0] : width;
        scaledX = vx / fontSizeScale;
        scaledY = (x + vy) / fontSizeScale;
      } else {
        scaledX = x / fontSizeScale;
        scaledY = 0;
      }

      if (font.remeasure && width > 0) {
        const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;

        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
          const characterScaleX = width / measuredWidth;
          restoreNeeded = true;
          ctx.save();
          ctx.scale(characterScaleX, 1);
          scaledX /= characterScaleX;
        } else if (width !== measuredWidth) {
          scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
        }
      }

      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
        if (simpleFillText && !accent) {
          ctx.fillText(character, scaledX, scaledY);
        } else {
          this.paintChar(character, scaledX, scaledY, patternTransform);

          if (accent) {
            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);
          }
        }
      }

      let charWidth;

      if (vertical) {
        charWidth = width * widthAdvanceScale - spacing * fontDirection;
      } else {
        charWidth = width * widthAdvanceScale + spacing * fontDirection;
      }

      x += charWidth;

      if (restoreNeeded) {
        ctx.restore();
      }
    }

    if (vertical) {
      current.y -= x;
    } else {
      current.x += x * textHScale;
    }

    ctx.restore();
    this.compose();
    return undefined;
  }

  showType3Text(glyphs) {
    const ctx = this.ctx;
    const current = this.current;
    const font = current.font;
    const fontSize = current.fontSize;
    const fontDirection = current.fontDirection;
    const spacingDir = font.vertical ? 1 : -1;
    const charSpacing = current.charSpacing;
    const wordSpacing = current.wordSpacing;
    const textHScale = current.textHScale * fontDirection;
    const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
    const glyphsLength = glyphs.length;
    const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
    let i, glyph, width, spacingLength;

    if (isTextInvisible || fontSize === 0) {
      return;
    }

    this._cachedScaleForStroking = null;
    this._cachedGetSinglePixelWidth = null;
    ctx.save();
    ctx.transform(...current.textMatrix);
    ctx.translate(current.x, current.y);
    ctx.scale(textHScale, fontDirection);

    for (i = 0; i < glyphsLength; ++i) {
      glyph = glyphs[i];

      if (typeof glyph === "number") {
        spacingLength = spacingDir * glyph * fontSize / 1000;
        this.ctx.translate(spacingLength, 0);
        current.x += spacingLength * textHScale;
        continue;
      }

      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
      const operatorList = font.charProcOperatorList[glyph.operatorListId];

      if (!operatorList) {
        (0, _util.warn)(`Type3 character "${glyph.operatorListId}" is not available.`);
        continue;
      }

      if (this.contentVisible) {
        this.processingType3 = glyph;
        this.save();
        ctx.scale(fontSize, fontSize);
        ctx.transform(...fontMatrix);
        this.executeOperatorList(operatorList);
        this.restore();
      }

      const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);

      width = transformed[0] * fontSize + spacing;
      ctx.translate(width, 0);
      current.x += width * textHScale;
    }

    ctx.restore();
    this.processingType3 = null;
  }

  setCharWidth(xWidth, yWidth) {}

  setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
    this.ctx.rect(llx, lly, urx - llx, ury - lly);
    this.ctx.clip();
    this.endPath();
  }

  getColorN_Pattern(IR) {
    let pattern;

    if (IR[0] === "TilingPattern") {
      const color = IR[1];
      const baseTransform = this.baseTransform || (0, _display_utils.getCurrentTransform)(this.ctx);
      const canvasGraphicsFactory = {
        createCanvasGraphics: ctx => {
          return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory);
        }
      };
      pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
    } else {
      pattern = this._getPattern(IR[1], IR[2]);
    }

    return pattern;
  }

  setStrokeColorN() {
    this.current.strokeColor = this.getColorN_Pattern(arguments);
  }

  setFillColorN() {
    this.current.fillColor = this.getColorN_Pattern(arguments);
    this.current.patternFill = true;
  }

  setStrokeRGBColor(r, g, b) {
    const color = this.selectColor?.(r, g, b) || _util.Util.makeHexColor(r, g, b);

    this.ctx.strokeStyle = color;
    this.current.strokeColor = color;
  }

  setFillRGBColor(r, g, b) {
    const color = this.selectColor?.(r, g, b) || _util.Util.makeHexColor(r, g, b);

    this.ctx.fillStyle = color;
    this.current.fillColor = color;
    this.current.patternFill = false;
  }

  _getPattern(objId, matrix = null) {
    let pattern;

    if (this.cachedPatterns.has(objId)) {
      pattern = this.cachedPatterns.get(objId);
    } else {
      pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId));
      this.cachedPatterns.set(objId, pattern);
    }

    if (matrix) {
      pattern.matrix = matrix;
    }

    return pattern;
  }

  shadingFill(objId) {
    if (!this.contentVisible) {
      return;
    }

    const ctx = this.ctx;
    this.save();

    const pattern = this._getPattern(objId);

    ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);
    const inv = (0, _display_utils.getCurrentTransformInverse)(ctx);

    if (inv) {
      const canvas = ctx.canvas;
      const width = canvas.width;
      const height = canvas.height;

      const bl = _util.Util.applyTransform([0, 0], inv);

      const br = _util.Util.applyTransform([0, height], inv);

      const ul = _util.Util.applyTransform([width, 0], inv);

      const ur = _util.Util.applyTransform([width, height], inv);

      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
    } else {
      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
    }

    this.compose(this.current.getClippedPathBoundingBox());
    this.restore();
  }

  beginInlineImage() {
    (0, _util.unreachable)("Should not call beginInlineImage");
  }

  beginImageData() {
    (0, _util.unreachable)("Should not call beginImageData");
  }

  paintFormXObjectBegin(matrix, bbox) {
    if (!this.contentVisible) {
      return;
    }

    this.save();
    this.baseTransformStack.push(this.baseTransform);

    if (Array.isArray(matrix) && matrix.length === 6) {
      this.transform(...matrix);
    }

    this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);

    if (bbox) {
      const width = bbox[2] - bbox[0];
      const height = bbox[3] - bbox[1];
      this.ctx.rect(bbox[0], bbox[1], width, height);
      this.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(this.ctx), bbox);
      this.clip();
      this.endPath();
    }
  }

  paintFormXObjectEnd() {
    if (!this.contentVisible) {
      return;
    }

    this.restore();
    this.baseTransform = this.baseTransformStack.pop();
  }

  beginGroup(group) {
    if (!this.contentVisible) {
      return;
    }

    this.save();

    if (this.inSMaskMode) {
      this.endSMaskMode();
      this.current.activeSMask = null;
    }

    const currentCtx = this.ctx;

    if (!group.isolated) {
      (0, _util.info)("TODO: Support non-isolated groups.");
    }

    if (group.knockout) {
      (0, _util.warn)("Knockout groups not supported.");
    }

    const currentTransform = (0, _display_utils.getCurrentTransform)(currentCtx);

    if (group.matrix) {
      currentCtx.transform(...group.matrix);
    }

    if (!group.bbox) {
      throw new Error("Bounding box is required.");
    }

    let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils.getCurrentTransform)(currentCtx));

    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
    bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
    const offsetX = Math.floor(bounds[0]);
    const offsetY = Math.floor(bounds[1]);
    let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
    let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
    let scaleX = 1,
        scaleY = 1;

    if (drawnWidth > MAX_GROUP_SIZE) {
      scaleX = drawnWidth / MAX_GROUP_SIZE;
      drawnWidth = MAX_GROUP_SIZE;
    }

    if (drawnHeight > MAX_GROUP_SIZE) {
      scaleY = drawnHeight / MAX_GROUP_SIZE;
      drawnHeight = MAX_GROUP_SIZE;
    }

    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
    let cacheId = "groupAt" + this.groupLevel;

    if (group.smask) {
      cacheId += "_smask_" + this.smaskCounter++ % 2;
    }

    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
    const groupCtx = scratchCanvas.context;
    groupCtx.scale(1 / scaleX, 1 / scaleY);
    groupCtx.translate(-offsetX, -offsetY);
    groupCtx.transform(...currentTransform);

    if (group.smask) {
      this.smaskStack.push({
        canvas: scratchCanvas.canvas,
        context: groupCtx,
        offsetX,
        offsetY,
        scaleX,
        scaleY,
        subtype: group.smask.subtype,
        backdrop: group.smask.backdrop,
        transferMap: group.smask.transferMap || null,
        startTransformInverse: null
      });
    } else {
      currentCtx.setTransform(1, 0, 0, 1, 0, 0);
      currentCtx.translate(offsetX, offsetY);
      currentCtx.scale(scaleX, scaleY);
      currentCtx.save();
    }

    copyCtxState(currentCtx, groupCtx);
    this.ctx = groupCtx;
    this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
    this.groupStack.push(currentCtx);
    this.groupLevel++;
  }

  endGroup(group) {
    if (!this.contentVisible) {
      return;
    }

    this.groupLevel--;
    const groupCtx = this.ctx;
    const ctx = this.groupStack.pop();
    this.ctx = ctx;
    this.ctx.imageSmoothingEnabled = false;

    if (group.smask) {
      this.tempSMask = this.smaskStack.pop();
      this.restore();
    } else {
      this.ctx.restore();
      const currentMtx = (0, _display_utils.getCurrentTransform)(this.ctx);
      this.restore();
      this.ctx.save();
      this.ctx.setTransform(...currentMtx);

      const dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);

      this.ctx.drawImage(groupCtx.canvas, 0, 0);
      this.ctx.restore();
      this.compose(dirtyBox);
    }
  }

  beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {
    this.#restoreInitialState();
    resetCtxToDefault(this.ctx, this.foregroundColor);
    this.ctx.save();
    this.save();

    if (this.baseTransform) {
      this.ctx.setTransform(...this.baseTransform);
    }

    if (Array.isArray(rect) && rect.length === 4) {
      const width = rect[2] - rect[0];
      const height = rect[3] - rect[1];

      if (hasOwnCanvas && this.annotationCanvasMap) {
        transform = transform.slice();
        transform[4] -= rect[0];
        transform[5] -= rect[1];
        rect = rect.slice();
        rect[0] = rect[1] = 0;
        rect[2] = width;
        rect[3] = height;

        const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(this.ctx));

        const {
          viewportScale
        } = this;
        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
        const {
          canvas,
          context
        } = this.annotationCanvas;
        this.annotationCanvasMap.set(id, canvas);
        this.annotationCanvas.savedCtx = this.ctx;
        this.ctx = context;
        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);
        resetCtxToDefault(this.ctx, this.foregroundColor);
      } else {
        resetCtxToDefault(this.ctx, this.foregroundColor);
        this.ctx.rect(rect[0], rect[1], width, height);
        this.ctx.clip();
        this.endPath();
      }
    }

    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
    this.transform(...transform);
    this.transform(...matrix);
  }

  endAnnotation() {
    if (this.annotationCanvas) {
      this.ctx = this.annotationCanvas.savedCtx;
      delete this.annotationCanvas.savedCtx;
      delete this.annotationCanvas;
    }
  }

  paintImageMaskXObject(img) {
    if (!this.contentVisible) {
      return;
    }

    const count = img.count;
    img = this.getObject(img.data, img);
    img.count = count;
    const ctx = this.ctx;
    const glyph = this.processingType3;

    if (glyph) {
      if (glyph.compiled === undefined) {
        glyph.compiled = compileType3Glyph(img);
      }

      if (glyph.compiled) {
        glyph.compiled(ctx);
        return;
      }
    }

    const mask = this._createMaskCanvas(img);

    const maskCanvas = mask.canvas;
    ctx.save();
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
    ctx.restore();
    this.compose();
  }

  paintImageMaskXObjectRepeat(img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
    if (!this.contentVisible) {
      return;
    }

    img = this.getObject(img.data, img);
    const ctx = this.ctx;
    ctx.save();
    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);
    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);

    const mask = this._createMaskCanvas(img);

    ctx.setTransform(1, 0, 0, 1, 0, 0);

    for (let i = 0, ii = positions.length; i < ii; i += 2) {
      const trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);

      const [x, y] = _util.Util.applyTransform([0, 0], trans);

      ctx.drawImage(mask.canvas, x, y);
    }

    ctx.restore();
    this.compose();
  }

  paintImageMaskXObjectGroup(images) {
    if (!this.contentVisible) {
      return;
    }

    const ctx = this.ctx;
    const fillColor = this.current.fillColor;
    const isPatternFill = this.current.patternFill;

    for (const image of images) {
      const {
        data,
        width,
        height,
        transform
      } = image;
      const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
      const maskCtx = maskCanvas.context;
      maskCtx.save();
      const img = this.getObject(data, image);
      putBinaryImageMask(maskCtx, img);
      maskCtx.globalCompositeOperation = "source-in";
      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;
      maskCtx.fillRect(0, 0, width, height);
      maskCtx.restore();
      ctx.save();
      ctx.transform(...transform);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
      ctx.restore();
    }

    this.compose();
  }

  paintImageXObject(objId) {
    if (!this.contentVisible) {
      return;
    }

    const imgData = this.getObject(objId);

    if (!imgData) {
      (0, _util.warn)("Dependent image isn't ready yet");
      return;
    }

    this.paintInlineImageXObject(imgData);
  }

  paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
    if (!this.contentVisible) {
      return;
    }

    const imgData = this.getObject(objId);

    if (!imgData) {
      (0, _util.warn)("Dependent image isn't ready yet");
      return;
    }

    const width = imgData.width;
    const height = imgData.height;
    const map = [];

    for (let i = 0, ii = positions.length; i < ii; i += 2) {
      map.push({
        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
        x: 0,
        y: 0,
        w: width,
        h: height
      });
    }

    this.paintInlineImageXObjectGroup(imgData, map);
  }

  paintInlineImageXObject(imgData) {
    if (!this.contentVisible) {
      return;
    }

    const width = imgData.width;
    const height = imgData.height;
    const ctx = this.ctx;
    this.save();
    ctx.scale(1 / width, -1 / height);
    let imgToPaint;

    if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
      imgToPaint = imgData;
    } else {
      const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
      const tmpCtx = tmpCanvas.context;
      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
      imgToPaint = tmpCanvas.canvas;
    }

    const scaled = this._scaleImage(imgToPaint, (0, _display_utils.getCurrentTransformInverse)(ctx));

    ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(ctx), imgData.interpolate);
    const [rWidth, rHeight] = drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);

    if (this.imageLayer) {
      const [left, top] = _util.Util.applyTransform([0, -height], (0, _display_utils.getCurrentTransform)(this.ctx));

      this.imageLayer.appendImage({
        imgData,
        left,
        top,
        width: rWidth,
        height: rHeight
      });
    }

    this.compose();
    this.restore();
  }

  paintInlineImageXObjectGroup(imgData, map) {
    if (!this.contentVisible) {
      return;
    }

    const ctx = this.ctx;
    const w = imgData.width;
    const h = imgData.height;
    const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
    const tmpCtx = tmpCanvas.context;
    putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);

    for (const entry of map) {
      ctx.save();
      ctx.transform(...entry.transform);
      ctx.scale(1, -1);
      drawImageAtIntegerCoords(ctx, tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);

      if (this.imageLayer) {
        const [left, top] = _util.Util.applyTransform([entry.x, entry.y], (0, _display_utils.getCurrentTransform)(this.ctx));

        this.imageLayer.appendImage({
          imgData,
          left,
          top,
          width: w,
          height: h
        });
      }

      ctx.restore();
    }

    this.compose();
  }

  paintSolidColorImageMask() {
    if (!this.contentVisible) {
      return;
    }

    this.ctx.fillRect(0, 0, 1, 1);
    this.compose();
  }

  markPoint(tag) {}

  markPointProps(tag, properties) {}

  beginMarkedContent(tag) {
    this.markedContentStack.push({
      visible: true
    });
  }

  beginMarkedContentProps(tag, properties) {
    if (tag === "OC") {
      this.markedContentStack.push({
        visible: this.optionalContentConfig.isVisible(properties)
      });
    } else {
      this.markedContentStack.push({
        visible: true
      });
    }

    this.contentVisible = this.isContentVisible();
  }

  endMarkedContent() {
    this.markedContentStack.pop();
    this.contentVisible = this.isContentVisible();
  }

  beginCompat() {}

  endCompat() {}

  consumePath(clipBox) {
    const isEmpty = this.current.isEmptyClip();

    if (this.pendingClip) {
      this.current.updateClipFromPath();
    }

    if (!this.pendingClip) {
      this.compose(clipBox);
    }

    const ctx = this.ctx;

    if (this.pendingClip) {
      if (!isEmpty) {
        if (this.pendingClip === EO_CLIP) {
          ctx.clip("evenodd");
        } else {
          ctx.clip();
        }
      }

      this.pendingClip = null;
    }

    this.current.startNewPathAndClipBox(this.current.clipBox);
    ctx.beginPath();
  }

  getSinglePixelWidth() {
    if (!this._cachedGetSinglePixelWidth) {
      const m = (0, _display_utils.getCurrentTransform)(this.ctx);

      if (m[1] === 0 && m[2] === 0) {
        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
      } else {
        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
        const normX = Math.hypot(m[0], m[2]);
        const normY = Math.hypot(m[1], m[3]);
        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
      }
    }

    return this._cachedGetSinglePixelWidth;
  }

  getScaleForStroking() {
    if (!this._cachedScaleForStroking) {
      const {
        lineWidth
      } = this.current;
      const m = (0, _display_utils.getCurrentTransform)(this.ctx);
      let scaleX, scaleY;

      if (m[1] === 0 && m[2] === 0) {
        const normX = Math.abs(m[0]);
        const normY = Math.abs(m[3]);

        if (lineWidth === 0) {
          scaleX = 1 / normX;
          scaleY = 1 / normY;
        } else {
          const scaledXLineWidth = normX * lineWidth;
          const scaledYLineWidth = normY * lineWidth;
          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
        }
      } else {
        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
        const normX = Math.hypot(m[0], m[1]);
        const normY = Math.hypot(m[2], m[3]);

        if (lineWidth === 0) {
          scaleX = normY / absDet;
          scaleY = normX / absDet;
        } else {
          const baseArea = lineWidth * absDet;
          scaleX = normY > baseArea ? normY / baseArea : 1;
          scaleY = normX > baseArea ? normX / baseArea : 1;
        }
      }

      this._cachedScaleForStroking = [scaleX, scaleY];
    }

    return this._cachedScaleForStroking;
  }

  rescaleAndStroke(saveRestore) {
    const {
      ctx
    } = this;
    const {
      lineWidth
    } = this.current;
    const [scaleX, scaleY] = this.getScaleForStroking();
    ctx.lineWidth = lineWidth || 1;

    if (scaleX === 1 && scaleY === 1) {
      ctx.stroke();
      return;
    }

    let savedMatrix, savedDashes, savedDashOffset;

    if (saveRestore) {
      savedMatrix = (0, _display_utils.getCurrentTransform)(ctx);
      savedDashes = ctx.getLineDash().slice();
      savedDashOffset = ctx.lineDashOffset;
    }

    ctx.scale(scaleX, scaleY);
    const scale = Math.max(scaleX, scaleY);
    ctx.setLineDash(ctx.getLineDash().map(x => x / scale));
    ctx.lineDashOffset /= scale;
    ctx.stroke();

    if (saveRestore) {
      ctx.setTransform(...savedMatrix);
      ctx.setLineDash(savedDashes);
      ctx.lineDashOffset = savedDashOffset;
    }
  }

  isContentVisible() {
    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
      if (!this.markedContentStack[i].visible) {
        return false;
      }
    }

    return true;
  }

}

exports.CanvasGraphics = CanvasGraphics;

for (const op in _util.OPS) {
  if (CanvasGraphics.prototype[op] !== undefined) {
    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
  }
}

/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TilingPattern = exports.PathType = void 0;
exports.getShadingPattern = getShadingPattern;

var _util = __w_pdfjs_require__(1);

var _display_utils = __w_pdfjs_require__(8);

var _is_node = __w_pdfjs_require__(3);

const PathType = {
  FILL: "Fill",
  STROKE: "Stroke",
  SHADING: "Shading"
};
exports.PathType = PathType;

function applyBoundingBox(ctx, bbox) {
  if (!bbox || _is_node.isNodeJS) {
    return;
  }

  const width = bbox[2] - bbox[0];
  const height = bbox[3] - bbox[1];
  const region = new Path2D();
  region.rect(bbox[0], bbox[1], width, height);
  ctx.clip(region);
}

class BaseShadingPattern {
  constructor() {
    if (this.constructor === BaseShadingPattern) {
      (0, _util.unreachable)("Cannot initialize BaseShadingPattern.");
    }
  }

  getPattern() {
    (0, _util.unreachable)("Abstract method `getPattern` called.");
  }

}

class RadialAxialShadingPattern extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._type = IR[1];
    this._bbox = IR[2];
    this._colorStops = IR[3];
    this._p0 = IR[4];
    this._p1 = IR[5];
    this._r0 = IR[6];
    this._r1 = IR[7];
    this.matrix = null;
  }

  _createGradient(ctx) {
    let grad;

    if (this._type === "axial") {
      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
    } else if (this._type === "radial") {
      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
    }

    for (const colorStop of this._colorStops) {
      grad.addColorStop(colorStop[0], colorStop[1]);
    }

    return grad;
  }

  getPattern(ctx, owner, inverse, pathType) {
    let pattern;

    if (pathType === PathType.STROKE || pathType === PathType.FILL) {
      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils.getCurrentTransform)(ctx)) || [0, 0, 0, 0];
      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
      const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height, true);
      const tmpCtx = tmpCanvas.context;
      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.beginPath();
      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
      inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
      tmpCtx.transform(...owner.baseTransform);

      if (this.matrix) {
        tmpCtx.transform(...this.matrix);
      }

      applyBoundingBox(tmpCtx, this._bbox);
      tmpCtx.fillStyle = this._createGradient(tmpCtx);
      tmpCtx.fill();
      pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
      const domMatrix = new DOMMatrix(inverse);

      try {
        pattern.setTransform(domMatrix);
      } catch (ex) {
        (0, _util.warn)(`RadialAxialShadingPattern.getPattern: "${ex?.message}".`);
      }
    } else {
      applyBoundingBox(ctx, this._bbox);
      pattern = this._createGradient(ctx);
    }

    return pattern;
  }

}

function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
  const coords = context.coords,
        colors = context.colors;
  const bytes = data.data,
        rowSize = data.width * 4;
  let tmp;

  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }

  if (coords[p2 + 1] > coords[p3 + 1]) {
    tmp = p2;
    p2 = p3;
    p3 = tmp;
    tmp = c2;
    c2 = c3;
    c3 = tmp;
  }

  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }

  const x1 = (coords[p1] + context.offsetX) * context.scaleX;
  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
  const x2 = (coords[p2] + context.offsetX) * context.scaleX;
  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
  const x3 = (coords[p3] + context.offsetX) * context.scaleX;
  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;

  if (y1 >= y3) {
    return;
  }

  const c1r = colors[c1],
        c1g = colors[c1 + 1],
        c1b = colors[c1 + 2];
  const c2r = colors[c2],
        c2g = colors[c2 + 1],
        c2b = colors[c2 + 2];
  const c3r = colors[c3],
        c3g = colors[c3 + 1],
        c3b = colors[c3 + 2];
  const minY = Math.round(y1),
        maxY = Math.round(y3);
  let xa, car, cag, cab;
  let xb, cbr, cbg, cbb;

  for (let y = minY; y <= maxY; y++) {
    if (y < y2) {
      let k;

      if (y < y1) {
        k = 0;
      } else {
        k = (y1 - y) / (y1 - y2);
      }

      xa = x1 - (x1 - x2) * k;
      car = c1r - (c1r - c2r) * k;
      cag = c1g - (c1g - c2g) * k;
      cab = c1b - (c1b - c2b) * k;
    } else {
      let k;

      if (y > y3) {
        k = 1;
      } else if (y2 === y3) {
        k = 0;
      } else {
        k = (y2 - y) / (y2 - y3);
      }

      xa = x2 - (x2 - x3) * k;
      car = c2r - (c2r - c3r) * k;
      cag = c2g - (c2g - c3g) * k;
      cab = c2b - (c2b - c3b) * k;
    }

    let k;

    if (y < y1) {
      k = 0;
    } else if (y > y3) {
      k = 1;
    } else {
      k = (y1 - y) / (y1 - y3);
    }

    xb = x1 - (x1 - x3) * k;
    cbr = c1r - (c1r - c3r) * k;
    cbg = c1g - (c1g - c3g) * k;
    cbb = c1b - (c1b - c3b) * k;
    const x1_ = Math.round(Math.min(xa, xb));
    const x2_ = Math.round(Math.max(xa, xb));
    let j = rowSize * y + x1_ * 4;

    for (let x = x1_; x <= x2_; x++) {
      k = (xa - x) / (xa - xb);

      if (k < 0) {
        k = 0;
      } else if (k > 1) {
        k = 1;
      }

      bytes[j++] = car - (car - cbr) * k | 0;
      bytes[j++] = cag - (cag - cbg) * k | 0;
      bytes[j++] = cab - (cab - cbb) * k | 0;
      bytes[j++] = 255;
    }
  }
}

function drawFigure(data, figure, context) {
  const ps = figure.coords;
  const cs = figure.colors;
  let i, ii;

  switch (figure.type) {
    case "lattice":
      const verticesPerRow = figure.verticesPerRow;
      const rows = Math.floor(ps.length / verticesPerRow) - 1;
      const cols = verticesPerRow - 1;

      for (i = 0; i < rows; i++) {
        let q = i * verticesPerRow;

        for (let j = 0; j < cols; j++, q++) {
          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
        }
      }

      break;

    case "triangles":
      for (i = 0, ii = ps.length; i < ii; i += 3) {
        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
      }

      break;

    default:
      throw new Error("illegal figure");
  }
}

class MeshShadingPattern extends BaseShadingPattern {
  constructor(IR) {
    super();
    this._coords = IR[2];
    this._colors = IR[3];
    this._figures = IR[4];
    this._bounds = IR[5];
    this._bbox = IR[7];
    this._background = IR[8];
    this.matrix = null;
  }

  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
    const EXPECTED_SCALE = 1.1;
    const MAX_PATTERN_SIZE = 3000;
    const BORDER_SIZE = 2;
    const offsetX = Math.floor(this._bounds[0]);
    const offsetY = Math.floor(this._bounds[1]);
    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
    const scaleX = boundsWidth / width;
    const scaleY = boundsHeight / height;
    const context = {
      coords: this._coords,
      colors: this._colors,
      offsetX: -offsetX,
      offsetY: -offsetY,
      scaleX: 1 / scaleX,
      scaleY: 1 / scaleY
    };
    const paddedWidth = width + BORDER_SIZE * 2;
    const paddedHeight = height + BORDER_SIZE * 2;
    const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
    const tmpCtx = tmpCanvas.context;
    const data = tmpCtx.createImageData(width, height);

    if (backgroundColor) {
      const bytes = data.data;

      for (let i = 0, ii = bytes.length; i < ii; i += 4) {
        bytes[i] = backgroundColor[0];
        bytes[i + 1] = backgroundColor[1];
        bytes[i + 2] = backgroundColor[2];
        bytes[i + 3] = 255;
      }
    }

    for (const figure of this._figures) {
      drawFigure(data, figure, context);
    }

    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
    const canvas = tmpCanvas.canvas;
    return {
      canvas,
      offsetX: offsetX - BORDER_SIZE * scaleX,
      offsetY: offsetY - BORDER_SIZE * scaleY,
      scaleX,
      scaleY
    };
  }

  getPattern(ctx, owner, inverse, pathType) {
    applyBoundingBox(ctx, this._bbox);
    let scale;

    if (pathType === PathType.SHADING) {
      scale = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(ctx));
    } else {
      scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);

      if (this.matrix) {
        const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
      }
    }

    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);

    if (pathType !== PathType.SHADING) {
      ctx.setTransform(...owner.baseTransform);

      if (this.matrix) {
        ctx.transform(...this.matrix);
      }
    }

    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
    return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
  }

}

class DummyShadingPattern extends BaseShadingPattern {
  getPattern() {
    return "hotpink";
  }

}

function getShadingPattern(IR) {
  switch (IR[0]) {
    case "RadialAxial":
      return new RadialAxialShadingPattern(IR);

    case "Mesh":
      return new MeshShadingPattern(IR);

    case "Dummy":
      return new DummyShadingPattern();
  }

  throw new Error(`Unknown IR type: ${IR[0]}`);
}

const PaintType = {
  COLORED: 1,
  UNCOLORED: 2
};

class TilingPattern {
  static get MAX_PATTERN_SIZE() {
    return (0, _util.shadow)(this, "MAX_PATTERN_SIZE", 3000);
  }

  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
    this.operatorList = IR[2];
    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
    this.bbox = IR[4];
    this.xstep = IR[5];
    this.ystep = IR[6];
    this.paintType = IR[7];
    this.tilingType = IR[8];
    this.color = color;
    this.ctx = ctx;
    this.canvasGraphicsFactory = canvasGraphicsFactory;
    this.baseTransform = baseTransform;
  }

  createPatternCanvas(owner) {
    const operatorList = this.operatorList;
    const bbox = this.bbox;
    const xstep = this.xstep;
    const ystep = this.ystep;
    const paintType = this.paintType;
    const tilingType = this.tilingType;
    const color = this.color;
    const canvasGraphicsFactory = this.canvasGraphicsFactory;
    (0, _util.info)("TilingType: " + tilingType);
    const x0 = bbox[0],
          y0 = bbox[1],
          x1 = bbox[2],
          y1 = bbox[3];

    const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

    const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);

    const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
    const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
    const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
    const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
    const tmpCtx = tmpCanvas.context;
    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
    graphics.groupLevel = owner.groupLevel;
    this.setFillAndStrokeStyleToContext(graphics, paintType, color);
    let adjustedX0 = x0;
    let adjustedY0 = y0;
    let adjustedX1 = x1;
    let adjustedY1 = y1;

    if (x0 < 0) {
      adjustedX0 = 0;
      adjustedX1 += Math.abs(x0);
    }

    if (y0 < 0) {
      adjustedY0 = 0;
      adjustedY1 += Math.abs(y0);
    }

    tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
    tmpCtx.save();
    this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
    graphics.baseTransform = (0, _display_utils.getCurrentTransform)(graphics.ctx);
    graphics.executeOperatorList(operatorList);
    graphics.endDrawing();
    return {
      canvas: tmpCanvas.canvas,
      scaleX: dimx.scale,
      scaleY: dimy.scale,
      offsetX: adjustedX0,
      offsetY: adjustedY0
    };
  }

  getSizeAndScale(step, realOutputSize, scale) {
    step = Math.abs(step);
    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
    let size = Math.ceil(step * scale);

    if (size >= maxSize) {
      size = maxSize;
    } else {
      scale = size / step;
    }

    return {
      scale,
      size
    };
  }

  clipBbox(graphics, x0, y0, x1, y1) {
    const bboxWidth = x1 - x0;
    const bboxHeight = y1 - y0;
    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
    graphics.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);
    graphics.clip();
    graphics.endPath();
  }

  setFillAndStrokeStyleToContext(graphics, paintType, color) {
    const context = graphics.ctx,
          current = graphics.current;

    switch (paintType) {
      case PaintType.COLORED:
        const ctx = this.ctx;
        context.fillStyle = ctx.fillStyle;
        context.strokeStyle = ctx.strokeStyle;
        current.fillColor = ctx.fillStyle;
        current.strokeColor = ctx.strokeStyle;
        break;

      case PaintType.UNCOLORED:
        const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);

        context.fillStyle = cssColor;
        context.strokeStyle = cssColor;
        current.fillColor = cssColor;
        current.strokeColor = cssColor;
        break;

      default:
        throw new _util.FormatError(`Unsupported paint type: ${paintType}`);
    }
  }

  getPattern(ctx, owner, inverse, pathType) {
    let matrix = inverse;

    if (pathType !== PathType.SHADING) {
      matrix = _util.Util.transform(matrix, owner.baseTransform);

      if (this.matrix) {
        matrix = _util.Util.transform(matrix, this.matrix);
      }
    }

    const temporaryPatternCanvas = this.createPatternCanvas(owner);
    let domMatrix = new DOMMatrix(matrix);
    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");

    try {
      pattern.setTransform(domMatrix);
    } catch (ex) {
      (0, _util.warn)(`TilingPattern.getPattern: "${ex?.message}".`);
    }

    return pattern;
  }

}

exports.TilingPattern = TilingPattern;

/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.applyMaskImageData = applyMaskImageData;

var _util = __w_pdfjs_require__(1);

function applyMaskImageData({
  src,
  srcPos = 0,
  dest,
  destPos = 0,
  width,
  height,
  inverseDecode = false
}) {
  const opaque = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
  const [zeroMapping, oneMapping] = !inverseDecode ? [opaque, 0] : [0, opaque];
  const widthInSource = width >> 3;
  const widthRemainder = width & 7;
  const srcLength = src.length;
  dest = new Uint32Array(dest.buffer);

  for (let i = 0; i < height; i++) {
    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
      const elem = srcPos < srcLength ? src[srcPos] : 255;
      dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;
      dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;
    }

    if (widthRemainder === 0) {
      continue;
    }

    const elem = srcPos < srcLength ? src[srcPos++] : 255;

    for (let j = 0; j < widthRemainder; j++) {
      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
    }
  }

  return {
    srcPos,
    destPos
  };
}

/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.GlobalWorkerOptions = void 0;
const GlobalWorkerOptions = Object.create(null);
exports.GlobalWorkerOptions = GlobalWorkerOptions;
GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;
GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? "" : GlobalWorkerOptions.workerSrc;

/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MessageHandler = void 0;

var _util = __w_pdfjs_require__(1);

const CallbackKind = {
  UNKNOWN: 0,
  DATA: 1,
  ERROR: 2
};
const StreamKind = {
  UNKNOWN: 0,
  CANCEL: 1,
  CANCEL_COMPLETE: 2,
  CLOSE: 3,
  ENQUEUE: 4,
  ERROR: 5,
  PULL: 6,
  PULL_COMPLETE: 7,
  START_COMPLETE: 8
};

function wrapReason(reason) {
  if (!(reason instanceof Error || typeof reason === "object" && reason !== null)) {
    (0, _util.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  }

  switch (reason.name) {
    case "AbortException":
      return new _util.AbortException(reason.message);

    case "MissingPDFException":
      return new _util.MissingPDFException(reason.message);

    case "PasswordException":
      return new _util.PasswordException(reason.message, reason.code);

    case "UnexpectedResponseException":
      return new _util.UnexpectedResponseException(reason.message, reason.status);

    case "UnknownErrorException":
      return new _util.UnknownErrorException(reason.message, reason.details);

    default:
      return new _util.UnknownErrorException(reason.message, reason.toString());
  }
}

class MessageHandler {
  constructor(sourceName, targetName, comObj) {
    this.sourceName = sourceName;
    this.targetName = targetName;
    this.comObj = comObj;
    this.callbackId = 1;
    this.streamId = 1;
    this.streamSinks = Object.create(null);
    this.streamControllers = Object.create(null);
    this.callbackCapabilities = Object.create(null);
    this.actionHandler = Object.create(null);

    this._onComObjOnMessage = event => {
      const data = event.data;

      if (data.targetName !== this.sourceName) {
        return;
      }

      if (data.stream) {
        this._processStreamMessage(data);

        return;
      }

      if (data.callback) {
        const callbackId = data.callbackId;
        const capability = this.callbackCapabilities[callbackId];

        if (!capability) {
          throw new Error(`Cannot resolve callback ${callbackId}`);
        }

        delete this.callbackCapabilities[callbackId];

        if (data.callback === CallbackKind.DATA) {
          capability.resolve(data.data);
        } else if (data.callback === CallbackKind.ERROR) {
          capability.reject(wrapReason(data.reason));
        } else {
          throw new Error("Unexpected callback case");
        }

        return;
      }

      const action = this.actionHandler[data.action];

      if (!action) {
        throw new Error(`Unknown action from worker: ${data.action}`);
      }

      if (data.callbackId) {
        const cbSourceName = this.sourceName;
        const cbTargetName = data.sourceName;
        new Promise(function (resolve) {
          resolve(action(data.data));
        }).then(function (result) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.DATA,
            callbackId: data.callbackId,
            data: result
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName: cbSourceName,
            targetName: cbTargetName,
            callback: CallbackKind.ERROR,
            callbackId: data.callbackId,
            reason: wrapReason(reason)
          });
        });
        return;
      }

      if (data.streamId) {
        this._createStreamSink(data);

        return;
      }

      action(data.data);
    };

    comObj.addEventListener("message", this._onComObjOnMessage);
  }

  on(actionName, handler) {
    const ah = this.actionHandler;

    if (ah[actionName]) {
      throw new Error(`There is already an actionName called "${actionName}"`);
    }

    ah[actionName] = handler;
  }

  send(actionName, data, transfers) {
    this.comObj.postMessage({
      sourceName: this.sourceName,
      targetName: this.targetName,
      action: actionName,
      data
    }, transfers);
  }

  sendWithPromise(actionName, data, transfers) {
    const callbackId = this.callbackId++;
    const capability = (0, _util.createPromiseCapability)();
    this.callbackCapabilities[callbackId] = capability;

    try {
      this.comObj.postMessage({
        sourceName: this.sourceName,
        targetName: this.targetName,
        action: actionName,
        callbackId,
        data
      }, transfers);
    } catch (ex) {
      capability.reject(ex);
    }

    return capability.promise;
  }

  sendWithStream(actionName, data, queueingStrategy, transfers) {
    const streamId = this.streamId++,
          sourceName = this.sourceName,
          targetName = this.targetName,
          comObj = this.comObj;
    return new ReadableStream({
      start: controller => {
        const startCapability = (0, _util.createPromiseCapability)();
        this.streamControllers[streamId] = {
          controller,
          startCall: startCapability,
          pullCall: null,
          cancelCall: null,
          isClosed: false
        };
        comObj.postMessage({
          sourceName,
          targetName,
          action: actionName,
          streamId,
          data,
          desiredSize: controller.desiredSize
        }, transfers);
        return startCapability.promise;
      },
      pull: controller => {
        const pullCapability = (0, _util.createPromiseCapability)();
        this.streamControllers[streamId].pullCall = pullCapability;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.PULL,
          streamId,
          desiredSize: controller.desiredSize
        });
        return pullCapability.promise;
      },
      cancel: reason => {
        (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
        const cancelCapability = (0, _util.createPromiseCapability)();
        this.streamControllers[streamId].cancelCall = cancelCapability;
        this.streamControllers[streamId].isClosed = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CANCEL,
          streamId,
          reason: wrapReason(reason)
        });
        return cancelCapability.promise;
      }
    }, queueingStrategy);
  }

  _createStreamSink(data) {
    const streamId = data.streamId,
          sourceName = this.sourceName,
          targetName = data.sourceName,
          comObj = this.comObj;
    const self = this,
          action = this.actionHandler[data.action];
    const streamSink = {
      enqueue(chunk, size = 1, transfers) {
        if (this.isCancelled) {
          return;
        }

        const lastDesiredSize = this.desiredSize;
        this.desiredSize -= size;

        if (lastDesiredSize > 0 && this.desiredSize <= 0) {
          this.sinkCapability = (0, _util.createPromiseCapability)();
          this.ready = this.sinkCapability.promise;
        }

        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ENQUEUE,
          streamId,
          chunk
        }, transfers);
      },

      close() {
        if (this.isCancelled) {
          return;
        }

        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.CLOSE,
          streamId
        });
        delete self.streamSinks[streamId];
      },

      error(reason) {
        (0, _util.assert)(reason instanceof Error, "error must have a valid reason");

        if (this.isCancelled) {
          return;
        }

        this.isCancelled = true;
        comObj.postMessage({
          sourceName,
          targetName,
          stream: StreamKind.ERROR,
          streamId,
          reason: wrapReason(reason)
        });
      },

      sinkCapability: (0, _util.createPromiseCapability)(),
      onPull: null,
      onCancel: null,
      isCancelled: false,
      desiredSize: data.desiredSize,
      ready: null
    };
    streamSink.sinkCapability.resolve();
    streamSink.ready = streamSink.sinkCapability.promise;
    this.streamSinks[streamId] = streamSink;
    new Promise(function (resolve) {
      resolve(action(data.data, streamSink));
    }).then(function () {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        success: true
      });
    }, function (reason) {
      comObj.postMessage({
        sourceName,
        targetName,
        stream: StreamKind.START_COMPLETE,
        streamId,
        reason: wrapReason(reason)
      });
    });
  }

  _processStreamMessage(data) {
    const streamId = data.streamId,
          sourceName = this.sourceName,
          targetName = data.sourceName,
          comObj = this.comObj;
    const streamController = this.streamControllers[streamId],
          streamSink = this.streamSinks[streamId];

    switch (data.stream) {
      case StreamKind.START_COMPLETE:
        if (data.success) {
          streamController.startCall.resolve();
        } else {
          streamController.startCall.reject(wrapReason(data.reason));
        }

        break;

      case StreamKind.PULL_COMPLETE:
        if (data.success) {
          streamController.pullCall.resolve();
        } else {
          streamController.pullCall.reject(wrapReason(data.reason));
        }

        break;

      case StreamKind.PULL:
        if (!streamSink) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
          break;
        }

        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
          streamSink.sinkCapability.resolve();
        }

        streamSink.desiredSize = data.desiredSize;
        new Promise(function (resolve) {
          resolve(streamSink.onPull && streamSink.onPull());
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.PULL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        break;

      case StreamKind.ENQUEUE:
        (0, _util.assert)(streamController, "enqueue should have stream controller");

        if (streamController.isClosed) {
          break;
        }

        streamController.controller.enqueue(data.chunk);
        break;

      case StreamKind.CLOSE:
        (0, _util.assert)(streamController, "close should have stream controller");

        if (streamController.isClosed) {
          break;
        }

        streamController.isClosed = true;
        streamController.controller.close();

        this._deleteStreamController(streamController, streamId);

        break;

      case StreamKind.ERROR:
        (0, _util.assert)(streamController, "error should have stream controller");
        streamController.controller.error(wrapReason(data.reason));

        this._deleteStreamController(streamController, streamId);

        break;

      case StreamKind.CANCEL_COMPLETE:
        if (data.success) {
          streamController.cancelCall.resolve();
        } else {
          streamController.cancelCall.reject(wrapReason(data.reason));
        }

        this._deleteStreamController(streamController, streamId);

        break;

      case StreamKind.CANCEL:
        if (!streamSink) {
          break;
        }

        new Promise(function (resolve) {
          resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));
        }).then(function () {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            success: true
          });
        }, function (reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.CANCEL_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
        streamSink.sinkCapability.reject(wrapReason(data.reason));
        streamSink.isCancelled = true;
        delete this.streamSinks[streamId];
        break;

      default:
        throw new Error("Unexpected stream case");
    }
  }

  async _deleteStreamController(streamController, streamId) {
    await Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);
    delete this.streamControllers[streamId];
  }

  destroy() {
    this.comObj.removeEventListener("message", this._onComObjOnMessage);
  }

}

exports.MessageHandler = MessageHandler;

/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Metadata = void 0;

var _util = __w_pdfjs_require__(1);

class Metadata {
  #metadataMap;
  #data;

  constructor({
    parsedData,
    rawData
  }) {
    this.#metadataMap = parsedData;
    this.#data = rawData;
  }

  getRaw() {
    return this.#data;
  }

  get(name) {
    return this.#metadataMap.get(name) ?? null;
  }

  getAll() {
    return (0, _util.objectFromMap)(this.#metadataMap);
  }

  has(name) {
    return this.#metadataMap.has(name);
  }

}

exports.Metadata = Metadata;

/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.OptionalContentConfig = void 0;

var _util = __w_pdfjs_require__(1);

const INTERNAL = Symbol("INTERNAL");

class OptionalContentGroup {
  #visible = true;

  constructor(name, intent) {
    this.name = name;
    this.intent = intent;
  }

  get visible() {
    return this.#visible;
  }

  _setVisible(internal, visible) {
    if (internal !== INTERNAL) {
      (0, _util.unreachable)("Internal method `_setVisible` called.");
    }

    this.#visible = visible;
  }

}

class OptionalContentConfig {
  #cachedHasInitialVisibility = true;
  #groups = new Map();
  #initialVisibility = null;
  #order = null;

  constructor(data) {
    this.name = null;
    this.creator = null;

    if (data === null) {
      return;
    }

    this.name = data.name;
    this.creator = data.creator;
    this.#order = data.order;

    for (const group of data.groups) {
      this.#groups.set(group.id, new OptionalContentGroup(group.name, group.intent));
    }

    if (data.baseState === "OFF") {
      for (const group of this.#groups.values()) {
        group._setVisible(INTERNAL, false);
      }
    }

    for (const on of data.on) {
      this.#groups.get(on)._setVisible(INTERNAL, true);
    }

    for (const off of data.off) {
      this.#groups.get(off)._setVisible(INTERNAL, false);
    }

    this.#initialVisibility = new Map();

    for (const [id, group] of this.#groups) {
      this.#initialVisibility.set(id, group.visible);
    }
  }

  #evaluateVisibilityExpression(array) {
    const length = array.length;

    if (length < 2) {
      return true;
    }

    const operator = array[0];

    for (let i = 1; i < length; i++) {
      const element = array[i];
      let state;

      if (Array.isArray(element)) {
        state = this.#evaluateVisibilityExpression(element);
      } else if (this.#groups.has(element)) {
        state = this.#groups.get(element).visible;
      } else {
        (0, _util.warn)(`Optional content group not found: ${element}`);
        return true;
      }

      switch (operator) {
        case "And":
          if (!state) {
            return false;
          }

          break;

        case "Or":
          if (state) {
            return true;
          }

          break;

        case "Not":
          return !state;

        default:
          return true;
      }
    }

    return operator === "And";
  }

  isVisible(group) {
    if (this.#groups.size === 0) {
      return true;
    }

    if (!group) {
      (0, _util.warn)("Optional content group not defined.");
      return true;
    }

    if (group.type === "OCG") {
      if (!this.#groups.has(group.id)) {
        (0, _util.warn)(`Optional content group not found: ${group.id}`);
        return true;
      }

      return this.#groups.get(group.id).visible;
    } else if (group.type === "OCMD") {
      if (group.expression) {
        return this.#evaluateVisibilityExpression(group.expression);
      }

      if (!group.policy || group.policy === "AnyOn") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (this.#groups.get(id).visible) {
            return true;
          }
        }

        return false;
      } else if (group.policy === "AllOn") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (!this.#groups.get(id).visible) {
            return false;
          }
        }

        return true;
      } else if (group.policy === "AnyOff") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (!this.#groups.get(id).visible) {
            return true;
          }
        }

        return false;
      } else if (group.policy === "AllOff") {
        for (const id of group.ids) {
          if (!this.#groups.has(id)) {
            (0, _util.warn)(`Optional content group not found: ${id}`);
            return true;
          }

          if (this.#groups.get(id).visible) {
            return false;
          }
        }

        return true;
      }

      (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);
      return true;
    }

    (0, _util.warn)(`Unknown group type ${group.type}.`);
    return true;
  }

  setVisibility(id, visible = true) {
    if (!this.#groups.has(id)) {
      (0, _util.warn)(`Optional content group not found: ${id}`);
      return;
    }

    this.#groups.get(id)._setVisible(INTERNAL, !!visible);

    this.#cachedHasInitialVisibility = null;
  }

  get hasInitialVisibility() {
    if (this.#cachedHasInitialVisibility !== null) {
      return this.#cachedHasInitialVisibility;
    }

    for (const [id, group] of this.#groups) {
      const visible = this.#initialVisibility.get(id);

      if (group.visible !== visible) {
        return this.#cachedHasInitialVisibility = false;
      }
    }

    return this.#cachedHasInitialVisibility = true;
  }

  getOrder() {
    if (!this.#groups.size) {
      return null;
    }

    if (this.#order) {
      return this.#order.slice();
    }

    return [...this.#groups.keys()];
  }

  getGroups() {
    return this.#groups.size > 0 ? (0, _util.objectFromMap)(this.#groups) : null;
  }

  getGroup(id) {
    return this.#groups.get(id) || null;
  }

}

exports.OptionalContentConfig = OptionalContentConfig;

/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFDataTransportStream = void 0;

var _util = __w_pdfjs_require__(1);

var _display_utils = __w_pdfjs_require__(8);

class PDFDataTransportStream {
  constructor(params, pdfDataRangeTransport) {
    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
    this._queuedChunks = [];
    this._progressiveDone = params.progressiveDone || false;
    this._contentDispositionFilename = params.contentDispositionFilename || null;
    const initialData = params.initialData;

    if (initialData?.length > 0) {
      const buffer = new Uint8Array(initialData).buffer;

      this._queuedChunks.push(buffer);
    }

    this._pdfDataRangeTransport = pdfDataRangeTransport;
    this._isStreamingSupported = !params.disableStream;
    this._isRangeSupported = !params.disableRange;
    this._contentLength = params.length;
    this._fullRequestReader = null;
    this._rangeReaders = [];

    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {
      this._onReceiveData({
        begin,
        chunk
      });
    });

    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {
      this._onProgress({
        loaded,
        total
      });
    });

    this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {
      this._onReceiveData({
        chunk
      });
    });

    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
      this._onProgressiveDone();
    });

    this._pdfDataRangeTransport.transportReady();
  }

  _onReceiveData(args) {
    const buffer = new Uint8Array(args.chunk).buffer;

    if (args.begin === undefined) {
      if (this._fullRequestReader) {
        this._fullRequestReader._enqueue(buffer);
      } else {
        this._queuedChunks.push(buffer);
      }
    } else {
      const found = this._rangeReaders.some(function (rangeReader) {
        if (rangeReader._begin !== args.begin) {
          return false;
        }

        rangeReader._enqueue(buffer);

        return true;
      });

      (0, _util.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
    }
  }

  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }

  _onProgress(evt) {
    if (evt.total === undefined) {
      const firstReader = this._rangeReaders[0];

      if (firstReader?.onProgress) {
        firstReader.onProgress({
          loaded: evt.loaded
        });
      }
    } else {
      const fullReader = this._fullRequestReader;

      if (fullReader?.onProgress) {
        fullReader.onProgress({
          loaded: evt.loaded,
          total: evt.total
        });
      }
    }
  }

  _onProgressiveDone() {
    if (this._fullRequestReader) {
      this._fullRequestReader.progressiveDone();
    }

    this._progressiveDone = true;
  }

  _removeRangeReader(reader) {
    const i = this._rangeReaders.indexOf(reader);

    if (i >= 0) {
      this._rangeReaders.splice(i, 1);
    }
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
    const queuedChunks = this._queuedChunks;
    this._queuedChunks = null;
    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
  }

  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }

    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);

    this._pdfDataRangeTransport.requestDataRange(begin, end);

    this._rangeReaders.push(reader);

    return reader;
  }

  cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }

    for (const reader of this._rangeReaders.slice(0)) {
      reader.cancel(reason);
    }

    this._pdfDataRangeTransport.abort();
  }

}

exports.PDFDataTransportStream = PDFDataTransportStream;

class PDFDataTransportStreamReader {
  constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
    this._stream = stream;
    this._done = progressiveDone || false;
    this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
    this._queuedChunks = queuedChunks || [];
    this._loaded = 0;

    for (const chunk of this._queuedChunks) {
      this._loaded += chunk.byteLength;
    }

    this._requests = [];
    this._headersReady = Promise.resolve();
    stream._fullRequestReader = this;
    this.onProgress = null;
  }

  _enqueue(chunk) {
    if (this._done) {
      return;
    }

    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();

      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunks.push(chunk);
    }

    this._loaded += chunk.byteLength;
  }

  get headersReady() {
    return this._headersReady;
  }

  get filename() {
    return this._filename;
  }

  get isRangeSupported() {
    return this._stream._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._stream._isStreamingSupported;
  }

  get contentLength() {
    return this._stream._contentLength;
  }

  async read() {
    if (this._queuedChunks.length > 0) {
      const chunk = this._queuedChunks.shift();

      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;
  }

  progressiveDone() {
    if (this._done) {
      return;
    }

    this._done = true;
  }

}

class PDFDataTransportStreamRangeReader {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._begin = begin;
    this._end = end;
    this._queuedChunk = null;
    this._requests = [];
    this._done = false;
    this.onProgress = null;
  }

  _enqueue(chunk) {
    if (this._done) {
      return;
    }

    if (this._requests.length === 0) {
      this._queuedChunk = chunk;
    } else {
      const requestsCapability = this._requests.shift();

      requestsCapability.resolve({
        value: chunk,
        done: false
      });

      for (const requestCapability of this._requests) {
        requestCapability.resolve({
          value: undefined,
          done: true
        });
      }

      this._requests.length = 0;
    }

    this._done = true;

    this._stream._removeRangeReader(this);
  }

  get isStreamingSupported() {
    return false;
  }

  async read() {
    if (this._queuedChunk) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    this._stream._removeRangeReader(this);
  }

}

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XfaText = void 0;

class XfaText {
  static textContent(xfa) {
    const items = [];
    const output = {
      items,
      styles: Object.create(null)
    };

    function walk(node) {
      if (!node) {
        return;
      }

      let str = null;
      const name = node.name;

      if (name === "#text") {
        str = node.value;
      } else if (!XfaText.shouldBuildText(name)) {
        return;
      } else if (node?.attributes?.textContent) {
        str = node.attributes.textContent;
      } else if (node.value) {
        str = node.value;
      }

      if (str !== null) {
        items.push({
          str
        });
      }

      if (!node.children) {
        return;
      }

      for (const child of node.children) {
        walk(child);
      }
    }

    walk(xfa);
    return output;
  }

  static shouldBuildText(name) {
    return !(name === "textarea" || name === "input" || name === "option" || name === "select");
  }

}

exports.XfaText = XfaText;

/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.NodeStandardFontDataFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;

var _base_factory = __w_pdfjs_require__(9);

;

const fetchData = function (url) {
  return new Promise((resolve, reject) => {
    const fs = __webpack_require__(1);

    fs.readFile(url, (error, data) => {
      if (error || !data) {
        reject(new Error(error));
        return;
      }

      resolve(new Uint8Array(data));
    });
  });
};

class NodeCanvasFactory extends _base_factory.BaseCanvasFactory {
  _createCanvas(width, height) {
    const Canvas = __webpack_require__(20);

    return Canvas.createCanvas(width, height);
  }

}

exports.NodeCanvasFactory = NodeCanvasFactory;

class NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {
  _fetchData(url, compressionType) {
    return fetchData(url).then(data => {
      return {
        cMapData: data,
        compressionType
      };
    });
  }

}

exports.NodeCMapReaderFactory = NodeCMapReaderFactory;

class NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {
  _fetchData(url) {
    return fetchData(url);
  }

}

exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;

/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AnnotationEditorLayer = void 0;

var _tools = __w_pdfjs_require__(7);

var _util = __w_pdfjs_require__(1);

var _freetext = __w_pdfjs_require__(23);

var _ink = __w_pdfjs_require__(24);

class AnnotationEditorLayer {
  #accessibilityManager;
  #allowClick = false;
  #boundPointerup = this.pointerup.bind(this);
  #boundPointerdown = this.pointerdown.bind(this);
  #editors = new Map();
  #hadPointerDown = false;
  #isCleaningUp = false;
  #uiManager;
  static _initialized = false;

  constructor(options) {
    if (!AnnotationEditorLayer._initialized) {
      AnnotationEditorLayer._initialized = true;

      _freetext.FreeTextEditor.initialize(options.l10n);

      _ink.InkEditor.initialize(options.l10n);

      options.uiManager.registerEditorTypes([_freetext.FreeTextEditor, _ink.InkEditor]);
    }

    this.#uiManager = options.uiManager;
    this.annotationStorage = options.annotationStorage;
    this.pageIndex = options.pageIndex;
    this.div = options.div;
    this.#accessibilityManager = options.accessibilityManager;
    this.#uiManager.addLayer(this);
  }

  updateToolbar(mode) {
    this.#uiManager.updateToolbar(mode);
  }

  updateMode(mode = this.#uiManager.getMode()) {
    this.#cleanup();

    if (mode === _util.AnnotationEditorType.INK) {
      this.addInkEditorIfNeeded(false);
      this.disableClick();
    } else {
      this.enableClick();
    }

    this.#uiManager.unselectAll();
  }

  addInkEditorIfNeeded(isCommitting) {
    if (!isCommitting && this.#uiManager.getMode() !== _util.AnnotationEditorType.INK) {
      return;
    }

    if (!isCommitting) {
      for (const editor of this.#editors.values()) {
        if (editor.isEmpty()) {
          editor.setInBackground();
          return;
        }
      }
    }

    const editor = this.#createAndAddNewEditor({
      offsetX: 0,
      offsetY: 0
    });
    editor.setInBackground();
  }

  setEditingState(isEditing) {
    this.#uiManager.setEditingState(isEditing);
  }

  addCommands(params) {
    this.#uiManager.addCommands(params);
  }

  enable() {
    this.div.style.pointerEvents = "auto";

    for (const editor of this.#editors.values()) {
      editor.enableEditing();
    }
  }

  disable() {
    this.div.style.pointerEvents = "none";

    for (const editor of this.#editors.values()) {
      editor.disableEditing();
    }
  }

  setActiveEditor(editor) {
    const currentActive = this.#uiManager.getActive();

    if (currentActive === editor) {
      return;
    }

    this.#uiManager.setActiveEditor(editor);
  }

  enableClick() {
    this.div.addEventListener("pointerdown", this.#boundPointerdown);
    this.div.addEventListener("pointerup", this.#boundPointerup);
  }

  disableClick() {
    this.div.removeEventListener("pointerdown", this.#boundPointerdown);
    this.div.removeEventListener("pointerup", this.#boundPointerup);
  }

  attach(editor) {
    this.#editors.set(editor.id, editor);
  }

  detach(editor) {
    this.#editors.delete(editor.id);
    this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
  }

  remove(editor) {
    this.#uiManager.removeEditor(editor);
    this.detach(editor);
    this.annotationStorage.remove(editor.id);
    editor.div.style.display = "none";
    setTimeout(() => {
      editor.div.style.display = "";
      editor.div.remove();
      editor.isAttachedToDOM = false;

      if (document.activeElement === document.body) {
        this.#uiManager.focusMainContainer();
      }
    }, 0);

    if (!this.#isCleaningUp) {
      this.addInkEditorIfNeeded(false);
    }
  }

  #changeParent(editor) {
    if (editor.parent === this) {
      return;
    }

    this.attach(editor);
    editor.pageIndex = this.pageIndex;
    editor.parent?.detach(editor);
    editor.parent = this;

    if (editor.div && editor.isAttachedToDOM) {
      editor.div.remove();
      this.div.append(editor.div);
    }
  }

  add(editor) {
    this.#changeParent(editor);
    this.#uiManager.addEditor(editor);
    this.attach(editor);

    if (!editor.isAttachedToDOM) {
      const div = editor.render();
      this.div.append(div);
      editor.isAttachedToDOM = true;
    }

    this.moveEditorInDOM(editor);
    editor.onceAdded();
    this.addToAnnotationStorage(editor);
  }

  moveEditorInDOM(editor) {
    this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
  }

  addToAnnotationStorage(editor) {
    if (!editor.isEmpty() && !this.annotationStorage.has(editor.id)) {
      this.annotationStorage.setValue(editor.id, editor);
    }
  }

  addOrRebuild(editor) {
    if (editor.needsToBeRebuilt()) {
      editor.rebuild();
    } else {
      this.add(editor);
    }
  }

  addANewEditor(editor) {
    const cmd = () => {
      this.addOrRebuild(editor);
    };

    const undo = () => {
      editor.remove();
    };

    this.addCommands({
      cmd,
      undo,
      mustExec: true
    });
  }

  addUndoableEditor(editor) {
    const cmd = () => {
      this.addOrRebuild(editor);
    };

    const undo = () => {
      editor.remove();
    };

    this.addCommands({
      cmd,
      undo,
      mustExec: false
    });
  }

  getNextId() {
    return this.#uiManager.getId();
  }

  #createNewEditor(params) {
    switch (this.#uiManager.getMode()) {
      case _util.AnnotationEditorType.FREETEXT:
        return new _freetext.FreeTextEditor(params);

      case _util.AnnotationEditorType.INK:
        return new _ink.InkEditor(params);
    }

    return null;
  }

  deserialize(data) {
    switch (data.annotationType) {
      case _util.AnnotationEditorType.FREETEXT:
        return _freetext.FreeTextEditor.deserialize(data, this);

      case _util.AnnotationEditorType.INK:
        return _ink.InkEditor.deserialize(data, this);
    }

    return null;
  }

  #createAndAddNewEditor(event) {
    const id = this.getNextId();
    const editor = this.#createNewEditor({
      parent: this,
      id,
      x: event.offsetX,
      y: event.offsetY
    });

    if (editor) {
      this.add(editor);
    }

    return editor;
  }

  setSelected(editor) {
    this.#uiManager.setSelected(editor);
  }

  toggleSelected(editor) {
    this.#uiManager.toggleSelected(editor);
  }

  isSelected(editor) {
    return this.#uiManager.isSelected(editor);
  }

  unselect(editor) {
    this.#uiManager.unselect(editor);
  }

  pointerup(event) {
    const isMac = _tools.KeyboardManager.platform.isMac;

    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }

    if (event.target !== this.div) {
      return;
    }

    if (!this.#hadPointerDown) {
      return;
    }

    this.#hadPointerDown = false;

    if (!this.#allowClick) {
      this.#allowClick = true;
      return;
    }

    this.#createAndAddNewEditor(event);
  }

  pointerdown(event) {
    const isMac = _tools.KeyboardManager.platform.isMac;

    if (event.button !== 0 || event.ctrlKey && isMac) {
      return;
    }

    if (event.target !== this.div) {
      return;
    }

    this.#hadPointerDown = true;
    const editor = this.#uiManager.getActive();
    this.#allowClick = !editor || editor.isEmpty();
  }

  drop(event) {
    const id = event.dataTransfer.getData("text/plain");
    const editor = this.#uiManager.getEditor(id);

    if (!editor) {
      return;
    }

    event.preventDefault();
    event.dataTransfer.dropEffect = "move";
    this.#changeParent(editor);
    const rect = this.div.getBoundingClientRect();
    const endX = event.clientX - rect.x;
    const endY = event.clientY - rect.y;
    editor.translate(endX - editor.startX, endY - editor.startY);
    this.moveEditorInDOM(editor);
    editor.div.focus();
  }

  dragover(event) {
    event.preventDefault();
  }

  destroy() {
    if (this.#uiManager.getActive()?.parent === this) {
      this.#uiManager.setActiveEditor(null);
    }

    for (const editor of this.#editors.values()) {
      this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
      editor.isAttachedToDOM = false;
      editor.div.remove();
      editor.parent = null;
    }

    this.div = null;
    this.#editors.clear();
    this.#uiManager.removeLayer(this);
  }

  #cleanup() {
    this.#isCleaningUp = true;

    for (const editor of this.#editors.values()) {
      if (editor.isEmpty()) {
        editor.remove();
      }
    }

    this.#isCleaningUp = false;
  }

  render(parameters) {
    this.viewport = parameters.viewport;
    (0, _tools.bindEvents)(this, this.div, ["dragover", "drop"]);
    this.setDimensions();

    for (const editor of this.#uiManager.getEditors(this.pageIndex)) {
      this.add(editor);
    }

    this.updateMode();
  }

  update(parameters) {
    this.viewport = parameters.viewport;
    this.setDimensions();
    this.updateMode();
  }

  get scaleFactor() {
    return this.viewport.scale;
  }

  get pageDimensions() {
    const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
    const width = pageURx - pageLLx;
    const height = pageURy - pageLLy;
    return [width, height];
  }

  get viewportBaseDimensions() {
    const {
      width,
      height,
      rotation
    } = this.viewport;
    return rotation % 180 === 0 ? [width, height] : [height, width];
  }

  setDimensions() {
    const {
      width,
      height,
      rotation
    } = this.viewport;
    const flipOrientation = rotation % 180 !== 0,
          widthStr = Math.floor(width) + "px",
          heightStr = Math.floor(height) + "px";
    this.div.style.width = flipOrientation ? heightStr : widthStr;
    this.div.style.height = flipOrientation ? widthStr : heightStr;
    this.div.setAttribute("data-main-rotation", rotation);
  }

}

exports.AnnotationEditorLayer = AnnotationEditorLayer;

/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FreeTextEditor = void 0;

var _util = __w_pdfjs_require__(1);

var _tools = __w_pdfjs_require__(7);

var _editor = __w_pdfjs_require__(6);

class FreeTextEditor extends _editor.AnnotationEditor {
  #boundEditorDivBlur = this.editorDivBlur.bind(this);
  #boundEditorDivFocus = this.editorDivFocus.bind(this);
  #boundEditorDivKeydown = this.editorDivKeydown.bind(this);
  #color;
  #content = "";
  #hasAlreadyBeenCommitted = false;
  #fontSize;
  static _freeTextDefaultContent = "";
  static _l10nPromise;
  static _internalPadding = 0;
  static _defaultColor = null;
  static _defaultFontSize = 10;
  static _keyboardManager = new _tools.KeyboardManager([[["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], FreeTextEditor.prototype.commitOrRemove]]);
  static _type = "freetext";

  constructor(params) {
    super({ ...params,
      name: "freeTextEditor"
    });
    this.#color = params.color || FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;
    this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;
  }

  static initialize(l10n) {
    this._l10nPromise = new Map(["free_text_default_content", "editor_free_text_aria_label"].map(str => [str, l10n.get(str)]));
    const style = getComputedStyle(document.documentElement);
    this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
  }

  static updateDefaultParams(type, value) {
    switch (type) {
      case _util.AnnotationEditorParamsType.FREETEXT_SIZE:
        FreeTextEditor._defaultFontSize = value;
        break;

      case _util.AnnotationEditorParamsType.FREETEXT_COLOR:
        FreeTextEditor._defaultColor = value;
        break;
    }
  }

  updateParams(type, value) {
    switch (type) {
      case _util.AnnotationEditorParamsType.FREETEXT_SIZE:
        this.#updateFontSize(value);
        break;

      case _util.AnnotationEditorParamsType.FREETEXT_COLOR:
        this.#updateColor(value);
        break;
    }
  }

  static get defaultPropertiesToUpdate() {
    return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];
  }

  get propertiesToUpdate() {
    return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, this.#color]];
  }

  #updateFontSize(fontSize) {
    const setFontsize = size => {
      this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;
      this.translate(0, -(size - this.#fontSize) * this.parent.scaleFactor);
      this.#fontSize = size;
      this.#setEditorDimensions();
    };

    const savedFontsize = this.#fontSize;
    this.parent.addCommands({
      cmd: () => {
        setFontsize(fontSize);
      },
      undo: () => {
        setFontsize(savedFontsize);
      },
      mustExec: true,
      type: _util.AnnotationEditorParamsType.FREETEXT_SIZE,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }

  #updateColor(color) {
    const savedColor = this.#color;
    this.parent.addCommands({
      cmd: () => {
        this.#color = color;
        this.editorDiv.style.color = color;
      },
      undo: () => {
        this.#color = savedColor;
        this.editorDiv.style.color = savedColor;
      },
      mustExec: true,
      type: _util.AnnotationEditorParamsType.FREETEXT_COLOR,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }

  getInitialTranslation() {
    return [-FreeTextEditor._internalPadding * this.parent.scaleFactor, -(FreeTextEditor._internalPadding + this.#fontSize) * this.parent.scaleFactor];
  }

  rebuild() {
    super.rebuild();

    if (this.div === null) {
      return;
    }

    if (!this.isAttachedToDOM) {
      this.parent.add(this);
    }
  }

  enableEditMode() {
    if (this.isInEditMode()) {
      return;
    }

    this.parent.setEditingState(false);
    this.parent.updateToolbar(_util.AnnotationEditorType.FREETEXT);
    super.enableEditMode();
    this.enableEditing();
    this.overlayDiv.classList.remove("enabled");
    this.editorDiv.contentEditable = true;
    this.div.draggable = false;
    this.editorDiv.addEventListener("keydown", this.#boundEditorDivKeydown);
    this.editorDiv.addEventListener("focus", this.#boundEditorDivFocus);
    this.editorDiv.addEventListener("blur", this.#boundEditorDivBlur);
  }

  disableEditMode() {
    if (!this.isInEditMode()) {
      return;
    }

    this.parent.setEditingState(true);
    super.disableEditMode();
    this.disableEditing();
    this.overlayDiv.classList.add("enabled");
    this.editorDiv.contentEditable = false;
    this.div.draggable = true;
    this.editorDiv.removeEventListener("keydown", this.#boundEditorDivKeydown);
    this.editorDiv.removeEventListener("focus", this.#boundEditorDivFocus);
    this.editorDiv.removeEventListener("blur", this.#boundEditorDivBlur);
    this.div.focus();
    this.isEditing = false;
  }

  focusin(event) {
    super.focusin(event);

    if (event.target !== this.editorDiv) {
      this.editorDiv.focus();
    }
  }

  onceAdded() {
    if (this.width) {
      return;
    }

    this.enableEditMode();
    this.editorDiv.focus();
  }

  isEmpty() {
    return !this.editorDiv || this.editorDiv.innerText.trim() === "";
  }

  remove() {
    this.isEditing = false;
    this.parent.setEditingState(true);
    super.remove();
  }

  #extractText() {
    const divs = this.editorDiv.getElementsByTagName("div");

    if (divs.length === 0) {
      return this.editorDiv.innerText;
    }

    const buffer = [];

    for (let i = 0, ii = divs.length; i < ii; i++) {
      const div = divs[i];
      const first = div.firstChild;

      if (first?.nodeName === "#text") {
        buffer.push(first.data);
      } else {
        buffer.push("");
      }
    }

    return buffer.join("\n");
  }

  #setEditorDimensions() {
    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
    const rect = this.div.getBoundingClientRect();
    this.width = rect.width / parentWidth;
    this.height = rect.height / parentHeight;
  }

  commit() {
    super.commit();

    if (!this.#hasAlreadyBeenCommitted) {
      this.#hasAlreadyBeenCommitted = true;
      this.parent.addUndoableEditor(this);
    }

    this.disableEditMode();
    this.#content = this.#extractText().trimEnd();
    this.#setEditorDimensions();
  }

  shouldGetKeyboardEvents() {
    return this.isInEditMode();
  }

  dblclick(event) {
    this.enableEditMode();
    this.editorDiv.focus();
  }

  keydown(event) {
    if (event.target === this.div && event.key === "Enter") {
      this.enableEditMode();
      this.editorDiv.focus();
    }
  }

  editorDivKeydown(event) {
    FreeTextEditor._keyboardManager.exec(this, event);
  }

  editorDivFocus(event) {
    this.isEditing = true;
  }

  editorDivBlur(event) {
    this.isEditing = false;
  }

  disableEditing() {
    this.editorDiv.setAttribute("role", "comment");
    this.editorDiv.removeAttribute("aria-multiline");
  }

  enableEditing() {
    this.editorDiv.setAttribute("role", "textbox");
    this.editorDiv.setAttribute("aria-multiline", true);
  }

  render() {
    if (this.div) {
      return this.div;
    }

    let baseX, baseY;

    if (this.width) {
      baseX = this.x;
      baseY = this.y;
    }

    super.render();
    this.editorDiv = document.createElement("div");
    this.editorDiv.className = "internal";
    this.editorDiv.setAttribute("id", `${this.id}-editor`);
    this.enableEditing();

    FreeTextEditor._l10nPromise.get("editor_free_text_aria_label").then(msg => this.editorDiv?.setAttribute("aria-label", msg));

    FreeTextEditor._l10nPromise.get("free_text_default_content").then(msg => this.editorDiv?.setAttribute("default-content", msg));

    this.editorDiv.contentEditable = true;
    const {
      style
    } = this.editorDiv;
    style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;
    style.color = this.#color;
    this.div.append(this.editorDiv);
    this.overlayDiv = document.createElement("div");
    this.overlayDiv.classList.add("overlay", "enabled");
    this.div.append(this.overlayDiv);
    (0, _tools.bindEvents)(this, this.div, ["dblclick", "keydown"]);

    if (this.width) {
      const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);

      for (const line of this.#content.split("\n")) {
        const div = document.createElement("div");
        div.append(line ? document.createTextNode(line) : document.createElement("br"));
        this.editorDiv.append(div);
      }

      this.div.draggable = true;
      this.editorDiv.contentEditable = false;
    } else {
      this.div.draggable = false;
      this.editorDiv.contentEditable = true;
    }

    return this.div;
  }

  get contentDiv() {
    return this.editorDiv;
  }

  static deserialize(data, parent) {
    const editor = super.deserialize(data, parent);
    editor.#fontSize = data.fontSize;
    editor.#color = _util.Util.makeHexColor(...data.color);
    editor.#content = data.value;
    return editor;
  }

  serialize() {
    if (this.isEmpty()) {
      return null;
    }

    const padding = FreeTextEditor._internalPadding * this.parent.scaleFactor;
    const rect = this.getRect(padding, padding);

    const color = _editor.AnnotationEditor._colorManager.convert(getComputedStyle(this.editorDiv).color);

    return {
      annotationType: _util.AnnotationEditorType.FREETEXT,
      color,
      fontSize: this.#fontSize,
      value: this.#content,
      pageIndex: this.parent.pageIndex,
      rect,
      rotation: this.rotation
    };
  }

}

exports.FreeTextEditor = FreeTextEditor;

/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.InkEditor = void 0;
Object.defineProperty(exports, "fitCurve", ({
  enumerable: true,
  get: function () {
    return _pdfjsFitCurve.fitCurve;
  }
}));

var _util = __w_pdfjs_require__(1);

var _editor = __w_pdfjs_require__(6);

var _pdfjsFitCurve = __w_pdfjs_require__(25);

var _tools = __w_pdfjs_require__(7);

const RESIZER_SIZE = 16;

class InkEditor extends _editor.AnnotationEditor {
  #aspectRatio = 0;
  #baseHeight = 0;
  #baseWidth = 0;
  #boundCanvasPointermove = this.canvasPointermove.bind(this);
  #boundCanvasPointerleave = this.canvasPointerleave.bind(this);
  #boundCanvasPointerup = this.canvasPointerup.bind(this);
  #boundCanvasPointerdown = this.canvasPointerdown.bind(this);
  #disableEditing = false;
  #isCanvasInitialized = false;
  #lastPoint = null;
  #observer = null;
  #realWidth = 0;
  #realHeight = 0;
  #requestFrameCallback = null;
  static _defaultColor = null;
  static _defaultOpacity = 1;
  static _defaultThickness = 1;
  static _l10nPromise;
  static _type = "ink";

  constructor(params) {
    super({ ...params,
      name: "inkEditor"
    });
    this.color = params.color || null;
    this.thickness = params.thickness || null;
    this.opacity = params.opacity || null;
    this.paths = [];
    this.bezierPath2D = [];
    this.currentPath = [];
    this.scaleFactor = 1;
    this.translationX = this.translationY = 0;
    this.x = 0;
    this.y = 0;
  }

  static initialize(l10n) {
    this._l10nPromise = new Map(["editor_ink_canvas_aria_label", "editor_ink_aria_label"].map(str => [str, l10n.get(str)]));
  }

  static updateDefaultParams(type, value) {
    switch (type) {
      case _util.AnnotationEditorParamsType.INK_THICKNESS:
        InkEditor._defaultThickness = value;
        break;

      case _util.AnnotationEditorParamsType.INK_COLOR:
        InkEditor._defaultColor = value;
        break;

      case _util.AnnotationEditorParamsType.INK_OPACITY:
        InkEditor._defaultOpacity = value / 100;
        break;
    }
  }

  updateParams(type, value) {
    switch (type) {
      case _util.AnnotationEditorParamsType.INK_THICKNESS:
        this.#updateThickness(value);
        break;

      case _util.AnnotationEditorParamsType.INK_COLOR:
        this.#updateColor(value);
        break;

      case _util.AnnotationEditorParamsType.INK_OPACITY:
        this.#updateOpacity(value);
        break;
    }
  }

  static get defaultPropertiesToUpdate() {
    return [[_util.AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(InkEditor._defaultOpacity * 100)]];
  }

  get propertiesToUpdate() {
    return [[_util.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, this.color || InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))]];
  }

  #updateThickness(thickness) {
    const savedThickness = this.thickness;
    this.parent.addCommands({
      cmd: () => {
        this.thickness = thickness;
        this.#fitToContent();
      },
      undo: () => {
        this.thickness = savedThickness;
        this.#fitToContent();
      },
      mustExec: true,
      type: _util.AnnotationEditorParamsType.INK_THICKNESS,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }

  #updateColor(color) {
    const savedColor = this.color;
    this.parent.addCommands({
      cmd: () => {
        this.color = color;
        this.#redraw();
      },
      undo: () => {
        this.color = savedColor;
        this.#redraw();
      },
      mustExec: true,
      type: _util.AnnotationEditorParamsType.INK_COLOR,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }

  #updateOpacity(opacity) {
    opacity /= 100;
    const savedOpacity = this.opacity;
    this.parent.addCommands({
      cmd: () => {
        this.opacity = opacity;
        this.#redraw();
      },
      undo: () => {
        this.opacity = savedOpacity;
        this.#redraw();
      },
      mustExec: true,
      type: _util.AnnotationEditorParamsType.INK_OPACITY,
      overwriteIfSameType: true,
      keepUndo: true
    });
  }

  rebuild() {
    super.rebuild();

    if (this.div === null) {
      return;
    }

    if (!this.canvas) {
      this.#createCanvas();
      this.#createObserver();
    }

    if (!this.isAttachedToDOM) {
      this.parent.add(this);
      this.#setCanvasDims();
    }

    this.#fitToContent();
  }

  remove() {
    if (this.canvas === null) {
      return;
    }

    if (!this.isEmpty()) {
      this.commit();
    }

    this.canvas.width = this.canvas.height = 0;
    this.canvas.remove();
    this.canvas = null;
    this.#observer.disconnect();
    this.#observer = null;
    super.remove();
  }

  enableEditMode() {
    if (this.#disableEditing || this.canvas === null) {
      return;
    }

    super.enableEditMode();
    this.div.draggable = false;
    this.canvas.addEventListener("pointerdown", this.#boundCanvasPointerdown);
    this.canvas.addEventListener("pointerup", this.#boundCanvasPointerup);
  }

  disableEditMode() {
    if (!this.isInEditMode() || this.canvas === null) {
      return;
    }

    super.disableEditMode();
    this.div.draggable = !this.isEmpty();
    this.div.classList.remove("editing");
    this.canvas.removeEventListener("pointerdown", this.#boundCanvasPointerdown);
    this.canvas.removeEventListener("pointerup", this.#boundCanvasPointerup);
  }

  onceAdded() {
    this.div.draggable = !this.isEmpty();
  }

  isEmpty() {
    return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
  }

  #getInitialBBox() {
    const {
      width,
      height,
      rotation
    } = this.parent.viewport;

    switch (rotation) {
      case 90:
        return [0, width, width, height];

      case 180:
        return [width, height, width, height];

      case 270:
        return [height, 0, width, height];

      default:
        return [0, 0, width, height];
    }
  }

  #setStroke() {
    this.ctx.lineWidth = this.thickness * this.parent.scaleFactor / this.scaleFactor;
    this.ctx.lineCap = "round";
    this.ctx.lineJoin = "round";
    this.ctx.miterLimit = 10;
    this.ctx.strokeStyle = `${this.color}${(0, _tools.opacityToHex)(this.opacity)}`;
  }

  #startDrawing(x, y) {
    this.isEditing = true;

    if (!this.#isCanvasInitialized) {
      this.#isCanvasInitialized = true;
      this.#setCanvasDims();
      this.thickness ||= InkEditor._defaultThickness;
      this.color ||= InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;
      this.opacity ??= InkEditor._defaultOpacity;
    }

    this.currentPath.push([x, y]);
    this.#lastPoint = null;
    this.#setStroke();
    this.ctx.beginPath();
    this.ctx.moveTo(x, y);

    this.#requestFrameCallback = () => {
      if (!this.#requestFrameCallback) {
        return;
      }

      if (this.#lastPoint) {
        if (this.isEmpty()) {
          this.ctx.setTransform(1, 0, 0, 1, 0, 0);
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        } else {
          this.#redraw();
        }

        this.ctx.lineTo(...this.#lastPoint);
        this.#lastPoint = null;
        this.ctx.stroke();
      }

      window.requestAnimationFrame(this.#requestFrameCallback);
    };

    window.requestAnimationFrame(this.#requestFrameCallback);
  }

  #draw(x, y) {
    const [lastX, lastY] = this.currentPath.at(-1);

    if (x === lastX && y === lastY) {
      return;
    }

    this.currentPath.push([x, y]);
    this.#lastPoint = [x, y];
  }

  #stopDrawing(x, y) {
    this.ctx.closePath();
    this.#requestFrameCallback = null;
    x = Math.min(Math.max(x, 0), this.canvas.width);
    y = Math.min(Math.max(y, 0), this.canvas.height);
    const [lastX, lastY] = this.currentPath.at(-1);

    if (x !== lastX || y !== lastY) {
      this.currentPath.push([x, y]);
    }

    let bezier;

    if (this.currentPath.length !== 1) {
      bezier = (0, _pdfjsFitCurve.fitCurve)(this.currentPath, 30, null);
    } else {
      const xy = [x, y];
      bezier = [[xy, xy.slice(), xy.slice(), xy]];
    }

    const path2D = InkEditor.#buildPath2D(bezier);
    this.currentPath.length = 0;

    const cmd = () => {
      this.paths.push(bezier);
      this.bezierPath2D.push(path2D);
      this.rebuild();
    };

    const undo = () => {
      this.paths.pop();
      this.bezierPath2D.pop();

      if (this.paths.length === 0) {
        this.remove();
      } else {
        if (!this.canvas) {
          this.#createCanvas();
          this.#createObserver();
        }

        this.#fitToContent();
      }
    };

    this.parent.addCommands({
      cmd,
      undo,
      mustExec: true
    });
  }

  #redraw() {
    if (this.isEmpty()) {
      this.#updateTransform();
      return;
    }

    this.#setStroke();
    const {
      canvas,
      ctx
    } = this;
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    this.#updateTransform();

    for (const path of this.bezierPath2D) {
      ctx.stroke(path);
    }
  }

  commit() {
    if (this.#disableEditing) {
      return;
    }

    super.commit();
    this.isEditing = false;
    this.disableEditMode();
    this.setInForeground();
    this.#disableEditing = true;
    this.div.classList.add("disabled");
    this.#fitToContent(true);
    this.parent.addInkEditorIfNeeded(true);
    this.parent.moveEditorInDOM(this);
    this.div.focus();
  }

  focusin(event) {
    super.focusin(event);
    this.enableEditMode();
  }

  canvasPointerdown(event) {
    if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) {
      return;
    }

    this.setInForeground();

    if (event.type !== "mouse") {
      this.div.focus();
    }

    event.stopPropagation();
    this.canvas.addEventListener("pointerleave", this.#boundCanvasPointerleave);
    this.canvas.addEventListener("pointermove", this.#boundCanvasPointermove);
    this.#startDrawing(event.offsetX, event.offsetY);
  }

  canvasPointermove(event) {
    event.stopPropagation();
    this.#draw(event.offsetX, event.offsetY);
  }

  canvasPointerup(event) {
    if (event.button !== 0) {
      return;
    }

    if (this.isInEditMode() && this.currentPath.length !== 0) {
      event.stopPropagation();
      this.#endDrawing(event);
      this.setInBackground();
    }
  }

  canvasPointerleave(event) {
    this.#endDrawing(event);
    this.setInBackground();
  }

  #endDrawing(event) {
    this.#stopDrawing(event.offsetX, event.offsetY);
    this.canvas.removeEventListener("pointerleave", this.#boundCanvasPointerleave);
    this.canvas.removeEventListener("pointermove", this.#boundCanvasPointermove);
    this.parent.addToAnnotationStorage(this);
  }

  #createCanvas() {
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.canvas.height = 0;
    this.canvas.className = "inkEditorCanvas";

    InkEditor._l10nPromise.get("editor_ink_canvas_aria_label").then(msg => this.canvas?.setAttribute("aria-label", msg));

    this.div.append(this.canvas);
    this.ctx = this.canvas.getContext("2d");
  }

  #createObserver() {
    this.#observer = new ResizeObserver(entries => {
      const rect = entries[0].contentRect;

      if (rect.width && rect.height) {
        this.setDimensions(rect.width, rect.height);
      }
    });
    this.#observer.observe(this.div);
  }

  render() {
    if (this.div) {
      return this.div;
    }

    let baseX, baseY;

    if (this.width) {
      baseX = this.x;
      baseY = this.y;
    }

    super.render();

    InkEditor._l10nPromise.get("editor_ink_aria_label").then(msg => this.div?.setAttribute("aria-label", msg));

    const [x, y, w, h] = this.#getInitialBBox();
    this.setAt(x, y, 0, 0);
    this.setDims(w, h);
    this.#createCanvas();

    if (this.width) {
      const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
      this.#isCanvasInitialized = true;
      this.#setCanvasDims();
      this.setDims(this.width * parentWidth, this.height * parentHeight);
      this.#redraw();
      this.#setMinDims();
      this.div.classList.add("disabled");
    } else {
      this.div.classList.add("editing");
      this.enableEditMode();
    }

    this.#createObserver();
    return this.div;
  }

  #setCanvasDims() {
    if (!this.#isCanvasInitialized) {
      return;
    }

    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
    this.canvas.width = Math.ceil(this.width * parentWidth);
    this.canvas.height = Math.ceil(this.height * parentHeight);
    this.#updateTransform();
  }

  setDimensions(width, height) {
    const roundedWidth = Math.round(width);
    const roundedHeight = Math.round(height);

    if (this.#realWidth === roundedWidth && this.#realHeight === roundedHeight) {
      return;
    }

    this.#realWidth = roundedWidth;
    this.#realHeight = roundedHeight;
    this.canvas.style.visibility = "hidden";

    if (this.#aspectRatio && Math.abs(this.#aspectRatio - width / height) > 1e-2) {
      height = Math.ceil(width / this.#aspectRatio);
      this.setDims(width, height);
    }

    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
    this.width = width / parentWidth;
    this.height = height / parentHeight;

    if (this.#disableEditing) {
      this.#setScaleFactor(width, height);
    }

    this.#setCanvasDims();
    this.#redraw();
    this.canvas.style.visibility = "visible";
  }

  #setScaleFactor(width, height) {
    const padding = this.#getPadding();
    const scaleFactorW = (width - padding) / this.#baseWidth;
    const scaleFactorH = (height - padding) / this.#baseHeight;
    this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);
  }

  #updateTransform() {
    const padding = this.#getPadding() / 2;
    this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);
  }

  static #buildPath2D(bezier) {
    const path2D = new Path2D();

    for (let i = 0, ii = bezier.length; i < ii; i++) {
      const [first, control1, control2, second] = bezier[i];

      if (i === 0) {
        path2D.moveTo(...first);
      }

      path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);
    }

    return path2D;
  }

  #serializePaths(s, tx, ty, h) {
    const NUMBER_OF_POINTS_ON_BEZIER_CURVE = 4;
    const paths = [];
    const padding = this.thickness / 2;
    let buffer, points;

    for (const bezier of this.paths) {
      buffer = [];
      points = [];

      for (let i = 0, ii = bezier.length; i < ii; i++) {
        const [first, control1, control2, second] = bezier[i];
        const p10 = s * (first[0] + tx) + padding;
        const p11 = h - s * (first[1] + ty) - padding;
        const p20 = s * (control1[0] + tx) + padding;
        const p21 = h - s * (control1[1] + ty) - padding;
        const p30 = s * (control2[0] + tx) + padding;
        const p31 = h - s * (control2[1] + ty) - padding;
        const p40 = s * (second[0] + tx) + padding;
        const p41 = h - s * (second[1] + ty) - padding;

        if (i === 0) {
          buffer.push(p10, p11);
          points.push(p10, p11);
        }

        buffer.push(p20, p21, p30, p31, p40, p41);
        this.#extractPointsOnBezier(p10, p11, p20, p21, p30, p31, p40, p41, NUMBER_OF_POINTS_ON_BEZIER_CURVE, points);
      }

      paths.push({
        bezier: buffer,
        points
      });
    }

    return paths;
  }

  #extractPointsOnBezier(p10, p11, p20, p21, p30, p31, p40, p41, n, points) {
    if (this.#isAlmostFlat(p10, p11, p20, p21, p30, p31, p40, p41)) {
      points.push(p40, p41);
      return;
    }

    for (let i = 1; i < n - 1; i++) {
      const t = i / n;
      const mt = 1 - t;
      let q10 = t * p10 + mt * p20;
      let q11 = t * p11 + mt * p21;
      let q20 = t * p20 + mt * p30;
      let q21 = t * p21 + mt * p31;
      const q30 = t * p30 + mt * p40;
      const q31 = t * p31 + mt * p41;
      q10 = t * q10 + mt * q20;
      q11 = t * q11 + mt * q21;
      q20 = t * q20 + mt * q30;
      q21 = t * q21 + mt * q31;
      q10 = t * q10 + mt * q20;
      q11 = t * q11 + mt * q21;
      points.push(q10, q11);
    }

    points.push(p40, p41);
  }

  #isAlmostFlat(p10, p11, p20, p21, p30, p31, p40, p41) {
    const tol = 10;
    const ax = (3 * p20 - 2 * p10 - p40) ** 2;
    const ay = (3 * p21 - 2 * p11 - p41) ** 2;
    const bx = (3 * p30 - p10 - 2 * p40) ** 2;
    const by = (3 * p31 - p11 - 2 * p41) ** 2;
    return Math.max(ax, bx) + Math.max(ay, by) <= tol;
  }

  #getBbox() {
    let xMin = Infinity;
    let xMax = -Infinity;
    let yMin = Infinity;
    let yMax = -Infinity;

    for (const path of this.paths) {
      for (const [first, control1, control2, second] of path) {
        const bbox = _util.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);

        xMin = Math.min(xMin, bbox[0]);
        yMin = Math.min(yMin, bbox[1]);
        xMax = Math.max(xMax, bbox[2]);
        yMax = Math.max(yMax, bbox[3]);
      }
    }

    return [xMin, yMin, xMax, yMax];
  }

  #getPadding() {
    return this.#disableEditing ? Math.ceil(this.thickness * this.parent.scaleFactor) : 0;
  }

  #fitToContent(firstTime = false) {
    if (this.isEmpty()) {
      return;
    }

    if (!this.#disableEditing) {
      this.#redraw();
      return;
    }

    const bbox = this.#getBbox();
    const padding = this.#getPadding();
    this.#baseWidth = Math.max(RESIZER_SIZE, bbox[2] - bbox[0]);
    this.#baseHeight = Math.max(RESIZER_SIZE, bbox[3] - bbox[1]);
    const width = Math.ceil(padding + this.#baseWidth * this.scaleFactor);
    const height = Math.ceil(padding + this.#baseHeight * this.scaleFactor);
    const [parentWidth, parentHeight] = this.parent.viewportBaseDimensions;
    this.width = width / parentWidth;
    this.height = height / parentHeight;
    this.#aspectRatio = width / height;
    this.#setMinDims();
    const prevTranslationX = this.translationX;
    const prevTranslationY = this.translationY;
    this.translationX = -bbox[0];
    this.translationY = -bbox[1];
    this.#setCanvasDims();
    this.#redraw();
    this.#realWidth = width;
    this.#realHeight = height;
    this.setDims(width, height);
    const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;
    this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);
  }

  #setMinDims() {
    const {
      style
    } = this.div;

    if (this.#aspectRatio >= 1) {
      style.minHeight = `${RESIZER_SIZE}px`;
      style.minWidth = `${Math.round(this.#aspectRatio * RESIZER_SIZE)}px`;
    } else {
      style.minWidth = `${RESIZER_SIZE}px`;
      style.minHeight = `${Math.round(RESIZER_SIZE / this.#aspectRatio)}px`;
    }
  }

  static deserialize(data, parent) {
    const editor = super.deserialize(data, parent);
    editor.thickness = data.thickness;
    editor.color = _util.Util.makeHexColor(...data.color);
    editor.opacity = data.opacity;
    const [pageWidth, pageHeight] = parent.pageDimensions;
    const width = editor.width * pageWidth;
    const height = editor.height * pageHeight;
    const scaleFactor = parent.scaleFactor;
    const padding = data.thickness / 2;
    editor.#aspectRatio = width / height;
    editor.#disableEditing = true;
    editor.#realWidth = Math.round(width);
    editor.#realHeight = Math.round(height);

    for (const {
      bezier
    } of data.paths) {
      const path = [];
      editor.paths.push(path);
      let p0 = scaleFactor * (bezier[0] - padding);
      let p1 = scaleFactor * (height - bezier[1] - padding);

      for (let i = 2, ii = bezier.length; i < ii; i += 6) {
        const p10 = scaleFactor * (bezier[i] - padding);
        const p11 = scaleFactor * (height - bezier[i + 1] - padding);
        const p20 = scaleFactor * (bezier[i + 2] - padding);
        const p21 = scaleFactor * (height - bezier[i + 3] - padding);
        const p30 = scaleFactor * (bezier[i + 4] - padding);
        const p31 = scaleFactor * (height - bezier[i + 5] - padding);
        path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);
        p0 = p30;
        p1 = p31;
      }

      const path2D = this.#buildPath2D(path);
      editor.bezierPath2D.push(path2D);
    }

    const bbox = editor.#getBbox();
    editor.#baseWidth = Math.max(RESIZER_SIZE, bbox[2] - bbox[0]);
    editor.#baseHeight = Math.max(RESIZER_SIZE, bbox[3] - bbox[1]);
    editor.#setScaleFactor(width, height);
    return editor;
  }

  serialize() {
    if (this.isEmpty()) {
      return null;
    }

    const rect = this.getRect(0, 0);
    const height = this.rotation % 180 === 0 ? rect[3] - rect[1] : rect[2] - rect[0];

    const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);

    return {
      annotationType: _util.AnnotationEditorType.INK,
      color,
      thickness: this.thickness,
      opacity: this.opacity,
      paths: this.#serializePaths(this.scaleFactor / this.parent.scaleFactor, this.translationX, this.translationY, height),
      pageIndex: this.parent.pageIndex,
      rect,
      rotation: this.rotation
    };
  }

}

exports.InkEditor = InkEditor;

/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.fitCurve = void 0;

const fitCurve = __w_pdfjs_require__(26);

exports.fitCurve = fitCurve;

/***/ }),
/* 26 */
/***/ ((module) => {



function fitCurve(points, maxError, progressCallback) {
  if (!Array.isArray(points)) {
    throw new TypeError("First argument should be an array");
  }

  points.forEach(point => {
    if (!Array.isArray(point) || point.some(item => typeof item !== 'number') || point.length !== points[0].length) {
      throw Error("Each point should be an array of numbers. Each point should have the same amount of numbers.");
    }
  });
  points = points.filter((point, i) => i === 0 || !point.every((val, j) => val === points[i - 1][j]));

  if (points.length < 2) {
    return [];
  }

  const len = points.length;
  const leftTangent = createTangent(points[1], points[0]);
  const rightTangent = createTangent(points[len - 2], points[len - 1]);
  return fitCubic(points, leftTangent, rightTangent, maxError, progressCallback);
}

function fitCubic(points, leftTangent, rightTangent, error, progressCallback) {
  const MaxIterations = 20;
  var bezCurve, u, uPrime, maxError, prevErr, splitPoint, prevSplit, centerVector, toCenterTangent, fromCenterTangent, beziers, dist, i;

  if (points.length === 2) {
    dist = maths.vectorLen(maths.subtract(points[0], points[1])) / 3.0;
    bezCurve = [points[0], maths.addArrays(points[0], maths.mulItems(leftTangent, dist)), maths.addArrays(points[1], maths.mulItems(rightTangent, dist)), points[1]];
    return [bezCurve];
  }

  u = chordLengthParameterize(points);
  [bezCurve, maxError, splitPoint] = generateAndReport(points, u, u, leftTangent, rightTangent, progressCallback);

  if (maxError === 0 || maxError < error) {
    return [bezCurve];
  }

  if (maxError < error * error) {
    uPrime = u;
    prevErr = maxError;
    prevSplit = splitPoint;

    for (i = 0; i < MaxIterations; i++) {
      uPrime = reparameterize(bezCurve, points, uPrime);
      [bezCurve, maxError, splitPoint] = generateAndReport(points, u, uPrime, leftTangent, rightTangent, progressCallback);

      if (maxError < error) {
        return [bezCurve];
      } else if (splitPoint === prevSplit) {
        let errChange = maxError / prevErr;

        if (errChange > .9999 && errChange < 1.0001) {
          break;
        }
      }

      prevErr = maxError;
      prevSplit = splitPoint;
    }
  }

  beziers = [];
  centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint + 1]);

  if (centerVector.every(val => val === 0)) {
    centerVector = maths.subtract(points[splitPoint - 1], points[splitPoint]);
    [centerVector[0], centerVector[1]] = [-centerVector[1], centerVector[0]];
  }

  toCenterTangent = maths.normalize(centerVector);
  fromCenterTangent = maths.mulItems(toCenterTangent, -1);
  beziers = beziers.concat(fitCubic(points.slice(0, splitPoint + 1), leftTangent, toCenterTangent, error, progressCallback));
  beziers = beziers.concat(fitCubic(points.slice(splitPoint), fromCenterTangent, rightTangent, error, progressCallback));
  return beziers;
}

;

function generateAndReport(points, paramsOrig, paramsPrime, leftTangent, rightTangent, progressCallback) {
  var bezCurve, maxError, splitPoint;
  bezCurve = generateBezier(points, paramsPrime, leftTangent, rightTangent, progressCallback);
  [maxError, splitPoint] = computeMaxError(points, bezCurve, paramsOrig);

  if (progressCallback) {
    progressCallback({
      bez: bezCurve,
      points: points,
      params: paramsOrig,
      maxErr: maxError,
      maxPoint: splitPoint
    });
  }

  return [bezCurve, maxError, splitPoint];
}

function generateBezier(points, parameters, leftTangent, rightTangent) {
  var bezCurve,
      A,
      a,
      C,
      X,
      det_C0_C1,
      det_C0_X,
      det_X_C1,
      alpha_l,
      alpha_r,
      epsilon,
      segLength,
      i,
      len,
      tmp,
      u,
      ux,
      firstPoint = points[0],
      lastPoint = points[points.length - 1];
  bezCurve = [firstPoint, null, null, lastPoint];
  A = maths.zeros_Xx2x2(parameters.length);

  for (i = 0, len = parameters.length; i < len; i++) {
    u = parameters[i];
    ux = 1 - u;
    a = A[i];
    a[0] = maths.mulItems(leftTangent, 3 * u * (ux * ux));
    a[1] = maths.mulItems(rightTangent, 3 * ux * (u * u));
  }

  C = [[0, 0], [0, 0]];
  X = [0, 0];

  for (i = 0, len = points.length; i < len; i++) {
    u = parameters[i];
    a = A[i];
    C[0][0] += maths.dot(a[0], a[0]);
    C[0][1] += maths.dot(a[0], a[1]);
    C[1][0] += maths.dot(a[0], a[1]);
    C[1][1] += maths.dot(a[1], a[1]);
    tmp = maths.subtract(points[i], bezier.q([firstPoint, firstPoint, lastPoint, lastPoint], u));
    X[0] += maths.dot(a[0], tmp);
    X[1] += maths.dot(a[1], tmp);
  }

  det_C0_C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1];
  det_C0_X = C[0][0] * X[1] - C[1][0] * X[0];
  det_X_C1 = X[0] * C[1][1] - X[1] * C[0][1];
  alpha_l = det_C0_C1 === 0 ? 0 : det_X_C1 / det_C0_C1;
  alpha_r = det_C0_C1 === 0 ? 0 : det_C0_X / det_C0_C1;
  segLength = maths.vectorLen(maths.subtract(firstPoint, lastPoint));
  epsilon = 1.0e-6 * segLength;

  if (alpha_l < epsilon || alpha_r < epsilon) {
    bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, segLength / 3.0));
    bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, segLength / 3.0));
  } else {
    bezCurve[1] = maths.addArrays(firstPoint, maths.mulItems(leftTangent, alpha_l));
    bezCurve[2] = maths.addArrays(lastPoint, maths.mulItems(rightTangent, alpha_r));
  }

  return bezCurve;
}

;

function reparameterize(bezier, points, parameters) {
  return parameters.map((p, i) => newtonRaphsonRootFind(bezier, points[i], p));
}

;

function newtonRaphsonRootFind(bez, point, u) {
  var d = maths.subtract(bezier.q(bez, u), point),
      qprime = bezier.qprime(bez, u),
      numerator = maths.mulMatrix(d, qprime),
      denominator = maths.sum(maths.squareItems(qprime)) + 2 * maths.mulMatrix(d, bezier.qprimeprime(bez, u));

  if (denominator === 0) {
    return u;
  } else {
    return u - numerator / denominator;
  }
}

;

function chordLengthParameterize(points) {
  var u = [],
      currU,
      prevU,
      prevP;
  points.forEach((p, i) => {
    currU = i ? prevU + maths.vectorLen(maths.subtract(p, prevP)) : 0;
    u.push(currU);
    prevU = currU;
    prevP = p;
  });
  u = u.map(x => x / prevU);
  return u;
}

;

function computeMaxError(points, bez, parameters) {
  var dist, maxDist, splitPoint, v, i, count, point, t;
  maxDist = 0;
  splitPoint = Math.floor(points.length / 2);
  const t_distMap = mapTtoRelativeDistances(bez, 10);

  for (i = 0, count = points.length; i < count; i++) {
    point = points[i];
    t = find_t(bez, parameters[i], t_distMap, 10);
    v = maths.subtract(bezier.q(bez, t), point);
    dist = v[0] * v[0] + v[1] * v[1];

    if (dist > maxDist) {
      maxDist = dist;
      splitPoint = i;
    }
  }

  return [maxDist, splitPoint];
}

;

var mapTtoRelativeDistances = function (bez, B_parts) {
  var B_t_curr;
  var B_t_dist = [0];
  var B_t_prev = bez[0];
  var sumLen = 0;

  for (var i = 1; i <= B_parts; i++) {
    B_t_curr = bezier.q(bez, i / B_parts);
    sumLen += maths.vectorLen(maths.subtract(B_t_curr, B_t_prev));
    B_t_dist.push(sumLen);
    B_t_prev = B_t_curr;
  }

  B_t_dist = B_t_dist.map(x => x / sumLen);
  return B_t_dist;
};

function find_t(bez, param, t_distMap, B_parts) {
  if (param < 0) {
    return 0;
  }

  if (param > 1) {
    return 1;
  }

  var lenMax, lenMin, tMax, tMin, t;

  for (var i = 1; i <= B_parts; i++) {
    if (param <= t_distMap[i]) {
      tMin = (i - 1) / B_parts;
      tMax = i / B_parts;
      lenMin = t_distMap[i - 1];
      lenMax = t_distMap[i];
      t = (param - lenMin) / (lenMax - lenMin) * (tMax - tMin) + tMin;
      break;
    }
  }

  return t;
}

function createTangent(pointA, pointB) {
  return maths.normalize(maths.subtract(pointA, pointB));
}

class maths {
  static zeros_Xx2x2(x) {
    var zs = [];

    while (x--) {
      zs.push([0, 0]);
    }

    return zs;
  }

  static mulItems(items, multiplier) {
    return items.map(x => x * multiplier);
  }

  static mulMatrix(m1, m2) {
    return m1.reduce((sum, x1, i) => sum + x1 * m2[i], 0);
  }

  static subtract(arr1, arr2) {
    return arr1.map((x1, i) => x1 - arr2[i]);
  }

  static addArrays(arr1, arr2) {
    return arr1.map((x1, i) => x1 + arr2[i]);
  }

  static addItems(items, addition) {
    return items.map(x => x + addition);
  }

  static sum(items) {
    return items.reduce((sum, x) => sum + x);
  }

  static dot(m1, m2) {
    return maths.mulMatrix(m1, m2);
  }

  static vectorLen(v) {
    return Math.hypot(...v);
  }

  static divItems(items, divisor) {
    return items.map(x => x / divisor);
  }

  static squareItems(items) {
    return items.map(x => x * x);
  }

  static normalize(v) {
    return this.divItems(v, this.vectorLen(v));
  }

}

class bezier {
  static q(ctrlPoly, t) {
    var tx = 1.0 - t;
    var pA = maths.mulItems(ctrlPoly[0], tx * tx * tx),
        pB = maths.mulItems(ctrlPoly[1], 3 * tx * tx * t),
        pC = maths.mulItems(ctrlPoly[2], 3 * tx * t * t),
        pD = maths.mulItems(ctrlPoly[3], t * t * t);
    return maths.addArrays(maths.addArrays(pA, pB), maths.addArrays(pC, pD));
  }

  static qprime(ctrlPoly, t) {
    var tx = 1.0 - t;
    var pA = maths.mulItems(maths.subtract(ctrlPoly[1], ctrlPoly[0]), 3 * tx * tx),
        pB = maths.mulItems(maths.subtract(ctrlPoly[2], ctrlPoly[1]), 6 * tx * t),
        pC = maths.mulItems(maths.subtract(ctrlPoly[3], ctrlPoly[2]), 3 * t * t);
    return maths.addArrays(maths.addArrays(pA, pB), pC);
  }

  static qprimeprime(ctrlPoly, t) {
    return maths.addArrays(maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[2], maths.mulItems(ctrlPoly[1], 2)), ctrlPoly[0]), 6 * (1.0 - t)), maths.mulItems(maths.addArrays(maths.subtract(ctrlPoly[3], maths.mulItems(ctrlPoly[2], 2)), ctrlPoly[1]), 6 * t));
  }

}

module.exports = fitCurve;
module.exports.fitCubic = fitCubic;
module.exports.createTangent = createTangent;

/***/ }),
/* 27 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AnnotationLayer = void 0;

var _util = __w_pdfjs_require__(1);

var _display_utils = __w_pdfjs_require__(8);

var _annotation_storage = __w_pdfjs_require__(5);

var _scripting_utils = __w_pdfjs_require__(28);

var _xfa_layer = __w_pdfjs_require__(29);

const DEFAULT_TAB_INDEX = 1000;
const DEFAULT_FONT_SIZE = 9;
const GetElementsByNameSet = new WeakSet();

function getRectDims(rect) {
  return {
    width: rect[2] - rect[0],
    height: rect[3] - rect[1]
  };
}

class AnnotationElementFactory {
  static create(parameters) {
    const subtype = parameters.data.annotationType;

    switch (subtype) {
      case _util.AnnotationType.LINK:
        return new LinkAnnotationElement(parameters);

      case _util.AnnotationType.TEXT:
        return new TextAnnotationElement(parameters);

      case _util.AnnotationType.WIDGET:
        const fieldType = parameters.data.fieldType;

        switch (fieldType) {
          case "Tx":
            return new TextWidgetAnnotationElement(parameters);

          case "Btn":
            if (parameters.data.radioButton) {
              return new RadioButtonWidgetAnnotationElement(parameters);
            } else if (parameters.data.checkBox) {
              return new CheckboxWidgetAnnotationElement(parameters);
            }

            return new PushButtonWidgetAnnotationElement(parameters);

          case "Ch":
            return new ChoiceWidgetAnnotationElement(parameters);
        }

        return new WidgetAnnotationElement(parameters);

      case _util.AnnotationType.POPUP:
        return new PopupAnnotationElement(parameters);

      case _util.AnnotationType.FREETEXT:
        return new FreeTextAnnotationElement(parameters);

      case _util.AnnotationType.LINE:
        return new LineAnnotationElement(parameters);

      case _util.AnnotationType.SQUARE:
        return new SquareAnnotationElement(parameters);

      case _util.AnnotationType.CIRCLE:
        return new CircleAnnotationElement(parameters);

      case _util.AnnotationType.POLYLINE:
        return new PolylineAnnotationElement(parameters);

      case _util.AnnotationType.CARET:
        return new CaretAnnotationElement(parameters);

      case _util.AnnotationType.INK:
        return new InkAnnotationElement(parameters);

      case _util.AnnotationType.POLYGON:
        return new PolygonAnnotationElement(parameters);

      case _util.AnnotationType.HIGHLIGHT:
        return new HighlightAnnotationElement(parameters);

      case _util.AnnotationType.UNDERLINE:
        return new UnderlineAnnotationElement(parameters);

      case _util.AnnotationType.SQUIGGLY:
        return new SquigglyAnnotationElement(parameters);

      case _util.AnnotationType.STRIKEOUT:
        return new StrikeOutAnnotationElement(parameters);

      case _util.AnnotationType.STAMP:
        return new StampAnnotationElement(parameters);

      case _util.AnnotationType.FILEATTACHMENT:
        return new FileAttachmentAnnotationElement(parameters);

      default:
        return new AnnotationElement(parameters);
    }
  }

}

class AnnotationElement {
  constructor(parameters, {
    isRenderable = false,
    ignoreBorder = false,
    createQuadrilaterals = false
  } = {}) {
    this.isRenderable = isRenderable;
    this.data = parameters.data;
    this.layer = parameters.layer;
    this.page = parameters.page;
    this.viewport = parameters.viewport;
    this.linkService = parameters.linkService;
    this.downloadManager = parameters.downloadManager;
    this.imageResourcesPath = parameters.imageResourcesPath;
    this.renderForms = parameters.renderForms;
    this.svgFactory = parameters.svgFactory;
    this.annotationStorage = parameters.annotationStorage;
    this.enableScripting = parameters.enableScripting;
    this.hasJSActions = parameters.hasJSActions;
    this._fieldObjects = parameters.fieldObjects;
    this._mouseState = parameters.mouseState;

    if (isRenderable) {
      this.container = this._createContainer(ignoreBorder);
    }

    if (createQuadrilaterals) {
      this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
    }
  }

  _createContainer(ignoreBorder = false) {
    const data = this.data,
          page = this.page,
          viewport = this.viewport;
    const container = document.createElement("section");
    const {
      width,
      height
    } = getRectDims(data.rect);
    const [pageLLx, pageLLy, pageURx, pageURy] = viewport.viewBox;
    const pageWidth = pageURx - pageLLx;
    const pageHeight = pageURy - pageLLy;
    container.setAttribute("data-annotation-id", data.id);

    const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);

    if (!ignoreBorder && data.borderStyle.width > 0) {
      container.style.borderWidth = `${data.borderStyle.width}px`;
      const horizontalRadius = data.borderStyle.horizontalCornerRadius;
      const verticalRadius = data.borderStyle.verticalCornerRadius;

      if (horizontalRadius > 0 || verticalRadius > 0) {
        const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;
        container.style.borderRadius = radius;
      } else if (this instanceof RadioButtonWidgetAnnotationElement) {
        const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;
        container.style.borderRadius = radius;
      }

      switch (data.borderStyle.style) {
        case _util.AnnotationBorderStyleType.SOLID:
          container.style.borderStyle = "solid";
          break;

        case _util.AnnotationBorderStyleType.DASHED:
          container.style.borderStyle = "dashed";
          break;

        case _util.AnnotationBorderStyleType.BEVELED:
          (0, _util.warn)("Unimplemented border style: beveled");
          break;

        case _util.AnnotationBorderStyleType.INSET:
          (0, _util.warn)("Unimplemented border style: inset");
          break;

        case _util.AnnotationBorderStyleType.UNDERLINE:
          container.style.borderBottomStyle = "solid";
          break;

        default:
          break;
      }

      const borderColor = data.borderColor || null;

      if (borderColor) {
        container.style.borderColor = _util.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
      } else {
        container.style.borderWidth = 0;
      }
    }

    container.style.left = `${100 * (rect[0] - pageLLx) / pageWidth}%`;
    container.style.top = `${100 * (rect[1] - pageLLy) / pageHeight}%`;
    const {
      rotation
    } = data;

    if (data.hasOwnCanvas || rotation === 0) {
      container.style.width = `${100 * width / pageWidth}%`;
      container.style.height = `${100 * height / pageHeight}%`;
    } else {
      this.setRotation(rotation, container);
    }

    return container;
  }

  setRotation(angle, container = this.container) {
    const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
    const pageWidth = pageURx - pageLLx;
    const pageHeight = pageURy - pageLLy;
    const {
      width,
      height
    } = getRectDims(this.data.rect);
    let elementWidth, elementHeight;

    if (angle % 180 === 0) {
      elementWidth = 100 * width / pageWidth;
      elementHeight = 100 * height / pageHeight;
    } else {
      elementWidth = 100 * height / pageWidth;
      elementHeight = 100 * width / pageHeight;
    }

    container.style.width = `${elementWidth}%`;
    container.style.height = `${elementHeight}%`;
    container.setAttribute("data-main-rotation", (360 - angle) % 360);
  }

  get _commonActions() {
    const setColor = (jsName, styleName, event) => {
      const color = event.detail[jsName];
      event.target.style[styleName] = _scripting_utils.ColorConverters[`${color[0]}_HTML`](color.slice(1));
    };

    return (0, _util.shadow)(this, "_commonActions", {
      display: event => {
        const hidden = event.detail.display % 2 === 1;
        this.container.style.visibility = hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          hidden,
          print: event.detail.display === 0 || event.detail.display === 3
        });
      },
      print: event => {
        this.annotationStorage.setValue(this.data.id, {
          print: event.detail.print
        });
      },
      hidden: event => {
        this.container.style.visibility = event.detail.hidden ? "hidden" : "visible";
        this.annotationStorage.setValue(this.data.id, {
          hidden: event.detail.hidden
        });
      },
      focus: event => {
        setTimeout(() => event.target.focus({
          preventScroll: false
        }), 0);
      },
      userName: event => {
        event.target.title = event.detail.userName;
      },
      readonly: event => {
        if (event.detail.readonly) {
          event.target.setAttribute("readonly", "");
        } else {
          event.target.removeAttribute("readonly");
        }
      },
      required: event => {
        this._setRequired(event.target, event.detail.required);
      },
      bgColor: event => {
        setColor("bgColor", "backgroundColor", event);
      },
      fillColor: event => {
        setColor("fillColor", "backgroundColor", event);
      },
      fgColor: event => {
        setColor("fgColor", "color", event);
      },
      textColor: event => {
        setColor("textColor", "color", event);
      },
      borderColor: event => {
        setColor("borderColor", "borderColor", event);
      },
      strokeColor: event => {
        setColor("strokeColor", "borderColor", event);
      },
      rotation: event => {
        const angle = event.detail.rotation;
        this.setRotation(angle);
        this.annotationStorage.setValue(this.data.id, {
          rotation: angle
        });
      }
    });
  }

  _dispatchEventFromSandbox(actions, jsEvent) {
    const commonActions = this._commonActions;

    for (const name of Object.keys(jsEvent.detail)) {
      const action = actions[name] || commonActions[name];

      if (action) {
        action(jsEvent);
      }
    }
  }

  _setDefaultPropertiesFromJS(element) {
    if (!this.enableScripting) {
      return;
    }

    const storedData = this.annotationStorage.getRawValue(this.data.id);

    if (!storedData) {
      return;
    }

    const commonActions = this._commonActions;

    for (const [actionName, detail] of Object.entries(storedData)) {
      const action = commonActions[actionName];

      if (action) {
        const eventProxy = {
          detail: {
            [actionName]: detail
          },
          target: element
        };
        action(eventProxy);
        delete storedData[actionName];
      }
    }
  }

  _createQuadrilaterals(ignoreBorder = false) {
    if (!this.data.quadPoints) {
      return null;
    }

    const quadrilaterals = [];
    const savedRect = this.data.rect;

    for (const quadPoint of this.data.quadPoints) {
      this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
      quadrilaterals.push(this._createContainer(ignoreBorder));
    }

    this.data.rect = savedRect;
    return quadrilaterals;
  }

  _createPopup(trigger, data) {
    let container = this.container;

    if (this.quadrilaterals) {
      trigger = trigger || this.quadrilaterals;
      container = this.quadrilaterals[0];
    }

    if (!trigger) {
      trigger = document.createElement("div");
      trigger.className = "popupTriggerArea";
      container.append(trigger);
    }

    const popupElement = new PopupElement({
      container,
      trigger,
      color: data.color,
      titleObj: data.titleObj,
      modificationDate: data.modificationDate,
      contentsObj: data.contentsObj,
      richText: data.richText,
      hideWrapper: true
    });
    const popup = popupElement.render();
    popup.style.left = "100%";
    container.append(popup);
  }

  _renderQuadrilaterals(className) {
    for (const quadrilateral of this.quadrilaterals) {
      quadrilateral.className = className;
    }

    return this.quadrilaterals;
  }

  render() {
    (0, _util.unreachable)("Abstract method `AnnotationElement.render` called");
  }

  _getElementsByName(name, skipId = null) {
    const fields = [];

    if (this._fieldObjects) {
      const fieldObj = this._fieldObjects[name];

      if (fieldObj) {
        for (const {
          page,
          id,
          exportValues
        } of fieldObj) {
          if (page === -1) {
            continue;
          }

          if (id === skipId) {
            continue;
          }

          const exportValue = typeof exportValues === "string" ? exportValues : null;
          const domElement = document.querySelector(`[data-element-id="${id}"]`);

          if (domElement && !GetElementsByNameSet.has(domElement)) {
            (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`);
            continue;
          }

          fields.push({
            id,
            exportValue,
            domElement
          });
        }
      }

      return fields;
    }

    for (const domElement of document.getElementsByName(name)) {
      const {
        id,
        exportValue
      } = domElement;

      if (id === skipId) {
        continue;
      }

      if (!GetElementsByNameSet.has(domElement)) {
        continue;
      }

      fields.push({
        id,
        exportValue,
        domElement
      });
    }

    return fields;
  }

  static get platform() {
    const platform = typeof navigator !== "undefined" ? navigator.platform : "";
    return (0, _util.shadow)(this, "platform", {
      isWin: platform.includes("Win"),
      isMac: platform.includes("Mac")
    });
  }

}

class LinkAnnotationElement extends AnnotationElement {
  constructor(parameters, options = null) {
    super(parameters, {
      isRenderable: true,
      ignoreBorder: !!options?.ignoreBorder,
      createQuadrilaterals: true
    });
    this.isTooltipOnly = parameters.data.isTooltipOnly;
  }

  render() {
    const {
      data,
      linkService
    } = this;
    const link = document.createElement("a");
    link.setAttribute("data-element-id", data.id);
    let isBound = false;

    if (data.url) {
      linkService.addLinkAttributes(link, data.url, data.newWindow);
      isBound = true;
    } else if (data.action) {
      this._bindNamedAction(link, data.action);

      isBound = true;
    } else if (data.dest) {
      this._bindLink(link, data.dest);

      isBound = true;
    } else {
      if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
        this._bindJSAction(link, data);

        isBound = true;
      }

      if (data.resetForm) {
        this._bindResetFormAction(link, data.resetForm);

        isBound = true;
      } else if (this.isTooltipOnly && !isBound) {
        this._bindLink(link, "");

        isBound = true;
      }
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("linkAnnotation").map((quadrilateral, index) => {
        const linkElement = index === 0 ? link : link.cloneNode();
        quadrilateral.append(linkElement);
        return quadrilateral;
      });
    }

    this.container.className = "linkAnnotation";

    if (isBound) {
      this.container.append(link);
    }

    return this.container;
  }

  _bindLink(link, destination) {
    link.href = this.linkService.getDestinationHash(destination);

    link.onclick = () => {
      if (destination) {
        this.linkService.goToDestination(destination);
      }

      return false;
    };

    if (destination || destination === "") {
      link.className = "internalLink";
    }
  }

  _bindNamedAction(link, action) {
    link.href = this.linkService.getAnchorUrl("");

    link.onclick = () => {
      this.linkService.executeNamedAction(action);
      return false;
    };

    link.className = "internalLink";
  }

  _bindJSAction(link, data) {
    link.href = this.linkService.getAnchorUrl("");
    const map = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);

    for (const name of Object.keys(data.actions)) {
      const jsName = map.get(name);

      if (!jsName) {
        continue;
      }

      link[jsName] = () => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: data.id,
            name
          }
        });
        return false;
      };
    }

    if (!link.onclick) {
      link.onclick = () => false;
    }

    link.className = "internalLink";
  }

  _bindResetFormAction(link, resetForm) {
    const otherClickAction = link.onclick;

    if (!otherClickAction) {
      link.href = this.linkService.getAnchorUrl("");
    }

    link.className = "internalLink";

    if (!this._fieldObjects) {
      (0, _util.warn)(`_bindResetFormAction - "resetForm" action not supported, ` + "ensure that the `fieldObjects` parameter is provided.");

      if (!otherClickAction) {
        link.onclick = () => false;
      }

      return;
    }

    link.onclick = () => {
      if (otherClickAction) {
        otherClickAction();
      }

      const {
        fields: resetFormFields,
        refs: resetFormRefs,
        include
      } = resetForm;
      const allFields = [];

      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
        const fieldIds = new Set(resetFormRefs);

        for (const fieldName of resetFormFields) {
          const fields = this._fieldObjects[fieldName] || [];

          for (const {
            id
          } of fields) {
            fieldIds.add(id);
          }
        }

        for (const fields of Object.values(this._fieldObjects)) {
          for (const field of fields) {
            if (fieldIds.has(field.id) === include) {
              allFields.push(field);
            }
          }
        }
      } else {
        for (const fields of Object.values(this._fieldObjects)) {
          allFields.push(...fields);
        }
      }

      const storage = this.annotationStorage;
      const allIds = [];

      for (const field of allFields) {
        const {
          id
        } = field;
        allIds.push(id);

        switch (field.type) {
          case "text":
            {
              const value = field.defaultValue || "";
              storage.setValue(id, {
                value
              });
              break;
            }

          case "checkbox":
          case "radiobutton":
            {
              const value = field.defaultValue === field.exportValues;
              storage.setValue(id, {
                value
              });
              break;
            }

          case "combobox":
          case "listbox":
            {
              const value = field.defaultValue || "";
              storage.setValue(id, {
                value
              });
              break;
            }

          default:
            continue;
        }

        const domElement = document.querySelector(`[data-element-id="${id}"]`);

        if (!domElement) {
          continue;
        } else if (!GetElementsByNameSet.has(domElement)) {
          (0, _util.warn)(`_bindResetFormAction - element not allowed: ${id}`);
          continue;
        }

        domElement.dispatchEvent(new Event("resetform"));
      }

      if (this.enableScripting) {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: "app",
            ids: allIds,
            name: "ResetForm"
          }
        });
      }

      return false;
    };
  }

}

class TextAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable
    });
  }

  render() {
    this.container.className = "textAnnotation";
    const image = document.createElement("img");
    image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
    image.alt = "[{{type}} Annotation]";
    image.dataset.l10nId = "text_annotation_type";
    image.dataset.l10nArgs = JSON.stringify({
      type: this.data.name
    });

    if (!this.data.hasPopup) {
      this._createPopup(image, this.data);
    }

    this.container.append(image);
    return this.container;
  }

}

class WidgetAnnotationElement extends AnnotationElement {
  render() {
    if (this.data.alternativeText) {
      this.container.title = this.data.alternativeText;
    }

    return this.container;
  }

  _getKeyModifier(event) {
    const {
      isWin,
      isMac
    } = AnnotationElement.platform;
    return isWin && event.ctrlKey || isMac && event.metaKey;
  }

  _setEventListener(element, baseName, eventName, valueGetter) {
    if (baseName.includes("mouse")) {
      element.addEventListener(baseName, event => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event),
            shift: event.shiftKey,
            modifier: this._getKeyModifier(event)
          }
        });
      });
    } else {
      element.addEventListener(baseName, event => {
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id: this.data.id,
            name: eventName,
            value: valueGetter(event)
          }
        });
      });
    }
  }

  _setEventListeners(element, names, getter) {
    for (const [baseName, eventName] of names) {
      if (eventName === "Action" || this.data.actions?.[eventName]) {
        this._setEventListener(element, baseName, eventName, getter);
      }
    }
  }

  _setBackgroundColor(element) {
    const color = this.data.backgroundColor || null;
    element.style.backgroundColor = color === null ? "transparent" : _util.Util.makeHexColor(color[0], color[1], color[2]);
  }

  _setTextStyle(element) {
    const TEXT_ALIGNMENT = ["left", "center", "right"];
    const {
      fontColor
    } = this.data.defaultAppearanceData;
    const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;
    const style = element.style;
    let computedFontSize;

    if (this.data.multiLine) {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1]);
      const numberOfLines = Math.round(height / (_util.LINE_FACTOR * fontSize)) || 1;
      const lineHeight = height / numberOfLines;
      computedFontSize = Math.min(fontSize, Math.round(lineHeight / _util.LINE_FACTOR));
    } else {
      const height = Math.abs(this.data.rect[3] - this.data.rect[1]);
      computedFontSize = Math.min(fontSize, Math.round(height / _util.LINE_FACTOR));
    }

    style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;
    style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);

    if (this.data.textAlignment !== null) {
      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
    }
  }

  _setRequired(element, isRequired) {
    if (isRequired) {
      element.setAttribute("required", true);
    } else {
      element.removeAttribute("required");
    }

    element.setAttribute("aria-required", isRequired);
  }

}

class TextWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
    super(parameters, {
      isRenderable
    });
  }

  setPropertyOnSiblings(base, key, value, keyInStorage) {
    const storage = this.annotationStorage;

    for (const element of this._getElementsByName(base.name, base.id)) {
      if (element.domElement) {
        element.domElement[key] = value;
      }

      storage.setValue(element.id, {
        [keyInStorage]: value
      });
    }
  }

  render() {
    const storage = this.annotationStorage;
    const id = this.data.id;
    this.container.className = "textWidgetAnnotation";
    let element = null;

    if (this.renderForms) {
      const storedData = storage.getValue(id, {
        value: this.data.fieldValue
      });
      let textContent = storedData.formattedValue || storedData.value || "";
      const maxLen = storage.getValue(id, {
        charLimit: this.data.maxLen
      }).charLimit;

      if (maxLen && textContent.length > maxLen) {
        textContent = textContent.slice(0, maxLen);
      }

      const elementData = {
        userValue: textContent,
        formattedValue: null,
        valueOnFocus: ""
      };

      if (this.data.multiLine) {
        element = document.createElement("textarea");
        element.textContent = textContent;

        if (this.data.doNotScroll) {
          element.style.overflowY = "hidden";
        }
      } else {
        element = document.createElement("input");
        element.type = "text";
        element.setAttribute("value", textContent);

        if (this.data.doNotScroll) {
          element.style.overflowX = "hidden";
        }
      }

      GetElementsByNameSet.add(element);
      element.setAttribute("data-element-id", id);
      element.disabled = this.data.readOnly;
      element.name = this.data.fieldName;
      element.tabIndex = DEFAULT_TAB_INDEX;

      this._setRequired(element, this.data.required);

      if (maxLen) {
        element.maxLength = maxLen;
      }

      element.addEventListener("input", event => {
        storage.setValue(id, {
          value: event.target.value
        });
        this.setPropertyOnSiblings(element, "value", event.target.value, "value");
      });
      element.addEventListener("resetform", event => {
        const defaultValue = this.data.defaultFieldValue ?? "";
        element.value = elementData.userValue = defaultValue;
        elementData.formattedValue = null;
      });

      let blurListener = event => {
        const {
          formattedValue
        } = elementData;

        if (formattedValue !== null && formattedValue !== undefined) {
          event.target.value = formattedValue;
        }

        event.target.scrollLeft = 0;
      };

      if (this.enableScripting && this.hasJSActions) {
        element.addEventListener("focus", event => {
          if (elementData.userValue) {
            event.target.value = elementData.userValue;
          }

          elementData.valueOnFocus = event.target.value;
        });
        element.addEventListener("updatefromsandbox", jsEvent => {
          const actions = {
            value(event) {
              elementData.userValue = event.detail.value ?? "";
              storage.setValue(id, {
                value: elementData.userValue.toString()
              });
              event.target.value = elementData.userValue;
            },

            formattedValue(event) {
              const {
                formattedValue
              } = event.detail;
              elementData.formattedValue = formattedValue;

              if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {
                event.target.value = formattedValue;
              }

              storage.setValue(id, {
                formattedValue
              });
            },

            selRange(event) {
              event.target.setSelectionRange(...event.detail.selRange);
            },

            charLimit: event => {
              const {
                charLimit
              } = event.detail;
              const {
                target
              } = event;

              if (charLimit === 0) {
                target.removeAttribute("maxLength");
                return;
              }

              target.setAttribute("maxLength", charLimit);
              let value = elementData.userValue;

              if (!value || value.length <= charLimit) {
                return;
              }

              value = value.slice(0, charLimit);
              target.value = elementData.userValue = value;
              storage.setValue(id, {
                value
              });
              this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id,
                  name: "Keystroke",
                  value,
                  willCommit: true,
                  commitKey: 1,
                  selStart: target.selectionStart,
                  selEnd: target.selectionEnd
                }
              });
            }
          };

          this._dispatchEventFromSandbox(actions, jsEvent);
        });
        element.addEventListener("keydown", event => {
          let commitKey = -1;

          if (event.key === "Escape") {
            commitKey = 0;
          } else if (event.key === "Enter") {
            commitKey = 2;
          } else if (event.key === "Tab") {
            commitKey = 3;
          }

          if (commitKey === -1) {
            return;
          }

          const {
            value
          } = event.target;

          if (elementData.valueOnFocus === value) {
            return;
          }

          elementData.userValue = value;
          this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
            source: this,
            detail: {
              id,
              name: "Keystroke",
              value,
              willCommit: true,
              commitKey,
              selStart: event.target.selectionStart,
              selEnd: event.target.selectionEnd
            }
          });
        });
        const _blurListener = blurListener;
        blurListener = null;
        element.addEventListener("blur", event => {
          const {
            value
          } = event.target;
          elementData.userValue = value;

          if (this._mouseState.isDown && elementData.valueOnFocus !== value) {
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value,
                willCommit: true,
                commitKey: 1,
                selStart: event.target.selectionStart,
                selEnd: event.target.selectionEnd
              }
            });
          }

          _blurListener(event);
        });

        if (this.data.actions?.Keystroke) {
          element.addEventListener("beforeinput", event => {
            const {
              data,
              target
            } = event;
            const {
              value,
              selectionStart,
              selectionEnd
            } = target;
            let selStart = selectionStart,
                selEnd = selectionEnd;

            switch (event.inputType) {
              case "deleteWordBackward":
                {
                  const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);

                  if (match) {
                    selStart -= match[0].length;
                  }

                  break;
                }

              case "deleteWordForward":
                {
                  const match = value.substring(selectionStart).match(/^[^\w]*\w*/);

                  if (match) {
                    selEnd += match[0].length;
                  }

                  break;
                }

              case "deleteContentBackward":
                if (selectionStart === selectionEnd) {
                  selStart -= 1;
                }

                break;

              case "deleteContentForward":
                if (selectionStart === selectionEnd) {
                  selEnd += 1;
                }

                break;
            }

            event.preventDefault();
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value,
                change: data || "",
                willCommit: false,
                selStart,
                selEnd
              }
            });
          });
        }

        this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.value);
      }

      if (blurListener) {
        element.addEventListener("blur", blurListener);
      }

      if (this.data.comb) {
        const fieldWidth = this.data.rect[2] - this.data.rect[0];
        const combWidth = fieldWidth / maxLen;
        element.classList.add("comb");
        element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;
      }
    } else {
      element = document.createElement("div");
      element.textContent = this.data.fieldValue;
      element.style.verticalAlign = "middle";
      element.style.display = "table-cell";
    }

    this._setTextStyle(element);

    this._setBackgroundColor(element);

    this._setDefaultPropertiesFromJS(element);

    this.container.append(element);
    return this.container;
  }

}

class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }

  render() {
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.exportValue === data.fieldValue
    }).value;

    if (typeof value === "string") {
      value = value !== "Off";
      storage.setValue(id, {
        value
      });
    }

    this.container.className = "buttonWidgetAnnotation checkBox";
    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id);
    element.disabled = data.readOnly;

    this._setRequired(element, this.data.required);

    element.type = "checkbox";
    element.name = data.fieldName;

    if (value) {
      element.setAttribute("checked", true);
    }

    element.setAttribute("exportValue", data.exportValue);
    element.tabIndex = DEFAULT_TAB_INDEX;
    element.addEventListener("change", event => {
      const {
        name,
        checked
      } = event.target;

      for (const checkbox of this._getElementsByName(name, id)) {
        const curChecked = checked && checkbox.exportValue === data.exportValue;

        if (checkbox.domElement) {
          checkbox.domElement.checked = curChecked;
        }

        storage.setValue(checkbox.id, {
          value: curChecked
        });
      }

      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", event => {
      const defaultValue = data.defaultFieldValue || "Off";
      event.target.checked = defaultValue === data.exportValue;
    });

    if (this.enableScripting && this.hasJSActions) {
      element.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value(event) {
            event.target.checked = event.detail.value !== "Off";
            storage.setValue(id, {
              value: event.target.checked
            });
          }

        };

        this._dispatchEventFromSandbox(actions, jsEvent);
      });

      this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
    }

    this._setBackgroundColor(element);

    this._setDefaultPropertiesFromJS(element);

    this.container.append(element);
    return this.container;
  }

}

class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }

  render() {
    this.container.className = "buttonWidgetAnnotation radioButton";
    const storage = this.annotationStorage;
    const data = this.data;
    const id = data.id;
    let value = storage.getValue(id, {
      value: data.fieldValue === data.buttonValue
    }).value;

    if (typeof value === "string") {
      value = value !== data.buttonValue;
      storage.setValue(id, {
        value
      });
    }

    const element = document.createElement("input");
    GetElementsByNameSet.add(element);
    element.setAttribute("data-element-id", id);
    element.disabled = data.readOnly;

    this._setRequired(element, this.data.required);

    element.type = "radio";
    element.name = data.fieldName;

    if (value) {
      element.setAttribute("checked", true);
    }

    element.tabIndex = DEFAULT_TAB_INDEX;
    element.addEventListener("change", event => {
      const {
        name,
        checked
      } = event.target;

      for (const radio of this._getElementsByName(name, id)) {
        storage.setValue(radio.id, {
          value: false
        });
      }

      storage.setValue(id, {
        value: checked
      });
    });
    element.addEventListener("resetform", event => {
      const defaultValue = data.defaultFieldValue;
      event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;
    });

    if (this.enableScripting && this.hasJSActions) {
      const pdfButtonValue = data.buttonValue;
      element.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value: event => {
            const checked = pdfButtonValue === event.detail.value;

            for (const radio of this._getElementsByName(event.target.name)) {
              const curChecked = checked && radio.id === id;

              if (radio.domElement) {
                radio.domElement.checked = curChecked;
              }

              storage.setValue(radio.id, {
                value: curChecked
              });
            }
          }
        };

        this._dispatchEventFromSandbox(actions, jsEvent);
      });

      this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
    }

    this._setBackgroundColor(element);

    this._setDefaultPropertiesFromJS(element);

    this.container.append(element);
    return this.container;
  }

}

class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      ignoreBorder: parameters.data.hasAppearance
    });
  }

  render() {
    const container = super.render();
    container.className = "buttonWidgetAnnotation pushButton";

    if (this.data.alternativeText) {
      container.title = this.data.alternativeText;
    }

    const linkElement = container.lastChild;

    if (this.enableScripting && this.hasJSActions && linkElement) {
      this._setDefaultPropertiesFromJS(linkElement);

      linkElement.addEventListener("updatefromsandbox", jsEvent => {
        this._dispatchEventFromSandbox({}, jsEvent);
      });
    }

    return container;
  }

}

class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: parameters.renderForms
    });
  }

  render() {
    this.container.className = "choiceWidgetAnnotation";
    const storage = this.annotationStorage;
    const id = this.data.id;
    const storedData = storage.getValue(id, {
      value: this.data.fieldValue
    });
    const selectElement = document.createElement("select");
    GetElementsByNameSet.add(selectElement);
    selectElement.setAttribute("data-element-id", id);
    selectElement.disabled = this.data.readOnly;

    this._setRequired(selectElement, this.data.required);

    selectElement.name = this.data.fieldName;
    selectElement.tabIndex = DEFAULT_TAB_INDEX;
    let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;

    if (!this.data.combo) {
      selectElement.size = this.data.options.length;

      if (this.data.multiSelect) {
        selectElement.multiple = true;
      }
    }

    selectElement.addEventListener("resetform", event => {
      const defaultValue = this.data.defaultFieldValue;

      for (const option of selectElement.options) {
        option.selected = option.value === defaultValue;
      }
    });

    for (const option of this.data.options) {
      const optionElement = document.createElement("option");
      optionElement.textContent = option.displayValue;
      optionElement.value = option.exportValue;

      if (storedData.value.includes(option.exportValue)) {
        optionElement.setAttribute("selected", true);
        addAnEmptyEntry = false;
      }

      selectElement.append(optionElement);
    }

    let removeEmptyEntry = null;

    if (addAnEmptyEntry) {
      const noneOptionElement = document.createElement("option");
      noneOptionElement.value = " ";
      noneOptionElement.setAttribute("hidden", true);
      noneOptionElement.setAttribute("selected", true);
      selectElement.prepend(noneOptionElement);

      removeEmptyEntry = () => {
        noneOptionElement.remove();
        selectElement.removeEventListener("input", removeEmptyEntry);
        removeEmptyEntry = null;
      };

      selectElement.addEventListener("input", removeEmptyEntry);
    }

    const getValue = (event, isExport) => {
      const name = isExport ? "value" : "textContent";
      const options = event.target.options;

      if (!event.target.multiple) {
        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
      }

      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);
    };

    const getItems = event => {
      const options = event.target.options;
      return Array.prototype.map.call(options, option => {
        return {
          displayValue: option.textContent,
          exportValue: option.value
        };
      });
    };

    if (this.enableScripting && this.hasJSActions) {
      selectElement.addEventListener("updatefromsandbox", jsEvent => {
        const actions = {
          value(event) {
            removeEmptyEntry?.();
            const value = event.detail.value;
            const values = new Set(Array.isArray(value) ? value : [value]);

            for (const option of selectElement.options) {
              option.selected = values.has(option.value);
            }

            storage.setValue(id, {
              value: getValue(event, true)
            });
          },

          multipleSelection(event) {
            selectElement.multiple = true;
          },

          remove(event) {
            const options = selectElement.options;
            const index = event.detail.remove;
            options[index].selected = false;
            selectElement.remove(index);

            if (options.length > 0) {
              const i = Array.prototype.findIndex.call(options, option => option.selected);

              if (i === -1) {
                options[0].selected = true;
              }
            }

            storage.setValue(id, {
              value: getValue(event, true),
              items: getItems(event)
            });
          },

          clear(event) {
            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }

            storage.setValue(id, {
              value: null,
              items: []
            });
          },

          insert(event) {
            const {
              index,
              displayValue,
              exportValue
            } = event.detail.insert;
            const selectChild = selectElement.children[index];
            const optionElement = document.createElement("option");
            optionElement.textContent = displayValue;
            optionElement.value = exportValue;

            if (selectChild) {
              selectChild.before(optionElement);
            } else {
              selectElement.append(optionElement);
            }

            storage.setValue(id, {
              value: getValue(event, true),
              items: getItems(event)
            });
          },

          items(event) {
            const {
              items
            } = event.detail;

            while (selectElement.length !== 0) {
              selectElement.remove(0);
            }

            for (const item of items) {
              const {
                displayValue,
                exportValue
              } = item;
              const optionElement = document.createElement("option");
              optionElement.textContent = displayValue;
              optionElement.value = exportValue;
              selectElement.append(optionElement);
            }

            if (selectElement.options.length > 0) {
              selectElement.options[0].selected = true;
            }

            storage.setValue(id, {
              value: getValue(event, true),
              items: getItems(event)
            });
          },

          indices(event) {
            const indices = new Set(event.detail.indices);

            for (const option of event.target.options) {
              option.selected = indices.has(option.index);
            }

            storage.setValue(id, {
              value: getValue(event, true)
            });
          },

          editable(event) {
            event.target.disabled = !event.detail.editable;
          }

        };

        this._dispatchEventFromSandbox(actions, jsEvent);
      });
      selectElement.addEventListener("input", event => {
        const exportValue = getValue(event, true);
        const value = getValue(event, false);
        storage.setValue(id, {
          value: exportValue
        });
        this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
          source: this,
          detail: {
            id,
            name: "Keystroke",
            value,
            changeEx: exportValue,
            willCommit: true,
            commitKey: 1,
            keyDown: false
          }
        });
      });

      this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], event => event.target.checked);
    } else {
      selectElement.addEventListener("input", function (event) {
        storage.setValue(id, {
          value: getValue(event, true)
        });
      });
    }

    if (this.data.combo) {
      this._setTextStyle(selectElement);
    } else {}

    this._setBackgroundColor(selectElement);

    this._setDefaultPropertiesFromJS(selectElement);

    this.container.append(selectElement);
    return this.container;
  }

}

class PopupAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable
    });
  }

  render() {
    const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
    this.container.className = "popupAnnotation";

    if (IGNORE_TYPES.includes(this.data.parentType)) {
      return this.container;
    }

    const selector = `[data-annotation-id="${this.data.parentId}"]`;
    const parentElements = this.layer.querySelectorAll(selector);

    if (parentElements.length === 0) {
      return this.container;
    }

    const popup = new PopupElement({
      container: this.container,
      trigger: Array.from(parentElements),
      color: this.data.color,
      titleObj: this.data.titleObj,
      modificationDate: this.data.modificationDate,
      contentsObj: this.data.contentsObj,
      richText: this.data.richText
    });
    const page = this.page;

    const rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);

    const popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
    const popupTop = rect[1];
    const [pageLLx, pageLLy, pageURx, pageURy] = this.viewport.viewBox;
    const pageWidth = pageURx - pageLLx;
    const pageHeight = pageURy - pageLLy;
    this.container.style.left = `${100 * (popupLeft - pageLLx) / pageWidth}%`;
    this.container.style.top = `${100 * (popupTop - pageLLy) / pageHeight}%`;
    this.container.append(popup.render());
    return this.container;
  }

}

class PopupElement {
  constructor(parameters) {
    this.container = parameters.container;
    this.trigger = parameters.trigger;
    this.color = parameters.color;
    this.titleObj = parameters.titleObj;
    this.modificationDate = parameters.modificationDate;
    this.contentsObj = parameters.contentsObj;
    this.richText = parameters.richText;
    this.hideWrapper = parameters.hideWrapper || false;
    this.pinned = false;
  }

  render() {
    const BACKGROUND_ENLIGHT = 0.7;
    const wrapper = document.createElement("div");
    wrapper.className = "popupWrapper";
    this.hideElement = this.hideWrapper ? wrapper : this.container;
    this.hideElement.hidden = true;
    const popup = document.createElement("div");
    popup.className = "popup";
    const color = this.color;

    if (color) {
      const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
      const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
      const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
      popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);
    }

    const title = document.createElement("h1");
    title.dir = this.titleObj.dir;
    title.textContent = this.titleObj.str;
    popup.append(title);

    const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);

    if (dateObject) {
      const modificationDate = document.createElement("span");
      modificationDate.className = "popupDate";
      modificationDate.textContent = "{{date}}, {{time}}";
      modificationDate.dataset.l10nId = "annotation_date_string";
      modificationDate.dataset.l10nArgs = JSON.stringify({
        date: dateObject.toLocaleDateString(),
        time: dateObject.toLocaleTimeString()
      });
      popup.append(modificationDate);
    }

    if (this.richText?.str && (!this.contentsObj?.str || this.contentsObj.str === this.richText.str)) {
      _xfa_layer.XfaLayer.render({
        xfaHtml: this.richText.html,
        intent: "richText",
        div: popup
      });

      popup.lastChild.className = "richText popupContent";
    } else {
      const contents = this._formatContents(this.contentsObj);

      popup.append(contents);
    }

    if (!Array.isArray(this.trigger)) {
      this.trigger = [this.trigger];
    }

    for (const element of this.trigger) {
      element.addEventListener("click", this._toggle.bind(this));
      element.addEventListener("mouseover", this._show.bind(this, false));
      element.addEventListener("mouseout", this._hide.bind(this, false));
    }

    popup.addEventListener("click", this._hide.bind(this, true));
    wrapper.append(popup);
    return wrapper;
  }

  _formatContents({
    str,
    dir
  }) {
    const p = document.createElement("p");
    p.className = "popupContent";
    p.dir = dir;
    const lines = str.split(/(?:\r\n?|\n)/);

    for (let i = 0, ii = lines.length; i < ii; ++i) {
      const line = lines[i];
      p.append(document.createTextNode(line));

      if (i < ii - 1) {
        p.append(document.createElement("br"));
      }
    }

    return p;
  }

  _toggle() {
    if (this.pinned) {
      this._hide(true);
    } else {
      this._show(true);
    }
  }

  _show(pin = false) {
    if (pin) {
      this.pinned = true;
    }

    if (this.hideElement.hidden) {
      this.hideElement.hidden = false;
      this.container.style.zIndex = parseInt(this.container.style.zIndex) + 1000;
    }
  }

  _hide(unpin = true) {
    if (unpin) {
      this.pinned = false;
    }

    if (!this.hideElement.hidden && !this.pinned) {
      this.hideElement.hidden = true;
      this.container.style.zIndex = parseInt(this.container.style.zIndex) - 1000;
    }
  }

}

class FreeTextAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
    this.textContent = parameters.data.textContent;
  }

  render() {
    this.container.className = "freeTextAnnotation";

    if (this.textContent) {
      const content = document.createElement("div");
      content.className = "annotationTextContent";
      content.setAttribute("role", "comment");

      for (const line of this.textContent) {
        const lineSpan = document.createElement("span");
        lineSpan.textContent = line;
        content.append(lineSpan);
      }

      this.container.append(content);
    }

    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    return this.container;
  }

}

class LineAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "lineAnnotation";
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    const line = this.svgFactory.createElement("svg:line");
    line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
    line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
    line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
    line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
    line.setAttribute("stroke-width", data.borderStyle.width || 1);
    line.setAttribute("stroke", "transparent");
    line.setAttribute("fill", "transparent");
    svg.append(line);
    this.container.append(svg);

    this._createPopup(line, data);

    return this.container;
  }

}

class SquareAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "squareAnnotation";
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data.borderStyle.width;
    const square = this.svgFactory.createElement("svg:rect");
    square.setAttribute("x", borderWidth / 2);
    square.setAttribute("y", borderWidth / 2);
    square.setAttribute("width", width - borderWidth);
    square.setAttribute("height", height - borderWidth);
    square.setAttribute("stroke-width", borderWidth || 1);
    square.setAttribute("stroke", "transparent");
    square.setAttribute("fill", "transparent");
    svg.append(square);
    this.container.append(svg);

    this._createPopup(square, data);

    return this.container;
  }

}

class CircleAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "circleAnnotation";
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    const borderWidth = data.borderStyle.width;
    const circle = this.svgFactory.createElement("svg:ellipse");
    circle.setAttribute("cx", width / 2);
    circle.setAttribute("cy", height / 2);
    circle.setAttribute("rx", width / 2 - borderWidth / 2);
    circle.setAttribute("ry", height / 2 - borderWidth / 2);
    circle.setAttribute("stroke-width", borderWidth || 1);
    circle.setAttribute("stroke", "transparent");
    circle.setAttribute("fill", "transparent");
    svg.append(circle);
    this.container.append(svg);

    this._createPopup(circle, data);

    return this.container;
  }

}

class PolylineAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
    this.containerClassName = "polylineAnnotation";
    this.svgElementName = "svg:polyline";
  }

  render() {
    this.container.className = this.containerClassName;
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);
    let points = [];

    for (const coordinate of data.vertices) {
      const x = coordinate.x - data.rect[0];
      const y = data.rect[3] - coordinate.y;
      points.push(x + "," + y);
    }

    points = points.join(" ");
    const polyline = this.svgFactory.createElement(this.svgElementName);
    polyline.setAttribute("points", points);
    polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
    polyline.setAttribute("stroke", "transparent");
    polyline.setAttribute("fill", "transparent");
    svg.append(polyline);
    this.container.append(svg);

    this._createPopup(polyline, data);

    return this.container;
  }

}

class PolygonAnnotationElement extends PolylineAnnotationElement {
  constructor(parameters) {
    super(parameters);
    this.containerClassName = "polygonAnnotation";
    this.svgElementName = "svg:polygon";
  }

}

class CaretAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "caretAnnotation";

    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    return this.container;
  }

}

class InkAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
    this.containerClassName = "inkAnnotation";
    this.svgElementName = "svg:polyline";
  }

  render() {
    this.container.className = this.containerClassName;
    const data = this.data;
    const {
      width,
      height
    } = getRectDims(data.rect);
    const svg = this.svgFactory.create(width, height, true);

    for (const inkList of data.inkLists) {
      let points = [];

      for (const coordinate of inkList) {
        const x = coordinate.x - data.rect[0];
        const y = data.rect[3] - coordinate.y;
        points.push(`${x},${y}`);
      }

      points = points.join(" ");
      const polyline = this.svgFactory.createElement(this.svgElementName);
      polyline.setAttribute("points", points);
      polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
      polyline.setAttribute("stroke", "transparent");
      polyline.setAttribute("fill", "transparent");

      this._createPopup(polyline, data);

      svg.append(polyline);
    }

    this.container.append(svg);
    return this.container;
  }

}

class HighlightAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("highlightAnnotation");
    }

    this.container.className = "highlightAnnotation";
    return this.container;
  }

}

class UnderlineAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("underlineAnnotation");
    }

    this.container.className = "underlineAnnotation";
    return this.container;
  }

}

class SquigglyAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("squigglyAnnotation");
    }

    this.container.className = "squigglyAnnotation";
    return this.container;
  }

}

class StrikeOutAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true,
      createQuadrilaterals: true
    });
  }

  render() {
    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    if (this.quadrilaterals) {
      return this._renderQuadrilaterals("strikeoutAnnotation");
    }

    this.container.className = "strikeoutAnnotation";
    return this.container;
  }

}

class StampAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    const isRenderable = !!(parameters.data.hasPopup || parameters.data.titleObj?.str || parameters.data.contentsObj?.str || parameters.data.richText?.str);
    super(parameters, {
      isRenderable,
      ignoreBorder: true
    });
  }

  render() {
    this.container.className = "stampAnnotation";

    if (!this.data.hasPopup) {
      this._createPopup(null, this.data);
    }

    return this.container;
  }

}

class FileAttachmentAnnotationElement extends AnnotationElement {
  constructor(parameters) {
    super(parameters, {
      isRenderable: true
    });
    const {
      filename,
      content
    } = this.data.file;
    this.filename = (0, _display_utils.getFilenameFromUrl)(filename);
    this.content = content;
    this.linkService.eventBus?.dispatch("fileattachmentannotation", {
      source: this,
      filename,
      content
    });
  }

  render() {
    this.container.className = "fileAttachmentAnnotation";
    const trigger = document.createElement("div");
    trigger.className = "popupTriggerArea";
    trigger.addEventListener("dblclick", this._download.bind(this));

    if (!this.data.hasPopup && (this.data.titleObj?.str || this.data.contentsObj?.str || this.data.richText)) {
      this._createPopup(trigger, this.data);
    }

    this.container.append(trigger);
    return this.container;
  }

  _download() {
    this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);
  }

}

class AnnotationLayer {
  static #appendElement(element, id, div, accessibilityManager) {
    const contentElement = element.firstChild || element;
    contentElement.id = `${_display_utils.AnnotationPrefix}${id}`;
    div.append(element);
    accessibilityManager?.moveElementInDOM(div, element, contentElement, false);
  }

  static render(parameters) {
    const {
      annotations,
      div,
      viewport,
      accessibilityManager
    } = parameters;
    this.#setDimensions(div, viewport);
    let zIndex = 0;

    for (const data of annotations) {
      if (data.annotationType !== _util.AnnotationType.POPUP) {
        const {
          width,
          height
        } = getRectDims(data.rect);

        if (width <= 0 || height <= 0) {
          continue;
        }
      }

      const element = AnnotationElementFactory.create({
        data,
        layer: div,
        page: parameters.page,
        viewport,
        linkService: parameters.linkService,
        downloadManager: parameters.downloadManager,
        imageResourcesPath: parameters.imageResourcesPath || "",
        renderForms: parameters.renderForms !== false,
        svgFactory: new _display_utils.DOMSVGFactory(),
        annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),
        enableScripting: parameters.enableScripting,
        hasJSActions: parameters.hasJSActions,
        fieldObjects: parameters.fieldObjects,
        mouseState: parameters.mouseState || {
          isDown: false
        }
      });

      if (element.isRenderable) {
        const rendered = element.render();

        if (data.hidden) {
          rendered.style.visibility = "hidden";
        }

        if (Array.isArray(rendered)) {
          for (const renderedElement of rendered) {
            renderedElement.style.zIndex = zIndex++;
            AnnotationLayer.#appendElement(renderedElement, data.id, div, accessibilityManager);
          }
        } else {
          rendered.style.zIndex = zIndex++;

          if (element instanceof PopupAnnotationElement) {
            div.prepend(rendered);
          } else {
            AnnotationLayer.#appendElement(rendered, data.id, div, accessibilityManager);
          }
        }
      }
    }

    this.#setAnnotationCanvasMap(div, parameters.annotationCanvasMap);
  }

  static update(parameters) {
    const {
      annotationCanvasMap,
      div,
      viewport
    } = parameters;
    this.#setDimensions(div, viewport);
    this.#setAnnotationCanvasMap(div, annotationCanvasMap);
    div.hidden = false;
  }

  static #setDimensions(div, {
    width,
    height,
    rotation
  }) {
    const {
      style
    } = div;
    const flipOrientation = rotation % 180 !== 0,
          widthStr = Math.floor(width) + "px",
          heightStr = Math.floor(height) + "px";
    style.width = flipOrientation ? heightStr : widthStr;
    style.height = flipOrientation ? widthStr : heightStr;
    div.setAttribute("data-main-rotation", rotation);
  }

  static #setAnnotationCanvasMap(div, annotationCanvasMap) {
    if (!annotationCanvasMap) {
      return;
    }

    for (const [id, canvas] of annotationCanvasMap) {
      const element = div.querySelector(`[data-annotation-id="${id}"]`);

      if (!element) {
        continue;
      }

      const {
        firstChild
      } = element;

      if (!firstChild) {
        element.append(canvas);
      } else if (firstChild.nodeName === "CANVAS") {
        firstChild.replaceWith(canvas);
      } else {
        firstChild.before(canvas);
      }
    }

    annotationCanvasMap.clear();
  }

}

exports.AnnotationLayer = AnnotationLayer;

/***/ }),
/* 28 */
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ColorConverters = void 0;

function makeColorComp(n) {
  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
}

class ColorConverters {
  static CMYK_G([c, y, m, k]) {
    return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
  }

  static G_CMYK([g]) {
    return ["CMYK", 0, 0, 0, 1 - g];
  }

  static G_RGB([g]) {
    return ["RGB", g, g, g];
  }

  static G_HTML([g]) {
    const G = makeColorComp(g);
    return `#${G}${G}${G}`;
  }

  static RGB_G([r, g, b]) {
    return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
  }

  static RGB_HTML([r, g, b]) {
    const R = makeColorComp(r);
    const G = makeColorComp(g);
    const B = makeColorComp(b);
    return `#${R}${G}${B}`;
  }

  static T_HTML() {
    return "#00000000";
  }

  static CMYK_RGB([c, y, m, k]) {
    return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
  }

  static CMYK_HTML(components) {
    const rgb = this.CMYK_RGB(components).slice(1);
    return this.RGB_HTML(rgb);
  }

  static RGB_CMYK([r, g, b]) {
    const c = 1 - r;
    const m = 1 - g;
    const y = 1 - b;
    const k = Math.min(c, m, y);
    return ["CMYK", c, m, y, k];
  }

}

exports.ColorConverters = ColorConverters;

/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.XfaLayer = void 0;

var _xfa_text = __w_pdfjs_require__(20);

class XfaLayer {
  static setupStorage(html, id, element, storage, intent) {
    const storedData = storage.getValue(id, {
      value: null
    });

    switch (element.name) {
      case "textarea":
        if (storedData.value !== null) {
          html.textContent = storedData.value;
        }

        if (intent === "print") {
          break;
        }

        html.addEventListener("input", event => {
          storage.setValue(id, {
            value: event.target.value
          });
        });
        break;

      case "input":
        if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
          if (storedData.value === element.attributes.xfaOn) {
            html.setAttribute("checked", true);
          } else if (storedData.value === element.attributes.xfaOff) {
            html.removeAttribute("checked");
          }

          if (intent === "print") {
            break;
          }

          html.addEventListener("change", event => {
            storage.setValue(id, {
              value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
            });
          });
        } else {
          if (storedData.value !== null) {
            html.setAttribute("value", storedData.value);
          }

          if (intent === "print") {
            break;
          }

          html.addEventListener("input", event => {
            storage.setValue(id, {
              value: event.target.value
            });
          });
        }

        break;

      case "select":
        if (storedData.value !== null) {
          for (const option of element.children) {
            if (option.attributes.value === storedData.value) {
              option.attributes.selected = true;
            }
          }
        }

        html.addEventListener("input", event => {
          const options = event.target.options;
          const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
          storage.setValue(id, {
            value
          });
        });
        break;
    }
  }

  static setAttributes({
    html,
    element,
    storage = null,
    intent,
    linkService
  }) {
    const {
      attributes
    } = element;
    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;

    if (attributes.type === "radio") {
      attributes.name = `${attributes.name}-${intent}`;
    }

    for (const [key, value] of Object.entries(attributes)) {
      if (value === null || value === undefined) {
        continue;
      }

      switch (key) {
        case "class":
          if (value.length) {
            html.setAttribute(key, value.join(" "));
          }

          break;

        case "dataId":
          break;

        case "id":
          html.setAttribute("data-element-id", value);
          break;

        case "style":
          Object.assign(html.style, value);
          break;

        case "textContent":
          html.textContent = value;
          break;

        default:
          if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
            html.setAttribute(key, value);
          }

      }
    }

    if (isHTMLAnchorElement) {
      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
    }

    if (storage && attributes.dataId) {
      this.setupStorage(html, attributes.dataId, element, storage);
    }
  }

  static render(parameters) {
    const storage = parameters.annotationStorage;
    const linkService = parameters.linkService;
    const root = parameters.xfaHtml;
    const intent = parameters.intent || "display";
    const rootHtml = document.createElement(root.name);

    if (root.attributes) {
      this.setAttributes({
        html: rootHtml,
        element: root,
        intent,
        linkService
      });
    }

    const stack = [[root, -1, rootHtml]];
    const rootDiv = parameters.div;
    rootDiv.append(rootHtml);

    if (parameters.viewport) {
      const transform = `matrix(${parameters.viewport.transform.join(",")})`;
      rootDiv.style.transform = transform;
    }

    if (intent !== "richText") {
      rootDiv.setAttribute("class", "xfaLayer xfaFont");
    }

    const textDivs = [];

    while (stack.length > 0) {
      const [parent, i, html] = stack.at(-1);

      if (i + 1 === parent.children.length) {
        stack.pop();
        continue;
      }

      const child = parent.children[++stack.at(-1)[1]];

      if (child === null) {
        continue;
      }

      const {
        name
      } = child;

      if (name === "#text") {
        const node = document.createTextNode(child.value);
        textDivs.push(node);
        html.append(node);
        continue;
      }

      let childHtml;

      if (child?.attributes?.xmlns) {
        childHtml = document.createElementNS(child.attributes.xmlns, name);
      } else {
        childHtml = document.createElement(name);
      }

      html.append(childHtml);

      if (child.attributes) {
        this.setAttributes({
          html: childHtml,
          element: child,
          storage,
          intent,
          linkService
        });
      }

      if (child.children && child.children.length > 0) {
        stack.push([child, -1, childHtml]);
      } else if (child.value) {
        const node = document.createTextNode(child.value);

        if (_xfa_text.XfaText.shouldBuildText(name)) {
          textDivs.push(node);
        }

        childHtml.append(node);
      }
    }

    for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
      el.setAttribute("readOnly", true);
    }

    return {
      textDivs
    };
  }

  static update(parameters) {
    const transform = `matrix(${parameters.viewport.transform.join(",")})`;
    parameters.div.style.transform = transform;
    parameters.div.hidden = false;
  }

}

exports.XfaLayer = XfaLayer;

/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.TextLayerRenderTask = void 0;
exports.renderTextLayer = renderTextLayer;

var _util = __w_pdfjs_require__(1);

var _display_utils = __w_pdfjs_require__(8);

const MAX_TEXT_DIVS_TO_RENDER = 100000;
const DEFAULT_FONT_SIZE = 30;
const DEFAULT_FONT_ASCENT = 0.8;
const ascentCache = new Map();
const AllWhitespaceRegexp = /^\s+$/g;

function getAscent(fontFamily, ctx) {
  const cachedAscent = ascentCache.get(fontFamily);

  if (cachedAscent) {
    return cachedAscent;
  }

  ctx.save();
  ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;
  const metrics = ctx.measureText("");
  let ascent = metrics.fontBoundingBoxAscent;
  let descent = Math.abs(metrics.fontBoundingBoxDescent);

  if (ascent) {
    ctx.restore();
    const ratio = ascent / (ascent + descent);
    ascentCache.set(fontFamily, ratio);
    return ratio;
  }

  ctx.strokeStyle = "red";
  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
  ctx.strokeText("g", 0, 0);
  let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
  descent = 0;

  for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {
    if (pixels[i] > 0) {
      descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
      break;
    }
  }

  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
  ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
  pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
  ascent = 0;

  for (let i = 0, ii = pixels.length; i < ii; i += 4) {
    if (pixels[i] > 0) {
      ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);
      break;
    }
  }

  ctx.restore();

  if (ascent) {
    const ratio = ascent / (ascent + descent);
    ascentCache.set(fontFamily, ratio);
    return ratio;
  }

  ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
  return DEFAULT_FONT_ASCENT;
}

function appendText(task, geom, styles, ctx) {
  const textDiv = document.createElement("span");
  const textDivProperties = task._enhanceTextSelection ? {
    angle: 0,
    canvasWidth: 0,
    hasText: geom.str !== "",
    hasEOL: geom.hasEOL,
    originalTransform: null,
    paddingBottom: 0,
    paddingLeft: 0,
    paddingRight: 0,
    paddingTop: 0,
    scale: 1,
    fontSize: 0
  } : {
    angle: 0,
    canvasWidth: 0,
    hasText: geom.str !== "",
    hasEOL: geom.hasEOL,
    fontSize: 0
  };

  task._textDivs.push(textDiv);

  const tx = _util.Util.transform(task._viewport.transform, geom.transform);

  let angle = Math.atan2(tx[1], tx[0]);
  const style = styles[geom.fontName];

  if (style.vertical) {
    angle += Math.PI / 2;
  }

  const fontHeight = Math.hypot(tx[2], tx[3]);
  const fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
  let left, top;

  if (angle === 0) {
    left = tx[4];
    top = tx[5] - fontAscent;
  } else {
    left = tx[4] + fontAscent * Math.sin(angle);
    top = tx[5] - fontAscent * Math.cos(angle);
  }

  textDiv.style.left = `${left}px`;
  textDiv.style.top = `${top}px`;
  textDiv.style.fontSize = `${fontHeight}px`;
  textDiv.style.fontFamily = style.fontFamily;
  textDivProperties.fontSize = fontHeight;
  textDiv.setAttribute("role", "presentation");
  textDiv.textContent = geom.str;
  textDiv.dir = geom.dir;

  if (task._fontInspectorEnabled) {
    textDiv.dataset.fontName = geom.fontName;
  }

  if (angle !== 0) {
    textDivProperties.angle = angle * (180 / Math.PI);
  }

  let shouldScaleText = false;

  if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {
    shouldScaleText = true;
  } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
    const absScaleX = Math.abs(geom.transform[0]),
          absScaleY = Math.abs(geom.transform[3]);

    if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
      shouldScaleText = true;
    }
  }

  if (shouldScaleText) {
    if (style.vertical) {
      textDivProperties.canvasWidth = geom.height * task._viewport.scale;
    } else {
      textDivProperties.canvasWidth = geom.width * task._viewport.scale;
    }
  }

  task._textDivProperties.set(textDiv, textDivProperties);

  if (task._textContentStream) {
    task._layoutText(textDiv);
  }

  if (task._enhanceTextSelection && textDivProperties.hasText) {
    let angleCos = 1,
        angleSin = 0;

    if (angle !== 0) {
      angleCos = Math.cos(angle);
      angleSin = Math.sin(angle);
    }

    const divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
    const divHeight = fontHeight;
    let m, b;

    if (angle !== 0) {
      m = [angleCos, angleSin, -angleSin, angleCos, left, top];
      b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
    } else {
      b = [left, top, left + divWidth, top + divHeight];
    }

    task._bounds.push({
      left: b[0],
      top: b[1],
      right: b[2],
      bottom: b[3],
      div: textDiv,
      size: [divWidth, divHeight],
      m
    });
  }
}

function render(task) {
  if (task._canceled) {
    return;
  }

  const textDivs = task._textDivs;
  const capability = task._capability;
  const textDivsLength = textDivs.length;

  if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
    task._renderingDone = true;
    capability.resolve();
    return;
  }

  if (!task._textContentStream) {
    for (let i = 0; i < textDivsLength; i++) {
      task._layoutText(textDivs[i]);
    }
  }

  task._renderingDone = true;
  capability.resolve();
}

function findPositiveMin(ts, offset, count) {
  let result = 0;

  for (let i = 0; i < count; i++) {
    const t = ts[offset++];

    if (t > 0) {
      result = result ? Math.min(t, result) : t;
    }
  }

  return result;
}

function expand(task) {
  const bounds = task._bounds;
  const viewport = task._viewport;
  const expanded = expandBounds(viewport.width, viewport.height, bounds);

  for (let i = 0; i < expanded.length; i++) {
    const div = bounds[i].div;

    const divProperties = task._textDivProperties.get(div);

    if (divProperties.angle === 0) {
      divProperties.paddingLeft = bounds[i].left - expanded[i].left;
      divProperties.paddingTop = bounds[i].top - expanded[i].top;
      divProperties.paddingRight = expanded[i].right - bounds[i].right;
      divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;

      task._textDivProperties.set(div, divProperties);

      continue;
    }

    const e = expanded[i],
          b = bounds[i];
    const m = b.m,
          c = m[0],
          s = m[1];
    const points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
    const ts = new Float64Array(64);

    for (let j = 0, jj = points.length; j < jj; j++) {
      const t = _util.Util.applyTransform(points[j], m);

      ts[j + 0] = c && (e.left - t[0]) / c;
      ts[j + 4] = s && (e.top - t[1]) / s;
      ts[j + 8] = c && (e.right - t[0]) / c;
      ts[j + 12] = s && (e.bottom - t[1]) / s;
      ts[j + 16] = s && (e.left - t[0]) / -s;
      ts[j + 20] = c && (e.top - t[1]) / c;
      ts[j + 24] = s && (e.right - t[0]) / -s;
      ts[j + 28] = c && (e.bottom - t[1]) / c;
      ts[j + 32] = c && (e.left - t[0]) / -c;
      ts[j + 36] = s && (e.top - t[1]) / -s;
      ts[j + 40] = c && (e.right - t[0]) / -c;
      ts[j + 44] = s && (e.bottom - t[1]) / -s;
      ts[j + 48] = s && (e.left - t[0]) / s;
      ts[j + 52] = c && (e.top - t[1]) / -c;
      ts[j + 56] = s && (e.right - t[0]) / s;
      ts[j + 60] = c && (e.bottom - t[1]) / -c;
    }

    const boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
    divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
    divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
    divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
    divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;

    task._textDivProperties.set(div, divProperties);
  }
}

function expandBounds(width, height, boxes) {
  const bounds = boxes.map(function (box, i) {
    return {
      x1: box.left,
      y1: box.top,
      x2: box.right,
      y2: box.bottom,
      index: i,
      x1New: undefined,
      x2New: undefined
    };
  });
  expandBoundsLTR(width, bounds);
  const expanded = new Array(boxes.length);

  for (const b of bounds) {
    const i = b.index;
    expanded[i] = {
      left: b.x1New,
      top: 0,
      right: b.x2New,
      bottom: 0
    };
  }

  boxes.map(function (box, i) {
    const e = expanded[i],
          b = bounds[i];
    b.x1 = box.top;
    b.y1 = width - e.right;
    b.x2 = box.bottom;
    b.y2 = width - e.left;
    b.index = i;
    b.x1New = undefined;
    b.x2New = undefined;
  });
  expandBoundsLTR(height, bounds);

  for (const b of bounds) {
    const i = b.index;
    expanded[i].top = b.x1New;
    expanded[i].bottom = b.x2New;
  }

  return expanded;
}

function expandBoundsLTR(width, bounds) {
  bounds.sort(function (a, b) {
    return a.x1 - b.x1 || a.index - b.index;
  });
  const fakeBoundary = {
    x1: -Infinity,
    y1: -Infinity,
    x2: 0,
    y2: Infinity,
    index: -1,
    x1New: 0,
    x2New: 0
  };
  const horizon = [{
    start: -Infinity,
    end: Infinity,
    boundary: fakeBoundary
  }];

  for (const boundary of bounds) {
    let i = 0;

    while (i < horizon.length && horizon[i].end <= boundary.y1) {
      i++;
    }

    let j = horizon.length - 1;

    while (j >= 0 && horizon[j].start >= boundary.y2) {
      j--;
    }

    let horizonPart, affectedBoundary;
    let q,
        k,
        maxXNew = -Infinity;

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;
      let xNew;

      if (affectedBoundary.x2 > boundary.x1) {
        xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;
      } else if (affectedBoundary.x2New === undefined) {
        xNew = (affectedBoundary.x2 + boundary.x1) / 2;
      } else {
        xNew = affectedBoundary.x2New;
      }

      if (xNew > maxXNew) {
        maxXNew = xNew;
      }
    }

    boundary.x1New = maxXNew;

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;

      if (affectedBoundary.x2New === undefined) {
        if (affectedBoundary.x2 > boundary.x1) {
          if (affectedBoundary.index > boundary.index) {
            affectedBoundary.x2New = affectedBoundary.x2;
          }
        } else {
          affectedBoundary.x2New = maxXNew;
        }
      } else if (affectedBoundary.x2New > maxXNew) {
        affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);
      }
    }

    const changedHorizon = [];
    let lastBoundary = null;

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;
      const useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;

      if (lastBoundary === useBoundary) {
        changedHorizon.at(-1).end = horizonPart.end;
      } else {
        changedHorizon.push({
          start: horizonPart.start,
          end: horizonPart.end,
          boundary: useBoundary
        });
        lastBoundary = useBoundary;
      }
    }

    if (horizon[i].start < boundary.y1) {
      changedHorizon[0].start = boundary.y1;
      changedHorizon.unshift({
        start: horizon[i].start,
        end: boundary.y1,
        boundary: horizon[i].boundary
      });
    }

    if (boundary.y2 < horizon[j].end) {
      changedHorizon.at(-1).end = boundary.y2;
      changedHorizon.push({
        start: boundary.y2,
        end: horizon[j].end,
        boundary: horizon[j].boundary
      });
    }

    for (q = i; q <= j; q++) {
      horizonPart = horizon[q];
      affectedBoundary = horizonPart.boundary;

      if (affectedBoundary.x2New !== undefined) {
        continue;
      }

      let used = false;

      for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {
        used = horizon[k].boundary === affectedBoundary;
      }

      for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {
        used = horizon[k].boundary === affectedBoundary;
      }

      for (k = 0; !used && k < changedHorizon.length; k++) {
        used = changedHorizon[k].boundary === affectedBoundary;
      }

      if (!used) {
        affectedBoundary.x2New = maxXNew;
      }
    }

    Array.prototype.splice.apply(horizon, [i, j - i + 1, ...changedHorizon]);
  }

  for (const horizonPart of horizon) {
    const affectedBoundary = horizonPart.boundary;

    if (affectedBoundary.x2New === undefined) {
      affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
    }
  }
}

class TextLayerRenderTask {
  constructor({
    textContent,
    textContentStream,
    container,
    viewport,
    textDivs,
    textContentItemsStr,
    enhanceTextSelection
  }) {
    if (enhanceTextSelection) {
      (0, _display_utils.deprecated)("The `enhanceTextSelection` functionality will be removed in the future.");
    }

    this._textContent = textContent;
    this._textContentStream = textContentStream;
    this._container = container;
    this._document = container.ownerDocument;
    this._viewport = viewport;
    this._textDivs = textDivs || [];
    this._textContentItemsStr = textContentItemsStr || [];
    this._enhanceTextSelection = !!enhanceTextSelection;
    this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;
    this._reader = null;
    this._layoutTextLastFontSize = null;
    this._layoutTextLastFontFamily = null;
    this._layoutTextCtx = null;
    this._textDivProperties = new WeakMap();
    this._renderingDone = false;
    this._canceled = false;
    this._capability = (0, _util.createPromiseCapability)();
    this._renderTimer = null;
    this._bounds = [];
    this._devicePixelRatio = globalThis.devicePixelRatio || 1;

    this._capability.promise.finally(() => {
      if (!this._enhanceTextSelection) {
        this._textDivProperties = null;
      }

      if (this._layoutTextCtx) {
        this._layoutTextCtx.canvas.width = 0;
        this._layoutTextCtx.canvas.height = 0;
        this._layoutTextCtx = null;
      }
    }).catch(() => {});
  }

  get promise() {
    return this._capability.promise;
  }

  cancel() {
    this._canceled = true;

    if (this._reader) {
      this._reader.cancel(new _util.AbortException("TextLayer task cancelled.")).catch(() => {});

      this._reader = null;
    }

    if (this._renderTimer !== null) {
      clearTimeout(this._renderTimer);
      this._renderTimer = null;
    }

    this._capability.reject(new Error("TextLayer task cancelled."));
  }

  _processItems(items, styleCache) {
    for (let i = 0, len = items.length; i < len; i++) {
      if (items[i].str === undefined) {
        if (items[i].type === "beginMarkedContentProps" || items[i].type === "beginMarkedContent") {
          const parent = this._container;
          this._container = document.createElement("span");

          this._container.classList.add("markedContent");

          if (items[i].id !== null) {
            this._container.setAttribute("id", `${items[i].id}`);
          }

          parent.append(this._container);
        } else if (items[i].type === "endMarkedContent") {
          this._container = this._container.parentNode;
        }

        continue;
      }

      this._textContentItemsStr.push(items[i].str);

      appendText(this, items[i], styleCache, this._layoutTextCtx);
    }
  }

  _layoutText(textDiv) {
    const textDivProperties = this._textDivProperties.get(textDiv);

    let transform = "";

    if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {
      const {
        fontFamily
      } = textDiv.style;
      const {
        fontSize
      } = textDivProperties;

      if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
        this._layoutTextCtx.font = `${fontSize * this._devicePixelRatio}px ${fontFamily}`;
        this._layoutTextLastFontSize = fontSize;
        this._layoutTextLastFontFamily = fontFamily;
      }

      const {
        width
      } = this._layoutTextCtx.measureText(textDiv.textContent);

      if (width > 0) {
        const scale = this._devicePixelRatio * textDivProperties.canvasWidth / width;

        if (this._enhanceTextSelection) {
          textDivProperties.scale = scale;
        }

        transform = `scaleX(${scale})`;
      }
    }

    if (textDivProperties.angle !== 0) {
      transform = `rotate(${textDivProperties.angle}deg) ${transform}`;
    }

    if (transform.length > 0) {
      if (this._enhanceTextSelection) {
        textDivProperties.originalTransform = transform;
      }

      textDiv.style.transform = transform;
    }

    if (textDivProperties.hasText) {
      this._container.append(textDiv);
    }

    if (textDivProperties.hasEOL) {
      const br = document.createElement("br");
      br.setAttribute("role", "presentation");

      this._container.append(br);
    }
  }

  _render(timeout = 0) {
    const capability = (0, _util.createPromiseCapability)();
    let styleCache = Object.create(null);

    const canvas = this._document.createElement("canvas");

    canvas.height = canvas.width = DEFAULT_FONT_SIZE;
    this._layoutTextCtx = canvas.getContext("2d", {
      alpha: false
    });

    if (this._textContent) {
      const textItems = this._textContent.items;
      const textStyles = this._textContent.styles;

      this._processItems(textItems, textStyles);

      capability.resolve();
    } else if (this._textContentStream) {
      const pump = () => {
        this._reader.read().then(({
          value,
          done
        }) => {
          if (done) {
            capability.resolve();
            return;
          }

          Object.assign(styleCache, value.styles);

          this._processItems(value.items, styleCache);

          pump();
        }, capability.reject);
      };

      this._reader = this._textContentStream.getReader();
      pump();
    } else {
      throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
    }

    capability.promise.then(() => {
      styleCache = null;

      if (!timeout) {
        render(this);
      } else {
        this._renderTimer = setTimeout(() => {
          render(this);
          this._renderTimer = null;
        }, timeout);
      }
    }, this._capability.reject);
  }

  expandTextDivs(expandDivs = false) {
    if (!this._enhanceTextSelection || !this._renderingDone) {
      return;
    }

    if (this._bounds !== null) {
      expand(this);
      this._bounds = null;
    }

    const transformBuf = [],
          paddingBuf = [];

    for (let i = 0, ii = this._textDivs.length; i < ii; i++) {
      const div = this._textDivs[i];

      const divProps = this._textDivProperties.get(div);

      if (!divProps.hasText) {
        continue;
      }

      if (expandDivs) {
        transformBuf.length = 0;
        paddingBuf.length = 0;

        if (divProps.originalTransform) {
          transformBuf.push(divProps.originalTransform);
        }

        if (divProps.paddingTop > 0) {
          paddingBuf.push(`${divProps.paddingTop}px`);
          transformBuf.push(`translateY(${-divProps.paddingTop}px)`);
        } else {
          paddingBuf.push(0);
        }

        if (divProps.paddingRight > 0) {
          paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`);
        } else {
          paddingBuf.push(0);
        }

        if (divProps.paddingBottom > 0) {
          paddingBuf.push(`${divProps.paddingBottom}px`);
        } else {
          paddingBuf.push(0);
        }

        if (divProps.paddingLeft > 0) {
          paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`);
          transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`);
        } else {
          paddingBuf.push(0);
        }

        div.style.padding = paddingBuf.join(" ");

        if (transformBuf.length) {
          div.style.transform = transformBuf.join(" ");
        }
      } else {
        div.style.padding = null;
        div.style.transform = divProps.originalTransform;
      }
    }
  }

}

exports.TextLayerRenderTask = TextLayerRenderTask;

function renderTextLayer(renderParameters) {
  const task = new TextLayerRenderTask({
    textContent: renderParameters.textContent,
    textContentStream: renderParameters.textContentStream,
    container: renderParameters.container,
    viewport: renderParameters.viewport,
    textDivs: renderParameters.textDivs,
    textContentItemsStr: renderParameters.textContentItemsStr,
    enhanceTextSelection: renderParameters.enhanceTextSelection
  });

  task._render(renderParameters.timeout);

  return task;
}

/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SVGGraphics = void 0;

var _display_utils = __w_pdfjs_require__(8);

var _util = __w_pdfjs_require__(1);

var _is_node = __w_pdfjs_require__(3);

let SVGGraphics = class {
  constructor() {
    (0, _util.unreachable)("Not implemented: SVGGraphics");
  }

};
exports.SVGGraphics = SVGGraphics;
{
  const SVG_DEFAULTS = {
    fontStyle: "normal",
    fontWeight: "normal",
    fillColor: "#000000"
  };
  const XML_NS = "http://www.w3.org/XML/1998/namespace";
  const XLINK_NS = "http://www.w3.org/1999/xlink";
  const LINE_CAP_STYLES = ["butt", "round", "square"];
  const LINE_JOIN_STYLES = ["miter", "round", "bevel"];

  const createObjectURL = function (data, contentType = "", forceDataSchema = false) {
    if (URL.createObjectURL && typeof Blob !== "undefined" && !forceDataSchema) {
      return URL.createObjectURL(new Blob([data], {
        type: contentType
      }));
    }

    const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let buffer = `data:${contentType};base64,`;

    for (let i = 0, ii = data.length; i < ii; i += 3) {
      const b1 = data[i] & 0xff;
      const b2 = data[i + 1] & 0xff;
      const b3 = data[i + 2] & 0xff;
      const d1 = b1 >> 2,
            d2 = (b1 & 3) << 4 | b2 >> 4;
      const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;
      const d4 = i + 2 < ii ? b3 & 0x3f : 64;
      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
    }

    return buffer;
  };

  const convertImgDataToPng = function () {
    const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
    const CHUNK_WRAPPER_SIZE = 12;
    const crcTable = new Int32Array(256);

    for (let i = 0; i < 256; i++) {
      let c = i;

      for (let h = 0; h < 8; h++) {
        if (c & 1) {
          c = 0xedb88320 ^ c >> 1 & 0x7fffffff;
        } else {
          c = c >> 1 & 0x7fffffff;
        }
      }

      crcTable[i] = c;
    }

    function crc32(data, start, end) {
      let crc = -1;

      for (let i = start; i < end; i++) {
        const a = (crc ^ data[i]) & 0xff;
        const b = crcTable[a];
        crc = crc >>> 8 ^ b;
      }

      return crc ^ -1;
    }

    function writePngChunk(type, body, data, offset) {
      let p = offset;
      const len = body.length;
      data[p] = len >> 24 & 0xff;
      data[p + 1] = len >> 16 & 0xff;
      data[p + 2] = len >> 8 & 0xff;
      data[p + 3] = len & 0xff;
      p += 4;
      data[p] = type.charCodeAt(0) & 0xff;
      data[p + 1] = type.charCodeAt(1) & 0xff;
      data[p + 2] = type.charCodeAt(2) & 0xff;
      data[p + 3] = type.charCodeAt(3) & 0xff;
      p += 4;
      data.set(body, p);
      p += body.length;
      const crc = crc32(data, offset + 4, p);
      data[p] = crc >> 24 & 0xff;
      data[p + 1] = crc >> 16 & 0xff;
      data[p + 2] = crc >> 8 & 0xff;
      data[p + 3] = crc & 0xff;
    }

    function adler32(data, start, end) {
      let a = 1;
      let b = 0;

      for (let i = start; i < end; ++i) {
        a = (a + (data[i] & 0xff)) % 65521;
        b = (b + a) % 65521;
      }

      return b << 16 | a;
    }

    function deflateSync(literals) {
      if (!_is_node.isNodeJS) {
        return deflateSyncUncompressed(literals);
      }

      try {
        let input;

        if (parseInt(process.versions.node) >= 8) {
          input = literals;
        } else {
          input = Buffer.from(literals);
        }

        const output = (__webpack_require__(35).deflateSync)(input, {
          level: 9
        });

        return output instanceof Uint8Array ? output : new Uint8Array(output);
      } catch (e) {
        (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
      }

      return deflateSyncUncompressed(literals);
    }

    function deflateSyncUncompressed(literals) {
      let len = literals.length;
      const maxBlockLength = 0xffff;
      const deflateBlocks = Math.ceil(len / maxBlockLength);
      const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
      let pi = 0;
      idat[pi++] = 0x78;
      idat[pi++] = 0x9c;
      let pos = 0;

      while (len > maxBlockLength) {
        idat[pi++] = 0x00;
        idat[pi++] = 0xff;
        idat[pi++] = 0xff;
        idat[pi++] = 0x00;
        idat[pi++] = 0x00;
        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
        pi += maxBlockLength;
        pos += maxBlockLength;
        len -= maxBlockLength;
      }

      idat[pi++] = 0x01;
      idat[pi++] = len & 0xff;
      idat[pi++] = len >> 8 & 0xff;
      idat[pi++] = ~len & 0xffff & 0xff;
      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
      idat.set(literals.subarray(pos), pi);
      pi += literals.length - pos;
      const adler = adler32(literals, 0, literals.length);
      idat[pi++] = adler >> 24 & 0xff;
      idat[pi++] = adler >> 16 & 0xff;
      idat[pi++] = adler >> 8 & 0xff;
      idat[pi++] = adler & 0xff;
      return idat;
    }

    function encode(imgData, kind, forceDataSchema, isMask) {
      const width = imgData.width;
      const height = imgData.height;
      let bitDepth, colorType, lineSize;
      const bytes = imgData.data;

      switch (kind) {
        case _util.ImageKind.GRAYSCALE_1BPP:
          colorType = 0;
          bitDepth = 1;
          lineSize = width + 7 >> 3;
          break;

        case _util.ImageKind.RGB_24BPP:
          colorType = 2;
          bitDepth = 8;
          lineSize = width * 3;
          break;

        case _util.ImageKind.RGBA_32BPP:
          colorType = 6;
          bitDepth = 8;
          lineSize = width * 4;
          break;

        default:
          throw new Error("invalid format");
      }

      const literals = new Uint8Array((1 + lineSize) * height);
      let offsetLiterals = 0,
          offsetBytes = 0;

      for (let y = 0; y < height; ++y) {
        literals[offsetLiterals++] = 0;
        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
        offsetBytes += lineSize;
        offsetLiterals += lineSize;
      }

      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {
        offsetLiterals = 0;

        for (let y = 0; y < height; y++) {
          offsetLiterals++;

          for (let i = 0; i < lineSize; i++) {
            literals[offsetLiterals++] ^= 0xff;
          }
        }
      }

      const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
      const idat = deflateSync(literals);
      const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
      const data = new Uint8Array(pngLength);
      let offset = 0;
      data.set(PNG_HEADER, offset);
      offset += PNG_HEADER.length;
      writePngChunk("IHDR", ihdr, data, offset);
      offset += CHUNK_WRAPPER_SIZE + ihdr.length;
      writePngChunk("IDATA", idat, data, offset);
      offset += CHUNK_WRAPPER_SIZE + idat.length;
      writePngChunk("IEND", new Uint8Array(0), data, offset);
      return createObjectURL(data, "image/png", forceDataSchema);
    }

    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {
      const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
      return encode(imgData, kind, forceDataSchema, isMask);
    };
  }();

  class SVGExtraState {
    constructor() {
      this.fontSizeScale = 1;
      this.fontWeight = SVG_DEFAULTS.fontWeight;
      this.fontSize = 0;
      this.textMatrix = _util.IDENTITY_MATRIX;
      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
      this.leading = 0;
      this.textRenderingMode = _util.TextRenderingMode.FILL;
      this.textMatrixScale = 1;
      this.x = 0;
      this.y = 0;
      this.lineX = 0;
      this.lineY = 0;
      this.charSpacing = 0;
      this.wordSpacing = 0;
      this.textHScale = 1;
      this.textRise = 0;
      this.fillColor = SVG_DEFAULTS.fillColor;
      this.strokeColor = "#000000";
      this.fillAlpha = 1;
      this.strokeAlpha = 1;
      this.lineWidth = 1;
      this.lineJoin = "";
      this.lineCap = "";
      this.miterLimit = 0;
      this.dashArray = [];
      this.dashPhase = 0;
      this.dependencies = [];
      this.activeClipUrl = null;
      this.clipGroup = null;
      this.maskId = "";
    }

    clone() {
      return Object.create(this);
    }

    setCurrentPoint(x, y) {
      this.x = x;
      this.y = y;
    }

  }

  function opListToTree(opList) {
    let opTree = [];
    const tmp = [];

    for (const opListElement of opList) {
      if (opListElement.fn === "save") {
        opTree.push({
          fnId: 92,
          fn: "group",
          items: []
        });
        tmp.push(opTree);
        opTree = opTree.at(-1).items;
        continue;
      }

      if (opListElement.fn === "restore") {
        opTree = tmp.pop();
      } else {
        opTree.push(opListElement);
      }
    }

    return opTree;
  }

  function pf(value) {
    if (Number.isInteger(value)) {
      return value.toString();
    }

    const s = value.toFixed(10);
    let i = s.length - 1;

    if (s[i] !== "0") {
      return s;
    }

    do {
      i--;
    } while (s[i] === "0");

    return s.substring(0, s[i] === "." ? i : i + 1);
  }

  function pm(m) {
    if (m[4] === 0 && m[5] === 0) {
      if (m[1] === 0 && m[2] === 0) {
        if (m[0] === 1 && m[3] === 1) {
          return "";
        }

        return `scale(${pf(m[0])} ${pf(m[3])})`;
      }

      if (m[0] === m[3] && m[1] === -m[2]) {
        const a = Math.acos(m[0]) * 180 / Math.PI;
        return `rotate(${pf(a)})`;
      }
    } else {
      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
        return `translate(${pf(m[4])} ${pf(m[5])})`;
      }
    }

    return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;
  }

  let clipCount = 0;
  let maskCount = 0;
  let shadingCount = 0;
  exports.SVGGraphics = SVGGraphics = class {
    constructor(commonObjs, objs, forceDataSchema = false) {
      (0, _display_utils.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future.");
      this.svgFactory = new _display_utils.DOMSVGFactory();
      this.current = new SVGExtraState();
      this.transformMatrix = _util.IDENTITY_MATRIX;
      this.transformStack = [];
      this.extraStack = [];
      this.commonObjs = commonObjs;
      this.objs = objs;
      this.pendingClip = null;
      this.pendingEOFill = false;
      this.embedFonts = false;
      this.embeddedFonts = Object.create(null);
      this.cssStyle = null;
      this.forceDataSchema = !!forceDataSchema;
      this._operatorIdMapping = [];

      for (const op in _util.OPS) {
        this._operatorIdMapping[_util.OPS[op]] = op;
      }
    }

    save() {
      this.transformStack.push(this.transformMatrix);
      const old = this.current;
      this.extraStack.push(old);
      this.current = old.clone();
    }

    restore() {
      this.transformMatrix = this.transformStack.pop();
      this.current = this.extraStack.pop();
      this.pendingClip = null;
      this.tgrp = null;
    }

    group(items) {
      this.save();
      this.executeOpTree(items);
      this.restore();
    }

    loadDependencies(operatorList) {
      const fnArray = operatorList.fnArray;
      const argsArray = operatorList.argsArray;

      for (let i = 0, ii = fnArray.length; i < ii; i++) {
        if (fnArray[i] !== _util.OPS.dependency) {
          continue;
        }

        for (const obj of argsArray[i]) {
          const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs;
          const promise = new Promise(resolve => {
            objsPool.get(obj, resolve);
          });
          this.current.dependencies.push(promise);
        }
      }

      return Promise.all(this.current.dependencies);
    }

    transform(a, b, c, d, e, f) {
      const transformMatrix = [a, b, c, d, e, f];
      this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
      this.tgrp = null;
    }

    getSVG(operatorList, viewport) {
      this.viewport = viewport;

      const svgElement = this._initialize(viewport);

      return this.loadDependencies(operatorList).then(() => {
        this.transformMatrix = _util.IDENTITY_MATRIX;
        this.executeOpTree(this.convertOpList(operatorList));
        return svgElement;
      });
    }

    convertOpList(operatorList) {
      const operatorIdMapping = this._operatorIdMapping;
      const argsArray = operatorList.argsArray;
      const fnArray = operatorList.fnArray;
      const opList = [];

      for (let i = 0, ii = fnArray.length; i < ii; i++) {
        const fnId = fnArray[i];
        opList.push({
          fnId,
          fn: operatorIdMapping[fnId],
          args: argsArray[i]
        });
      }

      return opListToTree(opList);
    }

    executeOpTree(opTree) {
      for (const opTreeElement of opTree) {
        const fn = opTreeElement.fn;
        const fnId = opTreeElement.fnId;
        const args = opTreeElement.args;

        switch (fnId | 0) {
          case _util.OPS.beginText:
            this.beginText();
            break;

          case _util.OPS.dependency:
            break;

          case _util.OPS.setLeading:
            this.setLeading(args);
            break;

          case _util.OPS.setLeadingMoveText:
            this.setLeadingMoveText(args[0], args[1]);
            break;

          case _util.OPS.setFont:
            this.setFont(args);
            break;

          case _util.OPS.showText:
            this.showText(args[0]);
            break;

          case _util.OPS.showSpacedText:
            this.showText(args[0]);
            break;

          case _util.OPS.endText:
            this.endText();
            break;

          case _util.OPS.moveText:
            this.moveText(args[0], args[1]);
            break;

          case _util.OPS.setCharSpacing:
            this.setCharSpacing(args[0]);
            break;

          case _util.OPS.setWordSpacing:
            this.setWordSpacing(args[0]);
            break;

          case _util.OPS.setHScale:
            this.setHScale(args[0]);
            break;

          case _util.OPS.setTextMatrix:
            this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
            break;

          case _util.OPS.setTextRise:
            this.setTextRise(args[0]);
            break;

          case _util.OPS.setTextRenderingMode:
            this.setTextRenderingMode(args[0]);
            break;

          case _util.OPS.setLineWidth:
            this.setLineWidth(args[0]);
            break;

          case _util.OPS.setLineJoin:
            this.setLineJoin(args[0]);
            break;

          case _util.OPS.setLineCap:
            this.setLineCap(args[0]);
            break;

          case _util.OPS.setMiterLimit:
            this.setMiterLimit(args[0]);
            break;

          case _util.OPS.setFillRGBColor:
            this.setFillRGBColor(args[0], args[1], args[2]);
            break;

          case _util.OPS.setStrokeRGBColor:
            this.setStrokeRGBColor(args[0], args[1], args[2]);
            break;

          case _util.OPS.setStrokeColorN:
            this.setStrokeColorN(args);
            break;

          case _util.OPS.setFillColorN:
            this.setFillColorN(args);
            break;

          case _util.OPS.shadingFill:
            this.shadingFill(args[0]);
            break;

          case _util.OPS.setDash:
            this.setDash(args[0], args[1]);
            break;

          case _util.OPS.setRenderingIntent:
            this.setRenderingIntent(args[0]);
            break;

          case _util.OPS.setFlatness:
            this.setFlatness(args[0]);
            break;

          case _util.OPS.setGState:
            this.setGState(args[0]);
            break;

          case _util.OPS.fill:
            this.fill();
            break;

          case _util.OPS.eoFill:
            this.eoFill();
            break;

          case _util.OPS.stroke:
            this.stroke();
            break;

          case _util.OPS.fillStroke:
            this.fillStroke();
            break;

          case _util.OPS.eoFillStroke:
            this.eoFillStroke();
            break;

          case _util.OPS.clip:
            this.clip("nonzero");
            break;

          case _util.OPS.eoClip:
            this.clip("evenodd");
            break;

          case _util.OPS.paintSolidColorImageMask:
            this.paintSolidColorImageMask();
            break;

          case _util.OPS.paintImageXObject:
            this.paintImageXObject(args[0]);
            break;

          case _util.OPS.paintInlineImageXObject:
            this.paintInlineImageXObject(args[0]);
            break;

          case _util.OPS.paintImageMaskXObject:
            this.paintImageMaskXObject(args[0]);
            break;

          case _util.OPS.paintFormXObjectBegin:
            this.paintFormXObjectBegin(args[0], args[1]);
            break;

          case _util.OPS.paintFormXObjectEnd:
            this.paintFormXObjectEnd();
            break;

          case _util.OPS.closePath:
            this.closePath();
            break;

          case _util.OPS.closeStroke:
            this.closeStroke();
            break;

          case _util.OPS.closeFillStroke:
            this.closeFillStroke();
            break;

          case _util.OPS.closeEOFillStroke:
            this.closeEOFillStroke();
            break;

          case _util.OPS.nextLine:
            this.nextLine();
            break;

          case _util.OPS.transform:
            this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
            break;

          case _util.OPS.constructPath:
            this.constructPath(args[0], args[1]);
            break;

          case _util.OPS.endPath:
            this.endPath();
            break;

          case 92:
            this.group(opTreeElement.items);
            break;

          default:
            (0, _util.warn)(`Unimplemented operator ${fn}`);
            break;
        }
      }
    }

    setWordSpacing(wordSpacing) {
      this.current.wordSpacing = wordSpacing;
    }

    setCharSpacing(charSpacing) {
      this.current.charSpacing = charSpacing;
    }

    nextLine() {
      this.moveText(0, this.current.leading);
    }

    setTextMatrix(a, b, c, d, e, f) {
      const current = this.current;
      current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
      current.textMatrixScale = Math.hypot(a, b);
      current.x = current.lineX = 0;
      current.y = current.lineY = 0;
      current.xcoords = [];
      current.ycoords = [];
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
      current.tspan.setAttributeNS(null, "y", pf(-current.y));
      current.txtElement = this.svgFactory.createElement("svg:text");
      current.txtElement.append(current.tspan);
    }

    beginText() {
      const current = this.current;
      current.x = current.lineX = 0;
      current.y = current.lineY = 0;
      current.textMatrix = _util.IDENTITY_MATRIX;
      current.lineMatrix = _util.IDENTITY_MATRIX;
      current.textMatrixScale = 1;
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.txtElement = this.svgFactory.createElement("svg:text");
      current.txtgrp = this.svgFactory.createElement("svg:g");
      current.xcoords = [];
      current.ycoords = [];
    }

    moveText(x, y) {
      const current = this.current;
      current.x = current.lineX += x;
      current.y = current.lineY += y;
      current.xcoords = [];
      current.ycoords = [];
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);
      current.tspan.setAttributeNS(null, "y", pf(-current.y));
    }

    showText(glyphs) {
      const current = this.current;
      const font = current.font;
      const fontSize = current.fontSize;

      if (fontSize === 0) {
        return;
      }

      const fontSizeScale = current.fontSizeScale;
      const charSpacing = current.charSpacing;
      const wordSpacing = current.wordSpacing;
      const fontDirection = current.fontDirection;
      const textHScale = current.textHScale * fontDirection;
      const vertical = font.vertical;
      const spacingDir = vertical ? 1 : -1;
      const defaultVMetrics = font.defaultVMetrics;
      const widthAdvanceScale = fontSize * current.fontMatrix[0];
      let x = 0;

      for (const glyph of glyphs) {
        if (glyph === null) {
          x += fontDirection * wordSpacing;
          continue;
        } else if (typeof glyph === "number") {
          x += spacingDir * glyph * fontSize / 1000;
          continue;
        }

        const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
        const character = glyph.fontChar;
        let scaledX, scaledY;
        let width = glyph.width;

        if (vertical) {
          let vx;
          const vmetric = glyph.vmetric || defaultVMetrics;
          vx = glyph.vmetric ? vmetric[1] : width * 0.5;
          vx = -vx * widthAdvanceScale;
          const vy = vmetric[2] * widthAdvanceScale;
          width = vmetric ? -vmetric[0] : width;
          scaledX = vx / fontSizeScale;
          scaledY = (x + vy) / fontSizeScale;
        } else {
          scaledX = x / fontSizeScale;
          scaledY = 0;
        }

        if (glyph.isInFont || font.missingFile) {
          current.xcoords.push(current.x + scaledX);

          if (vertical) {
            current.ycoords.push(-current.y + scaledY);
          }

          current.tspan.textContent += character;
        } else {}

        let charWidth;

        if (vertical) {
          charWidth = width * widthAdvanceScale - spacing * fontDirection;
        } else {
          charWidth = width * widthAdvanceScale + spacing * fontDirection;
        }

        x += charWidth;
      }

      current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));

      if (vertical) {
        current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
      } else {
        current.tspan.setAttributeNS(null, "y", pf(-current.y));
      }

      if (vertical) {
        current.y -= x;
      } else {
        current.x += x * textHScale;
      }

      current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
      current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`);

      if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
        current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
      }

      if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
        current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
      }

      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        if (current.fillColor !== SVG_DEFAULTS.fillColor) {
          current.tspan.setAttributeNS(null, "fill", current.fillColor);
        }

        if (current.fillAlpha < 1) {
          current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
        }
      } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {
        current.tspan.setAttributeNS(null, "fill", "transparent");
      } else {
        current.tspan.setAttributeNS(null, "fill", "none");
      }

      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
        const lineWidthScale = 1 / (current.textMatrixScale || 1);

        this._setStrokeAttributes(current.tspan, lineWidthScale);
      }

      let textMatrix = current.textMatrix;

      if (current.textRise !== 0) {
        textMatrix = textMatrix.slice();
        textMatrix[5] += current.textRise;
      }

      current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);
      current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
      current.txtElement.append(current.tspan);
      current.txtgrp.append(current.txtElement);

      this._ensureTransformGroup().append(current.txtElement);
    }

    setLeadingMoveText(x, y) {
      this.setLeading(-y);
      this.moveText(x, y);
    }

    addFontStyle(fontObj) {
      if (!fontObj.data) {
        throw new Error("addFontStyle: No font data available, " + 'ensure that the "fontExtraProperties" API parameter is set.');
      }

      if (!this.cssStyle) {
        this.cssStyle = this.svgFactory.createElement("svg:style");
        this.cssStyle.setAttributeNS(null, "type", "text/css");
        this.defs.append(this.cssStyle);
      }

      const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);
      this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}";` + ` src: url(${url}); }\n`;
    }

    setFont(details) {
      const current = this.current;
      const fontObj = this.commonObjs.get(details[0]);
      let size = details[1];
      current.font = fontObj;

      if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
        this.addFontStyle(fontObj);
        this.embeddedFonts[fontObj.loadedName] = fontObj;
      }

      current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;
      let bold = "normal";

      if (fontObj.black) {
        bold = "900";
      } else if (fontObj.bold) {
        bold = "bold";
      }

      const italic = fontObj.italic ? "italic" : "normal";

      if (size < 0) {
        size = -size;
        current.fontDirection = -1;
      } else {
        current.fontDirection = 1;
      }

      current.fontSize = size;
      current.fontFamily = fontObj.loadedName;
      current.fontWeight = bold;
      current.fontStyle = italic;
      current.tspan = this.svgFactory.createElement("svg:tspan");
      current.tspan.setAttributeNS(null, "y", pf(-current.y));
      current.xcoords = [];
      current.ycoords = [];
    }

    endText() {
      const current = this.current;

      if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {
        current.element = current.txtElement;
        this.clip("nonzero");
        this.endPath();
      }
    }

    setLineWidth(width) {
      if (width > 0) {
        this.current.lineWidth = width;
      }
    }

    setLineCap(style) {
      this.current.lineCap = LINE_CAP_STYLES[style];
    }

    setLineJoin(style) {
      this.current.lineJoin = LINE_JOIN_STYLES[style];
    }

    setMiterLimit(limit) {
      this.current.miterLimit = limit;
    }

    setStrokeAlpha(strokeAlpha) {
      this.current.strokeAlpha = strokeAlpha;
    }

    setStrokeRGBColor(r, g, b) {
      this.current.strokeColor = _util.Util.makeHexColor(r, g, b);
    }

    setFillAlpha(fillAlpha) {
      this.current.fillAlpha = fillAlpha;
    }

    setFillRGBColor(r, g, b) {
      this.current.fillColor = _util.Util.makeHexColor(r, g, b);
      this.current.tspan = this.svgFactory.createElement("svg:tspan");
      this.current.xcoords = [];
      this.current.ycoords = [];
    }

    setStrokeColorN(args) {
      this.current.strokeColor = this._makeColorN_Pattern(args);
    }

    setFillColorN(args) {
      this.current.fillColor = this._makeColorN_Pattern(args);
    }

    shadingFill(args) {
      const width = this.viewport.width;
      const height = this.viewport.height;

      const inv = _util.Util.inverseTransform(this.transformMatrix);

      const bl = _util.Util.applyTransform([0, 0], inv);

      const br = _util.Util.applyTransform([0, height], inv);

      const ul = _util.Util.applyTransform([width, 0], inv);

      const ur = _util.Util.applyTransform([width, height], inv);

      const x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
      const y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
      const x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
      const y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
      const rect = this.svgFactory.createElement("svg:rect");
      rect.setAttributeNS(null, "x", x0);
      rect.setAttributeNS(null, "y", y0);
      rect.setAttributeNS(null, "width", x1 - x0);
      rect.setAttributeNS(null, "height", y1 - y0);
      rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));

      if (this.current.fillAlpha < 1) {
        rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
      }

      this._ensureTransformGroup().append(rect);
    }

    _makeColorN_Pattern(args) {
      if (args[0] === "TilingPattern") {
        return this._makeTilingPattern(args);
      }

      return this._makeShadingPattern(args);
    }

    _makeTilingPattern(args) {
      const color = args[1];
      const operatorList = args[2];
      const matrix = args[3] || _util.IDENTITY_MATRIX;
      const [x0, y0, x1, y1] = args[4];
      const xstep = args[5];
      const ystep = args[6];
      const paintType = args[7];
      const tilingId = `shading${shadingCount++}`;

      const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([..._util.Util.applyTransform([x0, y0], matrix), ..._util.Util.applyTransform([x1, y1], matrix)]);

      const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);

      const txstep = xstep * xscale;
      const tystep = ystep * yscale;
      const tiling = this.svgFactory.createElement("svg:pattern");
      tiling.setAttributeNS(null, "id", tilingId);
      tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
      tiling.setAttributeNS(null, "width", txstep);
      tiling.setAttributeNS(null, "height", tystep);
      tiling.setAttributeNS(null, "x", `${tx0}`);
      tiling.setAttributeNS(null, "y", `${ty0}`);
      const svg = this.svg;
      const transformMatrix = this.transformMatrix;
      const fillColor = this.current.fillColor;
      const strokeColor = this.current.strokeColor;
      const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
      this.svg = bbox;
      this.transformMatrix = matrix;

      if (paintType === 2) {
        const cssColor = _util.Util.makeHexColor(...color);

        this.current.fillColor = cssColor;
        this.current.strokeColor = cssColor;
      }

      this.executeOpTree(this.convertOpList(operatorList));
      this.svg = svg;
      this.transformMatrix = transformMatrix;
      this.current.fillColor = fillColor;
      this.current.strokeColor = strokeColor;
      tiling.append(bbox.childNodes[0]);
      this.defs.append(tiling);
      return `url(#${tilingId})`;
    }

    _makeShadingPattern(args) {
      if (typeof args === "string") {
        args = this.objs.get(args);
      }

      switch (args[0]) {
        case "RadialAxial":
          const shadingId = `shading${shadingCount++}`;
          const colorStops = args[3];
          let gradient;

          switch (args[1]) {
            case "axial":
              const point0 = args[4];
              const point1 = args[5];
              gradient = this.svgFactory.createElement("svg:linearGradient");
              gradient.setAttributeNS(null, "id", shadingId);
              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
              gradient.setAttributeNS(null, "x1", point0[0]);
              gradient.setAttributeNS(null, "y1", point0[1]);
              gradient.setAttributeNS(null, "x2", point1[0]);
              gradient.setAttributeNS(null, "y2", point1[1]);
              break;

            case "radial":
              const focalPoint = args[4];
              const circlePoint = args[5];
              const focalRadius = args[6];
              const circleRadius = args[7];
              gradient = this.svgFactory.createElement("svg:radialGradient");
              gradient.setAttributeNS(null, "id", shadingId);
              gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
              gradient.setAttributeNS(null, "cx", circlePoint[0]);
              gradient.setAttributeNS(null, "cy", circlePoint[1]);
              gradient.setAttributeNS(null, "r", circleRadius);
              gradient.setAttributeNS(null, "fx", focalPoint[0]);
              gradient.setAttributeNS(null, "fy", focalPoint[1]);
              gradient.setAttributeNS(null, "fr", focalRadius);
              break;

            default:
              throw new Error(`Unknown RadialAxial type: ${args[1]}`);
          }

          for (const colorStop of colorStops) {
            const stop = this.svgFactory.createElement("svg:stop");
            stop.setAttributeNS(null, "offset", colorStop[0]);
            stop.setAttributeNS(null, "stop-color", colorStop[1]);
            gradient.append(stop);
          }

          this.defs.append(gradient);
          return `url(#${shadingId})`;

        case "Mesh":
          (0, _util.warn)("Unimplemented pattern Mesh");
          return null;

        case "Dummy":
          return "hotpink";

        default:
          throw new Error(`Unknown IR type: ${args[0]}`);
      }
    }

    setDash(dashArray, dashPhase) {
      this.current.dashArray = dashArray;
      this.current.dashPhase = dashPhase;
    }

    constructPath(ops, args) {
      const current = this.current;
      let x = current.x,
          y = current.y;
      let d = [];
      let j = 0;

      for (const op of ops) {
        switch (op | 0) {
          case _util.OPS.rectangle:
            x = args[j++];
            y = args[j++];
            const width = args[j++];
            const height = args[j++];
            const xw = x + width;
            const yh = y + height;
            d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
            break;

          case _util.OPS.moveTo:
            x = args[j++];
            y = args[j++];
            d.push("M", pf(x), pf(y));
            break;

          case _util.OPS.lineTo:
            x = args[j++];
            y = args[j++];
            d.push("L", pf(x), pf(y));
            break;

          case _util.OPS.curveTo:
            x = args[j + 4];
            y = args[j + 5];
            d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
            j += 6;
            break;

          case _util.OPS.curveTo2:
            d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
            x = args[j + 2];
            y = args[j + 3];
            j += 4;
            break;

          case _util.OPS.curveTo3:
            x = args[j + 2];
            y = args[j + 3];
            d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
            j += 4;
            break;

          case _util.OPS.closePath:
            d.push("Z");
            break;
        }
      }

      d = d.join(" ");

      if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {
        d = current.path.getAttributeNS(null, "d") + d;
      } else {
        current.path = this.svgFactory.createElement("svg:path");

        this._ensureTransformGroup().append(current.path);
      }

      current.path.setAttributeNS(null, "d", d);
      current.path.setAttributeNS(null, "fill", "none");
      current.element = current.path;
      current.setCurrentPoint(x, y);
    }

    endPath() {
      const current = this.current;
      current.path = null;

      if (!this.pendingClip) {
        return;
      }

      if (!current.element) {
        this.pendingClip = null;
        return;
      }

      const clipId = `clippath${clipCount++}`;
      const clipPath = this.svgFactory.createElement("svg:clipPath");
      clipPath.setAttributeNS(null, "id", clipId);
      clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
      const clipElement = current.element.cloneNode(true);

      if (this.pendingClip === "evenodd") {
        clipElement.setAttributeNS(null, "clip-rule", "evenodd");
      } else {
        clipElement.setAttributeNS(null, "clip-rule", "nonzero");
      }

      this.pendingClip = null;
      clipPath.append(clipElement);
      this.defs.append(clipPath);

      if (current.activeClipUrl) {
        current.clipGroup = null;

        for (const prev of this.extraStack) {
          prev.clipGroup = null;
        }

        clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
      }

      current.activeClipUrl = `url(#${clipId})`;
      this.tgrp = null;
    }

    clip(type) {
      this.pendingClip = type;
    }

    closePath() {
      const current = this.current;

      if (current.path) {
        const d = `${current.path.getAttributeNS(null, "d")}Z`;
        current.path.setAttributeNS(null, "d", d);
      }
    }

    setLeading(leading) {
      this.current.leading = -leading;
    }

    setTextRise(textRise) {
      this.current.textRise = textRise;
    }

    setTextRenderingMode(textRenderingMode) {
      this.current.textRenderingMode = textRenderingMode;
    }

    setHScale(scale) {
      this.current.textHScale = scale / 100;
    }

    setRenderingIntent(intent) {}

    setFlatness(flatness) {}

    setGState(states) {
      for (const [key, value] of states) {
        switch (key) {
          case "LW":
            this.setLineWidth(value);
            break;

          case "LC":
            this.setLineCap(value);
            break;

          case "LJ":
            this.setLineJoin(value);
            break;

          case "ML":
            this.setMiterLimit(value);
            break;

          case "D":
            this.setDash(value[0], value[1]);
            break;

          case "RI":
            this.setRenderingIntent(value);
            break;

          case "FL":
            this.setFlatness(value);
            break;

          case "Font":
            this.setFont(value);
            break;

          case "CA":
            this.setStrokeAlpha(value);
            break;

          case "ca":
            this.setFillAlpha(value);
            break;

          default:
            (0, _util.warn)(`Unimplemented graphic state operator ${key}`);
            break;
        }
      }
    }

    fill() {
      const current = this.current;

      if (current.element) {
        current.element.setAttributeNS(null, "fill", current.fillColor);
        current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
        this.endPath();
      }
    }

    stroke() {
      const current = this.current;

      if (current.element) {
        this._setStrokeAttributes(current.element);

        current.element.setAttributeNS(null, "fill", "none");
        this.endPath();
      }
    }

    _setStrokeAttributes(element, lineWidthScale = 1) {
      const current = this.current;
      let dashArray = current.dashArray;

      if (lineWidthScale !== 1 && dashArray.length > 0) {
        dashArray = dashArray.map(function (value) {
          return lineWidthScale * value;
        });
      }

      element.setAttributeNS(null, "stroke", current.strokeColor);
      element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
      element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
      element.setAttributeNS(null, "stroke-linecap", current.lineCap);
      element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
      element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
      element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
      element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
    }

    eoFill() {
      if (this.current.element) {
        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
      }

      this.fill();
    }

    fillStroke() {
      this.stroke();
      this.fill();
    }

    eoFillStroke() {
      if (this.current.element) {
        this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
      }

      this.fillStroke();
    }

    closeStroke() {
      this.closePath();
      this.stroke();
    }

    closeFillStroke() {
      this.closePath();
      this.fillStroke();
    }

    closeEOFillStroke() {
      this.closePath();
      this.eoFillStroke();
    }

    paintSolidColorImageMask() {
      const rect = this.svgFactory.createElement("svg:rect");
      rect.setAttributeNS(null, "x", "0");
      rect.setAttributeNS(null, "y", "0");
      rect.setAttributeNS(null, "width", "1px");
      rect.setAttributeNS(null, "height", "1px");
      rect.setAttributeNS(null, "fill", this.current.fillColor);

      this._ensureTransformGroup().append(rect);
    }

    paintImageXObject(objId) {
      const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

      if (!imgData) {
        (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);
        return;
      }

      this.paintInlineImageXObject(imgData);
    }

    paintInlineImageXObject(imgData, mask) {
      const width = imgData.width;
      const height = imgData.height;
      const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
      const cliprect = this.svgFactory.createElement("svg:rect");
      cliprect.setAttributeNS(null, "x", "0");
      cliprect.setAttributeNS(null, "y", "0");
      cliprect.setAttributeNS(null, "width", pf(width));
      cliprect.setAttributeNS(null, "height", pf(height));
      this.current.element = cliprect;
      this.clip("nonzero");
      const imgEl = this.svgFactory.createElement("svg:image");
      imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
      imgEl.setAttributeNS(null, "x", "0");
      imgEl.setAttributeNS(null, "y", pf(-height));
      imgEl.setAttributeNS(null, "width", pf(width) + "px");
      imgEl.setAttributeNS(null, "height", pf(height) + "px");
      imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`);

      if (mask) {
        mask.append(imgEl);
      } else {
        this._ensureTransformGroup().append(imgEl);
      }
    }

    paintImageMaskXObject(imgData) {
      const current = this.current;
      const width = imgData.width;
      const height = imgData.height;
      const fillColor = current.fillColor;
      current.maskId = `mask${maskCount++}`;
      const mask = this.svgFactory.createElement("svg:mask");
      mask.setAttributeNS(null, "id", current.maskId);
      const rect = this.svgFactory.createElement("svg:rect");
      rect.setAttributeNS(null, "x", "0");
      rect.setAttributeNS(null, "y", "0");
      rect.setAttributeNS(null, "width", pf(width));
      rect.setAttributeNS(null, "height", pf(height));
      rect.setAttributeNS(null, "fill", fillColor);
      rect.setAttributeNS(null, "mask", `url(#${current.maskId})`);
      this.defs.append(mask);

      this._ensureTransformGroup().append(rect);

      this.paintInlineImageXObject(imgData, mask);
    }

    paintFormXObjectBegin(matrix, bbox) {
      if (Array.isArray(matrix) && matrix.length === 6) {
        this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
      }

      if (bbox) {
        const width = bbox[2] - bbox[0];
        const height = bbox[3] - bbox[1];
        const cliprect = this.svgFactory.createElement("svg:rect");
        cliprect.setAttributeNS(null, "x", bbox[0]);
        cliprect.setAttributeNS(null, "y", bbox[1]);
        cliprect.setAttributeNS(null, "width", pf(width));
        cliprect.setAttributeNS(null, "height", pf(height));
        this.current.element = cliprect;
        this.clip("nonzero");
        this.endPath();
      }
    }

    paintFormXObjectEnd() {}

    _initialize(viewport) {
      const svg = this.svgFactory.create(viewport.width, viewport.height);
      const definitions = this.svgFactory.createElement("svg:defs");
      svg.append(definitions);
      this.defs = definitions;
      const rootGroup = this.svgFactory.createElement("svg:g");
      rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
      svg.append(rootGroup);
      this.svg = rootGroup;
      return svg;
    }

    _ensureClipGroup() {
      if (!this.current.clipGroup) {
        const clipGroup = this.svgFactory.createElement("svg:g");
        clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
        this.svg.append(clipGroup);
        this.current.clipGroup = clipGroup;
      }

      return this.current.clipGroup;
    }

    _ensureTransformGroup() {
      if (!this.tgrp) {
        this.tgrp = this.svgFactory.createElement("svg:g");
        this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));

        if (this.current.activeClipUrl) {
          this._ensureClipGroup().append(this.tgrp);
        } else {
          this.svg.append(this.tgrp);
        }
      }

      return this.tgrp;
    }

  };
}

/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFNodeStream = void 0;

var _util = __w_pdfjs_require__(1);

var _network_utils = __w_pdfjs_require__(33);

;

const fs = __webpack_require__(1);

const http = __webpack_require__(37);

const https = __webpack_require__(38);

const url = __webpack_require__(42);

const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;

function parseUrl(sourceUrl) {
  const parsedUrl = url.parse(sourceUrl);

  if (parsedUrl.protocol === "file:" || parsedUrl.host) {
    return parsedUrl;
  }

  if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
    return url.parse(`file:///${sourceUrl}`);
  }

  if (!parsedUrl.host) {
    parsedUrl.protocol = "file:";
  }

  return parsedUrl;
}

class PDFNodeStream {
  constructor(source) {
    this.source = source;
    this.url = parseUrl(source.url);
    this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
    this.isFsUrl = this.url.protocol === "file:";
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }

  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
    return this._fullRequestReader;
  }

  getRangeReader(start, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }

    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);

    this._rangeRequestReaders.push(rangeReader);

    return rangeReader;
  }

  cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }

    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }

}

exports.PDFNodeStream = PDFNodeStream;

class BaseFullReader {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    const source = stream.source;
    this._contentLength = source.length;
    this._loaded = 0;
    this._filename = null;
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;

    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }

    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._readableStream = null;
    this._readCapability = (0, _util.createPromiseCapability)();
    this._headersCapability = (0, _util.createPromiseCapability)();
  }

  get headersReady() {
    return this._headersCapability.promise;
  }

  get filename() {
    return this._filename;
  }

  get contentLength() {
    return this._contentLength;
  }

  get isRangeSupported() {
    return this._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._readCapability.promise;

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    if (this._storedError) {
      throw this._storedError;
    }

    const chunk = this._readableStream.read();

    if (chunk === null) {
      this._readCapability = (0, _util.createPromiseCapability)();
      return this.read();
    }

    this._loaded += chunk.length;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded,
        total: this._contentLength
      });
    }

    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);

      return;
    }

    this._readableStream.destroy(reason);
  }

  _error(reason) {
    this._storedError = reason;

    this._readCapability.resolve();
  }

  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;

      this._readCapability.resolve();
    });
    readableStream.on("error", reason => {
      this._error(reason);
    });

    if (!this._isStreamingSupported && this._isRangeSupported) {
      this._error(new _util.AbortException("streaming is disabled"));
    }

    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }

}

class BaseRangeReader {
  constructor(stream) {
    this._url = stream.url;
    this._done = false;
    this._storedError = null;
    this.onProgress = null;
    this._loaded = 0;
    this._readableStream = null;
    this._readCapability = (0, _util.createPromiseCapability)();
    const source = stream.source;
    this._isStreamingSupported = !source.disableStream;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._readCapability.promise;

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    if (this._storedError) {
      throw this._storedError;
    }

    const chunk = this._readableStream.read();

    if (chunk === null) {
      this._readCapability = (0, _util.createPromiseCapability)();
      return this.read();
    }

    this._loaded += chunk.length;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded
      });
    }

    const buffer = new Uint8Array(chunk).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (!this._readableStream) {
      this._error(reason);

      return;
    }

    this._readableStream.destroy(reason);
  }

  _error(reason) {
    this._storedError = reason;

    this._readCapability.resolve();
  }

  _setReadableStream(readableStream) {
    this._readableStream = readableStream;
    readableStream.on("readable", () => {
      this._readCapability.resolve();
    });
    readableStream.on("end", () => {
      readableStream.destroy();
      this._done = true;

      this._readCapability.resolve();
    });
    readableStream.on("error", reason => {
      this._error(reason);
    });

    if (this._storedError) {
      this._readableStream.destroy(this._storedError);
    }
  }

}

function createRequestOptions(parsedUrl, headers) {
  return {
    protocol: parsedUrl.protocol,
    auth: parsedUrl.auth,
    host: parsedUrl.hostname,
    port: parsedUrl.port,
    path: parsedUrl.path,
    method: "GET",
    headers
  };
}

class PDFNodeStreamFullReader extends BaseFullReader {
  constructor(stream) {
    super(stream);

    const handleResponse = response => {
      if (response.statusCode === 404) {
        const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
        this._storedError = error;

        this._headersCapability.reject(error);

        return;
      }

      this._headersCapability.resolve();

      this._setReadableStream(response);

      const getResponseHeader = name => {
        return this._readableStream.headers[name.toLowerCase()];
      };

      const {
        allowRangeRequests,
        suggestedLength
      } = (0, _network_utils.validateRangeRequestCapabilities)({
        getResponseHeader,
        isHttp: stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
    };

    this._request = null;

    if (this._url.protocol === "http:") {
      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
    } else {
      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);
    }

    this._request.on("error", reason => {
      this._storedError = reason;

      this._headersCapability.reject(reason);
    });

    this._request.end();
  }

}

class PDFNodeStreamRangeReader extends BaseRangeReader {
  constructor(stream, start, end) {
    super(stream);
    this._httpHeaders = {};

    for (const property in stream.httpHeaders) {
      const value = stream.httpHeaders[property];

      if (typeof value === "undefined") {
        continue;
      }

      this._httpHeaders[property] = value;
    }

    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;

    const handleResponse = response => {
      if (response.statusCode === 404) {
        const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`);
        this._storedError = error;
        return;
      }

      this._setReadableStream(response);
    };

    this._request = null;

    if (this._url.protocol === "http:") {
      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
    } else {
      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);
    }

    this._request.on("error", reason => {
      this._storedError = reason;
    });

    this._request.end();
  }

}

class PDFNodeStreamFsFullReader extends BaseFullReader {
  constructor(stream) {
    super(stream);
    let path = decodeURIComponent(this._url.path);

    if (fileUriRegex.test(this._url.href)) {
      path = path.replace(/^\//, "");
    }

    fs.lstat(path, (error, stat) => {
      if (error) {
        if (error.code === "ENOENT") {
          error = new _util.MissingPDFException(`Missing PDF "${path}".`);
        }

        this._storedError = error;

        this._headersCapability.reject(error);

        return;
      }

      this._contentLength = stat.size;

      this._setReadableStream(fs.createReadStream(path));

      this._headersCapability.resolve();
    });
  }

}

class PDFNodeStreamFsRangeReader extends BaseRangeReader {
  constructor(stream, start, end) {
    super(stream);
    let path = decodeURIComponent(this._url.path);

    if (fileUriRegex.test(this._url.href)) {
      path = path.replace(/^\//, "");
    }

    this._setReadableStream(fs.createReadStream(path, {
      start,
      end: end - 1
    }));
  }

}

/***/ }),
/* 33 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createResponseStatusError = createResponseStatusError;
exports.extractFilenameFromHeader = extractFilenameFromHeader;
exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
exports.validateResponseStatus = validateResponseStatus;

var _util = __w_pdfjs_require__(1);

var _content_disposition = __w_pdfjs_require__(34);

var _display_utils = __w_pdfjs_require__(8);

function validateRangeRequestCapabilities({
  getResponseHeader,
  isHttp,
  rangeChunkSize,
  disableRange
}) {
  const returnValues = {
    allowRangeRequests: false,
    suggestedLength: undefined
  };
  const length = parseInt(getResponseHeader("Content-Length"), 10);

  if (!Number.isInteger(length)) {
    return returnValues;
  }

  returnValues.suggestedLength = length;

  if (length <= 2 * rangeChunkSize) {
    return returnValues;
  }

  if (disableRange || !isHttp) {
    return returnValues;
  }

  if (getResponseHeader("Accept-Ranges") !== "bytes") {
    return returnValues;
  }

  const contentEncoding = getResponseHeader("Content-Encoding") || "identity";

  if (contentEncoding !== "identity") {
    return returnValues;
  }

  returnValues.allowRangeRequests = true;
  return returnValues;
}

function extractFilenameFromHeader(getResponseHeader) {
  const contentDisposition = getResponseHeader("Content-Disposition");

  if (contentDisposition) {
    let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);

    if (filename.includes("%")) {
      try {
        filename = decodeURIComponent(filename);
      } catch (ex) {}
    }

    if ((0, _display_utils.isPdfFile)(filename)) {
      return filename;
    }
  }

  return null;
}

function createResponseStatusError(status, url) {
  if (status === 404 || status === 0 && url.startsWith("file:")) {
    return new _util.MissingPDFException('Missing PDF "' + url + '".');
  }

  return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status);
}

function validateResponseStatus(status) {
  return status === 200 || status === 206;
}

/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;

var _util = __w_pdfjs_require__(1);

function getFilenameFromContentDispositionHeader(contentDisposition) {
  let needsEncodingFixup = true;
  let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);

  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = unescape(filename);
    filename = rfc5987decode(filename);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }

  tmp = rfc2231getparam(contentDisposition);

  if (tmp) {
    const filename = rfc2047decode(tmp);
    return fixupEncoding(filename);
  }

  tmp = toParamRegExp("filename", "i").exec(contentDisposition);

  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }

  function toParamRegExp(attributePattern, flags) {
    return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
  }

  function textdecode(encoding, value) {
    if (encoding) {
      if (!/^[\x00-\xFF]+$/.test(value)) {
        return value;
      }

      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = (0, _util.stringToBytes)(value);
        value = decoder.decode(buffer);
        needsEncodingFixup = false;
      } catch (e) {}
    }

    return value;
  }

  function fixupEncoding(value) {
    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
      value = textdecode("utf-8", value);

      if (needsEncodingFixup) {
        value = textdecode("iso-8859-1", value);
      }
    }

    return value;
  }

  function rfc2231getparam(contentDispositionStr) {
    const matches = [];
    let match;
    const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");

    while ((match = iter.exec(contentDispositionStr)) !== null) {
      let [, n, quot, part] = match;
      n = parseInt(n, 10);

      if (n in matches) {
        if (n === 0) {
          break;
        }

        continue;
      }

      matches[n] = [quot, part];
    }

    const parts = [];

    for (let n = 0; n < matches.length; ++n) {
      if (!(n in matches)) {
        break;
      }

      let [quot, part] = matches[n];
      part = rfc2616unquote(part);

      if (quot) {
        part = unescape(part);

        if (n === 0) {
          part = rfc5987decode(part);
        }
      }

      parts.push(part);
    }

    return parts.join("");
  }

  function rfc2616unquote(value) {
    if (value.startsWith('"')) {
      const parts = value.slice(1).split('\\"');

      for (let i = 0; i < parts.length; ++i) {
        const quotindex = parts[i].indexOf('"');

        if (quotindex !== -1) {
          parts[i] = parts[i].slice(0, quotindex);
          parts.length = i + 1;
        }

        parts[i] = parts[i].replace(/\\(.)/g, "$1");
      }

      value = parts.join('"');
    }

    return value;
  }

  function rfc5987decode(extvalue) {
    const encodingend = extvalue.indexOf("'");

    if (encodingend === -1) {
      return extvalue;
    }

    const encoding = extvalue.slice(0, encodingend);
    const langvalue = extvalue.slice(encodingend + 1);
    const value = langvalue.replace(/^[^']*'/, "");
    return textdecode(encoding, value);
  }

  function rfc2047decode(value) {
    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
      return value;
    }

    return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) {
      if (encoding === "q" || encoding === "Q") {
        text = text.replace(/_/g, " ");
        text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {
          return String.fromCharCode(parseInt(hex, 16));
        });
        return textdecode(charset, text);
      }

      try {
        text = atob(text);
      } catch (e) {}

      return textdecode(charset, text);
    });
  }

  return "";
}

/***/ }),
/* 35 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFNetworkStream = void 0;

var _util = __w_pdfjs_require__(1);

var _network_utils = __w_pdfjs_require__(33);

;
const OK_RESPONSE = 200;
const PARTIAL_CONTENT_RESPONSE = 206;

function getArrayBuffer(xhr) {
  const data = xhr.response;

  if (typeof data !== "string") {
    return data;
  }

  const array = (0, _util.stringToBytes)(data);
  return array.buffer;
}

class NetworkManager {
  constructor(url, args = {}) {
    this.url = url;
    this.isHttp = /^https?:/i.test(url);
    this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);
    this.withCredentials = args.withCredentials || false;

    this.getXhr = args.getXhr || function NetworkManager_getXhr() {
      return new XMLHttpRequest();
    };

    this.currXhrId = 0;
    this.pendingRequests = Object.create(null);
  }

  requestRange(begin, end, listeners) {
    const args = {
      begin,
      end
    };

    for (const prop in listeners) {
      args[prop] = listeners[prop];
    }

    return this.request(args);
  }

  requestFull(listeners) {
    return this.request(listeners);
  }

  request(args) {
    const xhr = this.getXhr();
    const xhrId = this.currXhrId++;
    const pendingRequest = this.pendingRequests[xhrId] = {
      xhr
    };
    xhr.open("GET", this.url);
    xhr.withCredentials = this.withCredentials;

    for (const property in this.httpHeaders) {
      const value = this.httpHeaders[property];

      if (typeof value === "undefined") {
        continue;
      }

      xhr.setRequestHeader(property, value);
    }

    if (this.isHttp && "begin" in args && "end" in args) {
      xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
    } else {
      pendingRequest.expectedStatus = OK_RESPONSE;
    }

    xhr.responseType = "arraybuffer";

    if (args.onError) {
      xhr.onerror = function (evt) {
        args.onError(xhr.status);
      };
    }

    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
    xhr.onprogress = this.onProgress.bind(this, xhrId);
    pendingRequest.onHeadersReceived = args.onHeadersReceived;
    pendingRequest.onDone = args.onDone;
    pendingRequest.onError = args.onError;
    pendingRequest.onProgress = args.onProgress;
    xhr.send(null);
    return xhrId;
  }

  onProgress(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];

    if (!pendingRequest) {
      return;
    }

    pendingRequest.onProgress?.(evt);
  }

  onStateChange(xhrId, evt) {
    const pendingRequest = this.pendingRequests[xhrId];

    if (!pendingRequest) {
      return;
    }

    const xhr = pendingRequest.xhr;

    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
      pendingRequest.onHeadersReceived();
      delete pendingRequest.onHeadersReceived;
    }

    if (xhr.readyState !== 4) {
      return;
    }

    if (!(xhrId in this.pendingRequests)) {
      return;
    }

    delete this.pendingRequests[xhrId];

    if (xhr.status === 0 && this.isHttp) {
      pendingRequest.onError?.(xhr.status);
      return;
    }

    const xhrStatus = xhr.status || OK_RESPONSE;
    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;

    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
      pendingRequest.onError?.(xhr.status);
      return;
    }

    const chunk = getArrayBuffer(xhr);

    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
      const rangeHeader = xhr.getResponseHeader("Content-Range");
      const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
      pendingRequest.onDone({
        begin: parseInt(matches[1], 10),
        chunk
      });
    } else if (chunk) {
      pendingRequest.onDone({
        begin: 0,
        chunk
      });
    } else {
      pendingRequest.onError?.(xhr.status);
    }
  }

  getRequestXhr(xhrId) {
    return this.pendingRequests[xhrId].xhr;
  }

  isPendingRequest(xhrId) {
    return xhrId in this.pendingRequests;
  }

  abortRequest(xhrId) {
    const xhr = this.pendingRequests[xhrId].xhr;
    delete this.pendingRequests[xhrId];
    xhr.abort();
  }

}

class PDFNetworkStream {
  constructor(source) {
    this._source = source;
    this._manager = new NetworkManager(source.url, {
      httpHeaders: source.httpHeaders,
      withCredentials: source.withCredentials
    });
    this._rangeChunkSize = source.rangeChunkSize;
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }

  _onRangeRequestReaderClosed(reader) {
    const i = this._rangeRequestReaders.indexOf(reader);

    if (i >= 0) {
      this._rangeRequestReaders.splice(i, 1);
    }
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
    return this._fullRequestReader;
  }

  getRangeReader(begin, end) {
    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);

    this._rangeRequestReaders.push(reader);

    return reader;
  }

  cancelAllRequests(reason) {
    this._fullRequestReader?.cancel(reason);

    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }

}

exports.PDFNetworkStream = PDFNetworkStream;

class PDFNetworkStreamFullRequestReader {
  constructor(manager, source) {
    this._manager = manager;
    const args = {
      onHeadersReceived: this._onHeadersReceived.bind(this),
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = source.url;
    this._fullRequestId = manager.requestFull(args);
    this._headersReceivedCapability = (0, _util.createPromiseCapability)();
    this._disableRange = source.disableRange || false;
    this._contentLength = source.length;
    this._rangeChunkSize = source.rangeChunkSize;

    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }

    this._isStreamingSupported = false;
    this._isRangeSupported = false;
    this._cachedChunks = [];
    this._requests = [];
    this._done = false;
    this._storedError = undefined;
    this._filename = null;
    this.onProgress = null;
  }

  _onHeadersReceived() {
    const fullRequestXhrId = this._fullRequestId;

    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);

    const getResponseHeader = name => {
      return fullRequestXhr.getResponseHeader(name);
    };

    const {
      allowRangeRequests,
      suggestedLength
    } = (0, _network_utils.validateRangeRequestCapabilities)({
      getResponseHeader,
      isHttp: this._manager.isHttp,
      rangeChunkSize: this._rangeChunkSize,
      disableRange: this._disableRange
    });

    if (allowRangeRequests) {
      this._isRangeSupported = true;
    }

    this._contentLength = suggestedLength || this._contentLength;
    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

    if (this._isRangeSupported) {
      this._manager.abortRequest(fullRequestXhrId);
    }

    this._headersReceivedCapability.resolve();
  }

  _onDone(data) {
    if (data) {
      if (this._requests.length > 0) {
        const requestCapability = this._requests.shift();

        requestCapability.resolve({
          value: data.chunk,
          done: false
        });
      } else {
        this._cachedChunks.push(data.chunk);
      }
    }

    this._done = true;

    if (this._cachedChunks.length > 0) {
      return;
    }

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;
  }

  _onError(status) {
    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);

    this._headersReceivedCapability.reject(this._storedError);

    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }

    this._requests.length = 0;
    this._cachedChunks.length = 0;
  }

  _onProgress(evt) {
    this.onProgress?.({
      loaded: evt.loaded,
      total: evt.lengthComputable ? evt.total : this._contentLength
    });
  }

  get filename() {
    return this._filename;
  }

  get isRangeSupported() {
    return this._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  get contentLength() {
    return this._contentLength;
  }

  get headersReady() {
    return this._headersReceivedCapability.promise;
  }

  async read() {
    if (this._storedError) {
      throw this._storedError;
    }

    if (this._cachedChunks.length > 0) {
      const chunk = this._cachedChunks.shift();

      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    this._headersReceivedCapability.reject(reason);

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    if (this._manager.isPendingRequest(this._fullRequestId)) {
      this._manager.abortRequest(this._fullRequestId);
    }

    this._fullRequestReader = null;
  }

}

class PDFNetworkStreamRangeRequestReader {
  constructor(manager, begin, end) {
    this._manager = manager;
    const args = {
      onDone: this._onDone.bind(this),
      onError: this._onError.bind(this),
      onProgress: this._onProgress.bind(this)
    };
    this._url = manager.url;
    this._requestId = manager.requestRange(begin, end, args);
    this._requests = [];
    this._queuedChunk = null;
    this._done = false;
    this._storedError = undefined;
    this.onProgress = null;
    this.onClosed = null;
  }

  _close() {
    this.onClosed?.(this);
  }

  _onDone(data) {
    const chunk = data.chunk;

    if (this._requests.length > 0) {
      const requestCapability = this._requests.shift();

      requestCapability.resolve({
        value: chunk,
        done: false
      });
    } else {
      this._queuedChunk = chunk;
    }

    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    this._close();
  }

  _onError(status) {
    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);

    for (const requestCapability of this._requests) {
      requestCapability.reject(this._storedError);
    }

    this._requests.length = 0;
    this._queuedChunk = null;
  }

  _onProgress(evt) {
    if (!this.isStreamingSupported) {
      this.onProgress?.({
        loaded: evt.loaded
      });
    }
  }

  get isStreamingSupported() {
    return false;
  }

  async read() {
    if (this._storedError) {
      throw this._storedError;
    }

    if (this._queuedChunk !== null) {
      const chunk = this._queuedChunk;
      this._queuedChunk = null;
      return {
        value: chunk,
        done: false
      };
    }

    if (this._done) {
      return {
        value: undefined,
        done: true
      };
    }

    const requestCapability = (0, _util.createPromiseCapability)();

    this._requests.push(requestCapability);

    return requestCapability.promise;
  }

  cancel(reason) {
    this._done = true;

    for (const requestCapability of this._requests) {
      requestCapability.resolve({
        value: undefined,
        done: true
      });
    }

    this._requests.length = 0;

    if (this._manager.isPendingRequest(this._requestId)) {
      this._manager.abortRequest(this._requestId);
    }

    this._close();
  }

}

/***/ }),
/* 36 */
/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PDFFetchStream = void 0;

var _util = __w_pdfjs_require__(1);

var _network_utils = __w_pdfjs_require__(33);

;

function createFetchOptions(headers, withCredentials, abortController) {
  return {
    method: "GET",
    headers,
    signal: abortController.signal,
    mode: "cors",
    credentials: withCredentials ? "include" : "same-origin",
    redirect: "follow"
  };
}

function createHeaders(httpHeaders) {
  const headers = new Headers();

  for (const property in httpHeaders) {
    const value = httpHeaders[property];

    if (typeof value === "undefined") {
      continue;
    }

    headers.append(property, value);
  }

  return headers;
}

class PDFFetchStream {
  constructor(source) {
    this.source = source;
    this.isHttp = /^https?:/i.test(source.url);
    this.httpHeaders = this.isHttp && source.httpHeaders || {};
    this._fullRequestReader = null;
    this._rangeRequestReaders = [];
  }

  get _progressiveDataLength() {
    return this._fullRequestReader?._loaded ?? 0;
  }

  getFullReader() {
    (0, _util.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
    this._fullRequestReader = new PDFFetchStreamReader(this);
    return this._fullRequestReader;
  }

  getRangeReader(begin, end) {
    if (end <= this._progressiveDataLength) {
      return null;
    }

    const reader = new PDFFetchStreamRangeReader(this, begin, end);

    this._rangeRequestReaders.push(reader);

    return reader;
  }

  cancelAllRequests(reason) {
    if (this._fullRequestReader) {
      this._fullRequestReader.cancel(reason);
    }

    for (const reader of this._rangeRequestReaders.slice(0)) {
      reader.cancel(reason);
    }
  }

}

exports.PDFFetchStream = PDFFetchStream;

class PDFFetchStreamReader {
  constructor(stream) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    this._filename = null;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._contentLength = source.length;
    this._headersCapability = (0, _util.createPromiseCapability)();
    this._disableRange = source.disableRange || false;
    this._rangeChunkSize = source.rangeChunkSize;

    if (!this._rangeChunkSize && !this._disableRange) {
      this._disableRange = true;
    }

    this._abortController = new AbortController();
    this._isStreamingSupported = !source.disableStream;
    this._isRangeSupported = !source.disableRange;
    this._headers = createHeaders(this._stream.httpHeaders);
    const url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
        throw (0, _network_utils.createResponseStatusError)(response.status, url);
      }

      this._reader = response.body.getReader();

      this._headersCapability.resolve();

      const getResponseHeader = name => {
        return response.headers.get(name);
      };

      const {
        allowRangeRequests,
        suggestedLength
      } = (0, _network_utils.validateRangeRequestCapabilities)({
        getResponseHeader,
        isHttp: this._stream.isHttp,
        rangeChunkSize: this._rangeChunkSize,
        disableRange: this._disableRange
      });
      this._isRangeSupported = allowRangeRequests;
      this._contentLength = suggestedLength || this._contentLength;
      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

      if (!this._isStreamingSupported && this._isRangeSupported) {
        this.cancel(new _util.AbortException("Streaming is disabled."));
      }
    }).catch(this._headersCapability.reject);
    this.onProgress = null;
  }

  get headersReady() {
    return this._headersCapability.promise;
  }

  get filename() {
    return this._filename;
  }

  get contentLength() {
    return this._contentLength;
  }

  get isRangeSupported() {
    return this._isRangeSupported;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._headersCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();

    if (done) {
      return {
        value,
        done
      };
    }

    this._loaded += value.byteLength;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded,
        total: this._contentLength
      });
    }

    const buffer = new Uint8Array(value).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (this._reader) {
      this._reader.cancel(reason);
    }

    this._abortController.abort();
  }

}

class PDFFetchStreamRangeReader {
  constructor(stream, begin, end) {
    this._stream = stream;
    this._reader = null;
    this._loaded = 0;
    const source = stream.source;
    this._withCredentials = source.withCredentials || false;
    this._readCapability = (0, _util.createPromiseCapability)();
    this._isStreamingSupported = !source.disableStream;
    this._abortController = new AbortController();
    this._headers = createHeaders(this._stream.httpHeaders);

    this._headers.append("Range", `bytes=${begin}-${end - 1}`);

    const url = source.url;
    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {
      if (!(0, _network_utils.validateResponseStatus)(response.status)) {
        throw (0, _network_utils.createResponseStatusError)(response.status, url);
      }

      this._readCapability.resolve();

      this._reader = response.body.getReader();
    }).catch(this._readCapability.reject);
    this.onProgress = null;
  }

  get isStreamingSupported() {
    return this._isStreamingSupported;
  }

  async read() {
    await this._readCapability.promise;
    const {
      value,
      done
    } = await this._reader.read();

    if (done) {
      return {
        value,
        done
      };
    }

    this._loaded += value.byteLength;

    if (this.onProgress) {
      this.onProgress({
        loaded: this._loaded
      });
    }

    const buffer = new Uint8Array(value).buffer;
    return {
      value: buffer,
      done: false
    };
  }

  cancel(reason) {
    if (this._reader) {
      this._reader.cancel(reason);
    }

    this._abortController.abort();
  }

}

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
var __nested_webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
var exports = __nested_webpack_exports__;


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "AnnotationEditorLayer", ({
  enumerable: true,
  get: function () {
    return _annotation_editor_layer.AnnotationEditorLayer;
  }
}));
Object.defineProperty(exports, "AnnotationEditorParamsType", ({
  enumerable: true,
  get: function () {
    return _util.AnnotationEditorParamsType;
  }
}));
Object.defineProperty(exports, "AnnotationEditorType", ({
  enumerable: true,
  get: function () {
    return _util.AnnotationEditorType;
  }
}));
Object.defineProperty(exports, "AnnotationEditorUIManager", ({
  enumerable: true,
  get: function () {
    return _tools.AnnotationEditorUIManager;
  }
}));
Object.defineProperty(exports, "AnnotationLayer", ({
  enumerable: true,
  get: function () {
    return _annotation_layer.AnnotationLayer;
  }
}));
Object.defineProperty(exports, "AnnotationMode", ({
  enumerable: true,
  get: function () {
    return _util.AnnotationMode;
  }
}));
Object.defineProperty(exports, "CMapCompressionType", ({
  enumerable: true,
  get: function () {
    return _util.CMapCompressionType;
  }
}));
Object.defineProperty(exports, "GlobalWorkerOptions", ({
  enumerable: true,
  get: function () {
    return _worker_options.GlobalWorkerOptions;
  }
}));
Object.defineProperty(exports, "InvalidPDFException", ({
  enumerable: true,
  get: function () {
    return _util.InvalidPDFException;
  }
}));
Object.defineProperty(exports, "LoopbackPort", ({
  enumerable: true,
  get: function () {
    return _api.LoopbackPort;
  }
}));
Object.defineProperty(exports, "MissingPDFException", ({
  enumerable: true,
  get: function () {
    return _util.MissingPDFException;
  }
}));
Object.defineProperty(exports, "OPS", ({
  enumerable: true,
  get: function () {
    return _util.OPS;
  }
}));
Object.defineProperty(exports, "PDFDataRangeTransport", ({
  enumerable: true,
  get: function () {
    return _api.PDFDataRangeTransport;
  }
}));
Object.defineProperty(exports, "PDFDateString", ({
  enumerable: true,
  get: function () {
    return _display_utils.PDFDateString;
  }
}));
Object.defineProperty(exports, "PDFWorker", ({
  enumerable: true,
  get: function () {
    return _api.PDFWorker;
  }
}));
Object.defineProperty(exports, "PasswordResponses", ({
  enumerable: true,
  get: function () {
    return _util.PasswordResponses;
  }
}));
Object.defineProperty(exports, "PermissionFlag", ({
  enumerable: true,
  get: function () {
    return _util.PermissionFlag;
  }
}));
Object.defineProperty(exports, "PixelsPerInch", ({
  enumerable: true,
  get: function () {
    return _display_utils.PixelsPerInch;
  }
}));
Object.defineProperty(exports, "RenderingCancelledException", ({
  enumerable: true,
  get: function () {
    return _display_utils.RenderingCancelledException;
  }
}));
Object.defineProperty(exports, "SVGGraphics", ({
  enumerable: true,
  get: function () {
    return _svg.SVGGraphics;
  }
}));
Object.defineProperty(exports, "UNSUPPORTED_FEATURES", ({
  enumerable: true,
  get: function () {
    return _util.UNSUPPORTED_FEATURES;
  }
}));
Object.defineProperty(exports, "UnexpectedResponseException", ({
  enumerable: true,
  get: function () {
    return _util.UnexpectedResponseException;
  }
}));
Object.defineProperty(exports, "Util", ({
  enumerable: true,
  get: function () {
    return _util.Util;
  }
}));
Object.defineProperty(exports, "VerbosityLevel", ({
  enumerable: true,
  get: function () {
    return _util.VerbosityLevel;
  }
}));
Object.defineProperty(exports, "XfaLayer", ({
  enumerable: true,
  get: function () {
    return _xfa_layer.XfaLayer;
  }
}));
Object.defineProperty(exports, "build", ({
  enumerable: true,
  get: function () {
    return _api.build;
  }
}));
Object.defineProperty(exports, "createPromiseCapability", ({
  enumerable: true,
  get: function () {
    return _util.createPromiseCapability;
  }
}));
Object.defineProperty(exports, "createValidAbsoluteUrl", ({
  enumerable: true,
  get: function () {
    return _util.createValidAbsoluteUrl;
  }
}));
Object.defineProperty(exports, "getDocument", ({
  enumerable: true,
  get: function () {
    return _api.getDocument;
  }
}));
Object.defineProperty(exports, "getFilenameFromUrl", ({
  enumerable: true,
  get: function () {
    return _display_utils.getFilenameFromUrl;
  }
}));
Object.defineProperty(exports, "getPdfFilenameFromUrl", ({
  enumerable: true,
  get: function () {
    return _display_utils.getPdfFilenameFromUrl;
  }
}));
Object.defineProperty(exports, "getXfaPageViewport", ({
  enumerable: true,
  get: function () {
    return _display_utils.getXfaPageViewport;
  }
}));
Object.defineProperty(exports, "isPdfFile", ({
  enumerable: true,
  get: function () {
    return _display_utils.isPdfFile;
  }
}));
Object.defineProperty(exports, "loadScript", ({
  enumerable: true,
  get: function () {
    return _display_utils.loadScript;
  }
}));
Object.defineProperty(exports, "renderTextLayer", ({
  enumerable: true,
  get: function () {
    return _text_layer.renderTextLayer;
  }
}));
Object.defineProperty(exports, "shadow", ({
  enumerable: true,
  get: function () {
    return _util.shadow;
  }
}));
Object.defineProperty(exports, "version", ({
  enumerable: true,
  get: function () {
    return _api.version;
  }
}));

var _util = __w_pdfjs_require__(1);

var _api = __w_pdfjs_require__(4);

var _display_utils = __w_pdfjs_require__(8);

var _annotation_editor_layer = __w_pdfjs_require__(22);

var _tools = __w_pdfjs_require__(7);

var _annotation_layer = __w_pdfjs_require__(27);

var _worker_options = __w_pdfjs_require__(15);

var _is_node = __w_pdfjs_require__(3);

var _text_layer = __w_pdfjs_require__(30);

var _svg = __w_pdfjs_require__(31);

var _xfa_layer = __w_pdfjs_require__(29);

const pdfjsVersion = '2.16.105';
const pdfjsBuild = '172ccdbe5';
{
  if (_is_node.isNodeJS) {
    const {
      PDFNodeStream
    } = __w_pdfjs_require__(32);

    (0, _api.setPDFNetworkStreamFactory)(params => {
      return new PDFNodeStream(params);
    });
  } else {
    const {
      PDFNetworkStream
    } = __w_pdfjs_require__(35);

    const {
      PDFFetchStream
    } = __w_pdfjs_require__(36);

    (0, _api.setPDFNetworkStreamFactory)(params => {
      if ((0, _display_utils.isValidFetchUrl)(params.url)) {
        return new PDFFetchStream(params);
      }

      return new PDFNetworkStream(params);
    });
  }
}
})();

/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=pdf.js.map

/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const Canvas = __webpack_require__(21)
const Image = __webpack_require__(31)
const CanvasRenderingContext2D = __webpack_require__(24)
const CanvasPattern = __webpack_require__(43)
const parseFont = __webpack_require__(25)
const packageJson = __webpack_require__(44)
const bindings = __webpack_require__(22)
const fs = __webpack_require__(1)
const PNGStream = __webpack_require__(27)
const PDFStream = __webpack_require__(29)
const JPEGStream = __webpack_require__(30)
const { DOMPoint, DOMMatrix } = __webpack_require__(26)

function createCanvas (width, height, type) {
  return new Canvas(width, height, type)
}

function createImageData (array, width, height) {
  return new bindings.ImageData(array, width, height)
}

function loadImage (src) {
  return new Promise((resolve, reject) => {
    const image = new Image()

    function cleanup () {
      image.onload = null
      image.onerror = null
    }

    image.onload = () => { cleanup(); resolve(image) }
    image.onerror = (err) => { cleanup(); reject(err) }

    image.src = src
  })
}

/**
 * Resolve paths for registerFont. Must be called *before* creating a Canvas
 * instance.
 * @param src {string} Path to font file.
 * @param fontFace {{family: string, weight?: string, style?: string}} Object
 * specifying font information. `weight` and `style` default to `"normal"`.
 */
function registerFont (src, fontFace) {
  // TODO this doesn't need to be on Canvas; it should just be a static method
  // of `bindings`.
  return Canvas._registerFont(fs.realpathSync(src), fontFace)
}

/**
 * Unload all fonts from pango to free up memory
 */
function deregisterAllFonts () {
  return Canvas._deregisterAllFonts()
}

exports.Canvas = Canvas
exports.Context2d = CanvasRenderingContext2D // Legacy/compat export
exports.CanvasRenderingContext2D = CanvasRenderingContext2D
exports.CanvasGradient = bindings.CanvasGradient
exports.CanvasPattern = CanvasPattern
exports.Image = Image
exports.ImageData = bindings.ImageData
exports.PNGStream = PNGStream
exports.PDFStream = PDFStream
exports.JPEGStream = JPEGStream
exports.DOMMatrix = DOMMatrix
exports.DOMPoint = DOMPoint

exports.registerFont = registerFont
exports.deregisterAllFonts = deregisterAllFonts
exports.parseFont = parseFont

exports.createCanvas = createCanvas
exports.createImageData = createImageData
exports.loadImage = loadImage

exports.backends = bindings.Backends

/** Library version. */
exports.version = packageJson.version
/** Cairo version. */
exports.cairoVersion = bindings.cairoVersion
/** jpeglib version. */
exports.jpegVersion = bindings.jpegVersion
/** gif_lib version. */
exports.gifVersion = bindings.gifVersion ? bindings.gifVersion.replace(/[^.\d]/g, '') : undefined
/** freetype version. */
exports.freetypeVersion = bindings.freetypeVersion
/** rsvg version. */
exports.rsvgVersion = bindings.rsvgVersion
/** pango version. */
exports.pangoVersion = bindings.pangoVersion


/***/ }),
/* 21 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*!
 * Canvas
 * Copyright (c) 2010 LearnBoost <tj@learnboost.com>
 * MIT Licensed
 */

const bindings = __webpack_require__(22)
const Canvas = module.exports = bindings.Canvas
const Context2d = __webpack_require__(24)
const PNGStream = __webpack_require__(27)
const PDFStream = __webpack_require__(29)
const JPEGStream = __webpack_require__(30)
const FORMATS = ['image/png', 'image/jpeg']
const util = __webpack_require__(5)

// TODO || is for Node.js pre-v6.6.0
Canvas.prototype[util.inspect.custom || 'inspect'] = function () {
  return `[Canvas ${this.width}x${this.height}]`
}

Canvas.prototype.getContext = function (contextType, contextAttributes) {
  if (contextType == '2d') {
    const ctx = this._context2d || (this._context2d = new Context2d(this, contextAttributes))
    this.context = ctx
    ctx.canvas = this
    return ctx
  }
}

Canvas.prototype.pngStream =
Canvas.prototype.createPNGStream = function (options) {
  return new PNGStream(this, options)
}

Canvas.prototype.pdfStream =
Canvas.prototype.createPDFStream = function (options) {
  return new PDFStream(this, options)
}

Canvas.prototype.jpegStream =
Canvas.prototype.createJPEGStream = function (options) {
  return new JPEGStream(this, options)
}

Canvas.prototype.toDataURL = function (a1, a2, a3) {
  // valid arg patterns (args -> [type, opts, fn]):
  // [] -> ['image/png', null, null]
  // [qual] -> ['image/png', null, null]
  // [undefined] -> ['image/png', null, null]
  // ['image/png'] -> ['image/png', null, null]
  // ['image/png', qual] -> ['image/png', null, null]
  // [fn] -> ['image/png', null, fn]
  // [type, fn] -> [type, null, fn]
  // [undefined, fn] -> ['image/png', null, fn]
  // ['image/png', qual, fn] -> ['image/png', null, fn]
  // ['image/jpeg', fn] -> ['image/jpeg', null, fn]
  // ['image/jpeg', opts, fn] -> ['image/jpeg', opts, fn]
  // ['image/jpeg', qual, fn] -> ['image/jpeg', {quality: qual}, fn]
  // ['image/jpeg', undefined, fn] -> ['image/jpeg', null, fn]
  // ['image/jpeg'] -> ['image/jpeg', null, fn]
  // ['image/jpeg', opts] -> ['image/jpeg', opts, fn]
  // ['image/jpeg', qual] -> ['image/jpeg', {quality: qual}, fn]

  let type = 'image/png'
  let opts = {}
  let fn

  if (typeof a1 === 'function') {
    fn = a1
  } else {
    if (typeof a1 === 'string' && FORMATS.includes(a1.toLowerCase())) {
      type = a1.toLowerCase()
    }

    if (typeof a2 === 'function') {
      fn = a2
    } else {
      if (typeof a2 === 'object') {
        opts = a2
      } else if (typeof a2 === 'number') {
        opts = { quality: Math.max(0, Math.min(1, a2)) }
      }

      if (typeof a3 === 'function') {
        fn = a3
      } else if (undefined !== a3) {
        throw new TypeError(`${typeof a3} is not a function`)
      }
    }
  }

  if (this.width === 0 || this.height === 0) {
    // Per spec, if the bitmap has no pixels, return this string:
    const str = 'data:,'
    if (fn) {
      setTimeout(() => fn(null, str))
      return
    } else {
      return str
    }
  }

  if (fn) {
    this.toBuffer((err, buf) => {
      if (err) return fn(err)
      fn(null, `data:${type};base64,${buf.toString('base64')}`)
    }, type, opts)
  } else {
    return `data:${type};base64,${this.toBuffer(type, opts).toString('base64')}`
  }
}


/***/ }),
/* 22 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const bindings = __webpack_require__(23)

module.exports = bindings

bindings.ImageData.prototype.toString = function () {
	return '[object ImageData]'
}

bindings.CanvasGradient.prototype.toString = function () {
	return '[object CanvasGradient]'
}


/***/ }),
/* 23 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);

try {
  process.dlopen(module, __dirname + (__webpack_require__(7).sep) + __webpack_require__.p + "24c864a4416d798d1f06f946c8af70f9.node");
} catch (error) {
  throw new Error('node-loader:\n' + error);
}


/***/ }),
/* 24 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*!
 * Canvas - Context2d
 * Copyright (c) 2010 LearnBoost <tj@learnboost.com>
 * MIT Licensed
 */

const bindings = __webpack_require__(22)
const parseFont = __webpack_require__(25)
const { DOMMatrix } = __webpack_require__(26)

bindings.CanvasRenderingContext2dInit(DOMMatrix, parseFont)
module.exports = bindings.CanvasRenderingContext2d


/***/ }),
/* 25 */
/***/ ((module) => {

"use strict";


/**
 * Font RegExp helpers.
 */

const weights = 'bold|bolder|lighter|[1-9]00'
const styles = 'italic|oblique'
const variants = 'small-caps'
const stretches = 'ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded'
const units = 'px|pt|pc|in|cm|mm|%|em|ex|ch|rem|q'
const string = '\'([^\']+)\'|"([^"]+)"|[\\w\\s-]+'

// [ [ <font-style> || <font-variant-css21> || <font-weight> || <font-stretch> ]?
//    <font-size> [ / <line-height> ]? <font-family> ]
// https://drafts.csswg.org/css-fonts-3/#font-prop
const weightRe = new RegExp(`(${weights}) +`, 'i')
const styleRe = new RegExp(`(${styles}) +`, 'i')
const variantRe = new RegExp(`(${variants}) +`, 'i')
const stretchRe = new RegExp(`(${stretches}) +`, 'i')
const sizeFamilyRe = new RegExp(
  `([\\d\\.]+)(${units}) *((?:${string})( *, *(?:${string}))*)`)

/**
 * Cache font parsing.
 */

const cache = {}

const defaultHeight = 16 // pt, common browser default

/**
 * Parse font `str`.
 *
 * @param {String} str
 * @return {Object} Parsed font. `size` is in device units. `unit` is the unit
 *   appearing in the input string.
 * @api private
 */

module.exports = str => {
  // Cached
  if (cache[str]) return cache[str]

  // Try for required properties first.
  const sizeFamily = sizeFamilyRe.exec(str)
  if (!sizeFamily) return // invalid

  // Default values and required properties
  const font = {
    weight: 'normal',
    style: 'normal',
    stretch: 'normal',
    variant: 'normal',
    size: parseFloat(sizeFamily[1]),
    unit: sizeFamily[2],
    family: sizeFamily[3].replace(/["']/g, '').replace(/ *, */g, ',')
  }

  // Optional, unordered properties.
  let weight, style, variant, stretch
  // Stop search at `sizeFamily.index`
  const substr = str.substring(0, sizeFamily.index)
  if ((weight = weightRe.exec(substr))) font.weight = weight[1]
  if ((style = styleRe.exec(substr))) font.style = style[1]
  if ((variant = variantRe.exec(substr))) font.variant = variant[1]
  if ((stretch = stretchRe.exec(substr))) font.stretch = stretch[1]

  // Convert to device units. (`font.unit` is the original unit)
  // TODO: ch, ex
  switch (font.unit) {
    case 'pt':
      font.size /= 0.75
      break
    case 'pc':
      font.size *= 16
      break
    case 'in':
      font.size *= 96
      break
    case 'cm':
      font.size *= 96.0 / 2.54
      break
    case 'mm':
      font.size *= 96.0 / 25.4
      break
    case '%':
      // TODO disabled because existing unit tests assume 100
      // font.size *= defaultHeight / 100 / 0.75
      break
    case 'em':
    case 'rem':
      font.size *= defaultHeight / 0.75
      break
    case 'q':
      font.size *= 96 / 25.4 / 4
      break
  }

  return (cache[str] = font)
}


/***/ }),
/* 26 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(5)

// DOMMatrix per https://drafts.fxtf.org/geometry/#DOMMatrix

class DOMPoint {
  constructor (x, y, z, w) {
    if (typeof x === 'object' && x !== null) {
      w = x.w
      z = x.z
      y = x.y
      x = x.x
    }
    this.x = typeof x === 'number' ? x : 0
    this.y = typeof y === 'number' ? y : 0
    this.z = typeof z === 'number' ? z : 0
    this.w = typeof w === 'number' ? w : 1
  }
}

// Constants to index into _values (col-major)
const M11 = 0; const M12 = 1; const M13 = 2; const M14 = 3
const M21 = 4; const M22 = 5; const M23 = 6; const M24 = 7
const M31 = 8; const M32 = 9; const M33 = 10; const M34 = 11
const M41 = 12; const M42 = 13; const M43 = 14; const M44 = 15

const DEGREE_PER_RAD = 180 / Math.PI
const RAD_PER_DEGREE = Math.PI / 180

function parseMatrix (init) {
  let parsed = init.replace('matrix(', '')
  parsed = parsed.split(',', 7) // 6 + 1 to handle too many params
  if (parsed.length !== 6) throw new Error(`Failed to parse ${init}`)
  parsed = parsed.map(parseFloat)
  return [
    parsed[0], parsed[1], 0, 0,
    parsed[2], parsed[3], 0, 0,
    0, 0, 1, 0,
    parsed[4], parsed[5], 0, 1
  ]
}

function parseMatrix3d (init) {
  let parsed = init.replace('matrix3d(', '')
  parsed = parsed.split(',', 17) // 16 + 1 to handle too many params
  if (parsed.length !== 16) throw new Error(`Failed to parse ${init}`)
  return parsed.map(parseFloat)
}

function parseTransform (tform) {
  const type = tform.split('(', 1)[0]
  switch (type) {
    case 'matrix':
      return parseMatrix(tform)
    case 'matrix3d':
      return parseMatrix3d(tform)
    // TODO This is supposed to support any CSS transform value.
    default:
      throw new Error(`${type} parsing not implemented`)
  }
}

class DOMMatrix {
  constructor (init) {
    this._is2D = true
    this._values = new Float64Array([
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    ])

    let i

    if (typeof init === 'string') { // parse CSS transformList
      if (init === '') return // default identity matrix
      const tforms = init.split(/\)\s+/, 20).map(parseTransform)
      if (tforms.length === 0) return
      init = tforms[0]
      for (i = 1; i < tforms.length; i++) init = multiply(tforms[i], init)
    }

    i = 0
    if (init && init.length === 6) {
      setNumber2D(this, M11, init[i++])
      setNumber2D(this, M12, init[i++])
      setNumber2D(this, M21, init[i++])
      setNumber2D(this, M22, init[i++])
      setNumber2D(this, M41, init[i++])
      setNumber2D(this, M42, init[i++])
    } else if (init && init.length === 16) {
      setNumber2D(this, M11, init[i++])
      setNumber2D(this, M12, init[i++])
      setNumber3D(this, M13, init[i++])
      setNumber3D(this, M14, init[i++])
      setNumber2D(this, M21, init[i++])
      setNumber2D(this, M22, init[i++])
      setNumber3D(this, M23, init[i++])
      setNumber3D(this, M24, init[i++])
      setNumber3D(this, M31, init[i++])
      setNumber3D(this, M32, init[i++])
      setNumber3D(this, M33, init[i++])
      setNumber3D(this, M34, init[i++])
      setNumber2D(this, M41, init[i++])
      setNumber2D(this, M42, init[i++])
      setNumber3D(this, M43, init[i++])
      setNumber3D(this, M44, init[i])
    } else if (init !== undefined) {
      throw new TypeError('Expected string or array.')
    }
  }

  toString () {
    return this.is2D
      ? `matrix(${this.a}, ${this.b}, ${this.c}, ${this.d}, ${this.e}, ${this.f})`
      : `matrix3d(${this._values.join(', ')})`
  }

  multiply (other) {
    return newInstance(this._values).multiplySelf(other)
  }

  multiplySelf (other) {
    this._values = multiply(other._values, this._values)
    if (!other.is2D) this._is2D = false
    return this
  }

  preMultiplySelf (other) {
    this._values = multiply(this._values, other._values)
    if (!other.is2D) this._is2D = false
    return this
  }

  translate (tx, ty, tz) {
    return newInstance(this._values).translateSelf(tx, ty, tz)
  }

  translateSelf (tx, ty, tz) {
    if (typeof tx !== 'number') tx = 0
    if (typeof ty !== 'number') ty = 0
    if (typeof tz !== 'number') tz = 0
    this._values = multiply([
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      tx, ty, tz, 1
    ], this._values)
    if (tz !== 0) this._is2D = false
    return this
  }

  scale (scaleX, scaleY, scaleZ, originX, originY, originZ) {
    return newInstance(this._values).scaleSelf(scaleX, scaleY, scaleZ, originX, originY, originZ)
  }

  scale3d (scale, originX, originY, originZ) {
    return newInstance(this._values).scale3dSelf(scale, originX, originY, originZ)
  }

  scale3dSelf (scale, originX, originY, originZ) {
    return this.scaleSelf(scale, scale, scale, originX, originY, originZ)
  }

  scaleSelf (scaleX, scaleY, scaleZ, originX, originY, originZ) {
    // Not redundant with translate's checks because we need to negate the values later.
    if (typeof originX !== 'number') originX = 0
    if (typeof originY !== 'number') originY = 0
    if (typeof originZ !== 'number') originZ = 0
    this.translateSelf(originX, originY, originZ)
    if (typeof scaleX !== 'number') scaleX = 1
    if (typeof scaleY !== 'number') scaleY = scaleX
    if (typeof scaleZ !== 'number') scaleZ = 1
    this._values = multiply([
      scaleX, 0, 0, 0,
      0, scaleY, 0, 0,
      0, 0, scaleZ, 0,
      0, 0, 0, 1
    ], this._values)
    this.translateSelf(-originX, -originY, -originZ)
    if (scaleZ !== 1 || originZ !== 0) this._is2D = false
    return this
  }

  rotateFromVector (x, y) {
    return newInstance(this._values).rotateFromVectorSelf(x, y)
  }

  rotateFromVectorSelf (x, y) {
    if (typeof x !== 'number') x = 0
    if (typeof y !== 'number') y = 0
    const theta = (x === 0 && y === 0) ? 0 : Math.atan2(y, x) * DEGREE_PER_RAD
    return this.rotateSelf(theta)
  }

  rotate (rotX, rotY, rotZ) {
    return newInstance(this._values).rotateSelf(rotX, rotY, rotZ)
  }

  rotateSelf (rotX, rotY, rotZ) {
    if (rotY === undefined && rotZ === undefined) {
      rotZ = rotX
      rotX = rotY = 0
    }
    if (typeof rotY !== 'number') rotY = 0
    if (typeof rotZ !== 'number') rotZ = 0
    if (rotX !== 0 || rotY !== 0) this._is2D = false
    rotX *= RAD_PER_DEGREE
    rotY *= RAD_PER_DEGREE
    rotZ *= RAD_PER_DEGREE
    let c, s
    c = Math.cos(rotZ)
    s = Math.sin(rotZ)
    this._values = multiply([
      c, s, 0, 0,
      -s, c, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    ], this._values)
    c = Math.cos(rotY)
    s = Math.sin(rotY)
    this._values = multiply([
      c, 0, -s, 0,
      0, 1, 0, 0,
      s, 0, c, 0,
      0, 0, 0, 1
    ], this._values)
    c = Math.cos(rotX)
    s = Math.sin(rotX)
    this._values = multiply([
      1, 0, 0, 0,
      0, c, s, 0,
      0, -s, c, 0,
      0, 0, 0, 1
    ], this._values)
    return this
  }

  rotateAxisAngle (x, y, z, angle) {
    return newInstance(this._values).rotateAxisAngleSelf(x, y, z, angle)
  }

  rotateAxisAngleSelf (x, y, z, angle) {
    if (typeof x !== 'number') x = 0
    if (typeof y !== 'number') y = 0
    if (typeof z !== 'number') z = 0
    // Normalize axis
    const length = Math.sqrt(x * x + y * y + z * z)
    if (length === 0) return this
    if (length !== 1) {
      x /= length
      y /= length
      z /= length
    }
    angle *= RAD_PER_DEGREE
    const c = Math.cos(angle)
    const s = Math.sin(angle)
    const t = 1 - c
    const tx = t * x
    const ty = t * y
    // NB: This is the generic transform. If the axis is a major axis, there are
    // faster transforms.
    this._values = multiply([
      tx * x + c, tx * y + s * z, tx * z - s * y, 0,
      tx * y - s * z, ty * y + c, ty * z + s * x, 0,
      tx * z + s * y, ty * z - s * x, t * z * z + c, 0,
      0, 0, 0, 1
    ], this._values)
    if (x !== 0 || y !== 0) this._is2D = false
    return this
  }

  skewX (sx) {
    return newInstance(this._values).skewXSelf(sx)
  }

  skewXSelf (sx) {
    if (typeof sx !== 'number') return this
    const t = Math.tan(sx * RAD_PER_DEGREE)
    this._values = multiply([
      1, 0, 0, 0,
      t, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    ], this._values)
    return this
  }

  skewY (sy) {
    return newInstance(this._values).skewYSelf(sy)
  }

  skewYSelf (sy) {
    if (typeof sy !== 'number') return this
    const t = Math.tan(sy * RAD_PER_DEGREE)
    this._values = multiply([
      1, t, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    ], this._values)
    return this
  }

  flipX () {
    return newInstance(multiply([
      -1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    ], this._values))
  }

  flipY () {
    return newInstance(multiply([
      1, 0, 0, 0,
      0, -1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    ], this._values))
  }

  inverse () {
    return newInstance(this._values).invertSelf()
  }

  invertSelf () {
    const m = this._values
    const inv = m.map(v => 0)

    inv[0] = m[5] * m[10] * m[15] -
            m[5] * m[11] * m[14] -
            m[9] * m[6] * m[15] +
            m[9] * m[7] * m[14] +
            m[13] * m[6] * m[11] -
            m[13] * m[7] * m[10]

    inv[4] = -m[4] * m[10] * m[15] +
            m[4] * m[11] * m[14] +
            m[8] * m[6] * m[15] -
            m[8] * m[7] * m[14] -
            m[12] * m[6] * m[11] +
            m[12] * m[7] * m[10]

    inv[8] = m[4] * m[9] * m[15] -
            m[4] * m[11] * m[13] -
            m[8] * m[5] * m[15] +
            m[8] * m[7] * m[13] +
            m[12] * m[5] * m[11] -
            m[12] * m[7] * m[9]

    inv[12] = -m[4] * m[9] * m[14] +
            m[4] * m[10] * m[13] +
            m[8] * m[5] * m[14] -
            m[8] * m[6] * m[13] -
            m[12] * m[5] * m[10] +
            m[12] * m[6] * m[9]

    // If the determinant is zero, this matrix cannot be inverted, and all
    // values should be set to NaN, with the is2D flag set to false.

    const det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12]

    if (det === 0) {
      this._values = m.map(v => NaN)
      this._is2D = false
      return this
    }

    inv[1] = -m[1] * m[10] * m[15] +
            m[1] * m[11] * m[14] +
            m[9] * m[2] * m[15] -
            m[9] * m[3] * m[14] -
            m[13] * m[2] * m[11] +
            m[13] * m[3] * m[10]

    inv[5] = m[0] * m[10] * m[15] -
            m[0] * m[11] * m[14] -
            m[8] * m[2] * m[15] +
            m[8] * m[3] * m[14] +
            m[12] * m[2] * m[11] -
            m[12] * m[3] * m[10]

    inv[9] = -m[0] * m[9] * m[15] +
            m[0] * m[11] * m[13] +
            m[8] * m[1] * m[15] -
            m[8] * m[3] * m[13] -
            m[12] * m[1] * m[11] +
            m[12] * m[3] * m[9]

    inv[13] = m[0] * m[9] * m[14] -
            m[0] * m[10] * m[13] -
            m[8] * m[1] * m[14] +
            m[8] * m[2] * m[13] +
            m[12] * m[1] * m[10] -
            m[12] * m[2] * m[9]

    inv[2] = m[1] * m[6] * m[15] -
            m[1] * m[7] * m[14] -
            m[5] * m[2] * m[15] +
            m[5] * m[3] * m[14] +
            m[13] * m[2] * m[7] -
            m[13] * m[3] * m[6]

    inv[6] = -m[0] * m[6] * m[15] +
            m[0] * m[7] * m[14] +
            m[4] * m[2] * m[15] -
            m[4] * m[3] * m[14] -
            m[12] * m[2] * m[7] +
            m[12] * m[3] * m[6]

    inv[10] = m[0] * m[5] * m[15] -
            m[0] * m[7] * m[13] -
            m[4] * m[1] * m[15] +
            m[4] * m[3] * m[13] +
            m[12] * m[1] * m[7] -
            m[12] * m[3] * m[5]

    inv[14] = -m[0] * m[5] * m[14] +
            m[0] * m[6] * m[13] +
            m[4] * m[1] * m[14] -
            m[4] * m[2] * m[13] -
            m[12] * m[1] * m[6] +
            m[12] * m[2] * m[5]

    inv[3] = -m[1] * m[6] * m[11] +
            m[1] * m[7] * m[10] +
            m[5] * m[2] * m[11] -
            m[5] * m[3] * m[10] -
            m[9] * m[2] * m[7] +
            m[9] * m[3] * m[6]

    inv[7] = m[0] * m[6] * m[11] -
            m[0] * m[7] * m[10] -
            m[4] * m[2] * m[11] +
            m[4] * m[3] * m[10] +
            m[8] * m[2] * m[7] -
            m[8] * m[3] * m[6]

    inv[11] = -m[0] * m[5] * m[11] +
            m[0] * m[7] * m[9] +
            m[4] * m[1] * m[11] -
            m[4] * m[3] * m[9] -
            m[8] * m[1] * m[7] +
            m[8] * m[3] * m[5]

    inv[15] = m[0] * m[5] * m[10] -
            m[0] * m[6] * m[9] -
            m[4] * m[1] * m[10] +
            m[4] * m[2] * m[9] +
            m[8] * m[1] * m[6] -
            m[8] * m[2] * m[5]

    inv.forEach((v, i) => { inv[i] = v / det })
    this._values = inv
    return this
  }

  setMatrixValue (transformList) {
    const temp = new DOMMatrix(transformList)
    this._values = temp._values
    this._is2D = temp._is2D
    return this
  }

  transformPoint (point) {
    point = new DOMPoint(point)
    const x = point.x
    const y = point.y
    const z = point.z
    const w = point.w
    const values = this._values
    const nx = values[M11] * x + values[M21] * y + values[M31] * z + values[M41] * w
    const ny = values[M12] * x + values[M22] * y + values[M32] * z + values[M42] * w
    const nz = values[M13] * x + values[M23] * y + values[M33] * z + values[M43] * w
    const nw = values[M14] * x + values[M24] * y + values[M34] * z + values[M44] * w
    return new DOMPoint(nx, ny, nz, nw)
  }

  toFloat32Array () {
    return Float32Array.from(this._values)
  }

  toFloat64Array () {
    return this._values.slice(0)
  }

  static fromMatrix (init) {
    if (!(init instanceof DOMMatrix)) throw new TypeError('Expected DOMMatrix')
    return new DOMMatrix(init._values)
  }

  static fromFloat32Array (init) {
    if (!(init instanceof Float32Array)) throw new TypeError('Expected Float32Array')
    return new DOMMatrix(init)
  }

  static fromFloat64Array (init) {
    if (!(init instanceof Float64Array)) throw new TypeError('Expected Float64Array')
    return new DOMMatrix(init)
  }

  [util.inspect.custom || 'inspect'] (depth, options) {
    if (depth < 0) return '[DOMMatrix]'

    return `DOMMatrix [
      a: ${this.a}
      b: ${this.b}
      c: ${this.c}
      d: ${this.d}
      e: ${this.e}
      f: ${this.f}
      m11: ${this.m11}
      m12: ${this.m12}
      m13: ${this.m13}
      m14: ${this.m14}
      m21: ${this.m21}
      m22: ${this.m22}
      m23: ${this.m23}
      m23: ${this.m23}
      m31: ${this.m31}
      m32: ${this.m32}
      m33: ${this.m33}
      m34: ${this.m34}
      m41: ${this.m41}
      m42: ${this.m42}
      m43: ${this.m43}
      m44: ${this.m44}
      is2D: ${this.is2D}
      isIdentity: ${this.isIdentity} ]`
  }
}

/**
 * Checks that `value` is a number and sets the value.
 */
function setNumber2D (receiver, index, value) {
  if (typeof value !== 'number') throw new TypeError('Expected number')
  return (receiver._values[index] = value)
}

/**
 * Checks that `value` is a number, sets `_is2D = false` if necessary and sets
 * the value.
 */
function setNumber3D (receiver, index, value) {
  if (typeof value !== 'number') throw new TypeError('Expected number')
  if (index === M33 || index === M44) {
    if (value !== 1) receiver._is2D = false
  } else if (value !== 0) receiver._is2D = false
  return (receiver._values[index] = value)
}

Object.defineProperties(DOMMatrix.prototype, {
  m11: { get () { return this._values[M11] }, set (v) { return setNumber2D(this, M11, v) } },
  m12: { get () { return this._values[M12] }, set (v) { return setNumber2D(this, M12, v) } },
  m13: { get () { return this._values[M13] }, set (v) { return setNumber3D(this, M13, v) } },
  m14: { get () { return this._values[M14] }, set (v) { return setNumber3D(this, M14, v) } },
  m21: { get () { return this._values[M21] }, set (v) { return setNumber2D(this, M21, v) } },
  m22: { get () { return this._values[M22] }, set (v) { return setNumber2D(this, M22, v) } },
  m23: { get () { return this._values[M23] }, set (v) { return setNumber3D(this, M23, v) } },
  m24: { get () { return this._values[M24] }, set (v) { return setNumber3D(this, M24, v) } },
  m31: { get () { return this._values[M31] }, set (v) { return setNumber3D(this, M31, v) } },
  m32: { get () { return this._values[M32] }, set (v) { return setNumber3D(this, M32, v) } },
  m33: { get () { return this._values[M33] }, set (v) { return setNumber3D(this, M33, v) } },
  m34: { get () { return this._values[M34] }, set (v) { return setNumber3D(this, M34, v) } },
  m41: { get () { return this._values[M41] }, set (v) { return setNumber2D(this, M41, v) } },
  m42: { get () { return this._values[M42] }, set (v) { return setNumber2D(this, M42, v) } },
  m43: { get () { return this._values[M43] }, set (v) { return setNumber3D(this, M43, v) } },
  m44: { get () { return this._values[M44] }, set (v) { return setNumber3D(this, M44, v) } },

  a: { get () { return this.m11 }, set (v) { return (this.m11 = v) } },
  b: { get () { return this.m12 }, set (v) { return (this.m12 = v) } },
  c: { get () { return this.m21 }, set (v) { return (this.m21 = v) } },
  d: { get () { return this.m22 }, set (v) { return (this.m22 = v) } },
  e: { get () { return this.m41 }, set (v) { return (this.m41 = v) } },
  f: { get () { return this.m42 }, set (v) { return (this.m42 = v) } },

  is2D: { get () { return this._is2D } }, // read-only

  isIdentity: {
    get () {
      const values = this._values
      return (values[M11] === 1 && values[M12] === 0 && values[M13] === 0 && values[M14] === 0 &&
             values[M21] === 0 && values[M22] === 1 && values[M23] === 0 && values[M24] === 0 &&
             values[M31] === 0 && values[M32] === 0 && values[M33] === 1 && values[M34] === 0 &&
             values[M41] === 0 && values[M42] === 0 && values[M43] === 0 && values[M44] === 1)
    }
  }
})

/**
 * Instantiates a DOMMatrix, bypassing the constructor.
 * @param {Float64Array} values Value to assign to `_values`. This is assigned
 *   without copying (okay because all usages are followed by a  multiply).
 */
function newInstance (values) {
  const instance = Object.create(DOMMatrix.prototype)
  instance.constructor = DOMMatrix
  instance._is2D = true
  instance._values = values
  return instance
}

function multiply (A, B) {
  const dest = new Float64Array(16)
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      let sum = 0
      for (let k = 0; k < 4; k++) {
        sum += A[i * 4 + k] * B[k * 4 + j]
      }
      dest[i * 4 + j] = sum
    }
  }
  return dest
}

module.exports = { DOMMatrix, DOMPoint }


/***/ }),
/* 27 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*!
 * Canvas - PNGStream
 * Copyright (c) 2010 LearnBoost <tj@learnboost.com>
 * MIT Licensed
 */

const { Readable } = __webpack_require__(28)
function noop () {}

class PNGStream extends Readable {
  constructor (canvas, options) {
    super()

    if (options &&
      options.palette instanceof Uint8ClampedArray &&
      options.palette.length % 4 !== 0) {
      throw new Error('Palette length must be a multiple of 4.')
    }
    this.canvas = canvas
    this.options = options || {}
  }

  _read () {
    // For now we're not controlling the c++ code's data emission, so we only
    // call canvas.streamPNGSync once and let it emit data at will.
    this._read = noop

    this.canvas.streamPNGSync((err, chunk, len) => {
      if (err) {
        this.emit('error', err)
      } else if (len) {
        this.push(chunk)
      } else {
        this.push(null)
      }
    }, this.options)
  }
}

module.exports = PNGStream


/***/ }),
/* 28 */
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),
/* 29 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*!
 * Canvas - PDFStream
 */

const { Readable } = __webpack_require__(28)
function noop () {}

class PDFStream extends Readable {
  constructor (canvas, options) {
    super()

    this.canvas = canvas
    this.options = options
  }

  _read () {
    // For now we're not controlling the c++ code's data emission, so we only
    // call canvas.streamPDFSync once and let it emit data at will.
    this._read = noop

    this.canvas.streamPDFSync((err, chunk, len) => {
      if (err) {
        this.emit('error', err)
      } else if (len) {
        this.push(chunk)
      } else {
        this.push(null)
      }
    }, this.options)
  }
}

module.exports = PDFStream


/***/ }),
/* 30 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*!
 * Canvas - JPEGStream
 * Copyright (c) 2010 LearnBoost <tj@learnboost.com>
 * MIT Licensed
 */

const { Readable } = __webpack_require__(28)
function noop () {}

class JPEGStream extends Readable {
  constructor (canvas, options) {
    super()

    if (canvas.streamJPEGSync === undefined) {
      throw new Error('node-canvas was built without JPEG support.')
    }

    this.options = options
    this.canvas = canvas
  }

  _read () {
    // For now we're not controlling the c++ code's data emission, so we only
    // call canvas.streamJPEGSync once and let it emit data at will.
    this._read = noop

    this.canvas.streamJPEGSync(this.options, (err, chunk) => {
      if (err) {
        this.emit('error', err)
      } else if (chunk) {
        this.push(chunk)
      } else {
        this.push(null)
      }
    })
  }
};

module.exports = JPEGStream


/***/ }),
/* 31 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*!
 * Canvas - Image
 * Copyright (c) 2010 LearnBoost <tj@learnboost.com>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

const bindings = __webpack_require__(22)
const Image = module.exports = bindings.Image
const util = __webpack_require__(5)

// Lazily loaded simple-get
let get

const { GetSource, SetSource } = bindings

Object.defineProperty(Image.prototype, 'src', {
  /**
   * src setter. Valid values:
   *  * `data:` URI
   *  * Local file path
   *  * HTTP or HTTPS URL
   *  * Buffer containing image data (i.e. not a `data:` URI stored in a Buffer)
   *
   * @param {String|Buffer} val filename, buffer, data URI, URL
   * @api public
   */
  set (val) {
    if (typeof val === 'string') {
      if (/^\s*data:/.test(val)) { // data: URI
        const commaI = val.indexOf(',')
        // 'base64' must come before the comma
        const isBase64 = val.lastIndexOf('base64', commaI) !== -1
        const content = val.slice(commaI + 1)
        setSource(this, Buffer.from(content, isBase64 ? 'base64' : 'utf8'), val)
      } else if (/^\s*https?:\/\//.test(val)) { // remote URL
        const onerror = err => {
          if (typeof this.onerror === 'function') {
            this.onerror(err)
          } else {
            throw err
          }
        }

        if (!get) get = __webpack_require__(32)

        get.concat({
          url: val,
          headers: { 'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36' }
        }, (err, res, data) => {
          if (err) return onerror(err)

          if (res.statusCode < 200 || res.statusCode >= 300) {
            return onerror(new Error(`Server responded with ${res.statusCode}`))
          }

          setSource(this, data)
        })
      } else { // local file path assumed
        setSource(this, val)
      }
    } else if (Buffer.isBuffer(val)) {
      setSource(this, val)
    }
  },

  get () {
    // TODO https://github.com/Automattic/node-canvas/issues/118
    return getSource(this)
  },

  configurable: true
})

// TODO || is for Node.js pre-v6.6.0
Image.prototype[util.inspect.custom || 'inspect'] = function () {
  return '[Image' +
    (this.complete ? ':' + this.width + 'x' + this.height : '') +
    (this.src ? ' ' + this.src : '') +
    (this.complete ? ' complete' : '') +
    ']'
}

function getSource (img) {
  return img._originalSource || GetSource.call(img)
}

function setSource (img, src, origSrc) {
  SetSource.call(img, src)
  img._originalSource = origSrc
}


/***/ }),
/* 32 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = simpleGet

const concat = __webpack_require__(33)
const decompressResponse = __webpack_require__(34) // excluded from browser build
const http = __webpack_require__(37)
const https = __webpack_require__(38)
const once = __webpack_require__(39)
const querystring = __webpack_require__(41)
const url = __webpack_require__(42)

const isStream = o => o !== null && typeof o === 'object' && typeof o.pipe === 'function'

function simpleGet (opts, cb) {
  opts = Object.assign({ maxRedirects: 10 }, typeof opts === 'string' ? { url: opts } : opts)
  cb = once(cb)

  if (opts.url) {
    const { hostname, port, protocol, auth, path } = url.parse(opts.url) // eslint-disable-line node/no-deprecated-api
    delete opts.url
    if (!hostname && !port && !protocol && !auth) opts.path = path // Relative redirect
    else Object.assign(opts, { hostname, port, protocol, auth, path }) // Absolute redirect
  }

  const headers = { 'accept-encoding': 'gzip, deflate' }
  if (opts.headers) Object.keys(opts.headers).forEach(k => (headers[k.toLowerCase()] = opts.headers[k]))
  opts.headers = headers

  let body
  if (opts.body) {
    body = opts.json && !isStream(opts.body) ? JSON.stringify(opts.body) : opts.body
  } else if (opts.form) {
    body = typeof opts.form === 'string' ? opts.form : querystring.stringify(opts.form)
    opts.headers['content-type'] = 'application/x-www-form-urlencoded'
  }

  if (body) {
    if (!opts.method) opts.method = 'POST'
    if (!isStream(body)) opts.headers['content-length'] = Buffer.byteLength(body)
    if (opts.json && !opts.form) opts.headers['content-type'] = 'application/json'
  }
  delete opts.body; delete opts.form

  if (opts.json) opts.headers.accept = 'application/json'
  if (opts.method) opts.method = opts.method.toUpperCase()

  const originalHost = opts.hostname // hostname before potential redirect
  const protocol = opts.protocol === 'https:' ? https : http // Support http/https urls
  const req = protocol.request(opts, res => {
    if (opts.followRedirects !== false && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
      opts.url = res.headers.location // Follow 3xx redirects
      delete opts.headers.host // Discard `host` header on redirect (see #32)
      res.resume() // Discard response

      const redirectHost = url.parse(opts.url).hostname // eslint-disable-line node/no-deprecated-api
      // If redirected host is different than original host, drop headers to prevent cookie leak (#73)
      if (redirectHost !== null && redirectHost !== originalHost) {
        delete opts.headers.cookie
        delete opts.headers.authorization
      }

      if (opts.method === 'POST' && [301, 302].includes(res.statusCode)) {
        opts.method = 'GET' // On 301/302 redirect, change POST to GET (see #35)
        delete opts.headers['content-length']; delete opts.headers['content-type']
      }

      if (opts.maxRedirects-- === 0) return cb(new Error('too many redirects'))
      else return simpleGet(opts, cb)
    }

    const tryUnzip = typeof decompressResponse === 'function' && opts.method !== 'HEAD'
    cb(null, tryUnzip ? decompressResponse(res) : res)
  })
  req.on('timeout', () => {
    req.abort()
    cb(new Error('Request timed out'))
  })
  req.on('error', cb)

  if (isStream(body)) body.on('error', cb).pipe(req)
  else req.end(body)

  return req
}

simpleGet.concat = (opts, cb) => {
  return simpleGet(opts, (err, res) => {
    if (err) return cb(err)
    concat(res, (err, data) => {
      if (err) return cb(err)
      if (opts.json) {
        try {
          data = JSON.parse(data.toString())
        } catch (err) {
          return cb(err, res, data)
        }
      }
      cb(null, res, data)
    })
  })
}

;['get', 'post', 'put', 'patch', 'head', 'delete'].forEach(method => {
  simpleGet[method] = (opts, cb) => {
    if (typeof opts === 'string') opts = { url: opts }
    return simpleGet(Object.assign({ method: method.toUpperCase() }, opts), cb)
  }
})


/***/ }),
/* 33 */
/***/ ((module) => {

/*! simple-concat. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
module.exports = function (stream, cb) {
  var chunks = []
  stream.on('data', function (chunk) {
    chunks.push(chunk)
  })
  stream.once('end', function () {
    if (cb) cb(null, Buffer.concat(chunks))
    cb = null
  })
  stream.once('error', function (err) {
    if (cb) cb(err)
    cb = null
  })
}


/***/ }),
/* 34 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const {PassThrough: PassThroughStream} = __webpack_require__(28);
const zlib = __webpack_require__(35);
const mimicResponse = __webpack_require__(36);

const decompressResponse = response => {
	const contentEncoding = (response.headers['content-encoding'] || '').toLowerCase();

	if (!['gzip', 'deflate', 'br'].includes(contentEncoding)) {
		return response;
	}

	const isBrotli = contentEncoding === 'br';
	if (isBrotli && typeof zlib.createBrotliDecompress !== 'function') {
		return response;
	}

	const decompress = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();
	const stream = new PassThroughStream();

	mimicResponse(response, stream);

	decompress.on('error', error => {
		// Ignore empty response
		if (error.code === 'Z_BUF_ERROR') {
			stream.end();
			return;
		}

		stream.emit('error', error);
	});

	response.pipe(decompress).pipe(stream);

	return stream;
};

module.exports = decompressResponse;
// TODO: remove this in the next major version
module.exports["default"] = decompressResponse;


/***/ }),
/* 35 */
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),
/* 36 */
/***/ ((module) => {

"use strict";


// We define these manually to ensure they're always copied
// even if they would move up the prototype chain
// https://nodejs.org/api/http.html#http_class_http_incomingmessage
const knownProperties = [
	'aborted',
	'complete',
	'destroy',
	'headers',
	'httpVersion',
	'httpVersionMinor',
	'httpVersionMajor',
	'method',
	'rawHeaders',
	'rawTrailers',
	'setTimeout',
	'socket',
	'statusCode',
	'statusMessage',
	'trailers',
	'url'
];

module.exports = (fromStream, toStream) => {
	const fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));

	for (const property of fromProperties) {
		// Don't overwrite existing properties.
		if (property in toStream) {
			continue;
		}

		toStream[property] = typeof fromStream[property] === 'function' ? fromStream[property].bind(fromStream) : fromStream[property];
	}

	return toStream;
};


/***/ }),
/* 37 */
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),
/* 38 */
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),
/* 39 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(40)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),
/* 40 */
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),
/* 41 */
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),
/* 42 */
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),
/* 43 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/*!
 * Canvas - CanvasPattern
 * Copyright (c) 2010 LearnBoost <tj@learnboost.com>
 * MIT Licensed
 */

const bindings = __webpack_require__(22)
const { DOMMatrix } = __webpack_require__(26)

bindings.CanvasPatternInit(DOMMatrix)
module.exports = bindings.CanvasPattern

bindings.CanvasPattern.prototype.toString = function () {
	return '[object CanvasPattern]'
}


/***/ }),
/* 44 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"canvas","description":"Canvas graphics API backed by Cairo","version":"2.11.2","author":"TJ Holowaychuk <tj@learnboost.com>","main":"index.js","browser":"browser.js","contributors":["Nathan Rajlich <nathan@tootallnate.net>","Rod Vagg <r@va.gg>","Juriy Zaytsev <kangax@gmail.com>"],"keywords":["canvas","graphic","graphics","pixman","cairo","image","images","pdf"],"homepage":"https://github.com/Automattic/node-canvas","repository":"git://github.com/Automattic/node-canvas.git","scripts":{"prebenchmark":"node-gyp build","benchmark":"node benchmarks/run.js","lint":"standard examples/*.js test/server.js test/public/*.js benchmarks/run.js lib/context2d.js util/has_lib.js browser.js index.js","test":"mocha test/*.test.js","pretest-server":"node-gyp build","test-server":"node test/server.js","generate-wpt":"node ./test/wpt/generate.js","test-wpt":"mocha test/wpt/generated/*.js","install":"node-pre-gyp install --fallback-to-build --update-binary","dtslint":"dtslint types"},"binary":{"module_name":"canvas","module_path":"build/Release","host":"https://github.com/Automattic/node-canvas/releases/download/","remote_path":"v{version}","package_name":"{module_name}-v{version}-{node_abi}-{platform}-{libc}-{arch}.tar.gz"},"files":["binding.gyp","lib/","src/","util/","types/index.d.ts"],"types":"types/index.d.ts","dependencies":{"@mapbox/node-pre-gyp":"^1.0.0","nan":"^2.17.0","simple-get":"^3.0.3"},"devDependencies":{"@types/node":"^10.12.18","assert-rejects":"^1.0.0","dtslint":"^4.0.7","express":"^4.16.3","js-yaml":"^4.1.0","mocha":"^5.2.0","pixelmatch":"^4.0.2","standard":"^12.0.1","typescript":"^4.2.2"},"engines":{"node":">=6"},"license":"MIT"}');

/***/ }),
/* 45 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Extension: () => (/* binding */ Extension),
/* harmony export */   generateJNodeImages: () => (/* binding */ generateJNodeImages),
/* harmony export */   printAllImages: () => (/* binding */ printAllImages)
/* harmony export */ });
/* harmony import */ var sharp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(46);
/* harmony import */ var sharp__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(sharp__WEBPACK_IMPORTED_MODULE_0__);

var Extension;
(function (Extension) {
    Extension["jpg"] = "jpg";
    Extension["png"] = "png";
    Extension["webp"] = "webp";
})(Extension || (Extension = {}));
async function printAllImages(outputFolder, images, extension) {
    images.forEach(async (image) => {
        const file = outputFolder + `/${image.name}.${extension.valueOf()}`;
        await saveWebPImage(image, file);
    });
}
async function generateJNodeImages(prefix, extMods, dictionary, images) {
    const re1 = /[ ]/gi;
    const re2 = /[\W]/gi;
    const re3 = /[_]/gi;
    Object.entries(dictionary).forEach(([key, value]) => {
        extMods.forEach(async (x) => {
            const file = `${prefix}/${key.toLowerCase().replace(re1, '_').replace(re2, '').replace(re3, '-')}.${x}.webp`;
            if (x === 'token' && value.icon !== undefined) {
                const image = images.find(y => y.name === value.icon);
                await saveWebPImage(image, file);
            }
            else {
                const image = images.find(y => y.name === value.orig);
                await saveWebPImage(image, file);
            }
        });
    });
}
async function saveWebPImage(image, file) {
    if (image != undefined) {
        const width = image.width;
        const height = image.height;
        const channels = image.channels();
        await sharp__WEBPACK_IMPORTED_MODULE_0___default()(image.data, {
            raw: { width, height, channels }
        }).toFile(file);
        console.log(`Image saved ${file}`);
    }
}


/***/ }),
/* 46 */
/***/ ((module) => {

"use strict";
module.exports = require("sharp");

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && queue.d < 1) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = -1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && queue.d < 0 && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "";
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(0);
/******/ 	
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5idW5kbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFvQjtBQUNVO0FBRXlCO0FBQ1U7QUFRakUsS0FBSyxVQUFVLElBQUksQ0FBQyxJQUFVO0lBQzVCLElBQUk7UUFFRixJQUFJLFFBQVEsR0FBRyxNQUFNLG9EQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBRy9DLElBQUksV0FBVyxHQUFJLHVEQUFhLENBQUMsaURBQVUsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLEtBQUssQ0FBb0IsQ0FBQztRQUMzRixJQUFJLFdBQVcsS0FBSyxTQUFTLEVBQUU7WUFDN0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1lBQ2hDLE9BQU87U0FDUjtRQUVELElBQUksSUFBSSxDQUFDLFNBQVMsS0FBSyxJQUFJLEVBQUU7WUFDM0IsTUFBTSwrREFBeUIsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLFFBQVEsQ0FBQyxNQUFNLEVBQUUsMERBQW9CLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDOUY7YUFBTTtZQUVMLE1BQU0sQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLEVBQUUsRUFBRTtnQkFFM0UsTUFBTSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVyxJQUFJLFdBQVcsQ0FBQyxJQUFJLElBQUksU0FBUyxFQUFFLENBQUM7Z0JBQ3RFLE1BQU0sa0RBQVcsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7Z0JBQ3JELE1BQU0sb0VBQThCLENBQUMsTUFBTSxFQUFFLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxFQUFFLFVBQVUsRUFBRSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUM7WUFFaEcsQ0FBQyxDQUFDLENBQUM7U0FDSjtLQUtGO0lBQUMsT0FBTyxLQUFLLEVBQUU7UUFDZCxPQUFPLENBQUMsR0FBRyxDQUFDLHVCQUF1QixLQUFLLEVBQUUsQ0FBQyxDQUFDO0tBQzdDO0FBQ0gsQ0FBQztBQUVELE1BQU0sSUFBSSxDQUFDLHVDQUFJLENBQUMsQ0FBQzs7Ozs7Ozs7OztBQzdDakI7Ozs7Ozs7Ozs7Ozs7QUNBMEM7QUFHMUMsTUFBTSxNQUFNLEdBQUcsSUFBSSxvREFBYyxDQUFDLEVBQUUsV0FBVyxFQUFFLHFCQUFxQixFQUFFLENBQUMsQ0FBQztBQUMxRSxNQUFNLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxhQUFhLEVBQUU7SUFDckMsT0FBTyxFQUFFLE9BQU87SUFDaEIsTUFBTSxFQUFFLFlBQVk7SUFDcEIsUUFBUSxFQUFFLEtBQUs7SUFDZixJQUFJLEVBQUUsc0RBQXNEO0NBQy9ELENBQUMsQ0FBQztBQUNILE1BQU0sQ0FBQyxZQUFZLENBQUMsVUFBVSxFQUFFO0lBQzVCLElBQUksRUFBRSxLQUFLO0lBQ1gsSUFBSSxFQUFFLG1DQUFtQztDQUM1QyxDQUFDLENBQUM7QUFDSCxNQUFNLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRTtJQUMvQixJQUFJLEVBQUUsS0FBSztJQUNYLElBQUksRUFBRSxtQkFBbUI7Q0FDNUIsQ0FBQyxDQUFDO0FBQ0ksTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLFVBQVUsRUFBRSxDQUFDOzs7Ozs7OztBQ2xCeEM7QUFDQTs7QUFFWTs7QUFFWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLENBQVE7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLENBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLENBQUk7QUFDdkIsWUFBWSxtQkFBTyxDQUFDLENBQVc7QUFDL0IsYUFBYSxtQkFBTyxDQUFDLENBQU07QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DLE1BQU07QUFDTiwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQyxrQkFBa0I7O0FBRW5EO0FBQ0EsVUFBVTtBQUNWLHNDQUFzQyxrQkFBa0I7O0FBRXhEO0FBQ0EsVUFBVTtBQUNWLHlDQUF5QyxrQkFBa0I7O0FBRTNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQkFBK0Isa0JBQWtCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QixVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDJCQUEyQixHQUFHO0FBQzlCLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxrQkFBa0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFPLENBQUMsQ0FBZ0I7QUFDL0MscUNBQXFDLE9BQU87QUFDNUM7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixtQkFBTyxDQUFDLENBQWdCO0FBQy9DLHFDQUFxQztBQUNyQztBQUNBLGdFQUFnRTtBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGlFQUFpRTtBQUNqRTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsY0FBYztBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0Msd0JBQXdCO0FBQzlEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9DQUFvQztBQUN4RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCLGNBQWMsZUFBZSxhQUFhO0FBQ2hFLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHlFQUF5RSxTQUFTO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxJQUFJLDBDQUEwQyxLQUFLO0FBQ3BHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLDBCQUEwQjtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhOztBQUUzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHNDQUFzQztBQUMzRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZLElBQUksYUFBYSxZQUFZLGNBQWM7QUFDaEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxvQkFBb0I7QUFDM0U7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0RBQXdEO0FBQ3hELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCLGlEQUFpRDtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsaUJBQWlCO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnREFBK0M7QUFDL0M7QUFDQTtBQUNBLHlCQUF5QixrRUFBa0U7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUMsRUFBQztBQUNGOzs7Ozs7OztBQzFuSEE7Ozs7Ozs7QUNBQTs7Ozs7OztBQ0FBO0FBQ0E7O0FBRVk7O0FBRVosUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyxDQUFNOzs7QUFHbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxLQUFLO0FBQzNFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRLG9DQUFvQyxXQUFXO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE9BQU87QUFDNUU7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDbEVBOzs7Ozs7O0FDQUE7QUFDQTs7QUFFWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQyw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBOztBQUVBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdCQUF3QjtBQUNsQyw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNEJBQTRCLHdDQUF3QztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjs7Ozs7Ozs7Ozs7Ozs7O0FDdmJvQjtBQUNaOzs7Ozs7Ozs7Ozs7QUNNcEIsTUFBTSxRQUFRO0lBV047SUFDQTtJQUNBO0lBQ0E7SUFaSixLQUFLLENBQVM7SUFRckIsWUFDVyxJQUFZLEVBQ1osS0FBYSxFQUNiLE1BQWMsRUFDZCxJQUF1QjtRQUh2QixTQUFJLEdBQUosSUFBSSxDQUFRO1FBQ1osVUFBSyxHQUFMLEtBQUssQ0FBUTtRQUNiLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDZCxTQUFJLEdBQUosSUFBSSxDQUFtQjtRQUU5QixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDN0IsQ0FBQztJQUtNLFFBQVE7UUFDWCxJQUFJLFFBQVEsR0FBa0IsQ0FBQyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQzlDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNQLFFBQVEsR0FBRyxDQUFDLENBQUM7U0FDaEI7YUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDZCxRQUFRLEdBQUcsQ0FBQyxDQUFDO1NBQ2hCO2FBQU07WUFDSCxRQUFRLEdBQUcsQ0FBa0IsQ0FBQztTQUNqQztRQUNELE9BQU8sUUFBUSxDQUFDO0lBQ3BCLENBQUM7SUFBQSxDQUFDO0NBRUw7Ozs7Ozs7Ozs7OztBQzFDRCxJQUFZLFVBS1g7QUFMRCxXQUFZLFVBQVU7SUFDbEIsNkNBQUs7SUFDTCx1REFBVTtJQUNWLDJEQUFZO0lBQ1osdURBQVU7QUFDZCxDQUFDLEVBTFcsVUFBVSxLQUFWLFVBQVUsUUFLckI7QUE4RUQsSUFBSSxRQUFRLEdBQWM7SUFDdEIsSUFBSSxFQUFFLE1BQU07SUFDWixLQUFLLEVBQUUsTUFBTTtJQUNiLE1BQU0sRUFBRSxNQUFNO0lBQ2QsYUFBYSxFQUFFLE1BQU07SUFDckIsTUFBTSxFQUFDLEVBQ047Q0FDSjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMxRmdEO0FBQ0o7QUFDRDs7Ozs7Ozs7Ozs7Ozs7QUNGTDtBQUNHO0FBUW5DLFNBQVMsYUFBYSxDQUFDLE1BQWtCLEVBQUUsT0FBZTtJQUM3RCxRQUFRLE1BQU0sRUFBRTtRQUVaLEtBQUssaURBQVUsQ0FBQyxVQUFVO1lBQ3RCLE9BQU8saUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDdEMsS0FBSyxpREFBVSxDQUFDLEtBQUssQ0FBQztRQUN0QixLQUFLLGlEQUFVLENBQUMsVUFBVSxDQUFDO1FBQzNCLEtBQUssaURBQVUsQ0FBQyxZQUFZLENBQUM7UUFDN0I7WUFDSSxPQUFPLFNBQVMsQ0FBQztLQUN4QjtBQUNMLENBQUM7QUFPRCxTQUFTLGlCQUFpQixDQUFDLE9BQWU7SUFDdEMsT0FBTyxvREFBYyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEtBQUssT0FBTyxDQUFDLENBQUM7QUFDbkUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0FDM0IwRDtBQUNBO0FBQ0E7QUFFcEQsTUFBTSxjQUFjLEdBQXFCO0lBQzVDLHdEQUFlO0lBQ2Ysd0RBQWU7SUFDZix3REFBZTtDQUNsQixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNWaUc7QUFDOUQ7QUFFckMsTUFBTSxPQUFPO0lBR0U7SUFDQTtJQUNBO0lBSkosTUFBTSxDQUFhO0lBQzFCLFlBQ1csS0FBYSxFQUNiLE1BQWMsRUFDZCxZQUFvQjtRQUZwQixVQUFLLEdBQUwsS0FBSyxDQUFRO1FBQ2IsV0FBTSxHQUFOLE1BQU0sQ0FBUTtRQUNkLGlCQUFZLEdBQVosWUFBWSxDQUFRO1FBRTNCLElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxDQUFDO0lBQ3JCLENBQUM7Q0FDSjtBQUlELDJEQUFtQixDQUFDLFNBQVM7SUFDekIsbURBQW1ELENBQUM7QUFRakQsS0FBSyxVQUFVLFVBQVUsQ0FBQyxJQUFZO0lBQ3pDLElBQUksR0FBRyxHQUFxQixNQUFNLHVEQUFXLENBQUMsSUFBSSxDQUFDLENBQUMsT0FBTyxDQUFDO0lBRTVELE1BQU0sUUFBUSxHQUFHLE1BQU0sR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQ3pDLElBQUksUUFBUSxHQUFHLElBQUksT0FBTyxDQUNyQixRQUFRLENBQUMsSUFBWSxDQUFDLE9BQU8sQ0FBQyxFQUM5QixRQUFRLENBQUMsSUFBWSxDQUFDLFFBQVEsQ0FBQyxFQUMvQixRQUFRLENBQUMsSUFBWSxDQUFDLGNBQWMsQ0FBQyxDQUN6QyxDQUFDO0lBQ0YsTUFBTSxhQUFhLEdBQUcsR0FBRyxDQUFDLFFBQVEsQ0FBQztJQUduQyxLQUFLLElBQUksV0FBVyxHQUFHLENBQUMsRUFBRSxXQUFXLElBQUksYUFBYSxFQUFFLFdBQVcsSUFBSSxDQUFDLEVBQUU7UUFDdEUsTUFBTSxNQUFNLEdBQUcsYUFBYSxDQUFDLFdBQVcsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUMvQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLE1BQU0sTUFBTSxDQUFDLENBQUM7S0FDekM7SUFFRCxPQUFPLE1BQU0sUUFBUSxDQUFDO0FBQzFCLENBQUM7QUFTRCxLQUFLLFVBQVUsYUFBYSxDQUFDLE9BQWUsRUFBRSxHQUFxQjtJQUMvRCxNQUFNLE1BQU0sR0FBZSxFQUFFLENBQUM7SUFDOUIsSUFBSTtRQUNBLE1BQU0sT0FBTyxHQUFpQixNQUFNLEdBQUcsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDekQsTUFBTSxZQUFZLEdBQUcsTUFBTSxPQUFPLENBQUMsZUFBZSxFQUFFLENBQUM7UUFHckQsTUFBTSxnQkFBZ0IsR0FBRztZQUNyQiwyQ0FBRyxDQUFDLGdCQUFnQjtZQUNwQiwyQ0FBRyxDQUFDLGlCQUFpQjtZQUNyQiwyQ0FBRyxDQUFDLHVCQUF1QjtTQUM5QixDQUFDO1FBR0YsWUFBWSxDQUFDLE9BQU87YUFDZixPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFLEVBQUU7WUFDdEIsSUFBSSxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ3BDLE1BQU0sU0FBUyxHQUFHLFlBQVksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2pELE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsU0FBUyxDQUFDLENBQUM7Z0JBRXJELE9BQU8sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBVSxFQUFFLEVBQUU7b0JBQzdDLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxHQUFHLEtBQUssQ0FBQztvQkFDdkMsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLCtDQUFRLENBQUMsU0FBUyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ3BFLENBQUMsQ0FBQyxDQUFDO2FBQ047UUFDTCxDQUFDLENBQUMsQ0FBQztLQUNWO0lBQUMsT0FBTyxLQUFLLEVBQUU7UUFDWixPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0tBQ3RCO0lBQ0QsT0FBTyxNQUFNLENBQUM7QUFDbEIsQ0FBQzs7Ozs7OztBQ2xGRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUtxRDtBQUMzRCxDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsSUFBSTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLElBQUk7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGNBQWMsRUFBRSxjQUFjLEVBQUUsY0FBYztBQUM3RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUixvQ0FBb0MsR0FBRztBQUN2QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxnQkFBZ0IsTUFBTTtBQUN0QixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWix5REFBeUQsR0FBRztBQUM1RDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBSTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1ELFFBQVE7QUFDM0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsNEZBQTRGO0FBQzVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFjO0FBQ3pDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQyxJQUFJLEdBQUc7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxnRkFBZ0YsZUFBZTtBQUMvRixLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixVQUFjO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdFQUFnRSxPQUFPO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3RUFBd0UsZUFBZTtBQUN2Rjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0IsR0FBRyw2REFBNkQ7QUFDbkc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0REFBNEQsS0FBSztBQUNqRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsaUJBQWlCO0FBQy9EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG1FQUFtRSxNQUFNO0FBQ3pFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQ7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVHQUF1RyxvQkFBb0I7QUFDM0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsSUFBSSxHQUFHLG9CQUFvQjtBQUNoRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDLDRCQUE0QixhQUFhO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsYUFBYTtBQUMxQyw0QkFBNEIsYUFBYTtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QiwwQkFBMEI7QUFDeEQsK0JBQStCLDRCQUE0QjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLDZCQUE2QixFQUFFLFdBQVc7QUFDeEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUs7QUFDM0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0RBQXdELEtBQUs7QUFDN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDJCQUEyQixFQUFFLFNBQVM7QUFDM0Q7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVEOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0RBQW9ELEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSwyQkFBMkIsRUFBRSxtQkFBbUIsRUFBRTtBQUM3Szs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELE1BQU07QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUNBQW1DLFdBQVcsSUFBSTtBQUMxRixLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGFBQWEsRUFBRSxTQUFTO0FBQzNDO0FBQ0Esc0RBQXNELElBQUk7QUFDMUQsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxtQ0FBbUMsTUFBTTtBQUN6QyxvQ0FBb0MsT0FBTztBQUMzQzs7QUFFQTtBQUNBLHVDQUF1QyxPQUFPLEVBQUUsT0FBTztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsUUFBUTtBQUNqRDs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QsV0FBVzs7QUFFM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVzs7QUFFWCxrREFBa0Qsc0JBQXNCLE1BQU0sR0FBRztBQUNqRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQ0FBa0MsV0FBVyxFQUFFLHNCQUFzQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtELFFBQVE7QUFDMUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsU0FBUyxXQUFXLEVBQUU7QUFDaEUsZ0NBQWdDLGVBQWUsZUFBZSxFQUFFLE1BQU0sS0FBSztBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrRUFBa0U7QUFDbEUsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQiw2QkFBNkI7QUFDNUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixlQUFlLFNBQVMsV0FBVyxFQUFFO0FBQ2pFOztBQUVBO0FBQ0EsMEJBQTBCLGVBQWUsZ0JBQWdCLEVBQUUsTUFBTSxLQUFLO0FBQ3RFLE1BQU07QUFDTixnQ0FBZ0MsNkJBQTZCOztBQUU3RDtBQUNBLHNDQUFzQyw2QkFBNkIsSUFBSTtBQUN2RTs7QUFFQSwwQkFBMEIsZUFBZSw0QkFBNEIsRUFBRSxFQUFFLElBQUksTUFBTSxLQUFLO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsWUFBWTtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixXQUFXO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBOztBQUVBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVDQUF1QyxhQUFhO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwQ0FBMEMsUUFBUTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsRUFBRTs7QUFFM0U7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsWUFBWTtBQUN6RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsS0FBSyxLQUFLLHFCQUFxQjtBQUN4RDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsUUFBUSxFQUFFLE1BQU0sRUFBRSxnQkFBZ0IsS0FBSyxTQUFTO0FBQ3ZFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGtCQUFrQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGtCQUFrQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxRQUFRO0FBQ25EOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQsUUFBUTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLGtFQUFrRSxZQUFZO0FBQzlFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsVUFBVTtBQUNoQzs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsVUFBVTtBQUM1Qjs7QUFFQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsTUFBTTtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrREFBK0QsVUFBVTtBQUN6RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0RBQW9ELFlBQVk7QUFDaEU7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFlBQVk7QUFDOUIsNkNBQTZDLGNBQWM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsdURBQXVELFlBQVk7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxnRUFBZ0UsV0FBVztBQUMzRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLDZEQUE2RCxRQUFRO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5REFBeUQsYUFBYTtBQUN0RTtBQUNBOztBQUVBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRCxHQUFHO0FBQzlEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLENBQUk7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxFQUFROztBQUVuQztBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxLQUFLO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZCQUE2QixlQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixXQUFXLEVBQUUsdUNBQXVDO0FBQ2xGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDLDBCQUEwQiw2Q0FBNkM7QUFDdkUsTUFBTTtBQUNOLDBCQUEwQixhQUFhO0FBQ3ZDLDJCQUEyQiw2Q0FBNkM7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLFdBQVc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1Q0FBdUMsdUJBQXVCO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsaUJBQWlCLG1DQUFtQyxlQUFlO0FBQ2xHO0FBQ0EsUUFBUTtBQUNSLCtCQUErQixNQUFNLG1DQUFtQyxPQUFPO0FBQy9FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsc0NBQXNDO0FBQ3BFLDZCQUE2Qix1Q0FBdUM7QUFDcEU7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQSxpQ0FBaUMsd0JBQXdCO0FBQ3pELGtDQUFrQywwQkFBMEI7QUFDNUQsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLCtCQUErQixhQUFhO0FBQzVDLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFNBQVM7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUVBQXlFLEdBQUc7O0FBRTVFO0FBQ0EseUVBQXlFLEdBQUc7QUFDNUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1RUFBdUUsR0FBRzs7QUFFMUU7QUFDQTtBQUNBLFVBQVU7QUFDVix5RUFBeUUsR0FBRztBQUM1RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsaUJBQWlCO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7O0FBRWI7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekMsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7O0FBRVg7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLGNBQWM7O0FBRWQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxtQkFBbUI7QUFDaEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3Q0FBd0M7QUFDM0Usa0NBQWtDLHdDQUF3QztBQUMxRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE1BQU0sSUFBSSxNQUFNO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixFQUFFLEdBQUcsRUFBRTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdDQUFnQyxFQUFFLEdBQUc7QUFDaEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0VBQWdFLEdBQUc7O0FBRW5FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7QUFDekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0EsMkJBQTJCLGdCQUFnQixHQUFHLE9BQU87QUFDckQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLHdDQUF3QztBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0Msd0NBQXdDO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGtCQUFrQixLQUFLLFdBQVc7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsS0FBSztBQUMvQix5QkFBeUIsSUFBSTtBQUM3Qiw4QkFBOEIsV0FBVztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFdBQVc7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUEsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsc0JBQXNCLDREQUE0RDtBQUNsRjtBQUNBOztBQUVBLHNCQUFzQixzRUFBc0U7QUFDNUY7QUFDQTs7QUFFQSxrQkFBa0Isb0NBQW9DO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGdCQUFnQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLCtGQUErRjs7QUFFL0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrREFBa0QsWUFBWTtBQUM5RDs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0Esc0NBQXNDLGtDQUFrQyxLQUFLLFdBQVc7QUFDeEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsd0JBQXdCLE9BQU8sVUFBVTtBQUNyRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRCxRQUFRO0FBQ3hEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLG9CQUFvQjtBQUNqRCwwQ0FBMEMscUJBQXFCO0FBQy9ELFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLHVDQUF1QztBQUNwRSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsc0NBQXNDO0FBQ25FLDBDQUEwQyx1Q0FBdUM7QUFDakYsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSx5QkFBeUIsYUFBYTs7QUFFdEMsc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUEsc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQixTQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSx1QkFBdUIscUNBQTJCO0FBQ2xEO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsd0JBQXdCLFlBQVk7QUFDcEM7O0FBRUEsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFVBQVUsRUFBRSxTQUFTO0FBQzdDOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQjtBQUNBLE1BQU07QUFDTjtBQUNBLDRCQUE0QixVQUFVLEVBQUUsU0FBUztBQUNqRDtBQUNBOztBQUVBLHFCQUFxQixVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxPQUFPLFNBQVM7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNELEdBQUc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQscUJBQXFCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQscUJBQXFCO0FBQzlFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EseURBQXlELHFCQUFxQjs7QUFFOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOERBQThELGdCQUFnQixRQUFRLGVBQWU7QUFDckc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlEQUFpRCxnQkFBZ0IsbUJBQW1CLEVBQUUsaUJBQWlCLElBQUksSUFBSTtBQUMvRzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTs7QUFFaEQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QywwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsZUFBZTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsUUFBUTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsVUFBVTs7QUFFbkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxPQUFPO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsdUNBQXVDO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FLElBQUk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxlQUFlLEVBQUUsZ0JBQWdCOztBQUV4RjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxlQUFlO0FBQy9EOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsV0FBVyxtQkFBTyxDQUFDLENBQUk7O0FBRXZCLGFBQWEsbUJBQU8sQ0FBQyxFQUFNOztBQUUzQixjQUFjLG1CQUFPLENBQUMsRUFBTzs7QUFFN0IsWUFBWSxtQkFBTyxDQUFDLEVBQUs7O0FBRXpCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0VBQW9FLFVBQVU7QUFDOUU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLE1BQU0sR0FBRyxRQUFROztBQUV4RDtBQUNBO0FBQ0Esb0VBQW9FLFVBQVU7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxLQUFLO0FBQ3JFOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4RUFBOEUsT0FBTywwQkFBMEIsSUFBSTtBQUNuSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixxREFBcUQsT0FBTztBQUN6Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixrQkFBa0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsRUFBRTtBQUM3QztBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkMsV0FBVyxHQUFHLGFBQWE7QUFDeEU7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDLE1BQU0sR0FBRyxRQUFROztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMEJBQW1CO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLDBCQUFtQjs7O0FBR2pDO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxpQkFBaUIsMEJBQW1CO0FBQ3BDLFVBQVU7QUFDVjtBQUNBLENBQUM7QUFDRDs7Ozs7O0FDNXptQkEsZUFBZSxtQkFBTyxDQUFDLEVBQWM7QUFDckMsY0FBYyxtQkFBTyxDQUFDLEVBQWE7QUFDbkMsaUNBQWlDLG1CQUFPLENBQUMsRUFBaUI7QUFDMUQsc0JBQXNCLG1CQUFPLENBQUMsRUFBZTtBQUM3QyxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFrQjtBQUM1QyxvQkFBb0IsbUJBQU8sQ0FBQyxFQUFnQjtBQUM1QyxpQkFBaUIsbUJBQU8sQ0FBQyxFQUFnQjtBQUN6QyxXQUFXLG1CQUFPLENBQUMsQ0FBSTtBQUN2QixrQkFBa0IsbUJBQU8sQ0FBQyxFQUFpQjtBQUMzQyxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFpQjtBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQyxFQUFrQjtBQUM3QyxRQUFRLHNCQUFzQixFQUFFLG1CQUFPLENBQUMsRUFBaUI7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixXQUFXO0FBQ3RDLCtCQUErQixXQUFXOztBQUUxQztBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIscUJBQXFCLGtEQUFrRDtBQUN2RTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCLGdDQUFnQztBQUNoQyxzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYixpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEIsaUJBQWlCO0FBQ2pCLGdCQUFnQjs7QUFFaEIsb0JBQW9CO0FBQ3BCLDBCQUEwQjtBQUMxQixpQkFBaUI7O0FBRWpCLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkIsaUJBQWlCOztBQUVqQixnQkFBZ0I7O0FBRWhCO0FBQ0EsZUFBZTtBQUNmO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0Esb0JBQW9COzs7Ozs7OztBQzdGUjs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLEVBQVk7QUFDckM7QUFDQSxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFhO0FBQ3ZDLGtCQUFrQixtQkFBTyxDQUFDLEVBQWE7QUFDdkMsa0JBQWtCLG1CQUFPLENBQUMsRUFBYTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyxFQUFjO0FBQ3pDO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLENBQU07O0FBRTNCO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVyxHQUFHLFlBQVk7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxjQUFjO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxjQUFjOztBQUUzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixNQUFNLFNBQVMsdUJBQXVCO0FBQzdELEtBQUs7QUFDTCxJQUFJO0FBQ0osbUJBQW1CLE1BQU0sU0FBUyw2Q0FBNkM7QUFDL0U7QUFDQTs7Ozs7Ozs7QUNoSFk7O0FBRVosaUJBQWlCLG1CQUFPLENBQUMsRUFBOEI7O0FBRXZEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQ1hBO0FBQ0EscUNBQXFDLDRCQUFtQixHQUFHLHFCQUF1QjtBQUNsRixFQUFFO0FBQ0Y7QUFDQTs7Ozs7Ozs7QUNMWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLEVBQVk7QUFDckMsa0JBQWtCLG1CQUFPLENBQUMsRUFBYztBQUN4QyxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLEVBQWE7O0FBRTNDO0FBQ0E7Ozs7Ozs7O0FDYlk7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QywrQkFBK0IsT0FBTztBQUN0QyxpQ0FBaUMsU0FBUztBQUMxQyxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBLGlCQUFpQixNQUFNLFNBQVMsT0FBTyxZQUFZLE9BQU87O0FBRTFEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7O0FDcEdZOztBQUVaLGFBQWEsbUJBQU8sQ0FBQyxDQUFNOztBQUUzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxlQUFlLGVBQWU7QUFDN0MsZUFBZSxlQUFlLGVBQWU7QUFDN0MsZUFBZSxlQUFlLGdCQUFnQjtBQUM5QyxnQkFBZ0IsZ0JBQWdCLGdCQUFnQjs7QUFFaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsS0FBSztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxLQUFLO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU8sSUFBSSxPQUFPLElBQUksT0FBTyxJQUFJLE9BQU8sSUFBSSxPQUFPLElBQUksT0FBTztBQUNoRixvQkFBb0Isd0JBQXdCO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYLFdBQVc7QUFDWCxXQUFXO0FBQ1gsV0FBVztBQUNYLFdBQVc7QUFDWCxXQUFXO0FBQ1gsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGNBQWM7QUFDZCxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsU0FBUyxTQUFTLDBCQUEwQixZQUFZLG9DQUFvQztBQUM1RixTQUFTLFNBQVMsMEJBQTBCLFlBQVksb0NBQW9DO0FBQzVGLFNBQVMsU0FBUywwQkFBMEIsWUFBWSxvQ0FBb0M7QUFDNUYsU0FBUyxTQUFTLDBCQUEwQixZQUFZLG9DQUFvQztBQUM1RixTQUFTLFNBQVMsMEJBQTBCLFlBQVksb0NBQW9DO0FBQzVGLFNBQVMsU0FBUywwQkFBMEIsWUFBWSxvQ0FBb0M7QUFDNUYsU0FBUyxTQUFTLDBCQUEwQixZQUFZLG9DQUFvQztBQUM1RixTQUFTLFNBQVMsMEJBQTBCLFlBQVksb0NBQW9DO0FBQzVGLFNBQVMsU0FBUywwQkFBMEIsWUFBWSxvQ0FBb0M7QUFDNUYsU0FBUyxTQUFTLDBCQUEwQixZQUFZLG9DQUFvQztBQUM1RixTQUFTLFNBQVMsMEJBQTBCLFlBQVksb0NBQW9DO0FBQzVGLFNBQVMsU0FBUywwQkFBMEIsWUFBWSxvQ0FBb0M7QUFDNUYsU0FBUyxTQUFTLDBCQUEwQixZQUFZLG9DQUFvQztBQUM1RixTQUFTLFNBQVMsMEJBQTBCLFlBQVksb0NBQW9DO0FBQzVGLFNBQVMsU0FBUywwQkFBMEIsWUFBWSxvQ0FBb0M7QUFDNUYsU0FBUyxTQUFTLDBCQUEwQixZQUFZLG9DQUFvQzs7QUFFNUYsT0FBTyxTQUFTLGlCQUFpQixZQUFZLHlCQUF5QjtBQUN0RSxPQUFPLFNBQVMsaUJBQWlCLFlBQVkseUJBQXlCO0FBQ3RFLE9BQU8sU0FBUyxpQkFBaUIsWUFBWSx5QkFBeUI7QUFDdEUsT0FBTyxTQUFTLGlCQUFpQixZQUFZLHlCQUF5QjtBQUN0RSxPQUFPLFNBQVMsaUJBQWlCLFlBQVkseUJBQXlCO0FBQ3RFLE9BQU8sU0FBUyxpQkFBaUIsWUFBWSx5QkFBeUI7O0FBRXRFLFVBQVUsU0FBUyxxQkFBcUI7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1COzs7Ozs7OztBQzNtQlA7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLEVBQVE7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN6Q0E7Ozs7Ozs7QUNBWTs7QUFFWjtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxFQUFRO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7Ozs7Ozs7QUNsQ1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLEVBQVE7QUFDckM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7Ozs7Ozs7QUN4Q1k7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsRUFBWTtBQUNyQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyxDQUFNOztBQUUzQjtBQUNBOztBQUVBLFFBQVEsdUJBQXVCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdDQUF3QztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixtQkFBTyxDQUFDLEVBQVk7O0FBRTVDO0FBQ0E7QUFDQSxxQkFBcUIsaUNBQWlDO0FBQ3RELFNBQVM7QUFDVDs7QUFFQTtBQUNBLDhEQUE4RCxlQUFlO0FBQzdFOztBQUVBO0FBQ0EsU0FBUztBQUNULFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUMvRkE7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLEVBQWU7QUFDdEMsMkJBQTJCLG1CQUFPLENBQUMsRUFBcUI7QUFDeEQsYUFBYSxtQkFBTyxDQUFDLEVBQU07QUFDM0IsY0FBYyxtQkFBTyxDQUFDLEVBQU87QUFDN0IsYUFBYSxtQkFBTyxDQUFDLEVBQU07QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsRUFBYTtBQUN6QyxZQUFZLG1CQUFPLENBQUMsRUFBSzs7QUFFekI7O0FBRUE7QUFDQSx5QkFBeUIsa0JBQWtCLCtCQUErQixZQUFZO0FBQ3RGOztBQUVBO0FBQ0EsWUFBWSx1Q0FBdUM7QUFDbkQ7QUFDQTtBQUNBLCtCQUErQixzQ0FBc0M7QUFDckU7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsMkNBQTJDO0FBQzNDLHFDQUFxQyw4QkFBOEI7QUFDbkU7QUFDQSxDQUFDOzs7Ozs7O0FDMUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7Ozs7QUNkYTtBQUNiLE9BQU8sZ0NBQWdDLEVBQUUsbUJBQU8sQ0FBQyxFQUFRO0FBQ3pELGFBQWEsbUJBQU8sQ0FBQyxFQUFNO0FBQzNCLHNCQUFzQixtQkFBTyxDQUFDLEVBQWdCOztBQUU5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXNCOzs7Ozs7OztBQ3ZDdEI7Ozs7Ozs7QUNBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7QUNyQ0E7Ozs7Ozs7QUNBQTs7Ozs7O0FDQUEsYUFBYSxtQkFBTyxDQUFDLEVBQVE7QUFDN0I7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNoQ0E7Ozs7Ozs7QUNBQTs7Ozs7OztBQ0FZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLG1CQUFPLENBQUMsRUFBWTtBQUNyQyxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLEVBQWE7O0FBRTNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ2YwQjtBQUUxQixJQUFZLFNBSVg7QUFKRCxXQUFZLFNBQVM7SUFDakIsd0JBQVc7SUFDWCx3QkFBVztJQUNYLDBCQUFhO0FBQ2pCLENBQUMsRUFKVyxTQUFTLEtBQVQsU0FBUyxRQUlwQjtBQU9NLEtBQUssVUFBVSxjQUFjLENBQUMsWUFBb0IsRUFBRSxNQUFrQixFQUFFLFNBQW9CO0lBQy9GLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEtBQWUsRUFBRSxFQUFFO1FBQ3JDLE1BQU0sSUFBSSxHQUFHLFlBQVksR0FBRyxJQUFJLEtBQUssQ0FBQyxJQUFJLElBQUksU0FBUyxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUM7UUFDcEUsTUFBTSxhQUFhLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3JDLENBQUMsQ0FBQyxDQUFDO0FBQ1AsQ0FBQztBQUdNLEtBQUssVUFBVSxtQkFBbUIsQ0FBQyxNQUFjLEVBQUUsT0FBaUIsRUFBRSxVQUF1QixFQUFFLE1BQWtCO0lBQ3BILE1BQU0sR0FBRyxHQUFHLE9BQU8sQ0FBQztJQUNwQixNQUFNLEdBQUcsR0FBRyxRQUFRLENBQUM7SUFDckIsTUFBTSxHQUFHLEdBQUcsT0FBTyxDQUFDO0lBQ3BCLE1BQU0sQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRTtRQUdoRCxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBQyxDQUFDLEVBQUMsRUFBRTtZQUV0QixNQUFNLElBQUksR0FBRyxHQUFHLE1BQU0sSUFBSSxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7WUFFN0csSUFBSSxDQUFDLEtBQUssT0FBTyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO2dCQUMzQyxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBRXRELE1BQU0sYUFBYSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQzthQUNwQztpQkFBTTtnQkFDSCxNQUFNLEtBQUssR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3RELE1BQU0sYUFBYSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQzthQUNwQztRQUVMLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDO0FBRUQsS0FBSyxVQUFVLGFBQWEsQ0FBQyxLQUEyQixFQUFFLElBQVk7SUFDbEUsSUFBSSxLQUFLLElBQUksU0FBUyxFQUFFO1FBQ3BCLE1BQU0sS0FBSyxHQUFHLEtBQUssQ0FBQyxLQUFLLENBQUM7UUFDMUIsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztRQUM1QixNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDbEMsTUFBTSw0Q0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUU7WUFDcEIsR0FBRyxFQUFFLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUU7U0FDbkMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoQixPQUFPLENBQUMsR0FBRyxDQUFDLGVBQWUsSUFBSSxFQUFFLENBQUMsQ0FBQztLQUN0QztBQUNMLENBQUM7Ozs7Ozs7O0FDeEREOzs7OztVQ0FBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N6QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxJQUFJO1dBQ0o7V0FDQTtXQUNBLElBQUk7V0FDSjtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxDQUFDO1dBQ0Q7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEVBQUU7V0FDRjtXQUNBLHNHQUFzRztXQUN0RztXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0EsRUFBRTtXQUNGO1dBQ0E7Ozs7O1dDaEVBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQSxpQ0FBaUMsV0FBVztXQUM1QztXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EseUNBQXlDLHdDQUF3QztXQUNqRjtXQUNBO1dBQ0E7Ozs7O1dDUEE7Ozs7O1dDQUE7V0FDQTtXQUNBO1dBQ0EsdURBQXVELGlCQUFpQjtXQUN4RTtXQUNBLGdEQUFnRCxhQUFhO1dBQzdEOzs7OztXQ05BO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7Ozs7O1dDSkE7Ozs7O1VFQUE7VUFDQTtVQUNBO1VBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zdGFyZmluZGVycGRmdG9mb3VuZHJ5Ly4vc3JjL2luZGV4LnRzIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImZzXCIiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS8uL3NyYy9hcmdzLnRzIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvLi9ub2RlX21vZHVsZXMvYXJncGFyc2UvYXJncGFyc2UuanMiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiYXNzZXJ0XCIiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwidXRpbFwiIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvLi9ub2RlX21vZHVsZXMvYXJncGFyc2UvbGliL3N1Yi5qcyIsIndlYnBhY2s6Ly9zdGFyZmluZGVycGRmdG9mb3VuZHJ5L2V4dGVybmFsIG5vZGUtY29tbW9uanMgXCJwYXRoXCIiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS8uL25vZGVfbW9kdWxlcy9hcmdwYXJzZS9saWIvdGV4dHdyYXAuanMiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS8uL3NyYy9tYXBwaW5ncy9tYXBwaW5ncy50cyIsIndlYnBhY2s6Ly9zdGFyZmluZGVycGRmdG9mb3VuZHJ5Ly4vc3JjL21hcHBpbmdzL2ltYWdlX21hcC50cyIsIndlYnBhY2s6Ly9zdGFyZmluZGVycGRmdG9mb3VuZHJ5Ly4vc3JjL21hcHBpbmdzL2pzb25fbWFwLnRzIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvLi9zcmMvd29ya2Vycy93b3JrZXJzLnRzIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvLi9zcmMvd29ya2Vycy9qc29uX2V4dHJhY3Rvci50cyIsIndlYnBhY2s6Ly9zdGFyZmluZGVycGRmdG9mb3VuZHJ5Ly4vc3JjL3NjaGVtYXMvc2NoZW1hcy50cyIsIndlYnBhY2s6Ly9zdGFyZmluZGVycGRmdG9mb3VuZHJ5Ly4vc3JjL3dvcmtlcnMvcGRmX2V4dHJhY3Rvci50cyIsIndlYnBhY2s6Ly9zdGFyZmluZGVycGRmdG9mb3VuZHJ5Ly4vbm9kZV9tb2R1bGVzL3BkZmpzLWRpc3QvYnVpbGQvcGRmLmpzIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvLi9ub2RlX21vZHVsZXMvY2FudmFzL2luZGV4LmpzIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvLi9ub2RlX21vZHVsZXMvY2FudmFzL2xpYi9jYW52YXMuanMiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS8uL25vZGVfbW9kdWxlcy9jYW52YXMvbGliL2JpbmRpbmdzLmpzIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvLi9ub2RlX21vZHVsZXMvY2FudmFzL2J1aWxkL1JlbGVhc2UvY2FudmFzLm5vZGUiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS8uL25vZGVfbW9kdWxlcy9jYW52YXMvbGliL2NvbnRleHQyZC5qcyIsIndlYnBhY2s6Ly9zdGFyZmluZGVycGRmdG9mb3VuZHJ5Ly4vbm9kZV9tb2R1bGVzL2NhbnZhcy9saWIvcGFyc2UtZm9udC5qcyIsIndlYnBhY2s6Ly9zdGFyZmluZGVycGRmdG9mb3VuZHJ5Ly4vbm9kZV9tb2R1bGVzL2NhbnZhcy9saWIvRE9NTWF0cml4LmpzIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvLi9ub2RlX21vZHVsZXMvY2FudmFzL2xpYi9wbmdzdHJlYW0uanMiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwic3RyZWFtXCIiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS8uL25vZGVfbW9kdWxlcy9jYW52YXMvbGliL3BkZnN0cmVhbS5qcyIsIndlYnBhY2s6Ly9zdGFyZmluZGVycGRmdG9mb3VuZHJ5Ly4vbm9kZV9tb2R1bGVzL2NhbnZhcy9saWIvanBlZ3N0cmVhbS5qcyIsIndlYnBhY2s6Ly9zdGFyZmluZGVycGRmdG9mb3VuZHJ5Ly4vbm9kZV9tb2R1bGVzL2NhbnZhcy9saWIvaW1hZ2UuanMiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS8uL25vZGVfbW9kdWxlcy9zaW1wbGUtZ2V0L2luZGV4LmpzIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvLi9ub2RlX21vZHVsZXMvc2ltcGxlLWNvbmNhdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9zdGFyZmluZGVycGRmdG9mb3VuZHJ5Ly4vbm9kZV9tb2R1bGVzL3NpbXBsZS1nZXQvbm9kZV9tb2R1bGVzL2RlY29tcHJlc3MtcmVzcG9uc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiemxpYlwiIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvLi9ub2RlX21vZHVsZXMvc2ltcGxlLWdldC9ub2RlX21vZHVsZXMvbWltaWMtcmVzcG9uc2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwiaHR0cFwiIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcImh0dHBzXCIiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS8uL25vZGVfbW9kdWxlcy9vbmNlL29uY2UuanMiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS8uL25vZGVfbW9kdWxlcy93cmFwcHkvd3JhcHB5LmpzIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvZXh0ZXJuYWwgbm9kZS1jb21tb25qcyBcInF1ZXJ5c3RyaW5nXCIiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS9leHRlcm5hbCBub2RlLWNvbW1vbmpzIFwidXJsXCIiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS8uL25vZGVfbW9kdWxlcy9jYW52YXMvbGliL3BhdHRlcm4uanMiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS8uL3NyYy93b3JrZXJzL2ltYWdlX3NhdmVyLnRzIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvZXh0ZXJuYWwgY29tbW9uanMgXCJzaGFycFwiIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS93ZWJwYWNrL3J1bnRpbWUvYXN5bmMgbW9kdWxlIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3N0YXJmaW5kZXJwZGZ0b2ZvdW5kcnkvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9zdGFyZmluZGVycGRmdG9mb3VuZHJ5L3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly9zdGFyZmluZGVycGRmdG9mb3VuZHJ5L3dlYnBhY2svYmVmb3JlLXN0YXJ0dXAiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS93ZWJwYWNrL3N0YXJ0dXAiLCJ3ZWJwYWNrOi8vc3RhcmZpbmRlcnBkZnRvZm91bmRyeS93ZWJwYWNrL2FmdGVyLXN0YXJ0dXAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgYXJncyB9IGZyb20gXCIuL2FyZ3NcIjtcbmltcG9ydCB7IHRlc3QgfSBmcm9tIFwiQGZvdW5kcnlcIjtcbmltcG9ydCB7IEdhbWVTeXN0ZW0sIGlTdGFyZmluZGVyRG9jIH0gZnJvbSBcIkBtYXBwaW5nc1wiO1xuaW1wb3J0IHsgR2V0UGRmRGFmYSwgSW1hZ2VTYXZlciwgSnNvbkV4dHJhY3RvciB9IGZyb20gXCJAd29ya2Vyc1wiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFyZ3Mge1xuICBub19zY2hlbWE6IGJvb2xlYW4sXG4gIHBkZl9wYXRoOiBzdHJpbmcsXG4gIG91dHB1dF9wYXRoOiBzdHJpbmdcbn1cblxuYXN5bmMgZnVuY3Rpb24gbWFpbihhcmdzOiBBcmdzKSB7XG4gIHRyeSB7XG4gICAgLy8gR2V0IFBERlxuICAgIGxldCBwZGZfZGF0YSA9IGF3YWl0IEdldFBkZkRhZmEoYXJncy5wZGZfcGF0aCk7XG5cbiAgICAvLyBHZXQgc2NoZW1hXG4gICAgbGV0IGpzb25fc2NoZW1hID0gKEpzb25FeHRyYWN0b3IoR2FtZVN5c3RlbS5TdGFyZmluZGVyLCBwZGZfZGF0YS50aXRsZSkgYXMgaVN0YXJmaW5kZXJEb2MpO1xuICAgIGlmIChqc29uX3NjaGVtYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInNjaGVtYSBub3QgZm91bmRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGFyZ3Mubm9fc2NoZW1hID09PSB0cnVlKSB7XG4gICAgICBhd2FpdCBJbWFnZVNhdmVyLnByaW50QWxsSW1hZ2VzKGFyZ3Mub3V0cHV0X3BhdGgsIHBkZl9kYXRhLmltYWdlcywgSW1hZ2VTYXZlci5FeHRlbnNpb24ucG5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTWFwIGltYWdlc1xuICAgICAgT2JqZWN0LmVudHJpZXMoanNvbl9zY2hlbWEuYXNzZXRzKS5mb3JFYWNoKGFzeW5jIChbYXNzZXRUeXBlLCBkaWN0aW9uYXJ5XSkgPT4ge1xuICAgICAgICAvLyBjb25zdCBrZXkgPSBPYmplY3Qua2V5cyhqc29uX3NjaGVtYS5hbGllbl9hcmNoaXZlcylbMF07XG4gICAgICAgIGNvbnN0IGZvbGRlciA9IGAke2FyZ3Mub3V0cHV0X3BhdGh9LyR7anNvbl9zY2hlbWEubmFtZX0vJHthc3NldFR5cGV9YDtcbiAgICAgICAgYXdhaXQgZnMucHJvbWlzZXMubWtkaXIoZm9sZGVyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgYXdhaXQgSW1hZ2VTYXZlci5nZW5lcmF0ZUpOb2RlSW1hZ2VzKGZvbGRlciwgWydhY3RvcicsICd0b2tlbiddLCBkaWN0aW9uYXJ5LCBwZGZfZGF0YS5pbWFnZXMpO1xuXG4gICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8vIFRPRE86IGRldGVybWluZSB3aGF0IGltYWdlcyB0byBzYXZlXG4gICAgLy8gYXdhaXQgcHJpbnRBbGxJbWFnZXNUb1dlYlAoYXJncy5vdXRwdXRfcGF0aCwgcGRmX2RhdGEuaW1hZ2VzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmxvZyhgRXJyb3IgcnVubmluZyBtYWluOiAke2Vycm9yfWApO1xuICB9XG59XG5cbmF3YWl0IG1haW4oYXJncyk7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiZnNcIik7IiwiaW1wb3J0IHsgQXJndW1lbnRQYXJzZXIgfSBmcm9tIFwiYXJncGFyc2VcIjtcblxuLy8gQ0xJIGFyZ3VtZW50IHBhcnNpbmdcbmNvbnN0IHBhcnNlciA9IG5ldyBBcmd1bWVudFBhcnNlcih7IGRlc2NyaXB0aW9uOiBcIkV4dHJhY3Qgc29tZSBpbWFnZXNcIiB9KTtcbnBhcnNlci5hZGRfYXJndW1lbnQoJy1uJywgJy0tbm8tc2NoZW1hJywge1xuICAgIGRlZmF1bHQ6ICdmYWxzZScsXG4gICAgYWN0aW9uOiBcInN0b3JlX3RydWVcIixcbiAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgaGVscDogXCJJZiB0cnVlIGV4cG9ydHMgYWxsIGltYWdlcyBmcm9tIFBERiB0byBvdXRwdXQgZm9sZGVyXCIsXG59KTtcbnBhcnNlci5hZGRfYXJndW1lbnQoJ3BkZl9wYXRoJywge1xuICAgIHR5cGU6ICdzdHInLFxuICAgIGhlbHA6IFwiVGhlIGFic29sdXRlIGZpbGUgcGF0aCB0byB0aGUgUERGXCIsXG59KTtcbnBhcnNlci5hZGRfYXJndW1lbnQoJ291dHB1dF9wYXRoJywge1xuICAgIHR5cGU6ICdzdHInLFxuICAgIGhlbHA6IFwiVGhlIG91dHB1dCBmb2xkZXJcIixcbn0pO1xuZXhwb3J0IGNvbnN0IGFyZ3MgPSBwYXJzZXIucGFyc2VfYXJncygpOyIsIi8vIFBvcnQgb2YgcHl0aG9uJ3MgYXJncGFyc2UgbW9kdWxlLCB2ZXJzaW9uIDMuOS4wOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3B5dGhvbi9jcHl0aG9uL2Jsb2IvdjMuOS4wcmMxL0xpYi9hcmdwYXJzZS5weVxuXG4ndXNlIHN0cmljdCdcblxuLy8gQ29weXJpZ2h0IChDKSAyMDEwLTIwMjAgUHl0aG9uIFNvZnR3YXJlIEZvdW5kYXRpb24uXG4vLyBDb3B5cmlnaHQgKEMpIDIwMjAgYXJncGFyc2UuanMgYXV0aG9yc1xuXG4vKlxuICogQ29tbWFuZC1saW5lIHBhcnNpbmcgbGlicmFyeVxuICpcbiAqIFRoaXMgbW9kdWxlIGlzIGFuIG9wdHBhcnNlLWluc3BpcmVkIGNvbW1hbmQtbGluZSBwYXJzaW5nIGxpYnJhcnkgdGhhdDpcbiAqXG4gKiAgICAgLSBoYW5kbGVzIGJvdGggb3B0aW9uYWwgYW5kIHBvc2l0aW9uYWwgYXJndW1lbnRzXG4gKiAgICAgLSBwcm9kdWNlcyBoaWdobHkgaW5mb3JtYXRpdmUgdXNhZ2UgbWVzc2FnZXNcbiAqICAgICAtIHN1cHBvcnRzIHBhcnNlcnMgdGhhdCBkaXNwYXRjaCB0byBzdWItcGFyc2Vyc1xuICpcbiAqIFRoZSBmb2xsb3dpbmcgaXMgYSBzaW1wbGUgdXNhZ2UgZXhhbXBsZSB0aGF0IHN1bXMgaW50ZWdlcnMgZnJvbSB0aGVcbiAqIGNvbW1hbmQtbGluZSBhbmQgd3JpdGVzIHRoZSByZXN1bHQgdG8gYSBmaWxlOjpcbiAqXG4gKiAgICAgcGFyc2VyID0gYXJncGFyc2UuQXJndW1lbnRQYXJzZXIoXG4gKiAgICAgICAgIGRlc2NyaXB0aW9uPSdzdW0gdGhlIGludGVnZXJzIGF0IHRoZSBjb21tYW5kIGxpbmUnKVxuICogICAgIHBhcnNlci5hZGRfYXJndW1lbnQoXG4gKiAgICAgICAgICdpbnRlZ2VycycsIG1ldGF2YXI9J2ludCcsIG5hcmdzPScrJywgdHlwZT1pbnQsXG4gKiAgICAgICAgIGhlbHA9J2FuIGludGVnZXIgdG8gYmUgc3VtbWVkJylcbiAqICAgICBwYXJzZXIuYWRkX2FyZ3VtZW50KFxuICogICAgICAgICAnLS1sb2cnLCBkZWZhdWx0PXN5cy5zdGRvdXQsIHR5cGU9YXJncGFyc2UuRmlsZVR5cGUoJ3cnKSxcbiAqICAgICAgICAgaGVscD0ndGhlIGZpbGUgd2hlcmUgdGhlIHN1bSBzaG91bGQgYmUgd3JpdHRlbicpXG4gKiAgICAgYXJncyA9IHBhcnNlci5wYXJzZV9hcmdzKClcbiAqICAgICBhcmdzLmxvZy53cml0ZSgnJXMnICUgc3VtKGFyZ3MuaW50ZWdlcnMpKVxuICogICAgIGFyZ3MubG9nLmNsb3NlKClcbiAqXG4gKiBUaGUgbW9kdWxlIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgcHVibGljIGNsYXNzZXM6XG4gKlxuICogICAgIC0gQXJndW1lbnRQYXJzZXIgLS0gVGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIGNvbW1hbmQtbGluZSBwYXJzaW5nLiBBcyB0aGVcbiAqICAgICAgICAgZXhhbXBsZSBhYm92ZSBzaG93cywgdGhlIGFkZF9hcmd1bWVudCgpIG1ldGhvZCBpcyB1c2VkIHRvIHBvcHVsYXRlXG4gKiAgICAgICAgIHRoZSBwYXJzZXIgd2l0aCBhY3Rpb25zIGZvciBvcHRpb25hbCBhbmQgcG9zaXRpb25hbCBhcmd1bWVudHMuIFRoZW5cbiAqICAgICAgICAgdGhlIHBhcnNlX2FyZ3MoKSBtZXRob2QgaXMgaW52b2tlZCB0byBjb252ZXJ0IHRoZSBhcmdzIGF0IHRoZVxuICogICAgICAgICBjb21tYW5kLWxpbmUgaW50byBhbiBvYmplY3Qgd2l0aCBhdHRyaWJ1dGVzLlxuICpcbiAqICAgICAtIEFyZ3VtZW50RXJyb3IgLS0gVGhlIGV4Y2VwdGlvbiByYWlzZWQgYnkgQXJndW1lbnRQYXJzZXIgb2JqZWN0cyB3aGVuXG4gKiAgICAgICAgIHRoZXJlIGFyZSBlcnJvcnMgd2l0aCB0aGUgcGFyc2VyJ3MgYWN0aW9ucy4gRXJyb3JzIHJhaXNlZCB3aGlsZVxuICogICAgICAgICBwYXJzaW5nIHRoZSBjb21tYW5kLWxpbmUgYXJlIGNhdWdodCBieSBBcmd1bWVudFBhcnNlciBhbmQgZW1pdHRlZFxuICogICAgICAgICBhcyBjb21tYW5kLWxpbmUgbWVzc2FnZXMuXG4gKlxuICogICAgIC0gRmlsZVR5cGUgLS0gQSBmYWN0b3J5IGZvciBkZWZpbmluZyB0eXBlcyBvZiBmaWxlcyB0byBiZSBjcmVhdGVkLiBBcyB0aGVcbiAqICAgICAgICAgZXhhbXBsZSBhYm92ZSBzaG93cywgaW5zdGFuY2VzIG9mIEZpbGVUeXBlIGFyZSB0eXBpY2FsbHkgcGFzc2VkIGFzXG4gKiAgICAgICAgIHRoZSB0eXBlPSBhcmd1bWVudCBvZiBhZGRfYXJndW1lbnQoKSBjYWxscy5cbiAqXG4gKiAgICAgLSBBY3Rpb24gLS0gVGhlIGJhc2UgY2xhc3MgZm9yIHBhcnNlciBhY3Rpb25zLiBUeXBpY2FsbHkgYWN0aW9ucyBhcmVcbiAqICAgICAgICAgc2VsZWN0ZWQgYnkgcGFzc2luZyBzdHJpbmdzIGxpa2UgJ3N0b3JlX3RydWUnIG9yICdhcHBlbmRfY29uc3QnIHRvXG4gKiAgICAgICAgIHRoZSBhY3Rpb249IGFyZ3VtZW50IG9mIGFkZF9hcmd1bWVudCgpLiBIb3dldmVyLCBmb3IgZ3JlYXRlclxuICogICAgICAgICBjdXN0b21pemF0aW9uIG9mIEFyZ3VtZW50UGFyc2VyIGFjdGlvbnMsIHN1YmNsYXNzZXMgb2YgQWN0aW9uIG1heVxuICogICAgICAgICBiZSBkZWZpbmVkIGFuZCBwYXNzZWQgYXMgdGhlIGFjdGlvbj0gYXJndW1lbnQuXG4gKlxuICogICAgIC0gSGVscEZvcm1hdHRlciwgUmF3RGVzY3JpcHRpb25IZWxwRm9ybWF0dGVyLCBSYXdUZXh0SGVscEZvcm1hdHRlcixcbiAqICAgICAgICAgQXJndW1lbnREZWZhdWx0c0hlbHBGb3JtYXR0ZXIgLS0gRm9ybWF0dGVyIGNsYXNzZXMgd2hpY2hcbiAqICAgICAgICAgbWF5IGJlIHBhc3NlZCBhcyB0aGUgZm9ybWF0dGVyX2NsYXNzPSBhcmd1bWVudCB0byB0aGVcbiAqICAgICAgICAgQXJndW1lbnRQYXJzZXIgY29uc3RydWN0b3IuIEhlbHBGb3JtYXR0ZXIgaXMgdGhlIGRlZmF1bHQsXG4gKiAgICAgICAgIFJhd0Rlc2NyaXB0aW9uSGVscEZvcm1hdHRlciBhbmQgUmF3VGV4dEhlbHBGb3JtYXR0ZXIgdGVsbCB0aGUgcGFyc2VyXG4gKiAgICAgICAgIG5vdCB0byBjaGFuZ2UgdGhlIGZvcm1hdHRpbmcgZm9yIGhlbHAgdGV4dCwgYW5kXG4gKiAgICAgICAgIEFyZ3VtZW50RGVmYXVsdHNIZWxwRm9ybWF0dGVyIGFkZHMgaW5mb3JtYXRpb24gYWJvdXQgYXJndW1lbnQgZGVmYXVsdHNcbiAqICAgICAgICAgdG8gdGhlIGhlbHAuXG4gKlxuICogQWxsIG90aGVyIGNsYXNzZXMgaW4gdGhpcyBtb2R1bGUgYXJlIGNvbnNpZGVyZWQgaW1wbGVtZW50YXRpb24gZGV0YWlscy5cbiAqIChBbHNvIG5vdGUgdGhhdCBIZWxwRm9ybWF0dGVyIGFuZCBSYXdEZXNjcmlwdGlvbkhlbHBGb3JtYXR0ZXIgYXJlIG9ubHlcbiAqIGNvbnNpZGVyZWQgcHVibGljIGFzIG9iamVjdCBuYW1lcyAtLSB0aGUgQVBJIG9mIHRoZSBmb3JtYXR0ZXIgb2JqZWN0cyBpc1xuICogc3RpbGwgY29uc2lkZXJlZCBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuKVxuICovXG5cbmNvbnN0IFNVUFBSRVNTID0gJz09U1VQUFJFU1M9PSdcblxuY29uc3QgT1BUSU9OQUwgPSAnPydcbmNvbnN0IFpFUk9fT1JfTU9SRSA9ICcqJ1xuY29uc3QgT05FX09SX01PUkUgPSAnKydcbmNvbnN0IFBBUlNFUiA9ICdBLi4uJ1xuY29uc3QgUkVNQUlOREVSID0gJy4uLidcbmNvbnN0IF9VTlJFQ09HTklaRURfQVJHU19BVFRSID0gJ191bnJlY29nbml6ZWRfYXJncydcblxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBVdGlsaXR5IGZ1bmN0aW9ucyB1c2VkIGZvciBwb3J0aW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBzdWIgPSByZXF1aXJlKCcuL2xpYi9zdWInKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgcmVwciA9IHV0aWwuaW5zcGVjdFxuXG5mdW5jdGlvbiBnZXRfYXJndigpIHtcbiAgICAvLyBvbWl0IGZpcnN0IGFyZ3VtZW50ICh3aGljaCBpcyBhc3N1bWVkIHRvIGJlIGludGVycHJldGVyIC0gYG5vZGVgLCBgY29mZmVlYCwgYHRzLW5vZGVgLCBldGMuKVxuICAgIHJldHVybiBwcm9jZXNzLmFyZ3Yuc2xpY2UoMSlcbn1cblxuZnVuY3Rpb24gZ2V0X3Rlcm1pbmFsX3NpemUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29sdW1uczogK3Byb2Nlc3MuZW52LkNPTFVNTlMgfHwgcHJvY2Vzcy5zdGRvdXQuY29sdW1ucyB8fCA4MFxuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFzYXR0cihvYmplY3QsIG5hbWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgbmFtZSlcbn1cblxuZnVuY3Rpb24gZ2V0YXR0cihvYmplY3QsIG5hbWUsIHZhbHVlKSB7XG4gICAgcmV0dXJuIGhhc2F0dHIob2JqZWN0LCBuYW1lKSA/IG9iamVjdFtuYW1lXSA6IHZhbHVlXG59XG5cbmZ1bmN0aW9uIHNldGF0dHIob2JqZWN0LCBuYW1lLCB2YWx1ZSkge1xuICAgIG9iamVjdFtuYW1lXSA9IHZhbHVlXG59XG5cbmZ1bmN0aW9uIHNldGRlZmF1bHQob2JqZWN0LCBuYW1lLCB2YWx1ZSkge1xuICAgIGlmICghaGFzYXR0cihvYmplY3QsIG5hbWUpKSBvYmplY3RbbmFtZV0gPSB2YWx1ZVxuICAgIHJldHVybiBvYmplY3RbbmFtZV1cbn1cblxuZnVuY3Rpb24gZGVsYXR0cihvYmplY3QsIG5hbWUpIHtcbiAgICBkZWxldGUgb2JqZWN0W25hbWVdXG59XG5cbmZ1bmN0aW9uIHJhbmdlKGZyb20sIHRvLCBzdGVwPTEpIHtcbiAgICAvLyByYW5nZSgxMCkgaXMgZXF1aXZhbGVudCB0byByYW5nZSgwLCAxMClcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkgWyB0bywgZnJvbSBdID0gWyBmcm9tLCAwIF1cbiAgICBpZiAodHlwZW9mIGZyb20gIT09ICdudW1iZXInIHx8IHR5cGVvZiB0byAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHN0ZXAgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IGNhbm5vdCBiZSBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyJylcbiAgICB9XG4gICAgaWYgKHN0ZXAgPT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JhbmdlKCkgYXJnIDMgbXVzdCBub3QgYmUgemVybycpXG5cbiAgICBsZXQgcmVzdWx0ID0gW11cbiAgICBpZiAoc3RlcCA+IDApIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGZyb207IGkgPCB0bzsgaSArPSBzdGVwKSByZXN1bHQucHVzaChpKVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpID4gdG87IGkgKz0gc3RlcCkgcmVzdWx0LnB1c2goaSlcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBzcGxpdGxpbmVzKHN0ciwga2VlcGVuZHMgPSBmYWxzZSkge1xuICAgIGxldCByZXN1bHRcbiAgICBpZiAoIWtlZXBlbmRzKSB7XG4gICAgICAgIHJlc3VsdCA9IHN0ci5zcGxpdCgvXFxyXFxufFtcXG5cXHJcXHZcXGZcXHgxY1xceDFkXFx4MWVcXHg4NVxcdTIwMjhcXHUyMDI5XS8pXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gW11cbiAgICAgICAgbGV0IHBhcnRzID0gc3RyLnNwbGl0KC8oXFxyXFxufFtcXG5cXHJcXHZcXGZcXHgxY1xceDFkXFx4MWVcXHg4NVxcdTIwMjhcXHUyMDI5XSkvKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJ0c1tpXSArIChpICsgMSA8IHBhcnRzLmxlbmd0aCA/IHBhcnRzW2kgKyAxXSA6ICcnKSlcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0pIHJlc3VsdC5wb3AoKVxuICAgIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gX3N0cmluZ19sc3RyaXAoc3RyaW5nLCBwcmVmaXhfY2hhcnMpIHtcbiAgICBsZXQgaWR4ID0gMFxuICAgIHdoaWxlIChpZHggPCBzdHJpbmcubGVuZ3RoICYmIHByZWZpeF9jaGFycy5pbmNsdWRlcyhzdHJpbmdbaWR4XSkpIGlkeCsrXG4gICAgcmV0dXJuIGlkeCA/IHN0cmluZy5zbGljZShpZHgpIDogc3RyaW5nXG59XG5cbmZ1bmN0aW9uIF9zdHJpbmdfc3BsaXQoc3RyaW5nLCBzZXAsIG1heHNwbGl0KSB7XG4gICAgbGV0IHJlc3VsdCA9IHN0cmluZy5zcGxpdChzZXApXG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPiBtYXhzcGxpdCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgbWF4c3BsaXQpLmNvbmNhdChbIHJlc3VsdC5zbGljZShtYXhzcGxpdCkuam9pbihzZXApIF0pXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gX2FycmF5X2VxdWFsKGFycmF5MSwgYXJyYXkyKSB7XG4gICAgaWYgKGFycmF5MS5sZW5ndGggIT09IGFycmF5Mi5sZW5ndGgpIHJldHVybiBmYWxzZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhcnJheTFbaV0gIT09IGFycmF5MltpXSkgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHJldHVybiB0cnVlXG59XG5cbmZ1bmN0aW9uIF9hcnJheV9yZW1vdmUoYXJyYXksIGl0ZW0pIHtcbiAgICBsZXQgaWR4ID0gYXJyYXkuaW5kZXhPZihpdGVtKVxuICAgIGlmIChpZHggPT09IC0xKSB0aHJvdyBuZXcgVHlwZUVycm9yKHN1YignJXIgbm90IGluIGxpc3QnLCBpdGVtKSlcbiAgICBhcnJheS5zcGxpY2UoaWR4LCAxKVxufVxuXG4vLyBub3JtYWxpemUgY2hvaWNlcyB0byBhcnJheTtcbi8vIHRoaXMgaXNuJ3QgcmVxdWlyZWQgaW4gcHl0aG9uIGJlY2F1c2UgYGluYCBhbmQgYG1hcGAgb3BlcmF0b3JzIHdvcmsgd2l0aCBhbnl0aGluZyxcbi8vIGJ1dCBpbiBqcyBkZWFsaW5nIHdpdGggbXVsdGlwbGUgdHlwZXMgaGVyZSBpcyB0b28gY2x1bmt5XG5mdW5jdGlvbiBfY2hvaWNlc190b19hcnJheShjaG9pY2VzKSB7XG4gICAgaWYgKGNob2ljZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW11cbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hvaWNlcykpIHtcbiAgICAgICAgcmV0dXJuIGNob2ljZXNcbiAgICB9IGVsc2UgaWYgKGNob2ljZXMgIT09IG51bGwgJiYgdHlwZW9mIGNob2ljZXNbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShjaG9pY2VzKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNob2ljZXMgPT09ICdvYmplY3QnICYmIGNob2ljZXMgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGNob2ljZXMpXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN1YignaW52YWxpZCBjaG9pY2VzIHZhbHVlOiAlcicsIGNob2ljZXMpKVxuICAgIH1cbn1cblxuLy8gZGVjb3JhdG9yIHRoYXQgYWxsb3dzIGEgY2xhc3MgdG8gYmUgY2FsbGVkIHdpdGhvdXQgbmV3XG5mdW5jdGlvbiBfY2FsbGFibGUoY2xzKSB7XG4gICAgbGV0IHJlc3VsdCA9IHsgLy8gb2JqZWN0IGlzIG5lZWRlZCBmb3IgaW5mZXJyZWQgY2xhc3MgbmFtZVxuICAgICAgICBbY2xzLm5hbWVdOiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgbGV0IHRoaXNfY2xhc3MgPSBuZXcudGFyZ2V0ID09PSByZXN1bHQgfHwgIW5ldy50YXJnZXRcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChjbHMsIGFyZ3MsIHRoaXNfY2xhc3MgPyBjbHMgOiBuZXcudGFyZ2V0KVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlc3VsdFtjbHMubmFtZV0ucHJvdG90eXBlID0gY2xzLnByb3RvdHlwZVxuICAgIC8vIGZpeCBkZWZhdWx0IHRhZyBmb3IgdG9TdHJpbmcsIGUuZy4gW29iamVjdCBBY3Rpb25dIGluc3RlYWQgb2YgW29iamVjdCBPYmplY3RdXG4gICAgY2xzLnByb3RvdHlwZVtTeW1ib2wudG9TdHJpbmdUYWddID0gY2xzLm5hbWVcbiAgICByZXR1cm4gcmVzdWx0W2Nscy5uYW1lXVxufVxuXG5mdW5jdGlvbiBfYWxpYXMob2JqZWN0LCBmcm9tLCB0bykge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCBuYW1lID0gb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgZnJvbSwge1xuICAgICAgICAgICAgdmFsdWU6IHV0aWwuZGVwcmVjYXRlKG9iamVjdFt0b10sIHN1YignJXMuJXMoKSBpcyByZW5hbWVkIHRvICVzLiVzKCknLFxuICAgICAgICAgICAgICAgIG5hbWUsIGZyb20sIG5hbWUsIHRvKSksXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICB9KVxuICAgIH0gY2F0Y2gge31cbn1cblxuLy8gZGVjb3JhdG9yIHRoYXQgYWxsb3dzIHNuYWtlX2Nhc2UgY2xhc3MgbWV0aG9kcyB0byBiZSBjYWxsZWQgd2l0aCBjYW1lbENhc2UgYW5kIHZpY2UgdmVyc2FcbmZ1bmN0aW9uIF9jYW1lbGNhc2VfYWxpYXMoX2NsYXNzKSB7XG4gICAgZm9yIChsZXQgbmFtZSBvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhfY2xhc3MucHJvdG90eXBlKSkge1xuICAgICAgICBsZXQgY2FtZWxjYXNlID0gbmFtZS5yZXBsYWNlKC9cXHdfW2Etel0vZywgcyA9PiBzWzBdICsgc1syXS50b1VwcGVyQ2FzZSgpKVxuICAgICAgICBpZiAoY2FtZWxjYXNlICE9PSBuYW1lKSBfYWxpYXMoX2NsYXNzLnByb3RvdHlwZSwgY2FtZWxjYXNlLCBuYW1lKVxuICAgIH1cbiAgICByZXR1cm4gX2NsYXNzXG59XG5cbmZ1bmN0aW9uIF90b19sZWdhY3lfbmFtZShrZXkpIHtcbiAgICBrZXkgPSBrZXkucmVwbGFjZSgvXFx3X1thLXpdL2csIHMgPT4gc1swXSArIHNbMl0udG9VcHBlckNhc2UoKSlcbiAgICBpZiAoa2V5ID09PSAnZGVmYXVsdCcpIGtleSA9ICdkZWZhdWx0VmFsdWUnXG4gICAgaWYgKGtleSA9PT0gJ2NvbnN0Jykga2V5ID0gJ2NvbnN0YW50J1xuICAgIHJldHVybiBrZXlcbn1cblxuZnVuY3Rpb24gX3RvX25ld19uYW1lKGtleSkge1xuICAgIGlmIChrZXkgPT09ICdkZWZhdWx0VmFsdWUnKSBrZXkgPSAnZGVmYXVsdCdcbiAgICBpZiAoa2V5ID09PSAnY29uc3RhbnQnKSBrZXkgPSAnY29uc3QnXG4gICAga2V5ID0ga2V5LnJlcGxhY2UoL1tBLVpdL2csIGMgPT4gJ18nICsgYy50b0xvd2VyQ2FzZSgpKVxuICAgIHJldHVybiBrZXlcbn1cblxuLy8gcGFyc2Ugb3B0aW9uc1xubGV0IG5vX2RlZmF1bHQgPSBTeW1ib2woJ25vX2RlZmF1bHRfdmFsdWUnKVxuZnVuY3Rpb24gX3BhcnNlX29wdHMoYXJncywgZGVzY3JpcHRvcikge1xuICAgIGZ1bmN0aW9uIGdldF9uYW1lKCkge1xuICAgICAgICBsZXQgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjay5zcGxpdCgnXFxuJylcbiAgICAgICAgICAgIC5tYXAoeCA9PiB4Lm1hdGNoKC9eICAgIGF0ICguKikgXFwoLipcXCkkLykpXG4gICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAubWFwKG0gPT4gbVsxXSlcbiAgICAgICAgICAgIC5tYXAoZm4gPT4gZm4ubWF0Y2goL1teIC5dKiQvKVswXSlcblxuICAgICAgICBpZiAoc3RhY2subGVuZ3RoICYmIHN0YWNrWzBdID09PSBnZXRfbmFtZS5uYW1lKSBzdGFjay5zaGlmdCgpXG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggJiYgc3RhY2tbMF0gPT09IF9wYXJzZV9vcHRzLm5hbWUpIHN0YWNrLnNoaWZ0KClcbiAgICAgICAgcmV0dXJuIHN0YWNrLmxlbmd0aCA/IHN0YWNrWzBdIDogJydcbiAgICB9XG5cbiAgICBhcmdzID0gQXJyYXkuZnJvbShhcmdzKVxuICAgIGxldCBrd2FyZ3MgPSB7fVxuICAgIGxldCByZXN1bHQgPSBbXVxuICAgIGxldCBsYXN0X29wdCA9IGFyZ3MubGVuZ3RoICYmIGFyZ3NbYXJncy5sZW5ndGggLSAxXVxuXG4gICAgaWYgKHR5cGVvZiBsYXN0X29wdCA9PT0gJ29iamVjdCcgJiYgbGFzdF9vcHQgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkobGFzdF9vcHQpICYmXG4gICAgICAgICghbGFzdF9vcHQuY29uc3RydWN0b3IgfHwgbGFzdF9vcHQuY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcpKSB7XG4gICAgICAgIGt3YXJncyA9IE9iamVjdC5hc3NpZ24oe30sIGFyZ3MucG9wKCkpXG4gICAgfVxuXG4gICAgLy8gTEVHQUNZICh2MSBjb21wYXRpYmlsaXR5KTogY2FtZWxjYXNlXG4gICAgbGV0IHJlbmFtZXMgPSBbXVxuICAgIGZvciAobGV0IGtleSBvZiBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKSkge1xuICAgICAgICBsZXQgb2xkX25hbWUgPSBfdG9fbGVnYWN5X25hbWUoa2V5KVxuICAgICAgICBpZiAob2xkX25hbWUgIT09IGtleSAmJiAob2xkX25hbWUgaW4ga3dhcmdzKSkge1xuICAgICAgICAgICAgaWYgKGtleSBpbiBrd2FyZ3MpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IGFuZCBkZWZhdWx0VmFsdWUgc3BlY2lmaWVkIGF0IHRoZSBzYW1lIHRpbWUsIGhhcHBlbnMgb2Z0ZW4gaW4gb2xkIHRlc3RzXG4gICAgICAgICAgICAgICAgLy90aHJvdyBuZXcgVHlwZUVycm9yKHN1YignJXMoKSBnb3QgbXVsdGlwbGUgdmFsdWVzIGZvciBhcmd1bWVudCAlcicsIGdldF9uYW1lKCksIGtleSkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGt3YXJnc1trZXldID0ga3dhcmdzW29sZF9uYW1lXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuYW1lcy5wdXNoKFsgb2xkX25hbWUsIGtleSBdKVxuICAgICAgICAgICAgZGVsZXRlIGt3YXJnc1tvbGRfbmFtZV1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBnZXRfbmFtZSgpXG4gICAgICAgIGRlcHJlY2F0ZSgnY2FtZWxjYXNlXycgKyBuYW1lLCBzdWIoJyVzKCk6IGZvbGxvd2luZyBvcHRpb25zIGFyZSByZW5hbWVkOiAlcycsXG4gICAgICAgICAgICBuYW1lLCByZW5hbWVzLm1hcCgoWyBhLCBiIF0pID0+IHN1YignJXIgLT4gJXInLCBhLCBiKSkpKVxuICAgIH1cbiAgICAvLyBlbmRcblxuICAgIGxldCBtaXNzaW5nX3Bvc2l0aW9uYWxzID0gW11cbiAgICBsZXQgcG9zaXRpb25hbF9jb3VudCA9IGFyZ3MubGVuZ3RoXG5cbiAgICBmb3IgKGxldCBbIGtleSwgZGVmIF0gb2YgT2JqZWN0LmVudHJpZXMoZGVzY3JpcHRvcikpIHtcbiAgICAgICAgaWYgKGtleVswXSA9PT0gJyonKSB7XG4gICAgICAgICAgICBpZiAoa2V5Lmxlbmd0aCA+IDAgJiYga2V5WzFdID09PSAnKicpIHtcbiAgICAgICAgICAgICAgICAvLyBMRUdBQ1kgKHYxIGNvbXBhdGliaWxpdHkpOiBjYW1lbGNhc2VcbiAgICAgICAgICAgICAgICBsZXQgcmVuYW1lcyA9IFtdXG4gICAgICAgICAgICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKGt3YXJncykpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld19uYW1lID0gX3RvX25ld19uYW1lKGtleSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld19uYW1lICE9PSBrZXkgJiYgKGtleSBpbiBrd2FyZ3MpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3X25hbWUgaW4ga3dhcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBhbmQgZGVmYXVsdFZhbHVlIHNwZWNpZmllZCBhdCB0aGUgc2FtZSB0aW1lLCBoYXBwZW5zIG9mdGVuIGluIG9sZCB0ZXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vdGhyb3cgbmV3IFR5cGVFcnJvcihzdWIoJyVzKCkgZ290IG11bHRpcGxlIHZhbHVlcyBmb3IgYXJndW1lbnQgJXInLCBnZXRfbmFtZSgpLCBuZXdfbmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGt3YXJnc1tuZXdfbmFtZV0gPSBrd2FyZ3Nba2V5XVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuYW1lcy5wdXNoKFsga2V5LCBuZXdfbmFtZSBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGt3YXJnc1trZXldXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlbmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lID0gZ2V0X25hbWUoKVxuICAgICAgICAgICAgICAgICAgICBkZXByZWNhdGUoJ2NhbWVsY2FzZV8nICsgbmFtZSwgc3ViKCclcygpOiBmb2xsb3dpbmcgb3B0aW9ucyBhcmUgcmVuYW1lZDogJXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSwgcmVuYW1lcy5tYXAoKFsgYSwgYiBdKSA9PiBzdWIoJyVyIC0+ICVyJywgYSwgYikpKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZW5kXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goa3dhcmdzKVxuICAgICAgICAgICAgICAgIGt3YXJncyA9IHt9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFyZ3MpXG4gICAgICAgICAgICAgICAgYXJncyA9IFtdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5IGluIGt3YXJncyAmJiBhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc3ViKCclcygpIGdvdCBtdWx0aXBsZSB2YWx1ZXMgZm9yIGFyZ3VtZW50ICVyJywgZ2V0X25hbWUoKSwga2V5KSlcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgaW4ga3dhcmdzKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChrd2FyZ3Nba2V5XSlcbiAgICAgICAgICAgIGRlbGV0ZSBrd2FyZ3Nba2V5XVxuICAgICAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJncy5zaGlmdCgpKVxuICAgICAgICB9IGVsc2UgaWYgKGRlZiAhPT0gbm9fZGVmYXVsdCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZGVmKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWlzc2luZ19wb3NpdGlvbmFscy5wdXNoKGtleSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChPYmplY3Qua2V5cyhrd2FyZ3MpLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHN1YignJXMoKSBnb3QgYW4gdW5leHBlY3RlZCBrZXl3b3JkIGFyZ3VtZW50ICVyJyxcbiAgICAgICAgICAgIGdldF9uYW1lKCksIE9iamVjdC5rZXlzKGt3YXJncylbMF0pKVxuICAgIH1cblxuICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBsZXQgZnJvbSA9IE9iamVjdC5lbnRyaWVzKGRlc2NyaXB0b3IpLmZpbHRlcigoWyBrLCB2IF0pID0+IGtbMF0gIT09ICcqJyAmJiB2ICE9PSBub19kZWZhdWx0KS5sZW5ndGhcbiAgICAgICAgbGV0IHRvID0gT2JqZWN0LmVudHJpZXMoZGVzY3JpcHRvcikuZmlsdGVyKChbIGsgXSkgPT4ga1swXSAhPT0gJyonKS5sZW5ndGhcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzdWIoJyVzKCkgdGFrZXMgJXMgcG9zaXRpb25hbCBhcmd1bWVudCVzIGJ1dCAlcyAlcyBnaXZlbicsXG4gICAgICAgICAgICBnZXRfbmFtZSgpLFxuICAgICAgICAgICAgZnJvbSA9PT0gdG8gPyBzdWIoJ2Zyb20gJXMgdG8gJXMnLCBmcm9tLCB0bykgOiB0byxcbiAgICAgICAgICAgIGZyb20gPT09IHRvICYmIHRvID09PSAxID8gJycgOiAncycsXG4gICAgICAgICAgICBwb3NpdGlvbmFsX2NvdW50LFxuICAgICAgICAgICAgcG9zaXRpb25hbF9jb3VudCA9PT0gMSA/ICd3YXMnIDogJ3dlcmUnKSlcbiAgICB9XG5cbiAgICBpZiAobWlzc2luZ19wb3NpdGlvbmFscy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IHN0cnMgPSBtaXNzaW5nX3Bvc2l0aW9uYWxzLm1hcChyZXByKVxuICAgICAgICBpZiAoc3Rycy5sZW5ndGggPiAxKSBzdHJzW3N0cnMubGVuZ3RoIC0gMV0gPSAnYW5kICcgKyBzdHJzW3N0cnMubGVuZ3RoIC0gMV1cbiAgICAgICAgbGV0IHN0cl9qb2luZWQgPSBzdHJzLmpvaW4oc3Rycy5sZW5ndGggPT09IDIgPyAnJyA6ICcsICcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc3ViKCclcygpIG1pc3NpbmcgJWkgcmVxdWlyZWQgcG9zaXRpb25hbCBhcmd1bWVudCVzOiAlcycsXG4gICAgICAgICAgICBnZXRfbmFtZSgpLCBzdHJzLmxlbmd0aCwgc3Rycy5sZW5ndGggPT09IDEgPyAnJyA6ICdzJywgc3RyX2pvaW5lZCkpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxufVxuXG5sZXQgX2RlcHJlY2F0aW9ucyA9IHt9XG5mdW5jdGlvbiBkZXByZWNhdGUoaWQsIHN0cmluZykge1xuICAgIF9kZXByZWNhdGlvbnNbaWRdID0gX2RlcHJlY2F0aW9uc1tpZF0gfHwgdXRpbC5kZXByZWNhdGUoKCkgPT4ge30sIHN0cmluZylcbiAgICBfZGVwcmVjYXRpb25zW2lkXSgpXG59XG5cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFV0aWxpdHkgZnVuY3Rpb25zIGFuZCBjbGFzc2VzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gX0F0dHJpYnV0ZUhvbGRlcihjbHMgPSBPYmplY3QpIHtcbiAgICAvKlxuICAgICAqICBBYnN0cmFjdCBiYXNlIGNsYXNzIHRoYXQgcHJvdmlkZXMgX19yZXByX18uXG4gICAgICpcbiAgICAgKiAgVGhlIF9fcmVwcl9fIG1ldGhvZCByZXR1cm5zIGEgc3RyaW5nIGluIHRoZSBmb3JtYXQ6OlxuICAgICAqICAgICAgQ2xhc3NOYW1lKGF0dHI9bmFtZSwgYXR0cj1uYW1lLCAuLi4pXG4gICAgICogIFRoZSBhdHRyaWJ1dGVzIGFyZSBkZXRlcm1pbmVkIGVpdGhlciBieSBhIGNsYXNzLWxldmVsIGF0dHJpYnV0ZSxcbiAgICAgKiAgJ19rd2FyZ19uYW1lcycsIG9yIGJ5IGluc3BlY3RpbmcgdGhlIGluc3RhbmNlIF9fZGljdF9fLlxuICAgICAqL1xuXG4gICAgcmV0dXJuIGNsYXNzIF9BdHRyaWJ1dGVIb2xkZXIgZXh0ZW5kcyBjbHMge1xuICAgICAgICBbdXRpbC5pbnNwZWN0LmN1c3RvbV0oKSB7XG4gICAgICAgICAgICBsZXQgdHlwZV9uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXG4gICAgICAgICAgICBsZXQgYXJnX3N0cmluZ3MgPSBbXVxuICAgICAgICAgICAgbGV0IHN0YXJfYXJncyA9IHt9XG4gICAgICAgICAgICBmb3IgKGxldCBhcmcgb2YgdGhpcy5fZ2V0X2FyZ3MoKSkge1xuICAgICAgICAgICAgICAgIGFyZ19zdHJpbmdzLnB1c2gocmVwcihhcmcpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgWyBuYW1lLCB2YWx1ZSBdIG9mIHRoaXMuX2dldF9rd2FyZ3MoKSkge1xuICAgICAgICAgICAgICAgIGlmICgvXlthLXpfXVthLXowLTlfJF0qJC9pLnRlc3QobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnX3N0cmluZ3MucHVzaChzdWIoJyVzPSVyJywgbmFtZSwgdmFsdWUpKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJfYXJnc1tuYW1lXSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHN0YXJfYXJncykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYXJnX3N0cmluZ3MucHVzaChzdWIoJyoqJXMnLCByZXByKHN0YXJfYXJncykpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1YignJXMoJXMpJywgdHlwZV9uYW1lLCBhcmdfc3RyaW5ncy5qb2luKCcsICcpKVxuICAgICAgICB9XG5cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t1dGlsLmluc3BlY3QuY3VzdG9tXSgpXG4gICAgICAgIH1cblxuICAgICAgICBfZ2V0X2t3YXJncygpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzKVxuICAgICAgICB9XG5cbiAgICAgICAgX2dldF9hcmdzKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdXG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZnVuY3Rpb24gX2NvcHlfaXRlbXMoaXRlbXMpIHtcbiAgICBpZiAoaXRlbXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW11cbiAgICB9XG4gICAgcmV0dXJuIGl0ZW1zLnNsaWNlKDApXG59XG5cblxuLy8gPT09PT09PT09PT09PT09XG4vLyBGb3JtYXR0aW5nIEhlbHBcbi8vID09PT09PT09PT09PT09PVxuY29uc3QgSGVscEZvcm1hdHRlciA9IF9jYW1lbGNhc2VfYWxpYXMoX2NhbGxhYmxlKGNsYXNzIEhlbHBGb3JtYXR0ZXIge1xuICAgIC8qXG4gICAgICogIEZvcm1hdHRlciBmb3IgZ2VuZXJhdGluZyB1c2FnZSBtZXNzYWdlcyBhbmQgYXJndW1lbnQgaGVscCBzdHJpbmdzLlxuICAgICAqXG4gICAgICogIE9ubHkgdGhlIG5hbWUgb2YgdGhpcyBjbGFzcyBpcyBjb25zaWRlcmVkIGEgcHVibGljIEFQSS4gQWxsIHRoZSBtZXRob2RzXG4gICAgICogIHByb3ZpZGVkIGJ5IHRoZSBjbGFzcyBhcmUgY29uc2lkZXJlZCBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuXG4gICAgICovXG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbGV0IFtcbiAgICAgICAgICAgIHByb2csXG4gICAgICAgICAgICBpbmRlbnRfaW5jcmVtZW50LFxuICAgICAgICAgICAgbWF4X2hlbHBfcG9zaXRpb24sXG4gICAgICAgICAgICB3aWR0aFxuICAgICAgICBdID0gX3BhcnNlX29wdHMoYXJndW1lbnRzLCB7XG4gICAgICAgICAgICBwcm9nOiBub19kZWZhdWx0LFxuICAgICAgICAgICAgaW5kZW50X2luY3JlbWVudDogMixcbiAgICAgICAgICAgIG1heF9oZWxwX3Bvc2l0aW9uOiAyNCxcbiAgICAgICAgICAgIHdpZHRoOiB1bmRlZmluZWRcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBkZWZhdWx0IHNldHRpbmcgZm9yIHdpZHRoXG4gICAgICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB3aWR0aCA9IGdldF90ZXJtaW5hbF9zaXplKCkuY29sdW1uc1xuICAgICAgICAgICAgd2lkdGggLT0gMlxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHJvZyA9IHByb2dcbiAgICAgICAgdGhpcy5faW5kZW50X2luY3JlbWVudCA9IGluZGVudF9pbmNyZW1lbnRcbiAgICAgICAgdGhpcy5fbWF4X2hlbHBfcG9zaXRpb24gPSBNYXRoLm1pbihtYXhfaGVscF9wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgod2lkdGggLSAyMCwgaW5kZW50X2luY3JlbWVudCAqIDIpKVxuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoXG5cbiAgICAgICAgdGhpcy5fY3VycmVudF9pbmRlbnQgPSAwXG4gICAgICAgIHRoaXMuX2xldmVsID0gMFxuICAgICAgICB0aGlzLl9hY3Rpb25fbWF4X2xlbmd0aCA9IDBcblxuICAgICAgICB0aGlzLl9yb290X3NlY3Rpb24gPSB0aGlzLl9TZWN0aW9uKHRoaXMsIHVuZGVmaW5lZClcbiAgICAgICAgdGhpcy5fY3VycmVudF9zZWN0aW9uID0gdGhpcy5fcm9vdF9zZWN0aW9uXG5cbiAgICAgICAgdGhpcy5fd2hpdGVzcGFjZV9tYXRjaGVyID0gL1sgXFx0XFxuXFxyXFxmXFx2XSsvZyAvLyBlcXVpdmFsZW50IHRvIHB5dGhvbiAvXFxzKy8gd2l0aCBBU0NJSSBmbGFnXG4gICAgICAgIHRoaXMuX2xvbmdfYnJlYWtfbWF0Y2hlciA9IC9cXG5cXG5cXG4rL2dcbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gU2VjdGlvbiBhbmQgaW5kZW50YXRpb24gbWV0aG9kc1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBfaW5kZW50KCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50X2luZGVudCArPSB0aGlzLl9pbmRlbnRfaW5jcmVtZW50XG4gICAgICAgIHRoaXMuX2xldmVsICs9IDFcbiAgICB9XG5cbiAgICBfZGVkZW50KCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50X2luZGVudCAtPSB0aGlzLl9pbmRlbnRfaW5jcmVtZW50XG4gICAgICAgIGFzc2VydCh0aGlzLl9jdXJyZW50X2luZGVudCA+PSAwLCAnSW5kZW50IGRlY3JlYXNlZCBiZWxvdyAwLicpXG4gICAgICAgIHRoaXMuX2xldmVsIC09IDFcbiAgICB9XG5cbiAgICBfYWRkX2l0ZW0oZnVuYywgYXJncykge1xuICAgICAgICB0aGlzLl9jdXJyZW50X3NlY3Rpb24uaXRlbXMucHVzaChbIGZ1bmMsIGFyZ3MgXSlcbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBNZXNzYWdlIGJ1aWxkaW5nIG1ldGhvZHNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBzdGFydF9zZWN0aW9uKGhlYWRpbmcpIHtcbiAgICAgICAgdGhpcy5faW5kZW50KClcbiAgICAgICAgbGV0IHNlY3Rpb24gPSB0aGlzLl9TZWN0aW9uKHRoaXMsIHRoaXMuX2N1cnJlbnRfc2VjdGlvbiwgaGVhZGluZylcbiAgICAgICAgdGhpcy5fYWRkX2l0ZW0oc2VjdGlvbi5mb3JtYXRfaGVscC5iaW5kKHNlY3Rpb24pLCBbXSlcbiAgICAgICAgdGhpcy5fY3VycmVudF9zZWN0aW9uID0gc2VjdGlvblxuICAgIH1cblxuICAgIGVuZF9zZWN0aW9uKCkge1xuICAgICAgICB0aGlzLl9jdXJyZW50X3NlY3Rpb24gPSB0aGlzLl9jdXJyZW50X3NlY3Rpb24ucGFyZW50XG4gICAgICAgIHRoaXMuX2RlZGVudCgpXG4gICAgfVxuXG4gICAgYWRkX3RleHQodGV4dCkge1xuICAgICAgICBpZiAodGV4dCAhPT0gU1VQUFJFU1MgJiYgdGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRfaXRlbSh0aGlzLl9mb3JtYXRfdGV4dC5iaW5kKHRoaXMpLCBbdGV4dF0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRfdXNhZ2UodXNhZ2UsIGFjdGlvbnMsIGdyb3VwcywgcHJlZml4ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh1c2FnZSAhPT0gU1VQUFJFU1MpIHtcbiAgICAgICAgICAgIGxldCBhcmdzID0gWyB1c2FnZSwgYWN0aW9ucywgZ3JvdXBzLCBwcmVmaXggXVxuICAgICAgICAgICAgdGhpcy5fYWRkX2l0ZW0odGhpcy5fZm9ybWF0X3VzYWdlLmJpbmQodGhpcyksIGFyZ3MpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRfYXJndW1lbnQoYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24uaGVscCAhPT0gU1VQUFJFU1MpIHtcblxuICAgICAgICAgICAgLy8gZmluZCBhbGwgaW52b2NhdGlvbnNcbiAgICAgICAgICAgIGxldCBpbnZvY2F0aW9ucyA9IFt0aGlzLl9mb3JtYXRfYWN0aW9uX2ludm9jYXRpb24oYWN0aW9uKV1cbiAgICAgICAgICAgIGZvciAobGV0IHN1YmFjdGlvbiBvZiB0aGlzLl9pdGVyX2luZGVudGVkX3N1YmFjdGlvbnMoYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIGludm9jYXRpb25zLnB1c2godGhpcy5fZm9ybWF0X2FjdGlvbl9pbnZvY2F0aW9uKHN1YmFjdGlvbikpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgbWF4aW11bSBpdGVtIGxlbmd0aFxuICAgICAgICAgICAgbGV0IGludm9jYXRpb25fbGVuZ3RoID0gTWF0aC5tYXgoLi4uaW52b2NhdGlvbnMubWFwKGludm9jYXRpb24gPT4gaW52b2NhdGlvbi5sZW5ndGgpKVxuICAgICAgICAgICAgbGV0IGFjdGlvbl9sZW5ndGggPSBpbnZvY2F0aW9uX2xlbmd0aCArIHRoaXMuX2N1cnJlbnRfaW5kZW50XG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25fbWF4X2xlbmd0aCA9IE1hdGgubWF4KHRoaXMuX2FjdGlvbl9tYXhfbGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25fbGVuZ3RoKVxuXG4gICAgICAgICAgICAvLyBhZGQgdGhlIGl0ZW0gdG8gdGhlIGxpc3RcbiAgICAgICAgICAgIHRoaXMuX2FkZF9pdGVtKHRoaXMuX2Zvcm1hdF9hY3Rpb24uYmluZCh0aGlzKSwgW2FjdGlvbl0pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRfYXJndW1lbnRzKGFjdGlvbnMpIHtcbiAgICAgICAgZm9yIChsZXQgYWN0aW9uIG9mIGFjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkX2FyZ3VtZW50KGFjdGlvbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gSGVscC1mb3JtYXR0aW5nIG1ldGhvZHNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuICAgIGZvcm1hdF9oZWxwKCkge1xuICAgICAgICBsZXQgaGVscCA9IHRoaXMuX3Jvb3Rfc2VjdGlvbi5mb3JtYXRfaGVscCgpXG4gICAgICAgIGlmIChoZWxwKSB7XG4gICAgICAgICAgICBoZWxwID0gaGVscC5yZXBsYWNlKHRoaXMuX2xvbmdfYnJlYWtfbWF0Y2hlciwgJ1xcblxcbicpXG4gICAgICAgICAgICBoZWxwID0gaGVscC5yZXBsYWNlKC9eXFxuK3xcXG4rJC9nLCAnJykgKyAnXFxuJ1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWxwXG4gICAgfVxuXG4gICAgX2pvaW5fcGFydHMocGFydF9zdHJpbmdzKSB7XG4gICAgICAgIHJldHVybiBwYXJ0X3N0cmluZ3MuZmlsdGVyKHBhcnQgPT4gcGFydCAmJiBwYXJ0ICE9PSBTVVBQUkVTUykuam9pbignJylcbiAgICB9XG5cbiAgICBfZm9ybWF0X3VzYWdlKHVzYWdlLCBhY3Rpb25zLCBncm91cHMsIHByZWZpeCkge1xuICAgICAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHByZWZpeCA9ICd1c2FnZTogJ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdXNhZ2UgaXMgc3BlY2lmaWVkLCB1c2UgdGhhdFxuICAgICAgICBpZiAodXNhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdXNhZ2UgPSBzdWIodXNhZ2UsIHsgcHJvZzogdGhpcy5fcHJvZyB9KVxuXG4gICAgICAgIC8vIGlmIG5vIG9wdGlvbmFscyBvciBwb3NpdGlvbmFscyBhcmUgYXZhaWxhYmxlLCB1c2FnZSBpcyBqdXN0IHByb2dcbiAgICAgICAgfSBlbHNlIGlmICh1c2FnZSA9PT0gdW5kZWZpbmVkICYmICFhY3Rpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgdXNhZ2UgPSBzdWIoJyUocHJvZylzJywgeyBwcm9nOiB0aGlzLl9wcm9nIH0pXG5cbiAgICAgICAgLy8gaWYgb3B0aW9uYWxzIGFuZCBwb3NpdGlvbmFscyBhcmUgYXZhaWxhYmxlLCBjYWxjdWxhdGUgdXNhZ2VcbiAgICAgICAgfSBlbHNlIGlmICh1c2FnZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgcHJvZyA9IHN1YignJShwcm9nKXMnLCB7IHByb2c6IHRoaXMuX3Byb2cgfSlcblxuICAgICAgICAgICAgLy8gc3BsaXQgb3B0aW9uYWxzIGZyb20gcG9zaXRpb25hbHNcbiAgICAgICAgICAgIGxldCBvcHRpb25hbHMgPSBbXVxuICAgICAgICAgICAgbGV0IHBvc2l0aW9uYWxzID0gW11cbiAgICAgICAgICAgIGZvciAobGV0IGFjdGlvbiBvZiBhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbi5vcHRpb25fc3RyaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uYWxzLnB1c2goYWN0aW9uKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uYWxzLnB1c2goYWN0aW9uKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYnVpbGQgZnVsbCB1c2FnZSBzdHJpbmdcbiAgICAgICAgICAgIGxldCBhY3Rpb25fdXNhZ2UgPSB0aGlzLl9mb3JtYXRfYWN0aW9uc191c2FnZShbXS5jb25jYXQob3B0aW9uYWxzKS5jb25jYXQocG9zaXRpb25hbHMpLCBncm91cHMpXG4gICAgICAgICAgICB1c2FnZSA9IFsgcHJvZywgYWN0aW9uX3VzYWdlIF0ubWFwKFN0cmluZykuam9pbignICcpXG5cbiAgICAgICAgICAgIC8vIHdyYXAgdGhlIHVzYWdlIHBhcnRzIGlmIGl0J3MgdG9vIGxvbmdcbiAgICAgICAgICAgIGxldCB0ZXh0X3dpZHRoID0gdGhpcy5fd2lkdGggLSB0aGlzLl9jdXJyZW50X2luZGVudFxuICAgICAgICAgICAgaWYgKHByZWZpeC5sZW5ndGggKyB1c2FnZS5sZW5ndGggPiB0ZXh0X3dpZHRoKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBicmVhayB1c2FnZSBpbnRvIHdyYXBwYWJsZSBwYXJ0c1xuICAgICAgICAgICAgICAgIGxldCBwYXJ0X3JlZ2V4cCA9IC9cXCguKj9cXCkrKD89XFxzfCQpfFxcWy4qP1xcXSsoPz1cXHN8JCl8XFxTKy9nXG4gICAgICAgICAgICAgICAgbGV0IG9wdF91c2FnZSA9IHRoaXMuX2Zvcm1hdF9hY3Rpb25zX3VzYWdlKG9wdGlvbmFscywgZ3JvdXBzKVxuICAgICAgICAgICAgICAgIGxldCBwb3NfdXNhZ2UgPSB0aGlzLl9mb3JtYXRfYWN0aW9uc191c2FnZShwb3NpdGlvbmFscywgZ3JvdXBzKVxuICAgICAgICAgICAgICAgIGxldCBvcHRfcGFydHMgPSBvcHRfdXNhZ2UubWF0Y2gocGFydF9yZWdleHApIHx8IFtdXG4gICAgICAgICAgICAgICAgbGV0IHBvc19wYXJ0cyA9IHBvc191c2FnZS5tYXRjaChwYXJ0X3JlZ2V4cCkgfHwgW11cbiAgICAgICAgICAgICAgICBhc3NlcnQob3B0X3BhcnRzLmpvaW4oJyAnKSA9PT0gb3B0X3VzYWdlKVxuICAgICAgICAgICAgICAgIGFzc2VydChwb3NfcGFydHMuam9pbignICcpID09PSBwb3NfdXNhZ2UpXG5cbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIgZm9yIHdyYXBwaW5nIGxpbmVzXG4gICAgICAgICAgICAgICAgbGV0IGdldF9saW5lcyA9IChwYXJ0cywgaW5kZW50LCBwcmVmaXggPSB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVzID0gW11cbiAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmUgPSBbXVxuICAgICAgICAgICAgICAgICAgICBsZXQgbGluZV9sZW5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZWZpeCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lX2xlbiA9IHByZWZpeC5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lX2xlbiA9IGluZGVudC5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcGFydCBvZiBwYXJ0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmVfbGVuICsgMSArIHBhcnQubGVuZ3RoID4gdGV4dF93aWR0aCAmJiBsaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChpbmRlbnQgKyBsaW5lLmpvaW4oJyAnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lX2xlbiA9IGluZGVudC5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lLnB1c2gocGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVfbGVuICs9IHBhcnQubGVuZ3RoICsgMVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChpbmRlbnQgKyBsaW5lLmpvaW4oJyAnKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZml4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzWzBdID0gbGluZXNbMF0uc2xpY2UoaW5kZW50Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGluZXNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgbGluZXNcblxuICAgICAgICAgICAgICAgIC8vIGlmIHByb2cgaXMgc2hvcnQsIGZvbGxvdyBpdCB3aXRoIG9wdGlvbmFscyBvciBwb3NpdGlvbmFsc1xuICAgICAgICAgICAgICAgIGlmIChwcmVmaXgubGVuZ3RoICsgcHJvZy5sZW5ndGggPD0gMC43NSAqIHRleHRfd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGluZGVudCA9ICcgJy5yZXBlYXQocHJlZml4Lmxlbmd0aCArIHByb2cubGVuZ3RoICsgMSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdF9wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzID0gZ2V0X2xpbmVzKFtwcm9nXS5jb25jYXQob3B0X3BhcnRzKSwgaW5kZW50LCBwcmVmaXgpXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyA9IGxpbmVzLmNvbmNhdChnZXRfbGluZXMocG9zX3BhcnRzLCBpbmRlbnQpKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvc19wYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzID0gZ2V0X2xpbmVzKFtwcm9nXS5jb25jYXQocG9zX3BhcnRzKSwgaW5kZW50LCBwcmVmaXgpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyA9IFtwcm9nXVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiBwcm9nIGlzIGxvbmcsIHB1dCBpdCBvbiBpdHMgb3duIGxpbmVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZW50ID0gJyAnLnJlcGVhdChwcmVmaXgubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFydHMgPSBbXS5jb25jYXQob3B0X3BhcnRzKS5jb25jYXQocG9zX3BhcnRzKVxuICAgICAgICAgICAgICAgICAgICBsaW5lcyA9IGdldF9saW5lcyhwYXJ0cywgaW5kZW50KVxuICAgICAgICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMgPSBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMgPSBsaW5lcy5jb25jYXQoZ2V0X2xpbmVzKG9wdF9wYXJ0cywgaW5kZW50KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzID0gbGluZXMuY29uY2F0KGdldF9saW5lcyhwb3NfcGFydHMsIGluZGVudCkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGluZXMgPSBbcHJvZ10uY29uY2F0KGxpbmVzKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGpvaW4gbGluZXMgaW50byB1c2FnZVxuICAgICAgICAgICAgICAgIHVzYWdlID0gbGluZXMuam9pbignXFxuJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZWZpeCB3aXRoICd1c2FnZTonXG4gICAgICAgIHJldHVybiBzdWIoJyVzJXNcXG5cXG4nLCBwcmVmaXgsIHVzYWdlKVxuICAgIH1cblxuICAgIF9mb3JtYXRfYWN0aW9uc191c2FnZShhY3Rpb25zLCBncm91cHMpIHtcbiAgICAgICAgLy8gZmluZCBncm91cCBpbmRpY2VzIGFuZCBpZGVudGlmeSBhY3Rpb25zIGluIGdyb3Vwc1xuICAgICAgICBsZXQgZ3JvdXBfYWN0aW9ucyA9IG5ldyBTZXQoKVxuICAgICAgICBsZXQgaW5zZXJ0cyA9IHt9XG4gICAgICAgIGZvciAobGV0IGdyb3VwIG9mIGdyb3Vwcykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gYWN0aW9ucy5pbmRleE9mKGdyb3VwLl9ncm91cF9hY3Rpb25zWzBdKVxuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBzdGFydCArIGdyb3VwLl9ncm91cF9hY3Rpb25zLmxlbmd0aFxuICAgICAgICAgICAgICAgIGlmIChfYXJyYXlfZXF1YWwoYWN0aW9ucy5zbGljZShzdGFydCwgZW5kKSwgZ3JvdXAuX2dyb3VwX2FjdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGFjdGlvbiBvZiBncm91cC5fZ3JvdXBfYWN0aW9ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBfYWN0aW9ucy5hZGQoYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ3JvdXAucmVxdWlyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCBpbiBpbnNlcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0c1tzdGFydF0gKz0gJyBbJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRzW3N0YXJ0XSA9ICdbJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCBpbiBpbnNlcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0c1tlbmRdICs9ICddJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRzW2VuZF0gPSAnXSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCBpbiBpbnNlcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0c1tzdGFydF0gKz0gJyAoJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRzW3N0YXJ0XSA9ICcoJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZCBpbiBpbnNlcnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0c1tlbmRdICs9ICcpJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRzW2VuZF0gPSAnKSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpIG9mIHJhbmdlKHN0YXJ0ICsgMSwgZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0c1tpXSA9ICd8J1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29sbGVjdCBhbGwgYWN0aW9ucyBmb3JtYXQgc3RyaW5nc1xuICAgICAgICBsZXQgcGFydHMgPSBbXVxuICAgICAgICBmb3IgKGxldCBbIGksIGFjdGlvbiBdIG9mIE9iamVjdC5lbnRyaWVzKGFjdGlvbnMpKSB7XG5cbiAgICAgICAgICAgIC8vIHN1cHByZXNzZWQgYXJndW1lbnRzIGFyZSBtYXJrZWQgd2l0aCBOb25lXG4gICAgICAgICAgICAvLyByZW1vdmUgfCBzZXBhcmF0b3JzIGZvciBzdXBwcmVzc2VkIGFyZ3VtZW50c1xuICAgICAgICAgICAgaWYgKGFjdGlvbi5oZWxwID09PSBTVVBQUkVTUykge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2godW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGlmIChpbnNlcnRzWytpXSA9PT0gJ3wnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnNlcnRzWytpXVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5zZXJ0c1sraSArIDFdID09PSAnfCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGluc2VydHNbK2kgKyAxXVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHJvZHVjZSBhbGwgYXJnIHN0cmluZ3NcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWFjdGlvbi5vcHRpb25fc3RyaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVmYXVsdF92YWx1ZSA9IHRoaXMuX2dldF9kZWZhdWx0X21ldGF2YXJfZm9yX3Bvc2l0aW9uYWwoYWN0aW9uKVxuICAgICAgICAgICAgICAgIGxldCBwYXJ0ID0gdGhpcy5fZm9ybWF0X2FyZ3MoYWN0aW9uLCBkZWZhdWx0X3ZhbHVlKVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBpbiBhIGdyb3VwLCBzdHJpcCB0aGUgb3V0ZXIgW11cbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBfYWN0aW9ucy5oYXMoYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFydFswXSA9PT0gJ1snICYmIHBhcnRbcGFydC5sZW5ndGggLSAxXSA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydC5zbGljZSgxLCAtMSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgYWN0aW9uIHN0cmluZyB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydClcblxuICAgICAgICAgICAgLy8gcHJvZHVjZSB0aGUgZmlyc3Qgd2F5IHRvIGludm9rZSB0aGUgb3B0aW9uIGluIGJyYWNrZXRzXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBvcHRpb25fc3RyaW5nID0gYWN0aW9uLm9wdGlvbl9zdHJpbmdzWzBdXG4gICAgICAgICAgICAgICAgbGV0IHBhcnRcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBPcHRpb25hbCBkb2Vzbid0IHRha2UgYSB2YWx1ZSwgZm9ybWF0IGlzOlxuICAgICAgICAgICAgICAgIC8vICAgIC1zIG9yIC0tbG9uZ1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24ubmFyZ3MgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydCA9IGFjdGlvbi5mb3JtYXRfdXNhZ2UoKVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIE9wdGlvbmFsIHRha2VzIGEgdmFsdWUsIGZvcm1hdCBpczpcbiAgICAgICAgICAgICAgICAvLyAgICAtcyBBUkdTIG9yIC0tbG9uZyBBUkdTXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRlZmF1bHRfdmFsdWUgPSB0aGlzLl9nZXRfZGVmYXVsdF9tZXRhdmFyX2Zvcl9vcHRpb25hbChhY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIGxldCBhcmdzX3N0cmluZyA9IHRoaXMuX2Zvcm1hdF9hcmdzKGFjdGlvbiwgZGVmYXVsdF92YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgcGFydCA9IHN1YignJXMgJXMnLCBvcHRpb25fc3RyaW5nLCBhcmdzX3N0cmluZylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBtYWtlIGl0IGxvb2sgb3B0aW9uYWwgaWYgaXQncyBub3QgcmVxdWlyZWQgb3IgaW4gYSBncm91cFxuICAgICAgICAgICAgICAgIGlmICghYWN0aW9uLnJlcXVpcmVkICYmICFncm91cF9hY3Rpb25zLmhhcyhhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnQgPSBzdWIoJ1slc10nLCBwYXJ0KVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGFkZCB0aGUgYWN0aW9uIHN0cmluZyB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGluc2VydCB0aGluZ3MgYXQgdGhlIG5lY2Vzc2FyeSBpbmRpY2VzXG4gICAgICAgIGZvciAobGV0IGkgb2YgT2JqZWN0LmtleXMoaW5zZXJ0cykubWFwKE51bWJlcikuc29ydCgoYSwgYikgPT4gYiAtIGEpKSB7XG4gICAgICAgICAgICBwYXJ0cy5zcGxpY2UoK2ksIDAsIGluc2VydHNbK2ldKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gam9pbiBhbGwgdGhlIGFjdGlvbiBpdGVtcyB3aXRoIHNwYWNlc1xuICAgICAgICBsZXQgdGV4dCA9IHBhcnRzLmZpbHRlcihCb29sZWFuKS5qb2luKCcgJylcblxuICAgICAgICAvLyBjbGVhbiB1cCBzZXBhcmF0b3JzIGZvciBtdXR1YWxseSBleGNsdXNpdmUgZ3JvdXBzXG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLyhbXFxbKF0pIC9nLCAnJDEnKVxuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKC8gKFtcXF0pXSkvZywgJyQxJylcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvW1xcWyhdICpbXFxdKV0vZywgJycpXG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcKChbXnxdKilcXCkvZywgJyQxJywgdGV4dClcbiAgICAgICAgdGV4dCA9IHRleHQudHJpbSgpXG5cbiAgICAgICAgLy8gcmV0dXJuIHRoZSB0ZXh0XG4gICAgICAgIHJldHVybiB0ZXh0XG4gICAgfVxuXG4gICAgX2Zvcm1hdF90ZXh0KHRleHQpIHtcbiAgICAgICAgaWYgKHRleHQuaW5jbHVkZXMoJyUocHJvZyknKSkge1xuICAgICAgICAgICAgdGV4dCA9IHN1Yih0ZXh0LCB7IHByb2c6IHRoaXMuX3Byb2cgfSlcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGV4dF93aWR0aCA9IE1hdGgubWF4KHRoaXMuX3dpZHRoIC0gdGhpcy5fY3VycmVudF9pbmRlbnQsIDExKVxuICAgICAgICBsZXQgaW5kZW50ID0gJyAnLnJlcGVhdCh0aGlzLl9jdXJyZW50X2luZGVudClcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbGxfdGV4dCh0ZXh0LCB0ZXh0X3dpZHRoLCBpbmRlbnQpICsgJ1xcblxcbidcbiAgICB9XG5cbiAgICBfZm9ybWF0X2FjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSByZXF1aXJlZCB3aWR0aCBhbmQgdGhlIGVudHJ5IGxhYmVsXG4gICAgICAgIGxldCBoZWxwX3Bvc2l0aW9uID0gTWF0aC5taW4odGhpcy5fYWN0aW9uX21heF9sZW5ndGggKyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21heF9oZWxwX3Bvc2l0aW9uKVxuICAgICAgICBsZXQgaGVscF93aWR0aCA9IE1hdGgubWF4KHRoaXMuX3dpZHRoIC0gaGVscF9wb3NpdGlvbiwgMTEpXG4gICAgICAgIGxldCBhY3Rpb25fd2lkdGggPSBoZWxwX3Bvc2l0aW9uIC0gdGhpcy5fY3VycmVudF9pbmRlbnQgLSAyXG4gICAgICAgIGxldCBhY3Rpb25faGVhZGVyID0gdGhpcy5fZm9ybWF0X2FjdGlvbl9pbnZvY2F0aW9uKGFjdGlvbilcbiAgICAgICAgbGV0IGluZGVudF9maXJzdFxuXG4gICAgICAgIC8vIG5vIGhlbHA7IHN0YXJ0IG9uIHNhbWUgbGluZSBhbmQgYWRkIGEgZmluYWwgbmV3bGluZVxuICAgICAgICBpZiAoIWFjdGlvbi5oZWxwKSB7XG4gICAgICAgICAgICBsZXQgdHVwID0gWyB0aGlzLl9jdXJyZW50X2luZGVudCwgJycsIGFjdGlvbl9oZWFkZXIgXVxuICAgICAgICAgICAgYWN0aW9uX2hlYWRlciA9IHN1YignJSpzJXNcXG4nLCAuLi50dXApXG5cbiAgICAgICAgLy8gc2hvcnQgYWN0aW9uIG5hbWU7IHN0YXJ0IG9uIHRoZSBzYW1lIGxpbmUgYW5kIHBhZCB0d28gc3BhY2VzXG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uX2hlYWRlci5sZW5ndGggPD0gYWN0aW9uX3dpZHRoKSB7XG4gICAgICAgICAgICBsZXQgdHVwID0gWyB0aGlzLl9jdXJyZW50X2luZGVudCwgJycsIGFjdGlvbl93aWR0aCwgYWN0aW9uX2hlYWRlciBdXG4gICAgICAgICAgICBhY3Rpb25faGVhZGVyID0gc3ViKCclKnMlLSpzICAnLCAuLi50dXApXG4gICAgICAgICAgICBpbmRlbnRfZmlyc3QgPSAwXG5cbiAgICAgICAgLy8gbG9uZyBhY3Rpb24gbmFtZTsgc3RhcnQgb24gdGhlIG5leHQgbGluZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHR1cCA9IFsgdGhpcy5fY3VycmVudF9pbmRlbnQsICcnLCBhY3Rpb25faGVhZGVyIF1cbiAgICAgICAgICAgIGFjdGlvbl9oZWFkZXIgPSBzdWIoJyUqcyVzXFxuJywgLi4udHVwKVxuICAgICAgICAgICAgaW5kZW50X2ZpcnN0ID0gaGVscF9wb3NpdGlvblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29sbGVjdCB0aGUgcGllY2VzIG9mIHRoZSBhY3Rpb24gaGVscFxuICAgICAgICBsZXQgcGFydHMgPSBbYWN0aW9uX2hlYWRlcl1cblxuICAgICAgICAvLyBpZiB0aGVyZSB3YXMgaGVscCBmb3IgdGhlIGFjdGlvbiwgYWRkIGxpbmVzIG9mIGhlbHAgdGV4dFxuICAgICAgICBpZiAoYWN0aW9uLmhlbHApIHtcbiAgICAgICAgICAgIGxldCBoZWxwX3RleHQgPSB0aGlzLl9leHBhbmRfaGVscChhY3Rpb24pXG4gICAgICAgICAgICBsZXQgaGVscF9saW5lcyA9IHRoaXMuX3NwbGl0X2xpbmVzKGhlbHBfdGV4dCwgaGVscF93aWR0aClcbiAgICAgICAgICAgIHBhcnRzLnB1c2goc3ViKCclKnMlc1xcbicsIGluZGVudF9maXJzdCwgJycsIGhlbHBfbGluZXNbMF0pKVxuICAgICAgICAgICAgZm9yIChsZXQgbGluZSBvZiBoZWxwX2xpbmVzLnNsaWNlKDEpKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChzdWIoJyUqcyVzXFxuJywgaGVscF9wb3NpdGlvbiwgJycsIGxpbmUpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIC8vIG9yIGFkZCBhIG5ld2xpbmUgaWYgdGhlIGRlc2NyaXB0aW9uIGRvZXNuJ3QgZW5kIHdpdGggb25lXG4gICAgICAgIH0gZWxzZSBpZiAoIWFjdGlvbl9oZWFkZXIuZW5kc1dpdGgoJ1xcbicpKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKCdcXG4nKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIGFueSBzdWItYWN0aW9ucywgYWRkIHRoZWlyIGhlbHAgYXMgd2VsbFxuICAgICAgICBmb3IgKGxldCBzdWJhY3Rpb24gb2YgdGhpcy5faXRlcl9pbmRlbnRlZF9zdWJhY3Rpb25zKGFjdGlvbikpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2godGhpcy5fZm9ybWF0X2FjdGlvbihzdWJhY3Rpb24pKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIGEgc2luZ2xlIHN0cmluZ1xuICAgICAgICByZXR1cm4gdGhpcy5fam9pbl9wYXJ0cyhwYXJ0cylcbiAgICB9XG5cbiAgICBfZm9ybWF0X2FjdGlvbl9pbnZvY2F0aW9uKGFjdGlvbikge1xuICAgICAgICBpZiAoIWFjdGlvbi5vcHRpb25fc3RyaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBkZWZhdWx0X3ZhbHVlID0gdGhpcy5fZ2V0X2RlZmF1bHRfbWV0YXZhcl9mb3JfcG9zaXRpb25hbChhY3Rpb24pXG4gICAgICAgICAgICBsZXQgbWV0YXZhciA9IHRoaXMuX21ldGF2YXJfZm9ybWF0dGVyKGFjdGlvbiwgZGVmYXVsdF92YWx1ZSkoMSlbMF1cbiAgICAgICAgICAgIHJldHVybiBtZXRhdmFyXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwYXJ0cyA9IFtdXG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBPcHRpb25hbCBkb2Vzbid0IHRha2UgYSB2YWx1ZSwgZm9ybWF0IGlzOlxuICAgICAgICAgICAgLy8gICAgLXMsIC0tbG9uZ1xuICAgICAgICAgICAgaWYgKGFjdGlvbi5uYXJncyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHBhcnRzID0gcGFydHMuY29uY2F0KGFjdGlvbi5vcHRpb25fc3RyaW5ncylcblxuICAgICAgICAgICAgLy8gaWYgdGhlIE9wdGlvbmFsIHRha2VzIGEgdmFsdWUsIGZvcm1hdCBpczpcbiAgICAgICAgICAgIC8vICAgIC1zIEFSR1MsIC0tbG9uZyBBUkdTXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBkZWZhdWx0X3ZhbHVlID0gdGhpcy5fZ2V0X2RlZmF1bHRfbWV0YXZhcl9mb3Jfb3B0aW9uYWwoYWN0aW9uKVxuICAgICAgICAgICAgICAgIGxldCBhcmdzX3N0cmluZyA9IHRoaXMuX2Zvcm1hdF9hcmdzKGFjdGlvbiwgZGVmYXVsdF92YWx1ZSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBvcHRpb25fc3RyaW5nIG9mIGFjdGlvbi5vcHRpb25fc3RyaW5ncykge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKHN1YignJXMgJXMnLCBvcHRpb25fc3RyaW5nLCBhcmdzX3N0cmluZykpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcGFydHMuam9pbignLCAnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX21ldGF2YXJfZm9ybWF0dGVyKGFjdGlvbiwgZGVmYXVsdF9tZXRhdmFyKSB7XG4gICAgICAgIGxldCByZXN1bHRcbiAgICAgICAgaWYgKGFjdGlvbi5tZXRhdmFyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGFjdGlvbi5tZXRhdmFyXG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uLmNob2ljZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGNob2ljZV9zdHJzID0gX2Nob2ljZXNfdG9fYXJyYXkoYWN0aW9uLmNob2ljZXMpLm1hcChTdHJpbmcpXG4gICAgICAgICAgICByZXN1bHQgPSBzdWIoJ3slc30nLCBjaG9pY2Vfc3Rycy5qb2luKCcsJykpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBkZWZhdWx0X21ldGF2YXJcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGZvcm1hdCh0dXBsZV9zaXplKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkodHVwbGVfc2l6ZSkuZmlsbChyZXN1bHQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdFxuICAgIH1cblxuICAgIF9mb3JtYXRfYXJncyhhY3Rpb24sIGRlZmF1bHRfbWV0YXZhcikge1xuICAgICAgICBsZXQgZ2V0X21ldGF2YXIgPSB0aGlzLl9tZXRhdmFyX2Zvcm1hdHRlcihhY3Rpb24sIGRlZmF1bHRfbWV0YXZhcilcbiAgICAgICAgbGV0IHJlc3VsdFxuICAgICAgICBpZiAoYWN0aW9uLm5hcmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHN1YignJXMnLCAuLi5nZXRfbWV0YXZhcigxKSlcbiAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24ubmFyZ3MgPT09IE9QVElPTkFMKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdWIoJ1slc10nLCAuLi5nZXRfbWV0YXZhcigxKSlcbiAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24ubmFyZ3MgPT09IFpFUk9fT1JfTU9SRSkge1xuICAgICAgICAgICAgbGV0IG1ldGF2YXIgPSBnZXRfbWV0YXZhcigxKVxuICAgICAgICAgICAgaWYgKG1ldGF2YXIubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc3ViKCdbJXMgWyVzIC4uLl1dJywgLi4ubWV0YXZhcilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc3ViKCdbJXMgLi4uXScsIC4uLm1ldGF2YXIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uLm5hcmdzID09PSBPTkVfT1JfTU9SRSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc3ViKCclcyBbJXMgLi4uXScsIC4uLmdldF9tZXRhdmFyKDIpKVxuICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbi5uYXJncyA9PT0gUkVNQUlOREVSKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAnLi4uJ1xuICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbi5uYXJncyA9PT0gUEFSU0VSKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBzdWIoJyVzIC4uLicsIC4uLmdldF9tZXRhdmFyKDEpKVxuICAgICAgICB9IGVsc2UgaWYgKGFjdGlvbi5uYXJncyA9PT0gU1VQUFJFU1MpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9ICcnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZm9ybWF0c1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3JtYXRzID0gcmFuZ2UoYWN0aW9uLm5hcmdzKS5tYXAoKCkgPT4gJyVzJylcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgbmFyZ3MgdmFsdWUnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gc3ViKGZvcm1hdHMuam9pbignICcpLCAuLi5nZXRfbWV0YXZhcihhY3Rpb24ubmFyZ3MpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICBfZXhwYW5kX2hlbHAoYWN0aW9uKSB7XG4gICAgICAgIGxldCBwYXJhbXMgPSBPYmplY3QuYXNzaWduKHsgcHJvZzogdGhpcy5fcHJvZyB9LCBhY3Rpb24pXG4gICAgICAgIGZvciAobGV0IG5hbWUgb2YgT2JqZWN0LmtleXMocGFyYW1zKSkge1xuICAgICAgICAgICAgaWYgKHBhcmFtc1tuYW1lXSA9PT0gU1VQUFJFU1MpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1zW25hbWVdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBvZiBPYmplY3Qua2V5cyhwYXJhbXMpKSB7XG4gICAgICAgICAgICBpZiAocGFyYW1zW25hbWVdICYmIHBhcmFtc1tuYW1lXS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW25hbWVdID0gcGFyYW1zW25hbWVdLm5hbWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmNob2ljZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGNob2ljZXNfc3RyID0gX2Nob2ljZXNfdG9fYXJyYXkocGFyYW1zLmNob2ljZXMpLm1hcChTdHJpbmcpLmpvaW4oJywgJylcbiAgICAgICAgICAgIHBhcmFtcy5jaG9pY2VzID0gY2hvaWNlc19zdHJcbiAgICAgICAgfVxuICAgICAgICAvLyBMRUdBQ1kgKHYxIGNvbXBhdGliaWxpdHkpOiBjYW1lbGNhc2VcbiAgICAgICAgZm9yIChsZXQga2V5IG9mIE9iamVjdC5rZXlzKHBhcmFtcykpIHtcbiAgICAgICAgICAgIGxldCBvbGRfbmFtZSA9IF90b19sZWdhY3lfbmFtZShrZXkpXG4gICAgICAgICAgICBpZiAob2xkX25hbWUgIT09IGtleSkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1tvbGRfbmFtZV0gPSBwYXJhbXNba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVuZFxuICAgICAgICByZXR1cm4gc3ViKHRoaXMuX2dldF9oZWxwX3N0cmluZyhhY3Rpb24pLCBwYXJhbXMpXG4gICAgfVxuXG4gICAgKiBfaXRlcl9pbmRlbnRlZF9zdWJhY3Rpb25zKGFjdGlvbikge1xuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbi5fZ2V0X3N1YmFjdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZGVudCgpXG4gICAgICAgICAgICB5aWVsZCogYWN0aW9uLl9nZXRfc3ViYWN0aW9ucygpXG4gICAgICAgICAgICB0aGlzLl9kZWRlbnQoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3NwbGl0X2xpbmVzKHRleHQsIHdpZHRoKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UodGhpcy5fd2hpdGVzcGFjZV9tYXRjaGVyLCAnICcpLnRyaW0oKVxuICAgICAgICAvLyBUaGUgdGV4dHdyYXAgbW9kdWxlIGlzIHVzZWQgb25seSBmb3IgZm9ybWF0dGluZyBoZWxwLlxuICAgICAgICAvLyBEZWxheSBpdHMgaW1wb3J0IGZvciBzcGVlZGluZyB1cCB0aGUgY29tbW9uIHVzYWdlIG9mIGFyZ3BhcnNlLlxuICAgICAgICBsZXQgdGV4dHdyYXAgPSByZXF1aXJlKCcuL2xpYi90ZXh0d3JhcCcpXG4gICAgICAgIHJldHVybiB0ZXh0d3JhcC53cmFwKHRleHQsIHsgd2lkdGggfSlcbiAgICB9XG5cbiAgICBfZmlsbF90ZXh0KHRleHQsIHdpZHRoLCBpbmRlbnQpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSh0aGlzLl93aGl0ZXNwYWNlX21hdGNoZXIsICcgJykudHJpbSgpXG4gICAgICAgIGxldCB0ZXh0d3JhcCA9IHJlcXVpcmUoJy4vbGliL3RleHR3cmFwJylcbiAgICAgICAgcmV0dXJuIHRleHR3cmFwLmZpbGwodGV4dCwgeyB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsX2luZGVudDogaW5kZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNlcXVlbnRfaW5kZW50OiBpbmRlbnQgfSlcbiAgICB9XG5cbiAgICBfZ2V0X2hlbHBfc3RyaW5nKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gYWN0aW9uLmhlbHBcbiAgICB9XG5cbiAgICBfZ2V0X2RlZmF1bHRfbWV0YXZhcl9mb3Jfb3B0aW9uYWwoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb24uZGVzdC50b1VwcGVyQ2FzZSgpXG4gICAgfVxuXG4gICAgX2dldF9kZWZhdWx0X21ldGF2YXJfZm9yX3Bvc2l0aW9uYWwoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb24uZGVzdFxuICAgIH1cbn0pKVxuXG5IZWxwRm9ybWF0dGVyLnByb3RvdHlwZS5fU2VjdGlvbiA9IF9jYWxsYWJsZShjbGFzcyBfU2VjdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3Rvcihmb3JtYXR0ZXIsIHBhcmVudCwgaGVhZGluZyA9IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmZvcm1hdHRlciA9IGZvcm1hdHRlclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudFxuICAgICAgICB0aGlzLmhlYWRpbmcgPSBoZWFkaW5nXG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXVxuICAgIH1cblxuICAgIGZvcm1hdF9oZWxwKCkge1xuICAgICAgICAvLyBmb3JtYXQgdGhlIGluZGVudGVkIHNlY3Rpb25cbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVyLl9pbmRlbnQoKVxuICAgICAgICB9XG4gICAgICAgIGxldCBpdGVtX2hlbHAgPSB0aGlzLmZvcm1hdHRlci5fam9pbl9wYXJ0cyh0aGlzLml0ZW1zLm1hcCgoWyBmdW5jLCBhcmdzIF0pID0+IGZ1bmMuYXBwbHkobnVsbCwgYXJncykpKVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5mb3JtYXR0ZXIuX2RlZGVudCgpXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gbm90aGluZyBpZiB0aGUgc2VjdGlvbiB3YXMgZW1wdHlcbiAgICAgICAgaWYgKCFpdGVtX2hlbHApIHtcbiAgICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIHRoZSBoZWFkaW5nIGlmIHRoZSBzZWN0aW9uIHdhcyBub24tZW1wdHlcbiAgICAgICAgbGV0IGhlYWRpbmdcbiAgICAgICAgaWYgKHRoaXMuaGVhZGluZyAhPT0gU1VQUFJFU1MgJiYgdGhpcy5oZWFkaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50X2luZGVudCA9IHRoaXMuZm9ybWF0dGVyLl9jdXJyZW50X2luZGVudFxuICAgICAgICAgICAgaGVhZGluZyA9IHN1YignJSpzJXM6XFxuJywgY3VycmVudF9pbmRlbnQsICcnLCB0aGlzLmhlYWRpbmcpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoZWFkaW5nID0gJydcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGpvaW4gdGhlIHNlY3Rpb24taW5pdGlhbCBuZXdsaW5lLCB0aGUgaGVhZGluZyBhbmQgdGhlIGhlbHBcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLl9qb2luX3BhcnRzKFsnXFxuJywgaGVhZGluZywgaXRlbV9oZWxwLCAnXFxuJ10pXG4gICAgfVxufSlcblxuXG5jb25zdCBSYXdEZXNjcmlwdGlvbkhlbHBGb3JtYXR0ZXIgPSBfY2FtZWxjYXNlX2FsaWFzKF9jYWxsYWJsZShjbGFzcyBSYXdEZXNjcmlwdGlvbkhlbHBGb3JtYXR0ZXIgZXh0ZW5kcyBIZWxwRm9ybWF0dGVyIHtcbiAgICAvKlxuICAgICAqICBIZWxwIG1lc3NhZ2UgZm9ybWF0dGVyIHdoaWNoIHJldGFpbnMgYW55IGZvcm1hdHRpbmcgaW4gZGVzY3JpcHRpb25zLlxuICAgICAqXG4gICAgICogIE9ubHkgdGhlIG5hbWUgb2YgdGhpcyBjbGFzcyBpcyBjb25zaWRlcmVkIGEgcHVibGljIEFQSS4gQWxsIHRoZSBtZXRob2RzXG4gICAgICogIHByb3ZpZGVkIGJ5IHRoZSBjbGFzcyBhcmUgY29uc2lkZXJlZCBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuXG4gICAgICovXG5cbiAgICBfZmlsbF90ZXh0KHRleHQsIHdpZHRoLCBpbmRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHNwbGl0bGluZXModGV4dCwgdHJ1ZSkubWFwKGxpbmUgPT4gaW5kZW50ICsgbGluZSkuam9pbignJylcbiAgICB9XG59KSlcblxuXG5jb25zdCBSYXdUZXh0SGVscEZvcm1hdHRlciA9IF9jYW1lbGNhc2VfYWxpYXMoX2NhbGxhYmxlKGNsYXNzIFJhd1RleHRIZWxwRm9ybWF0dGVyIGV4dGVuZHMgUmF3RGVzY3JpcHRpb25IZWxwRm9ybWF0dGVyIHtcbiAgICAvKlxuICAgICAqICBIZWxwIG1lc3NhZ2UgZm9ybWF0dGVyIHdoaWNoIHJldGFpbnMgZm9ybWF0dGluZyBvZiBhbGwgaGVscCB0ZXh0LlxuICAgICAqXG4gICAgICogIE9ubHkgdGhlIG5hbWUgb2YgdGhpcyBjbGFzcyBpcyBjb25zaWRlcmVkIGEgcHVibGljIEFQSS4gQWxsIHRoZSBtZXRob2RzXG4gICAgICogIHByb3ZpZGVkIGJ5IHRoZSBjbGFzcyBhcmUgY29uc2lkZXJlZCBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuXG4gICAgICovXG5cbiAgICBfc3BsaXRfbGluZXModGV4dC8qLCB3aWR0aCovKSB7XG4gICAgICAgIHJldHVybiBzcGxpdGxpbmVzKHRleHQpXG4gICAgfVxufSkpXG5cblxuY29uc3QgQXJndW1lbnREZWZhdWx0c0hlbHBGb3JtYXR0ZXIgPSBfY2FtZWxjYXNlX2FsaWFzKF9jYWxsYWJsZShjbGFzcyBBcmd1bWVudERlZmF1bHRzSGVscEZvcm1hdHRlciBleHRlbmRzIEhlbHBGb3JtYXR0ZXIge1xuICAgIC8qXG4gICAgICogIEhlbHAgbWVzc2FnZSBmb3JtYXR0ZXIgd2hpY2ggYWRkcyBkZWZhdWx0IHZhbHVlcyB0byBhcmd1bWVudCBoZWxwLlxuICAgICAqXG4gICAgICogIE9ubHkgdGhlIG5hbWUgb2YgdGhpcyBjbGFzcyBpcyBjb25zaWRlcmVkIGEgcHVibGljIEFQSS4gQWxsIHRoZSBtZXRob2RzXG4gICAgICogIHByb3ZpZGVkIGJ5IHRoZSBjbGFzcyBhcmUgY29uc2lkZXJlZCBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuXG4gICAgICovXG5cbiAgICBfZ2V0X2hlbHBfc3RyaW5nKGFjdGlvbikge1xuICAgICAgICBsZXQgaGVscCA9IGFjdGlvbi5oZWxwXG4gICAgICAgIC8vIExFR0FDWSAodjEgY29tcGF0aWJpbGl0eSk6IGFkZGl0aW9uYWwgY2hlY2sgZm9yIGRlZmF1bHRWYWx1ZSBuZWVkZWRcbiAgICAgICAgaWYgKCFhY3Rpb24uaGVscC5pbmNsdWRlcygnJShkZWZhdWx0KScpICYmICFhY3Rpb24uaGVscC5pbmNsdWRlcygnJShkZWZhdWx0VmFsdWUpJykpIHtcbiAgICAgICAgICAgIGlmIChhY3Rpb24uZGVmYXVsdCAhPT0gU1VQUFJFU1MpIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVmYXVsdGluZ19uYXJncyA9IFtPUFRJT05BTCwgWkVST19PUl9NT1JFXVxuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24ub3B0aW9uX3N0cmluZ3MubGVuZ3RoIHx8IGRlZmF1bHRpbmdfbmFyZ3MuaW5jbHVkZXMoYWN0aW9uLm5hcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICBoZWxwICs9ICcgKGRlZmF1bHQ6ICUoZGVmYXVsdClzKSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlbHBcbiAgICB9XG59KSlcblxuXG5jb25zdCBNZXRhdmFyVHlwZUhlbHBGb3JtYXR0ZXIgPSBfY2FtZWxjYXNlX2FsaWFzKF9jYWxsYWJsZShjbGFzcyBNZXRhdmFyVHlwZUhlbHBGb3JtYXR0ZXIgZXh0ZW5kcyBIZWxwRm9ybWF0dGVyIHtcbiAgICAvKlxuICAgICAqICBIZWxwIG1lc3NhZ2UgZm9ybWF0dGVyIHdoaWNoIHVzZXMgdGhlIGFyZ3VtZW50ICd0eXBlJyBhcyB0aGUgZGVmYXVsdFxuICAgICAqICBtZXRhdmFyIHZhbHVlIChpbnN0ZWFkIG9mIHRoZSBhcmd1bWVudCAnZGVzdCcpXG4gICAgICpcbiAgICAgKiAgT25seSB0aGUgbmFtZSBvZiB0aGlzIGNsYXNzIGlzIGNvbnNpZGVyZWQgYSBwdWJsaWMgQVBJLiBBbGwgdGhlIG1ldGhvZHNcbiAgICAgKiAgcHJvdmlkZWQgYnkgdGhlIGNsYXNzIGFyZSBjb25zaWRlcmVkIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbC5cbiAgICAgKi9cblxuICAgIF9nZXRfZGVmYXVsdF9tZXRhdmFyX2Zvcl9vcHRpb25hbChhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBhY3Rpb24udHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IGFjdGlvbi50eXBlLm5hbWUgOiBhY3Rpb24udHlwZVxuICAgIH1cblxuICAgIF9nZXRfZGVmYXVsdF9tZXRhdmFyX2Zvcl9wb3NpdGlvbmFsKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGFjdGlvbi50eXBlID09PSAnZnVuY3Rpb24nID8gYWN0aW9uLnR5cGUubmFtZSA6IGFjdGlvbi50eXBlXG4gICAgfVxufSkpXG5cblxuLy8gPT09PT09PT09PT09PT09PT09PT09XG4vLyBPcHRpb25zIGFuZCBBcmd1bWVudHNcbi8vID09PT09PT09PT09PT09PT09PT09PVxuZnVuY3Rpb24gX2dldF9hY3Rpb25fbmFtZShhcmd1bWVudCkge1xuICAgIGlmIChhcmd1bWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50Lm9wdGlvbl9zdHJpbmdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnQub3B0aW9uX3N0cmluZ3Muam9pbignLycpXG4gICAgfSBlbHNlIGlmICghWyB1bmRlZmluZWQsIFNVUFBSRVNTIF0uaW5jbHVkZXMoYXJndW1lbnQubWV0YXZhcikpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50Lm1ldGF2YXJcbiAgICB9IGVsc2UgaWYgKCFbIHVuZGVmaW5lZCwgU1VQUFJFU1MgXS5pbmNsdWRlcyhhcmd1bWVudC5kZXN0KSkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnQuZGVzdFxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICB9XG59XG5cblxuY29uc3QgQXJndW1lbnRFcnJvciA9IF9jYWxsYWJsZShjbGFzcyBBcmd1bWVudEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8qXG4gICAgICogIEFuIGVycm9yIGZyb20gY3JlYXRpbmcgb3IgdXNpbmcgYW4gYXJndW1lbnQgKG9wdGlvbmFsIG9yIHBvc2l0aW9uYWwpLlxuICAgICAqXG4gICAgICogIFRoZSBzdHJpbmcgdmFsdWUgb2YgdGhpcyBleGNlcHRpb24gaXMgdGhlIG1lc3NhZ2UsIGF1Z21lbnRlZCB3aXRoXG4gICAgICogIGluZm9ybWF0aW9uIGFib3V0IHRoZSBhcmd1bWVudCB0aGF0IGNhdXNlZCBpdC5cbiAgICAgKi9cblxuICAgIGNvbnN0cnVjdG9yKGFyZ3VtZW50LCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FyZ3VtZW50RXJyb3InXG4gICAgICAgIHRoaXMuX2FyZ3VtZW50X25hbWUgPSBfZ2V0X2FjdGlvbl9uYW1lKGFyZ3VtZW50KVxuICAgICAgICB0aGlzLl9tZXNzYWdlID0gbWVzc2FnZVxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLnN0cigpXG4gICAgfVxuXG4gICAgc3RyKCkge1xuICAgICAgICBsZXQgZm9ybWF0XG4gICAgICAgIGlmICh0aGlzLl9hcmd1bWVudF9uYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9ICclKG1lc3NhZ2UpcydcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9ICdhcmd1bWVudCAlKGFyZ3VtZW50X25hbWUpczogJShtZXNzYWdlKXMnXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Yihmb3JtYXQsIHsgbWVzc2FnZTogdGhpcy5fbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRfbmFtZTogdGhpcy5fYXJndW1lbnRfbmFtZSB9KVxuICAgIH1cbn0pXG5cblxuY29uc3QgQXJndW1lbnRUeXBlRXJyb3IgPSBfY2FsbGFibGUoY2xhc3MgQXJndW1lbnRUeXBlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgLypcbiAgICAgKiBBbiBlcnJvciBmcm9tIHRyeWluZyB0byBjb252ZXJ0IGEgY29tbWFuZCBsaW5lIHN0cmluZyB0byBhIHR5cGUuXG4gICAgICovXG5cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgICAgIHRoaXMubmFtZSA9ICdBcmd1bWVudFR5cGVFcnJvcidcbiAgICB9XG59KVxuXG5cbi8vID09PT09PT09PT09PT09XG4vLyBBY3Rpb24gY2xhc3Nlc1xuLy8gPT09PT09PT09PT09PT1cbmNvbnN0IEFjdGlvbiA9IF9jYW1lbGNhc2VfYWxpYXMoX2NhbGxhYmxlKGNsYXNzIEFjdGlvbiBleHRlbmRzIF9BdHRyaWJ1dGVIb2xkZXIoRnVuY3Rpb24pIHtcbiAgICAvKlxuICAgICAqICBJbmZvcm1hdGlvbiBhYm91dCBob3cgdG8gY29udmVydCBjb21tYW5kIGxpbmUgc3RyaW5ncyB0byBQeXRob24gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqICBBY3Rpb24gb2JqZWN0cyBhcmUgdXNlZCBieSBhbiBBcmd1bWVudFBhcnNlciB0byByZXByZXNlbnQgdGhlIGluZm9ybWF0aW9uXG4gICAgICogIG5lZWRlZCB0byBwYXJzZSBhIHNpbmdsZSBhcmd1bWVudCBmcm9tIG9uZSBvciBtb3JlIHN0cmluZ3MgZnJvbSB0aGVcbiAgICAgKiAgY29tbWFuZCBsaW5lLiBUaGUga2V5d29yZCBhcmd1bWVudHMgdG8gdGhlIEFjdGlvbiBjb25zdHJ1Y3RvciBhcmUgYWxzb1xuICAgICAqICBhbGwgYXR0cmlidXRlcyBvZiBBY3Rpb24gaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogIEtleXdvcmQgQXJndW1lbnRzOlxuICAgICAqXG4gICAgICogICAgICAtIG9wdGlvbl9zdHJpbmdzIC0tIEEgbGlzdCBvZiBjb21tYW5kLWxpbmUgb3B0aW9uIHN0cmluZ3Mgd2hpY2hcbiAgICAgKiAgICAgICAgICBzaG91bGQgYmUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgYWN0aW9uLlxuICAgICAqXG4gICAgICogICAgICAtIGRlc3QgLS0gVGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0byBob2xkIHRoZSBjcmVhdGVkIG9iamVjdChzKVxuICAgICAqXG4gICAgICogICAgICAtIG5hcmdzIC0tIFRoZSBudW1iZXIgb2YgY29tbWFuZC1saW5lIGFyZ3VtZW50cyB0aGF0IHNob3VsZCBiZVxuICAgICAqICAgICAgICAgIGNvbnN1bWVkLiBCeSBkZWZhdWx0LCBvbmUgYXJndW1lbnQgd2lsbCBiZSBjb25zdW1lZCBhbmQgYSBzaW5nbGVcbiAgICAgKiAgICAgICAgICB2YWx1ZSB3aWxsIGJlIHByb2R1Y2VkLiAgT3RoZXIgdmFsdWVzIGluY2x1ZGU6XG4gICAgICogICAgICAgICAgICAgIC0gTiAoYW4gaW50ZWdlcikgY29uc3VtZXMgTiBhcmd1bWVudHMgKGFuZCBwcm9kdWNlcyBhIGxpc3QpXG4gICAgICogICAgICAgICAgICAgIC0gJz8nIGNvbnN1bWVzIHplcm8gb3Igb25lIGFyZ3VtZW50c1xuICAgICAqICAgICAgICAgICAgICAtICcqJyBjb25zdW1lcyB6ZXJvIG9yIG1vcmUgYXJndW1lbnRzIChhbmQgcHJvZHVjZXMgYSBsaXN0KVxuICAgICAqICAgICAgICAgICAgICAtICcrJyBjb25zdW1lcyBvbmUgb3IgbW9yZSBhcmd1bWVudHMgKGFuZCBwcm9kdWNlcyBhIGxpc3QpXG4gICAgICogICAgICAgICAgTm90ZSB0aGF0IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGRlZmF1bHQgYW5kIG5hcmdzPTEgaXMgdGhhdFxuICAgICAqICAgICAgICAgIHdpdGggdGhlIGRlZmF1bHQsIGEgc2luZ2xlIHZhbHVlIHdpbGwgYmUgcHJvZHVjZWQsIHdoaWxlIHdpdGhcbiAgICAgKiAgICAgICAgICBuYXJncz0xLCBhIGxpc3QgY29udGFpbmluZyBhIHNpbmdsZSB2YWx1ZSB3aWxsIGJlIHByb2R1Y2VkLlxuICAgICAqXG4gICAgICogICAgICAtIGNvbnN0IC0tIFRoZSB2YWx1ZSB0byBiZSBwcm9kdWNlZCBpZiB0aGUgb3B0aW9uIGlzIHNwZWNpZmllZCBhbmQgdGhlXG4gICAgICogICAgICAgICAgb3B0aW9uIHVzZXMgYW4gYWN0aW9uIHRoYXQgdGFrZXMgbm8gdmFsdWVzLlxuICAgICAqXG4gICAgICogICAgICAtIGRlZmF1bHQgLS0gVGhlIHZhbHVlIHRvIGJlIHByb2R1Y2VkIGlmIHRoZSBvcHRpb24gaXMgbm90IHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqICAgICAgLSB0eXBlIC0tIEEgY2FsbGFibGUgdGhhdCBhY2NlcHRzIGEgc2luZ2xlIHN0cmluZyBhcmd1bWVudCwgYW5kXG4gICAgICogICAgICAgICAgcmV0dXJucyB0aGUgY29udmVydGVkIHZhbHVlLiAgVGhlIHN0YW5kYXJkIFB5dGhvbiB0eXBlcyBzdHIsIGludCxcbiAgICAgKiAgICAgICAgICBmbG9hdCwgYW5kIGNvbXBsZXggYXJlIHVzZWZ1bCBleGFtcGxlcyBvZiBzdWNoIGNhbGxhYmxlcy4gIElmIE5vbmUsXG4gICAgICogICAgICAgICAgc3RyIGlzIHVzZWQuXG4gICAgICpcbiAgICAgKiAgICAgIC0gY2hvaWNlcyAtLSBBIGNvbnRhaW5lciBvZiB2YWx1ZXMgdGhhdCBzaG91bGQgYmUgYWxsb3dlZC4gSWYgbm90IE5vbmUsXG4gICAgICogICAgICAgICAgYWZ0ZXIgYSBjb21tYW5kLWxpbmUgYXJndW1lbnQgaGFzIGJlZW4gY29udmVydGVkIHRvIHRoZSBhcHByb3ByaWF0ZVxuICAgICAqICAgICAgICAgIHR5cGUsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHJhaXNlZCBpZiBpdCBpcyBub3QgYSBtZW1iZXIgb2YgdGhpc1xuICAgICAqICAgICAgICAgIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiAgICAgIC0gcmVxdWlyZWQgLS0gVHJ1ZSBpZiB0aGUgYWN0aW9uIG11c3QgYWx3YXlzIGJlIHNwZWNpZmllZCBhdCB0aGVcbiAgICAgKiAgICAgICAgICBjb21tYW5kIGxpbmUuIFRoaXMgaXMgb25seSBtZWFuaW5nZnVsIGZvciBvcHRpb25hbCBjb21tYW5kLWxpbmVcbiAgICAgKiAgICAgICAgICBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAgICAgIC0gaGVscCAtLSBUaGUgaGVscCBzdHJpbmcgZGVzY3JpYmluZyB0aGUgYXJndW1lbnQuXG4gICAgICpcbiAgICAgKiAgICAgIC0gbWV0YXZhciAtLSBUaGUgbmFtZSB0byBiZSB1c2VkIGZvciB0aGUgb3B0aW9uJ3MgYXJndW1lbnQgd2l0aCB0aGVcbiAgICAgKiAgICAgICAgICBoZWxwIHN0cmluZy4gSWYgTm9uZSwgdGhlICdkZXN0JyB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIG5hbWUuXG4gICAgICovXG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbGV0IFtcbiAgICAgICAgICAgIG9wdGlvbl9zdHJpbmdzLFxuICAgICAgICAgICAgZGVzdCxcbiAgICAgICAgICAgIG5hcmdzLFxuICAgICAgICAgICAgY29uc3RfdmFsdWUsXG4gICAgICAgICAgICBkZWZhdWx0X3ZhbHVlLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIGNob2ljZXMsXG4gICAgICAgICAgICByZXF1aXJlZCxcbiAgICAgICAgICAgIGhlbHAsXG4gICAgICAgICAgICBtZXRhdmFyXG4gICAgICAgIF0gPSBfcGFyc2Vfb3B0cyhhcmd1bWVudHMsIHtcbiAgICAgICAgICAgIG9wdGlvbl9zdHJpbmdzOiBub19kZWZhdWx0LFxuICAgICAgICAgICAgZGVzdDogbm9fZGVmYXVsdCxcbiAgICAgICAgICAgIG5hcmdzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb25zdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2hvaWNlczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaGVscDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWV0YXZhcjogdW5kZWZpbmVkXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gd2hlbiB0aGlzIGNsYXNzIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCByZWRpcmVjdCBpdCB0byAuY2FsbCgpIG1ldGhvZCBvZiBpdHNlbGZcbiAgICAgICAgc3VwZXIoJ3JldHVybiBhcmd1bWVudHMuY2FsbGVlLmNhbGwuYXBwbHkoYXJndW1lbnRzLmNhbGxlZSwgYXJndW1lbnRzKScpXG5cbiAgICAgICAgdGhpcy5vcHRpb25fc3RyaW5ncyA9IG9wdGlvbl9zdHJpbmdzXG4gICAgICAgIHRoaXMuZGVzdCA9IGRlc3RcbiAgICAgICAgdGhpcy5uYXJncyA9IG5hcmdzXG4gICAgICAgIHRoaXMuY29uc3QgPSBjb25zdF92YWx1ZVxuICAgICAgICB0aGlzLmRlZmF1bHQgPSBkZWZhdWx0X3ZhbHVlXG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICAgICAgdGhpcy5jaG9pY2VzID0gY2hvaWNlc1xuICAgICAgICB0aGlzLnJlcXVpcmVkID0gcmVxdWlyZWRcbiAgICAgICAgdGhpcy5oZWxwID0gaGVscFxuICAgICAgICB0aGlzLm1ldGF2YXIgPSBtZXRhdmFyXG4gICAgfVxuXG4gICAgX2dldF9rd2FyZ3MoKSB7XG4gICAgICAgIGxldCBuYW1lcyA9IFtcbiAgICAgICAgICAgICdvcHRpb25fc3RyaW5ncycsXG4gICAgICAgICAgICAnZGVzdCcsXG4gICAgICAgICAgICAnbmFyZ3MnLFxuICAgICAgICAgICAgJ2NvbnN0JyxcbiAgICAgICAgICAgICdkZWZhdWx0JyxcbiAgICAgICAgICAgICd0eXBlJyxcbiAgICAgICAgICAgICdjaG9pY2VzJyxcbiAgICAgICAgICAgICdoZWxwJyxcbiAgICAgICAgICAgICdtZXRhdmFyJ1xuICAgICAgICBdXG4gICAgICAgIHJldHVybiBuYW1lcy5tYXAobmFtZSA9PiBbIG5hbWUsIGdldGF0dHIodGhpcywgbmFtZSkgXSlcbiAgICB9XG5cbiAgICBmb3JtYXRfdXNhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbl9zdHJpbmdzWzBdXG4gICAgfVxuXG4gICAgY2FsbCgvKnBhcnNlciwgbmFtZXNwYWNlLCB2YWx1ZXMsIG9wdGlvbl9zdHJpbmcgPSB1bmRlZmluZWQqLykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJy5jYWxsKCkgbm90IGRlZmluZWQnKVxuICAgIH1cbn0pKVxuXG5cbmNvbnN0IEJvb2xlYW5PcHRpb25hbEFjdGlvbiA9IF9jYW1lbGNhc2VfYWxpYXMoX2NhbGxhYmxlKGNsYXNzIEJvb2xlYW5PcHRpb25hbEFjdGlvbiBleHRlbmRzIEFjdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbGV0IFtcbiAgICAgICAgICAgIG9wdGlvbl9zdHJpbmdzLFxuICAgICAgICAgICAgZGVzdCxcbiAgICAgICAgICAgIGRlZmF1bHRfdmFsdWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgY2hvaWNlcyxcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgICAgaGVscCxcbiAgICAgICAgICAgIG1ldGF2YXJcbiAgICAgICAgXSA9IF9wYXJzZV9vcHRzKGFyZ3VtZW50cywge1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3M6IG5vX2RlZmF1bHQsXG4gICAgICAgICAgICBkZXN0OiBub19kZWZhdWx0LFxuICAgICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2hvaWNlczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaGVscDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWV0YXZhcjogdW5kZWZpbmVkXG4gICAgICAgIH0pXG5cbiAgICAgICAgbGV0IF9vcHRpb25fc3RyaW5ncyA9IFtdXG4gICAgICAgIGZvciAobGV0IG9wdGlvbl9zdHJpbmcgb2Ygb3B0aW9uX3N0cmluZ3MpIHtcbiAgICAgICAgICAgIF9vcHRpb25fc3RyaW5ncy5wdXNoKG9wdGlvbl9zdHJpbmcpXG5cbiAgICAgICAgICAgIGlmIChvcHRpb25fc3RyaW5nLnN0YXJ0c1dpdGgoJy0tJykpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25fc3RyaW5nID0gJy0tbm8tJyArIG9wdGlvbl9zdHJpbmcuc2xpY2UoMilcbiAgICAgICAgICAgICAgICBfb3B0aW9uX3N0cmluZ3MucHVzaChvcHRpb25fc3RyaW5nKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlbHAgIT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0X3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGhlbHAgKz0gYCAoZGVmYXVsdDogJHtkZWZhdWx0X3ZhbHVlfSlgXG4gICAgICAgIH1cblxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBvcHRpb25fc3RyaW5nczogX29wdGlvbl9zdHJpbmdzLFxuICAgICAgICAgICAgZGVzdCxcbiAgICAgICAgICAgIG5hcmdzOiAwLFxuICAgICAgICAgICAgZGVmYXVsdDogZGVmYXVsdF92YWx1ZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBjaG9pY2VzLFxuICAgICAgICAgICAgcmVxdWlyZWQsXG4gICAgICAgICAgICBoZWxwLFxuICAgICAgICAgICAgbWV0YXZhclxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGNhbGwocGFyc2VyLCBuYW1lc3BhY2UsIHZhbHVlcywgb3B0aW9uX3N0cmluZyA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25fc3RyaW5ncy5pbmNsdWRlcyhvcHRpb25fc3RyaW5nKSkge1xuICAgICAgICAgICAgc2V0YXR0cihuYW1lc3BhY2UsIHRoaXMuZGVzdCwgIW9wdGlvbl9zdHJpbmcuc3RhcnRzV2l0aCgnLS1uby0nKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvcm1hdF91c2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uX3N0cmluZ3Muam9pbignIHwgJylcbiAgICB9XG59KSlcblxuXG5jb25zdCBfU3RvcmVBY3Rpb24gPSBfY2FsbGFibGUoY2xhc3MgX1N0b3JlQWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBsZXQgW1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3MsXG4gICAgICAgICAgICBkZXN0LFxuICAgICAgICAgICAgbmFyZ3MsXG4gICAgICAgICAgICBjb25zdF92YWx1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRfdmFsdWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgY2hvaWNlcyxcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgICAgaGVscCxcbiAgICAgICAgICAgIG1ldGF2YXJcbiAgICAgICAgXSA9IF9wYXJzZV9vcHRzKGFyZ3VtZW50cywge1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3M6IG5vX2RlZmF1bHQsXG4gICAgICAgICAgICBkZXN0OiBub19kZWZhdWx0LFxuICAgICAgICAgICAgbmFyZ3M6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbnN0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0eXBlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaG9pY2VzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICBoZWxwOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtZXRhdmFyOiB1bmRlZmluZWRcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAobmFyZ3MgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25hcmdzIGZvciBzdG9yZSBhY3Rpb25zIG11c3QgYmUgIT0gMDsgaWYgeW91ICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2hhdmUgbm90aGluZyB0byBzdG9yZSwgYWN0aW9ucyBzdWNoIGFzIHN0b3JlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RydWUgb3Igc3RvcmUgY29uc3QgbWF5IGJlIG1vcmUgYXBwcm9wcmlhdGUnKVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdF92YWx1ZSAhPT0gdW5kZWZpbmVkICYmIG5hcmdzICE9PSBPUFRJT05BTCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzdWIoJ25hcmdzIG11c3QgYmUgJXIgdG8gc3VwcGx5IGNvbnN0JywgT1BUSU9OQUwpKVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHtcbiAgICAgICAgICAgIG9wdGlvbl9zdHJpbmdzLFxuICAgICAgICAgICAgZGVzdCxcbiAgICAgICAgICAgIG5hcmdzLFxuICAgICAgICAgICAgY29uc3Q6IGNvbnN0X3ZhbHVlLFxuICAgICAgICAgICAgZGVmYXVsdDogZGVmYXVsdF92YWx1ZSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBjaG9pY2VzLFxuICAgICAgICAgICAgcmVxdWlyZWQsXG4gICAgICAgICAgICBoZWxwLFxuICAgICAgICAgICAgbWV0YXZhclxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGNhbGwocGFyc2VyLCBuYW1lc3BhY2UsIHZhbHVlcy8qLCBvcHRpb25fc3RyaW5nID0gdW5kZWZpbmVkKi8pIHtcbiAgICAgICAgc2V0YXR0cihuYW1lc3BhY2UsIHRoaXMuZGVzdCwgdmFsdWVzKVxuICAgIH1cbn0pXG5cblxuY29uc3QgX1N0b3JlQ29uc3RBY3Rpb24gPSBfY2FsbGFibGUoY2xhc3MgX1N0b3JlQ29uc3RBY3Rpb24gZXh0ZW5kcyBBY3Rpb24ge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGxldCBbXG4gICAgICAgICAgICBvcHRpb25fc3RyaW5ncyxcbiAgICAgICAgICAgIGRlc3QsXG4gICAgICAgICAgICBjb25zdF92YWx1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRfdmFsdWUsXG4gICAgICAgICAgICByZXF1aXJlZCxcbiAgICAgICAgICAgIGhlbHBcbiAgICAgICAgICAgIC8vLCBtZXRhdmFyXG4gICAgICAgIF0gPSBfcGFyc2Vfb3B0cyhhcmd1bWVudHMsIHtcbiAgICAgICAgICAgIG9wdGlvbl9zdHJpbmdzOiBub19kZWZhdWx0LFxuICAgICAgICAgICAgZGVzdDogbm9fZGVmYXVsdCxcbiAgICAgICAgICAgIGNvbnN0OiBub19kZWZhdWx0LFxuICAgICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaGVscDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWV0YXZhcjogdW5kZWZpbmVkXG4gICAgICAgIH0pXG5cbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3MsXG4gICAgICAgICAgICBkZXN0LFxuICAgICAgICAgICAgbmFyZ3M6IDAsXG4gICAgICAgICAgICBjb25zdDogY29uc3RfdmFsdWUsXG4gICAgICAgICAgICBkZWZhdWx0OiBkZWZhdWx0X3ZhbHVlLFxuICAgICAgICAgICAgcmVxdWlyZWQsXG4gICAgICAgICAgICBoZWxwXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgY2FsbChwYXJzZXIsIG5hbWVzcGFjZS8qLCB2YWx1ZXMsIG9wdGlvbl9zdHJpbmcgPSB1bmRlZmluZWQqLykge1xuICAgICAgICBzZXRhdHRyKG5hbWVzcGFjZSwgdGhpcy5kZXN0LCB0aGlzLmNvbnN0KVxuICAgIH1cbn0pXG5cblxuY29uc3QgX1N0b3JlVHJ1ZUFjdGlvbiA9IF9jYWxsYWJsZShjbGFzcyBfU3RvcmVUcnVlQWN0aW9uIGV4dGVuZHMgX1N0b3JlQ29uc3RBY3Rpb24ge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGxldCBbXG4gICAgICAgICAgICBvcHRpb25fc3RyaW5ncyxcbiAgICAgICAgICAgIGRlc3QsXG4gICAgICAgICAgICBkZWZhdWx0X3ZhbHVlLFxuICAgICAgICAgICAgcmVxdWlyZWQsXG4gICAgICAgICAgICBoZWxwXG4gICAgICAgIF0gPSBfcGFyc2Vfb3B0cyhhcmd1bWVudHMsIHtcbiAgICAgICAgICAgIG9wdGlvbl9zdHJpbmdzOiBub19kZWZhdWx0LFxuICAgICAgICAgICAgZGVzdDogbm9fZGVmYXVsdCxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaGVscDogdW5kZWZpbmVkXG4gICAgICAgIH0pXG5cbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3MsXG4gICAgICAgICAgICBkZXN0LFxuICAgICAgICAgICAgY29uc3Q6IHRydWUsXG4gICAgICAgICAgICBkZWZhdWx0OiBkZWZhdWx0X3ZhbHVlLFxuICAgICAgICAgICAgcmVxdWlyZWQsXG4gICAgICAgICAgICBoZWxwXG4gICAgICAgIH0pXG4gICAgfVxufSlcblxuXG5jb25zdCBfU3RvcmVGYWxzZUFjdGlvbiA9IF9jYWxsYWJsZShjbGFzcyBfU3RvcmVGYWxzZUFjdGlvbiBleHRlbmRzIF9TdG9yZUNvbnN0QWN0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBsZXQgW1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3MsXG4gICAgICAgICAgICBkZXN0LFxuICAgICAgICAgICAgZGVmYXVsdF92YWx1ZSxcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgICAgaGVscFxuICAgICAgICBdID0gX3BhcnNlX29wdHMoYXJndW1lbnRzLCB7XG4gICAgICAgICAgICBvcHRpb25fc3RyaW5nczogbm9fZGVmYXVsdCxcbiAgICAgICAgICAgIGRlc3Q6IG5vX2RlZmF1bHQsXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaGVscDogdW5kZWZpbmVkXG4gICAgICAgIH0pXG5cbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3MsXG4gICAgICAgICAgICBkZXN0LFxuICAgICAgICAgICAgY29uc3Q6IGZhbHNlLFxuICAgICAgICAgICAgZGVmYXVsdDogZGVmYXVsdF92YWx1ZSxcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgICAgaGVscFxuICAgICAgICB9KVxuICAgIH1cbn0pXG5cblxuY29uc3QgX0FwcGVuZEFjdGlvbiA9IF9jYWxsYWJsZShjbGFzcyBfQXBwZW5kQWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBsZXQgW1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3MsXG4gICAgICAgICAgICBkZXN0LFxuICAgICAgICAgICAgbmFyZ3MsXG4gICAgICAgICAgICBjb25zdF92YWx1ZSxcbiAgICAgICAgICAgIGRlZmF1bHRfdmFsdWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgY2hvaWNlcyxcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgICAgaGVscCxcbiAgICAgICAgICAgIG1ldGF2YXJcbiAgICAgICAgXSA9IF9wYXJzZV9vcHRzKGFyZ3VtZW50cywge1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3M6IG5vX2RlZmF1bHQsXG4gICAgICAgICAgICBkZXN0OiBub19kZWZhdWx0LFxuICAgICAgICAgICAgbmFyZ3M6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNvbnN0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0eXBlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaG9pY2VzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICBoZWxwOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtZXRhdmFyOiB1bmRlZmluZWRcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAobmFyZ3MgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25hcmdzIGZvciBhcHBlbmQgYWN0aW9ucyBtdXN0IGJlICE9IDA7IGlmIGFyZyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdHJpbmdzIGFyZSBub3Qgc3VwcGx5aW5nIHRoZSB2YWx1ZSB0byBhcHBlbmQsICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RoZSBhcHBlbmQgY29uc3QgYWN0aW9uIG1heSBiZSBtb3JlIGFwcHJvcHJpYXRlJylcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RfdmFsdWUgIT09IHVuZGVmaW5lZCAmJiBuYXJncyAhPT0gT1BUSU9OQUwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc3ViKCduYXJncyBtdXN0IGJlICVyIHRvIHN1cHBseSBjb25zdCcsIE9QVElPTkFMKSlcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBvcHRpb25fc3RyaW5ncyxcbiAgICAgICAgICAgIGRlc3QsXG4gICAgICAgICAgICBuYXJncyxcbiAgICAgICAgICAgIGNvbnN0OiBjb25zdF92YWx1ZSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGRlZmF1bHRfdmFsdWUsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgY2hvaWNlcyxcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgICAgaGVscCxcbiAgICAgICAgICAgIG1ldGF2YXJcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBjYWxsKHBhcnNlciwgbmFtZXNwYWNlLCB2YWx1ZXMvKiwgb3B0aW9uX3N0cmluZyA9IHVuZGVmaW5lZCovKSB7XG4gICAgICAgIGxldCBpdGVtcyA9IGdldGF0dHIobmFtZXNwYWNlLCB0aGlzLmRlc3QsIHVuZGVmaW5lZClcbiAgICAgICAgaXRlbXMgPSBfY29weV9pdGVtcyhpdGVtcylcbiAgICAgICAgaXRlbXMucHVzaCh2YWx1ZXMpXG4gICAgICAgIHNldGF0dHIobmFtZXNwYWNlLCB0aGlzLmRlc3QsIGl0ZW1zKVxuICAgIH1cbn0pXG5cblxuY29uc3QgX0FwcGVuZENvbnN0QWN0aW9uID0gX2NhbGxhYmxlKGNsYXNzIF9BcHBlbmRDb25zdEFjdGlvbiBleHRlbmRzIEFjdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbGV0IFtcbiAgICAgICAgICAgIG9wdGlvbl9zdHJpbmdzLFxuICAgICAgICAgICAgZGVzdCxcbiAgICAgICAgICAgIGNvbnN0X3ZhbHVlLFxuICAgICAgICAgICAgZGVmYXVsdF92YWx1ZSxcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgICAgaGVscCxcbiAgICAgICAgICAgIG1ldGF2YXJcbiAgICAgICAgXSA9IF9wYXJzZV9vcHRzKGFyZ3VtZW50cywge1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3M6IG5vX2RlZmF1bHQsXG4gICAgICAgICAgICBkZXN0OiBub19kZWZhdWx0LFxuICAgICAgICAgICAgY29uc3Q6IG5vX2RlZmF1bHQsXG4gICAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICBoZWxwOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtZXRhdmFyOiB1bmRlZmluZWRcbiAgICAgICAgfSlcblxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBvcHRpb25fc3RyaW5ncyxcbiAgICAgICAgICAgIGRlc3QsXG4gICAgICAgICAgICBuYXJnczogMCxcbiAgICAgICAgICAgIGNvbnN0OiBjb25zdF92YWx1ZSxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGRlZmF1bHRfdmFsdWUsXG4gICAgICAgICAgICByZXF1aXJlZCxcbiAgICAgICAgICAgIGhlbHAsXG4gICAgICAgICAgICBtZXRhdmFyXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgY2FsbChwYXJzZXIsIG5hbWVzcGFjZS8qLCB2YWx1ZXMsIG9wdGlvbl9zdHJpbmcgPSB1bmRlZmluZWQqLykge1xuICAgICAgICBsZXQgaXRlbXMgPSBnZXRhdHRyKG5hbWVzcGFjZSwgdGhpcy5kZXN0LCB1bmRlZmluZWQpXG4gICAgICAgIGl0ZW1zID0gX2NvcHlfaXRlbXMoaXRlbXMpXG4gICAgICAgIGl0ZW1zLnB1c2godGhpcy5jb25zdClcbiAgICAgICAgc2V0YXR0cihuYW1lc3BhY2UsIHRoaXMuZGVzdCwgaXRlbXMpXG4gICAgfVxufSlcblxuXG5jb25zdCBfQ291bnRBY3Rpb24gPSBfY2FsbGFibGUoY2xhc3MgX0NvdW50QWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBsZXQgW1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3MsXG4gICAgICAgICAgICBkZXN0LFxuICAgICAgICAgICAgZGVmYXVsdF92YWx1ZSxcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgICAgaGVscFxuICAgICAgICBdID0gX3BhcnNlX29wdHMoYXJndW1lbnRzLCB7XG4gICAgICAgICAgICBvcHRpb25fc3RyaW5nczogbm9fZGVmYXVsdCxcbiAgICAgICAgICAgIGRlc3Q6IG5vX2RlZmF1bHQsXG4gICAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICBoZWxwOiB1bmRlZmluZWRcbiAgICAgICAgfSlcblxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBvcHRpb25fc3RyaW5ncyxcbiAgICAgICAgICAgIGRlc3QsXG4gICAgICAgICAgICBuYXJnczogMCxcbiAgICAgICAgICAgIGRlZmF1bHQ6IGRlZmF1bHRfdmFsdWUsXG4gICAgICAgICAgICByZXF1aXJlZCxcbiAgICAgICAgICAgIGhlbHBcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBjYWxsKHBhcnNlciwgbmFtZXNwYWNlLyosIHZhbHVlcywgb3B0aW9uX3N0cmluZyA9IHVuZGVmaW5lZCovKSB7XG4gICAgICAgIGxldCBjb3VudCA9IGdldGF0dHIobmFtZXNwYWNlLCB0aGlzLmRlc3QsIHVuZGVmaW5lZClcbiAgICAgICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvdW50ID0gMFxuICAgICAgICB9XG4gICAgICAgIHNldGF0dHIobmFtZXNwYWNlLCB0aGlzLmRlc3QsIGNvdW50ICsgMSlcbiAgICB9XG59KVxuXG5cbmNvbnN0IF9IZWxwQWN0aW9uID0gX2NhbGxhYmxlKGNsYXNzIF9IZWxwQWN0aW9uIGV4dGVuZHMgQWN0aW9uIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBsZXQgW1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3MsXG4gICAgICAgICAgICBkZXN0LFxuICAgICAgICAgICAgZGVmYXVsdF92YWx1ZSxcbiAgICAgICAgICAgIGhlbHBcbiAgICAgICAgXSA9IF9wYXJzZV9vcHRzKGFyZ3VtZW50cywge1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3M6IG5vX2RlZmF1bHQsXG4gICAgICAgICAgICBkZXN0OiBTVVBQUkVTUyxcbiAgICAgICAgICAgIGRlZmF1bHQ6IFNVUFBSRVNTLFxuICAgICAgICAgICAgaGVscDogdW5kZWZpbmVkXG4gICAgICAgIH0pXG5cbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3MsXG4gICAgICAgICAgICBkZXN0LFxuICAgICAgICAgICAgZGVmYXVsdDogZGVmYXVsdF92YWx1ZSxcbiAgICAgICAgICAgIG5hcmdzOiAwLFxuICAgICAgICAgICAgaGVscFxuICAgICAgICB9KVxuICAgIH1cblxuICAgIGNhbGwocGFyc2VyLyosIG5hbWVzcGFjZSwgdmFsdWVzLCBvcHRpb25fc3RyaW5nID0gdW5kZWZpbmVkKi8pIHtcbiAgICAgICAgcGFyc2VyLnByaW50X2hlbHAoKVxuICAgICAgICBwYXJzZXIuZXhpdCgpXG4gICAgfVxufSlcblxuXG5jb25zdCBfVmVyc2lvbkFjdGlvbiA9IF9jYWxsYWJsZShjbGFzcyBfVmVyc2lvbkFjdGlvbiBleHRlbmRzIEFjdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbGV0IFtcbiAgICAgICAgICAgIG9wdGlvbl9zdHJpbmdzLFxuICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgIGRlc3QsXG4gICAgICAgICAgICBkZWZhdWx0X3ZhbHVlLFxuICAgICAgICAgICAgaGVscFxuICAgICAgICBdID0gX3BhcnNlX29wdHMoYXJndW1lbnRzLCB7XG4gICAgICAgICAgICBvcHRpb25fc3RyaW5nczogbm9fZGVmYXVsdCxcbiAgICAgICAgICAgIHZlcnNpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGRlc3Q6IFNVUFBSRVNTLFxuICAgICAgICAgICAgZGVmYXVsdDogU1VQUFJFU1MsXG4gICAgICAgICAgICBoZWxwOiBcInNob3cgcHJvZ3JhbSdzIHZlcnNpb24gbnVtYmVyIGFuZCBleGl0XCJcbiAgICAgICAgfSlcblxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBvcHRpb25fc3RyaW5ncyxcbiAgICAgICAgICAgIGRlc3QsXG4gICAgICAgICAgICBkZWZhdWx0OiBkZWZhdWx0X3ZhbHVlLFxuICAgICAgICAgICAgbmFyZ3M6IDAsXG4gICAgICAgICAgICBoZWxwXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb25cbiAgICB9XG5cbiAgICBjYWxsKHBhcnNlci8qLCBuYW1lc3BhY2UsIHZhbHVlcywgb3B0aW9uX3N0cmluZyA9IHVuZGVmaW5lZCovKSB7XG4gICAgICAgIGxldCB2ZXJzaW9uID0gdGhpcy52ZXJzaW9uXG4gICAgICAgIGlmICh2ZXJzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZlcnNpb24gPSBwYXJzZXIudmVyc2lvblxuICAgICAgICB9XG4gICAgICAgIGxldCBmb3JtYXR0ZXIgPSBwYXJzZXIuX2dldF9mb3JtYXR0ZXIoKVxuICAgICAgICBmb3JtYXR0ZXIuYWRkX3RleHQodmVyc2lvbilcbiAgICAgICAgcGFyc2VyLl9wcmludF9tZXNzYWdlKGZvcm1hdHRlci5mb3JtYXRfaGVscCgpLCBwcm9jZXNzLnN0ZG91dClcbiAgICAgICAgcGFyc2VyLmV4aXQoKVxuICAgIH1cbn0pXG5cblxuY29uc3QgX1N1YlBhcnNlcnNBY3Rpb24gPSBfY2FtZWxjYXNlX2FsaWFzKF9jYWxsYWJsZShjbGFzcyBfU3ViUGFyc2Vyc0FjdGlvbiBleHRlbmRzIEFjdGlvbiB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbGV0IFtcbiAgICAgICAgICAgIG9wdGlvbl9zdHJpbmdzLFxuICAgICAgICAgICAgcHJvZyxcbiAgICAgICAgICAgIHBhcnNlcl9jbGFzcyxcbiAgICAgICAgICAgIGRlc3QsXG4gICAgICAgICAgICByZXF1aXJlZCxcbiAgICAgICAgICAgIGhlbHAsXG4gICAgICAgICAgICBtZXRhdmFyXG4gICAgICAgIF0gPSBfcGFyc2Vfb3B0cyhhcmd1bWVudHMsIHtcbiAgICAgICAgICAgIG9wdGlvbl9zdHJpbmdzOiBub19kZWZhdWx0LFxuICAgICAgICAgICAgcHJvZzogbm9fZGVmYXVsdCxcbiAgICAgICAgICAgIHBhcnNlcl9jbGFzczogbm9fZGVmYXVsdCxcbiAgICAgICAgICAgIGRlc3Q6IFNVUFBSRVNTLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaGVscDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWV0YXZhcjogdW5kZWZpbmVkXG4gICAgICAgIH0pXG5cbiAgICAgICAgbGV0IG5hbWVfcGFyc2VyX21hcCA9IHt9XG5cbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3MsXG4gICAgICAgICAgICBkZXN0LFxuICAgICAgICAgICAgbmFyZ3M6IFBBUlNFUixcbiAgICAgICAgICAgIGNob2ljZXM6IG5hbWVfcGFyc2VyX21hcCxcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgICAgaGVscCxcbiAgICAgICAgICAgIG1ldGF2YXJcbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLl9wcm9nX3ByZWZpeCA9IHByb2dcbiAgICAgICAgdGhpcy5fcGFyc2VyX2NsYXNzID0gcGFyc2VyX2NsYXNzXG4gICAgICAgIHRoaXMuX25hbWVfcGFyc2VyX21hcCA9IG5hbWVfcGFyc2VyX21hcFxuICAgICAgICB0aGlzLl9jaG9pY2VzX2FjdGlvbnMgPSBbXVxuICAgIH1cblxuICAgIGFkZF9wYXJzZXIoKSB7XG4gICAgICAgIGxldCBbXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAga3dhcmdzXG4gICAgICAgIF0gPSBfcGFyc2Vfb3B0cyhhcmd1bWVudHMsIHtcbiAgICAgICAgICAgIG5hbWU6IG5vX2RlZmF1bHQsXG4gICAgICAgICAgICAnKiprd2FyZ3MnOiBub19kZWZhdWx0XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gc2V0IHByb2cgZnJvbSB0aGUgZXhpc3RpbmcgcHJlZml4XG4gICAgICAgIGlmIChrd2FyZ3MucHJvZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBrd2FyZ3MucHJvZyA9IHN1YignJXMgJXMnLCB0aGlzLl9wcm9nX3ByZWZpeCwgbmFtZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhbGlhc2VzID0gZ2V0YXR0cihrd2FyZ3MsICdhbGlhc2VzJywgW10pXG4gICAgICAgIGRlbGV0ZSBrd2FyZ3MuYWxpYXNlc1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIHBzZXVkby1hY3Rpb24gdG8gaG9sZCB0aGUgY2hvaWNlIGhlbHBcbiAgICAgICAgaWYgKCdoZWxwJyBpbiBrd2FyZ3MpIHtcbiAgICAgICAgICAgIGxldCBoZWxwID0ga3dhcmdzLmhlbHBcbiAgICAgICAgICAgIGRlbGV0ZSBrd2FyZ3MuaGVscFxuICAgICAgICAgICAgbGV0IGNob2ljZV9hY3Rpb24gPSB0aGlzLl9DaG9pY2VzUHNldWRvQWN0aW9uKG5hbWUsIGFsaWFzZXMsIGhlbHApXG4gICAgICAgICAgICB0aGlzLl9jaG9pY2VzX2FjdGlvbnMucHVzaChjaG9pY2VfYWN0aW9uKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBwYXJzZXIgYW5kIGFkZCBpdCB0byB0aGUgbWFwXG4gICAgICAgIGxldCBwYXJzZXIgPSBuZXcgdGhpcy5fcGFyc2VyX2NsYXNzKGt3YXJncylcbiAgICAgICAgdGhpcy5fbmFtZV9wYXJzZXJfbWFwW25hbWVdID0gcGFyc2VyXG5cbiAgICAgICAgLy8gbWFrZSBwYXJzZXIgYXZhaWxhYmxlIHVuZGVyIGFsaWFzZXMgYWxzb1xuICAgICAgICBmb3IgKGxldCBhbGlhcyBvZiBhbGlhc2VzKSB7XG4gICAgICAgICAgICB0aGlzLl9uYW1lX3BhcnNlcl9tYXBbYWxpYXNdID0gcGFyc2VyXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGFyc2VyXG4gICAgfVxuXG4gICAgX2dldF9zdWJhY3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hvaWNlc19hY3Rpb25zXG4gICAgfVxuXG4gICAgY2FsbChwYXJzZXIsIG5hbWVzcGFjZSwgdmFsdWVzLyosIG9wdGlvbl9zdHJpbmcgPSB1bmRlZmluZWQqLykge1xuICAgICAgICBsZXQgcGFyc2VyX25hbWUgPSB2YWx1ZXNbMF1cbiAgICAgICAgbGV0IGFyZ19zdHJpbmdzID0gdmFsdWVzLnNsaWNlKDEpXG5cbiAgICAgICAgLy8gc2V0IHRoZSBwYXJzZXIgbmFtZSBpZiByZXF1ZXN0ZWRcbiAgICAgICAgaWYgKHRoaXMuZGVzdCAhPT0gU1VQUFJFU1MpIHtcbiAgICAgICAgICAgIHNldGF0dHIobmFtZXNwYWNlLCB0aGlzLmRlc3QsIHBhcnNlcl9uYW1lKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VsZWN0IHRoZSBwYXJzZXJcbiAgICAgICAgaWYgKGhhc2F0dHIodGhpcy5fbmFtZV9wYXJzZXJfbWFwLCBwYXJzZXJfbmFtZSkpIHtcbiAgICAgICAgICAgIHBhcnNlciA9IHRoaXMuX25hbWVfcGFyc2VyX21hcFtwYXJzZXJfbmFtZV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBhcmdzID0ge3BhcnNlcl9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hvaWNlczogdGhpcy5fbmFtZV9wYXJzZXJfbWFwLmpvaW4oJywgJyl9XG4gICAgICAgICAgICBsZXQgbXNnID0gc3ViKCd1bmtub3duIHBhcnNlciAlKHBhcnNlcl9uYW1lKXIgKGNob2ljZXM6ICUoY2hvaWNlcylzKScsIGFyZ3MpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFcnJvcih0aGlzLCBtc2cpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBwYXJzZSBhbGwgdGhlIHJlbWFpbmluZyBvcHRpb25zIGludG8gdGhlIG5hbWVzcGFjZVxuICAgICAgICAvLyBzdG9yZSBhbnkgdW5yZWNvZ25pemVkIG9wdGlvbnMgb24gdGhlIG9iamVjdCwgc28gdGhhdCB0aGUgdG9wXG4gICAgICAgIC8vIGxldmVsIHBhcnNlciBjYW4gZGVjaWRlIHdoYXQgdG8gZG8gd2l0aCB0aGVtXG5cbiAgICAgICAgLy8gSW4gY2FzZSB0aGlzIHN1YnBhcnNlciBkZWZpbmVzIG5ldyBkZWZhdWx0cywgd2UgcGFyc2UgdGhlbVxuICAgICAgICAvLyBpbiBhIG5ldyBuYW1lc3BhY2Ugb2JqZWN0IGFuZCB0aGVuIHVwZGF0ZSB0aGUgb3JpZ2luYWxcbiAgICAgICAgLy8gbmFtZXNwYWNlIGZvciB0aGUgcmVsZXZhbnQgcGFydHMuXG4gICAgICAgIGxldCBzdWJuYW1lc3BhY2VcbiAgICAgICAgWyBzdWJuYW1lc3BhY2UsIGFyZ19zdHJpbmdzIF0gPSBwYXJzZXIucGFyc2Vfa25vd25fYXJncyhhcmdfc3RyaW5ncywgdW5kZWZpbmVkKVxuICAgICAgICBmb3IgKGxldCBbIGtleSwgdmFsdWUgXSBvZiBPYmplY3QuZW50cmllcyhzdWJuYW1lc3BhY2UpKSB7XG4gICAgICAgICAgICBzZXRhdHRyKG5hbWVzcGFjZSwga2V5LCB2YWx1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdfc3RyaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNldGRlZmF1bHQobmFtZXNwYWNlLCBfVU5SRUNPR05JWkVEX0FSR1NfQVRUUiwgW10pXG4gICAgICAgICAgICBnZXRhdHRyKG5hbWVzcGFjZSwgX1VOUkVDT0dOSVpFRF9BUkdTX0FUVFIpLnB1c2goLi4uYXJnX3N0cmluZ3MpXG4gICAgICAgIH1cbiAgICB9XG59KSlcblxuXG5fU3ViUGFyc2Vyc0FjdGlvbi5wcm90b3R5cGUuX0Nob2ljZXNQc2V1ZG9BY3Rpb24gPSBfY2FsbGFibGUoY2xhc3MgX0Nob2ljZXNQc2V1ZG9BY3Rpb24gZXh0ZW5kcyBBY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGFsaWFzZXMsIGhlbHApIHtcbiAgICAgICAgbGV0IG1ldGF2YXIgPSBuYW1lLCBkZXN0ID0gbmFtZVxuICAgICAgICBpZiAoYWxpYXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1ldGF2YXIgKz0gc3ViKCcgKCVzKScsIGFsaWFzZXMuam9pbignLCAnKSlcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih7IG9wdGlvbl9zdHJpbmdzOiBbXSwgZGVzdCwgaGVscCwgbWV0YXZhciB9KVxuICAgIH1cbn0pXG5cblxuY29uc3QgX0V4dGVuZEFjdGlvbiA9IF9jYWxsYWJsZShjbGFzcyBfRXh0ZW5kQWN0aW9uIGV4dGVuZHMgX0FwcGVuZEFjdGlvbiB7XG4gICAgY2FsbChwYXJzZXIsIG5hbWVzcGFjZSwgdmFsdWVzLyosIG9wdGlvbl9zdHJpbmcgPSB1bmRlZmluZWQqLykge1xuICAgICAgICBsZXQgaXRlbXMgPSBnZXRhdHRyKG5hbWVzcGFjZSwgdGhpcy5kZXN0LCB1bmRlZmluZWQpXG4gICAgICAgIGl0ZW1zID0gX2NvcHlfaXRlbXMoaXRlbXMpXG4gICAgICAgIGl0ZW1zID0gaXRlbXMuY29uY2F0KHZhbHVlcylcbiAgICAgICAgc2V0YXR0cihuYW1lc3BhY2UsIHRoaXMuZGVzdCwgaXRlbXMpXG4gICAgfVxufSlcblxuXG4vLyA9PT09PT09PT09PT09PVxuLy8gVHlwZSBjbGFzc2VzXG4vLyA9PT09PT09PT09PT09PVxuY29uc3QgRmlsZVR5cGUgPSBfY2FsbGFibGUoY2xhc3MgRmlsZVR5cGUgZXh0ZW5kcyBGdW5jdGlvbiB7XG4gICAgLypcbiAgICAgKiAgRmFjdG9yeSBmb3IgY3JlYXRpbmcgZmlsZSBvYmplY3QgdHlwZXNcbiAgICAgKlxuICAgICAqICBJbnN0YW5jZXMgb2YgRmlsZVR5cGUgYXJlIHR5cGljYWxseSBwYXNzZWQgYXMgdHlwZT0gYXJndW1lbnRzIHRvIHRoZVxuICAgICAqICBBcmd1bWVudFBhcnNlciBhZGRfYXJndW1lbnQoKSBtZXRob2QuXG4gICAgICpcbiAgICAgKiAgS2V5d29yZCBBcmd1bWVudHM6XG4gICAgICogICAgICAtIG1vZGUgLS0gQSBzdHJpbmcgaW5kaWNhdGluZyBob3cgdGhlIGZpbGUgaXMgdG8gYmUgb3BlbmVkLiBBY2NlcHRzIHRoZVxuICAgICAqICAgICAgICAgIHNhbWUgdmFsdWVzIGFzIHRoZSBidWlsdGluIG9wZW4oKSBmdW5jdGlvbi5cbiAgICAgKiAgICAgIC0gYnVmc2l6ZSAtLSBUaGUgZmlsZSdzIGRlc2lyZWQgYnVmZmVyIHNpemUuIEFjY2VwdHMgdGhlIHNhbWUgdmFsdWVzIGFzXG4gICAgICogICAgICAgICAgdGhlIGJ1aWx0aW4gb3BlbigpIGZ1bmN0aW9uLlxuICAgICAqICAgICAgLSBlbmNvZGluZyAtLSBUaGUgZmlsZSdzIGVuY29kaW5nLiBBY2NlcHRzIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGVcbiAgICAgKiAgICAgICAgICBidWlsdGluIG9wZW4oKSBmdW5jdGlvbi5cbiAgICAgKiAgICAgIC0gZXJyb3JzIC0tIEEgc3RyaW5nIGluZGljYXRpbmcgaG93IGVuY29kaW5nIGFuZCBkZWNvZGluZyBlcnJvcnMgYXJlIHRvXG4gICAgICogICAgICAgICAgYmUgaGFuZGxlZC4gQWNjZXB0cyB0aGUgc2FtZSB2YWx1ZSBhcyB0aGUgYnVpbHRpbiBvcGVuKCkgZnVuY3Rpb24uXG4gICAgICovXG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbGV0IFtcbiAgICAgICAgICAgIGZsYWdzLFxuICAgICAgICAgICAgZW5jb2RpbmcsXG4gICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgYXV0b0Nsb3NlLFxuICAgICAgICAgICAgZW1pdENsb3NlLFxuICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICBoaWdoV2F0ZXJNYXJrLFxuICAgICAgICAgICAgZnNcbiAgICAgICAgXSA9IF9wYXJzZV9vcHRzKGFyZ3VtZW50cywge1xuICAgICAgICAgICAgZmxhZ3M6ICdyJyxcbiAgICAgICAgICAgIGVuY29kaW5nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBtb2RlOiB1bmRlZmluZWQsIC8vIDBvNjY2XG4gICAgICAgICAgICBhdXRvQ2xvc2U6IHVuZGVmaW5lZCwgLy8gdHJ1ZVxuICAgICAgICAgICAgZW1pdENsb3NlOiB1bmRlZmluZWQsIC8vIGZhbHNlXG4gICAgICAgICAgICBzdGFydDogdW5kZWZpbmVkLCAvLyAwXG4gICAgICAgICAgICBlbmQ6IHVuZGVmaW5lZCwgLy8gSW5maW5pdHlcbiAgICAgICAgICAgIGhpZ2hXYXRlck1hcms6IHVuZGVmaW5lZCwgLy8gNjQgKiAxMDI0XG4gICAgICAgICAgICBmczogdW5kZWZpbmVkXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gd2hlbiB0aGlzIGNsYXNzIGlzIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLCByZWRpcmVjdCBpdCB0byAuY2FsbCgpIG1ldGhvZCBvZiBpdHNlbGZcbiAgICAgICAgc3VwZXIoJ3JldHVybiBhcmd1bWVudHMuY2FsbGVlLmNhbGwuYXBwbHkoYXJndW1lbnRzLmNhbGxlZSwgYXJndW1lbnRzKScpXG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYW1lJywge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdWIoJ0ZpbGVUeXBlKCVyKScsIGZsYWdzKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICB0aGlzLl9mbGFncyA9IGZsYWdzXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7fVxuICAgICAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkgdGhpcy5fb3B0aW9ucy5lbmNvZGluZyA9IGVuY29kaW5nXG4gICAgICAgIGlmIChtb2RlICE9PSB1bmRlZmluZWQpIHRoaXMuX29wdGlvbnMubW9kZSA9IG1vZGVcbiAgICAgICAgaWYgKGF1dG9DbG9zZSAhPT0gdW5kZWZpbmVkKSB0aGlzLl9vcHRpb25zLmF1dG9DbG9zZSA9IGF1dG9DbG9zZVxuICAgICAgICBpZiAoZW1pdENsb3NlICE9PSB1bmRlZmluZWQpIHRoaXMuX29wdGlvbnMuZW1pdENsb3NlID0gZW1pdENsb3NlXG4gICAgICAgIGlmIChzdGFydCAhPT0gdW5kZWZpbmVkKSB0aGlzLl9vcHRpb25zLnN0YXJ0ID0gc3RhcnRcbiAgICAgICAgaWYgKGVuZCAhPT0gdW5kZWZpbmVkKSB0aGlzLl9vcHRpb25zLmVuZCA9IGVuZFxuICAgICAgICBpZiAoaGlnaFdhdGVyTWFyayAhPT0gdW5kZWZpbmVkKSB0aGlzLl9vcHRpb25zLmhpZ2hXYXRlck1hcmsgPSBoaWdoV2F0ZXJNYXJrXG4gICAgICAgIGlmIChmcyAhPT0gdW5kZWZpbmVkKSB0aGlzLl9vcHRpb25zLmZzID0gZnNcbiAgICB9XG5cbiAgICBjYWxsKHN0cmluZykge1xuICAgICAgICAvLyB0aGUgc3BlY2lhbCBhcmd1bWVudCBcIi1cIiBtZWFucyBzeXMuc3Rke2luLG91dH1cbiAgICAgICAgaWYgKHN0cmluZyA9PT0gJy0nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZmxhZ3MuaW5jbHVkZXMoJ3InKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzLnN0ZGluXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmluY2x1ZGVzKCd3JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5zdGRvdXRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1zZyA9IHN1YignYXJndW1lbnQgXCItXCIgd2l0aCBtb2RlICVyJywgdGhpcy5fZmxhZ3MpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2cpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbGwgb3RoZXIgYXJndW1lbnRzIGFyZSB1c2VkIGFzIGZpbGUgbmFtZXNcbiAgICAgICAgbGV0IGZkXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmZCA9IGZzLm9wZW5TeW5jKHN0cmluZywgdGhpcy5fZmxhZ3MsIHRoaXMuX29wdGlvbnMubW9kZSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGV0IGFyZ3MgPSB7IGZpbGVuYW1lOiBzdHJpbmcsIGVycm9yOiBlLm1lc3NhZ2UgfVxuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBcImNhbid0IG9wZW4gJyUoZmlsZW5hbWUpcyc6ICUoZXJyb3Ipc1wiXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRUeXBlRXJyb3Ioc3ViKG1lc3NhZ2UsIGFyZ3MpKVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgZmQsIGZsYWdzOiB0aGlzLl9mbGFncyB9LCB0aGlzLl9vcHRpb25zKVxuICAgICAgICBpZiAodGhpcy5fZmxhZ3MuaW5jbHVkZXMoJ3InKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZzLmNyZWF0ZVJlYWRTdHJlYW0odW5kZWZpbmVkLCBvcHRpb25zKVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2ZsYWdzLmluY2x1ZGVzKCd3JykpIHtcbiAgICAgICAgICAgIHJldHVybiBmcy5jcmVhdGVXcml0ZVN0cmVhbSh1bmRlZmluZWQsIG9wdGlvbnMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbXNnID0gc3ViKCdhcmd1bWVudCBcIiVzXCIgd2l0aCBtb2RlICVyJywgc3RyaW5nLCB0aGlzLl9mbGFncylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobXNnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgW3V0aWwuaW5zcGVjdC5jdXN0b21dKCkge1xuICAgICAgICBsZXQgYXJncyA9IFsgdGhpcy5fZmxhZ3MgXVxuICAgICAgICBsZXQga3dhcmdzID0gT2JqZWN0LmVudHJpZXModGhpcy5fb3B0aW9ucykubWFwKChbIGssIHYgXSkgPT4ge1xuICAgICAgICAgICAgaWYgKGsgPT09ICdtb2RlJykgdiA9IHsgdmFsdWU6IHYsIFt1dGlsLmluc3BlY3QuY3VzdG9tXSgpIHsgcmV0dXJuICcwbycgKyB0aGlzLnZhbHVlLnRvU3RyaW5nKDgpIH0gfVxuICAgICAgICAgICAgcmV0dXJuIFsgaywgdiBdXG4gICAgICAgIH0pXG4gICAgICAgIGxldCBhcmdzX3N0ciA9IFtdXG4gICAgICAgICAgICAgICAgLmNvbmNhdChhcmdzLmZpbHRlcihhcmcgPT4gYXJnICE9PSAtMSkubWFwKHJlcHIpKVxuICAgICAgICAgICAgICAgIC5jb25jYXQoa3dhcmdzLmZpbHRlcigoWy8qa3cqLywgYXJnXSkgPT4gYXJnICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKFtrdywgYXJnXSkgPT4gc3ViKCclcz0lcicsIGt3LCBhcmcpKSlcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKVxuICAgICAgICByZXR1cm4gc3ViKCclcyglcyknLCB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIGFyZ3Nfc3RyKVxuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t1dGlsLmluc3BlY3QuY3VzdG9tXSgpXG4gICAgfVxufSlcblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBPcHRpb25hbCBhbmQgUG9zaXRpb25hbCBQYXJzaW5nXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IE5hbWVzcGFjZSA9IF9jYWxsYWJsZShjbGFzcyBOYW1lc3BhY2UgZXh0ZW5kcyBfQXR0cmlidXRlSG9sZGVyKCkge1xuICAgIC8qXG4gICAgICogIFNpbXBsZSBvYmplY3QgZm9yIHN0b3JpbmcgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqICBJbXBsZW1lbnRzIGVxdWFsaXR5IGJ5IGF0dHJpYnV0ZSBuYW1lcyBhbmQgdmFsdWVzLCBhbmQgcHJvdmlkZXMgYSBzaW1wbGVcbiAgICAgKiAgc3RyaW5nIHJlcHJlc2VudGF0aW9uLlxuICAgICAqL1xuXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zKVxuICAgIH1cbn0pXG5cbi8vIHVuc2V0IHN0cmluZyB0YWcgdG8gbWltaWMgcGxhaW4gb2JqZWN0XG5OYW1lc3BhY2UucHJvdG90eXBlW1N5bWJvbC50b1N0cmluZ1RhZ10gPSB1bmRlZmluZWRcblxuXG5jb25zdCBfQWN0aW9uc0NvbnRhaW5lciA9IF9jYW1lbGNhc2VfYWxpYXMoX2NhbGxhYmxlKGNsYXNzIF9BY3Rpb25zQ29udGFpbmVyIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBsZXQgW1xuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBwcmVmaXhfY2hhcnMsXG4gICAgICAgICAgICBhcmd1bWVudF9kZWZhdWx0LFxuICAgICAgICAgICAgY29uZmxpY3RfaGFuZGxlclxuICAgICAgICBdID0gX3BhcnNlX29wdHMoYXJndW1lbnRzLCB7XG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogbm9fZGVmYXVsdCxcbiAgICAgICAgICAgIHByZWZpeF9jaGFyczogbm9fZGVmYXVsdCxcbiAgICAgICAgICAgIGFyZ3VtZW50X2RlZmF1bHQ6IG5vX2RlZmF1bHQsXG4gICAgICAgICAgICBjb25mbGljdF9oYW5kbGVyOiBub19kZWZhdWx0XG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uXG4gICAgICAgIHRoaXMuYXJndW1lbnRfZGVmYXVsdCA9IGFyZ3VtZW50X2RlZmF1bHRcbiAgICAgICAgdGhpcy5wcmVmaXhfY2hhcnMgPSBwcmVmaXhfY2hhcnNcbiAgICAgICAgdGhpcy5jb25mbGljdF9oYW5kbGVyID0gY29uZmxpY3RfaGFuZGxlclxuXG4gICAgICAgIC8vIHNldCB1cCByZWdpc3RyaWVzXG4gICAgICAgIHRoaXMuX3JlZ2lzdHJpZXMgPSB7fVxuXG4gICAgICAgIC8vIHJlZ2lzdGVyIGFjdGlvbnNcbiAgICAgICAgdGhpcy5yZWdpc3RlcignYWN0aW9uJywgdW5kZWZpbmVkLCBfU3RvcmVBY3Rpb24pXG4gICAgICAgIHRoaXMucmVnaXN0ZXIoJ2FjdGlvbicsICdzdG9yZScsIF9TdG9yZUFjdGlvbilcbiAgICAgICAgdGhpcy5yZWdpc3RlcignYWN0aW9uJywgJ3N0b3JlX2NvbnN0JywgX1N0b3JlQ29uc3RBY3Rpb24pXG4gICAgICAgIHRoaXMucmVnaXN0ZXIoJ2FjdGlvbicsICdzdG9yZV90cnVlJywgX1N0b3JlVHJ1ZUFjdGlvbilcbiAgICAgICAgdGhpcy5yZWdpc3RlcignYWN0aW9uJywgJ3N0b3JlX2ZhbHNlJywgX1N0b3JlRmFsc2VBY3Rpb24pXG4gICAgICAgIHRoaXMucmVnaXN0ZXIoJ2FjdGlvbicsICdhcHBlbmQnLCBfQXBwZW5kQWN0aW9uKVxuICAgICAgICB0aGlzLnJlZ2lzdGVyKCdhY3Rpb24nLCAnYXBwZW5kX2NvbnN0JywgX0FwcGVuZENvbnN0QWN0aW9uKVxuICAgICAgICB0aGlzLnJlZ2lzdGVyKCdhY3Rpb24nLCAnY291bnQnLCBfQ291bnRBY3Rpb24pXG4gICAgICAgIHRoaXMucmVnaXN0ZXIoJ2FjdGlvbicsICdoZWxwJywgX0hlbHBBY3Rpb24pXG4gICAgICAgIHRoaXMucmVnaXN0ZXIoJ2FjdGlvbicsICd2ZXJzaW9uJywgX1ZlcnNpb25BY3Rpb24pXG4gICAgICAgIHRoaXMucmVnaXN0ZXIoJ2FjdGlvbicsICdwYXJzZXJzJywgX1N1YlBhcnNlcnNBY3Rpb24pXG4gICAgICAgIHRoaXMucmVnaXN0ZXIoJ2FjdGlvbicsICdleHRlbmQnLCBfRXh0ZW5kQWN0aW9uKVxuICAgICAgICAvLyBMRUdBQ1kgKHYxIGNvbXBhdGliaWxpdHkpOiBjYW1lbGNhc2UgdmFyaWFudHNcbiAgICAgICAgO1sgJ3N0b3JlQ29uc3QnLCAnc3RvcmVUcnVlJywgJ3N0b3JlRmFsc2UnLCAnYXBwZW5kQ29uc3QnIF0uZm9yRWFjaChvbGRfbmFtZSA9PiB7XG4gICAgICAgICAgICBsZXQgbmV3X25hbWUgPSBfdG9fbmV3X25hbWUob2xkX25hbWUpXG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKCdhY3Rpb24nLCBvbGRfbmFtZSwgdXRpbC5kZXByZWNhdGUodGhpcy5fcmVnaXN0cnlfZ2V0KCdhY3Rpb24nLCBuZXdfbmFtZSksXG4gICAgICAgICAgICAgICAgc3ViKCd7YWN0aW9uOiBcIiVzXCJ9IGlzIHJlbmFtZWQgdG8ge2FjdGlvbjogXCIlc1wifScsIG9sZF9uYW1lLCBuZXdfbmFtZSkpKVxuICAgICAgICB9KVxuICAgICAgICAvLyBlbmRcblxuICAgICAgICAvLyByYWlzZSBhbiBleGNlcHRpb24gaWYgdGhlIGNvbmZsaWN0IGhhbmRsZXIgaXMgaW52YWxpZFxuICAgICAgICB0aGlzLl9nZXRfaGFuZGxlcigpXG5cbiAgICAgICAgLy8gYWN0aW9uIHN0b3JhZ2VcbiAgICAgICAgdGhpcy5fYWN0aW9ucyA9IFtdXG4gICAgICAgIHRoaXMuX29wdGlvbl9zdHJpbmdfYWN0aW9ucyA9IHt9XG5cbiAgICAgICAgLy8gZ3JvdXBzXG4gICAgICAgIHRoaXMuX2FjdGlvbl9ncm91cHMgPSBbXVxuICAgICAgICB0aGlzLl9tdXR1YWxseV9leGNsdXNpdmVfZ3JvdXBzID0gW11cblxuICAgICAgICAvLyBkZWZhdWx0cyBzdG9yYWdlXG4gICAgICAgIHRoaXMuX2RlZmF1bHRzID0ge31cblxuICAgICAgICAvLyBkZXRlcm1pbmVzIHdoZXRoZXIgYW4gXCJvcHRpb25cIiBsb29rcyBsaWtlIGEgbmVnYXRpdmUgbnVtYmVyXG4gICAgICAgIHRoaXMuX25lZ2F0aXZlX251bWJlcl9tYXRjaGVyID0gL14tXFxkKyR8Xi1cXGQqXFwuXFxkKyQvXG5cbiAgICAgICAgLy8gd2hldGhlciBvciBub3QgdGhlcmUgYXJlIGFueSBvcHRpb25hbHMgdGhhdCBsb29rIGxpa2UgbmVnYXRpdmVcbiAgICAgICAgLy8gbnVtYmVycyAtLSB1c2VzIGEgbGlzdCBzbyBpdCBjYW4gYmUgc2hhcmVkIGFuZCBlZGl0ZWRcbiAgICAgICAgdGhpcy5faGFzX25lZ2F0aXZlX251bWJlcl9vcHRpb25hbHMgPSBbXVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUmVnaXN0cmF0aW9uIG1ldGhvZHNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PVxuICAgIHJlZ2lzdGVyKHJlZ2lzdHJ5X25hbWUsIHZhbHVlLCBvYmplY3QpIHtcbiAgICAgICAgbGV0IHJlZ2lzdHJ5ID0gc2V0ZGVmYXVsdCh0aGlzLl9yZWdpc3RyaWVzLCByZWdpc3RyeV9uYW1lLCB7fSlcbiAgICAgICAgcmVnaXN0cnlbdmFsdWVdID0gb2JqZWN0XG4gICAgfVxuXG4gICAgX3JlZ2lzdHJ5X2dldChyZWdpc3RyeV9uYW1lLCB2YWx1ZSwgZGVmYXVsdF92YWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZ2V0YXR0cih0aGlzLl9yZWdpc3RyaWVzW3JlZ2lzdHJ5X25hbWVdLCB2YWx1ZSwgZGVmYXVsdF92YWx1ZSlcbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gTmFtZXNwYWNlIGRlZmF1bHQgYWNjZXNzb3IgbWV0aG9kc1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBzZXRfZGVmYXVsdHMoa3dhcmdzKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5fZGVmYXVsdHMsIGt3YXJncylcblxuICAgICAgICAvLyBpZiB0aGVzZSBkZWZhdWx0cyBtYXRjaCBhbnkgZXhpc3RpbmcgYXJndW1lbnRzLCByZXBsYWNlXG4gICAgICAgIC8vIHRoZSBwcmV2aW91cyBkZWZhdWx0IG9uIHRoZSBvYmplY3Qgd2l0aCB0aGUgbmV3IG9uZVxuICAgICAgICBmb3IgKGxldCBhY3Rpb24gb2YgdGhpcy5fYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKGFjdGlvbi5kZXN0IGluIGt3YXJncykge1xuICAgICAgICAgICAgICAgIGFjdGlvbi5kZWZhdWx0ID0ga3dhcmdzW2FjdGlvbi5kZXN0XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0X2RlZmF1bHQoZGVzdCkge1xuICAgICAgICBmb3IgKGxldCBhY3Rpb24gb2YgdGhpcy5fYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKGFjdGlvbi5kZXN0ID09PSBkZXN0ICYmIGFjdGlvbi5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uLmRlZmF1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmYXVsdHNbZGVzdF1cbiAgICB9XG5cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gQWRkaW5nIGFyZ3VtZW50IGFjdGlvbnNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuICAgIGFkZF9hcmd1bWVudCgpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogIGFkZF9hcmd1bWVudChkZXN0LCAuLi4sIG5hbWU9dmFsdWUsIC4uLilcbiAgICAgICAgICogIGFkZF9hcmd1bWVudChvcHRpb25fc3RyaW5nLCBvcHRpb25fc3RyaW5nLCAuLi4sIG5hbWU9dmFsdWUsIC4uLilcbiAgICAgICAgICovXG4gICAgICAgIGxldCBbXG4gICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAga3dhcmdzXG4gICAgICAgIF0gPSBfcGFyc2Vfb3B0cyhhcmd1bWVudHMsIHtcbiAgICAgICAgICAgICcqYXJncyc6IG5vX2RlZmF1bHQsXG4gICAgICAgICAgICAnKiprd2FyZ3MnOiBub19kZWZhdWx0XG4gICAgICAgIH0pXG4gICAgICAgIC8vIExFR0FDWSAodjEgY29tcGF0aWJpbGl0eSksIG9sZC1zdHlsZSBhZGRfYXJndW1lbnQoWyBhcmdzIF0sIHsgb3B0aW9ucyB9KVxuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgICAgYXJncyA9IGFyZ3NbMF1cbiAgICAgICAgICAgIGRlcHJlY2F0ZSgnYXJndW1lbnQtYXJyYXknLFxuICAgICAgICAgICAgICAgIHN1YigndXNlIGFkZF9hcmd1bWVudCglKGFyZ3Mpcywgey4uLn0pIGluc3RlYWQgb2YgYWRkX2FyZ3VtZW50KFsgJShhcmdzKXMgXSwgeyAuLi4gfSknLCB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3MubWFwKHJlcHIpLmpvaW4oJywgJylcbiAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgICAgICAvLyBlbmRcblxuICAgICAgICAvLyBpZiBubyBwb3NpdGlvbmFsIGFyZ3MgYXJlIHN1cHBsaWVkIG9yIG9ubHkgb25lIGlzIHN1cHBsaWVkIGFuZFxuICAgICAgICAvLyBpdCBkb2Vzbid0IGxvb2sgbGlrZSBhbiBvcHRpb24gc3RyaW5nLCBwYXJzZSBhIHBvc2l0aW9uYWxcbiAgICAgICAgLy8gYXJndW1lbnRcbiAgICAgICAgbGV0IGNoYXJzID0gdGhpcy5wcmVmaXhfY2hhcnNcbiAgICAgICAgaWYgKCFhcmdzLmxlbmd0aCB8fCBhcmdzLmxlbmd0aCA9PT0gMSAmJiAhY2hhcnMuaW5jbHVkZXMoYXJnc1swXVswXSkpIHtcbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAmJiAnZGVzdCcgaW4ga3dhcmdzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGVzdCBzdXBwbGllZCB0d2ljZSBmb3IgcG9zaXRpb25hbCBhcmd1bWVudCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrd2FyZ3MgPSB0aGlzLl9nZXRfcG9zaXRpb25hbF9rd2FyZ3MoLi4uYXJncywga3dhcmdzKVxuXG4gICAgICAgIC8vIG90aGVyd2lzZSwgd2UncmUgYWRkaW5nIGFuIG9wdGlvbmFsIGFyZ3VtZW50XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBrd2FyZ3MgPSB0aGlzLl9nZXRfb3B0aW9uYWxfa3dhcmdzKC4uLmFyZ3MsIGt3YXJncylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vIGRlZmF1bHQgd2FzIHN1cHBsaWVkLCB1c2UgdGhlIHBhcnNlci1sZXZlbCBkZWZhdWx0XG4gICAgICAgIGlmICghKCdkZWZhdWx0JyBpbiBrd2FyZ3MpKSB7XG4gICAgICAgICAgICBsZXQgZGVzdCA9IGt3YXJncy5kZXN0XG4gICAgICAgICAgICBpZiAoZGVzdCBpbiB0aGlzLl9kZWZhdWx0cykge1xuICAgICAgICAgICAgICAgIGt3YXJncy5kZWZhdWx0ID0gdGhpcy5fZGVmYXVsdHNbZGVzdF1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5hcmd1bWVudF9kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBrd2FyZ3MuZGVmYXVsdCA9IHRoaXMuYXJndW1lbnRfZGVmYXVsdFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBhY3Rpb24gb2JqZWN0LCBhbmQgYWRkIGl0IHRvIHRoZSBwYXJzZXJcbiAgICAgICAgbGV0IGFjdGlvbl9jbGFzcyA9IHRoaXMuX3BvcF9hY3Rpb25fY2xhc3Moa3dhcmdzKVxuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbl9jbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzdWIoJ3Vua25vd24gYWN0aW9uIFwiJXNcIicsIGFjdGlvbl9jbGFzcykpXG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5ldy1jYXBcbiAgICAgICAgbGV0IGFjdGlvbiA9IG5ldyBhY3Rpb25fY2xhc3Moa3dhcmdzKVxuXG4gICAgICAgIC8vIHJhaXNlIGFuIGVycm9yIGlmIHRoZSBhY3Rpb24gdHlwZSBpcyBub3QgY2FsbGFibGVcbiAgICAgICAgbGV0IHR5cGVfZnVuYyA9IHRoaXMuX3JlZ2lzdHJ5X2dldCgndHlwZScsIGFjdGlvbi50eXBlLCBhY3Rpb24udHlwZSlcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlX2Z1bmMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc3ViKCclciBpcyBub3QgY2FsbGFibGUnLCB0eXBlX2Z1bmMpKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVfZnVuYyA9PT0gRmlsZVR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc3ViKCclciBpcyBhIEZpbGVUeXBlIGNsYXNzIG9iamVjdCwgaW5zdGFuY2Ugb2YgaXQnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgbXVzdCBiZSBwYXNzZWQnLCB0eXBlX2Z1bmMpKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmFpc2UgYW4gZXJyb3IgaWYgdGhlIG1ldGF2YXIgZG9lcyBub3QgbWF0Y2ggdGhlIHR5cGVcbiAgICAgICAgaWYgKCdfZ2V0X2Zvcm1hdHRlcicgaW4gdGhpcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRfZm9ybWF0dGVyKCkuX2Zvcm1hdF9hcmdzKGFjdGlvbiwgdW5kZWZpbmVkKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yICdpbnZhbGlkIG5hcmdzIHZhbHVlJyBpcyBhbiBhcnRpZmFjdCBvZiBUeXBlRXJyb3IgYW5kIFZhbHVlRXJyb3IgaW4ganMgYmVpbmcgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVyci5tZXNzYWdlICE9PSAnaW52YWxpZCBuYXJncyB2YWx1ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGVuZ3RoIG9mIG1ldGF2YXIgdHVwbGUgZG9lcyBub3QgbWF0Y2ggbmFyZ3MnKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVyclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRfYWN0aW9uKGFjdGlvbilcbiAgICB9XG5cbiAgICBhZGRfYXJndW1lbnRfZ3JvdXAoKSB7XG4gICAgICAgIGxldCBncm91cCA9IF9Bcmd1bWVudEdyb3VwKHRoaXMsIC4uLmFyZ3VtZW50cylcbiAgICAgICAgdGhpcy5fYWN0aW9uX2dyb3Vwcy5wdXNoKGdyb3VwKVxuICAgICAgICByZXR1cm4gZ3JvdXBcbiAgICB9XG5cbiAgICBhZGRfbXV0dWFsbHlfZXhjbHVzaXZlX2dyb3VwKCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgbGV0IGdyb3VwID0gX011dHVhbGx5RXhjbHVzaXZlR3JvdXAodGhpcywgLi4uYXJndW1lbnRzKVxuICAgICAgICB0aGlzLl9tdXR1YWxseV9leGNsdXNpdmVfZ3JvdXBzLnB1c2goZ3JvdXApXG4gICAgICAgIHJldHVybiBncm91cFxuICAgIH1cblxuICAgIF9hZGRfYWN0aW9uKGFjdGlvbikge1xuICAgICAgICAvLyByZXNvbHZlIGFueSBjb25mbGljdHNcbiAgICAgICAgdGhpcy5fY2hlY2tfY29uZmxpY3QoYWN0aW9uKVxuXG4gICAgICAgIC8vIGFkZCB0byBhY3Rpb25zIGxpc3RcbiAgICAgICAgdGhpcy5fYWN0aW9ucy5wdXNoKGFjdGlvbilcbiAgICAgICAgYWN0aW9uLmNvbnRhaW5lciA9IHRoaXNcblxuICAgICAgICAvLyBpbmRleCB0aGUgYWN0aW9uIGJ5IGFueSBvcHRpb24gc3RyaW5ncyBpdCBoYXNcbiAgICAgICAgZm9yIChsZXQgb3B0aW9uX3N0cmluZyBvZiBhY3Rpb24ub3B0aW9uX3N0cmluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbl9zdHJpbmdfYWN0aW9uc1tvcHRpb25fc3RyaW5nXSA9IGFjdGlvblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IHRoZSBmbGFnIGlmIGFueSBvcHRpb24gc3RyaW5ncyBsb29rIGxpa2UgbmVnYXRpdmUgbnVtYmVyc1xuICAgICAgICBmb3IgKGxldCBvcHRpb25fc3RyaW5nIG9mIGFjdGlvbi5vcHRpb25fc3RyaW5ncykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25lZ2F0aXZlX251bWJlcl9tYXRjaGVyLnRlc3Qob3B0aW9uX3N0cmluZykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2hhc19uZWdhdGl2ZV9udW1iZXJfb3B0aW9uYWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYXNfbmVnYXRpdmVfbnVtYmVyX29wdGlvbmFscy5wdXNoKHRydWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBjcmVhdGVkIGFjdGlvblxuICAgICAgICByZXR1cm4gYWN0aW9uXG4gICAgfVxuXG4gICAgX3JlbW92ZV9hY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIF9hcnJheV9yZW1vdmUodGhpcy5fYWN0aW9ucywgYWN0aW9uKVxuICAgIH1cblxuICAgIF9hZGRfY29udGFpbmVyX2FjdGlvbnMoY29udGFpbmVyKSB7XG4gICAgICAgIC8vIGNvbGxlY3QgZ3JvdXBzIGJ5IHRpdGxlc1xuICAgICAgICBsZXQgdGl0bGVfZ3JvdXBfbWFwID0ge31cbiAgICAgICAgZm9yIChsZXQgZ3JvdXAgb2YgdGhpcy5fYWN0aW9uX2dyb3Vwcykge1xuICAgICAgICAgICAgaWYgKGdyb3VwLnRpdGxlIGluIHRpdGxlX2dyb3VwX21hcCkge1xuICAgICAgICAgICAgICAgIGxldCBtc2cgPSAnY2Fubm90IG1lcmdlIGFjdGlvbnMgLSB0d28gZ3JvdXBzIGFyZSBuYW1lZCAlcidcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHN1Yihtc2csIGdyb3VwLnRpdGxlKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRpdGxlX2dyb3VwX21hcFtncm91cC50aXRsZV0gPSBncm91cFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFwIGVhY2ggYWN0aW9uIHRvIGl0cyBncm91cFxuICAgICAgICBsZXQgZ3JvdXBfbWFwID0gbmV3IE1hcCgpXG4gICAgICAgIGZvciAobGV0IGdyb3VwIG9mIGNvbnRhaW5lci5fYWN0aW9uX2dyb3Vwcykge1xuXG4gICAgICAgICAgICAvLyBpZiBhIGdyb3VwIHdpdGggdGhlIHRpdGxlIGV4aXN0cywgdXNlIHRoYXQsIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gY3JlYXRlIGEgbmV3IGdyb3VwIG1hdGNoaW5nIHRoZSBjb250YWluZXIncyBncm91cFxuICAgICAgICAgICAgaWYgKCEoZ3JvdXAudGl0bGUgaW4gdGl0bGVfZ3JvdXBfbWFwKSkge1xuICAgICAgICAgICAgICAgIHRpdGxlX2dyb3VwX21hcFtncm91cC50aXRsZV0gPSB0aGlzLmFkZF9hcmd1bWVudF9ncm91cCh7XG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBncm91cC50aXRsZSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGdyb3VwLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBjb25mbGljdF9oYW5kbGVyOiBncm91cC5jb25mbGljdF9oYW5kbGVyXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbWFwIHRoZSBhY3Rpb25zIHRvIHRoZWlyIG5ldyBncm91cFxuICAgICAgICAgICAgZm9yIChsZXQgYWN0aW9uIG9mIGdyb3VwLl9ncm91cF9hY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBfbWFwLnNldChhY3Rpb24sIHRpdGxlX2dyb3VwX21hcFtncm91cC50aXRsZV0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgY29udGFpbmVyJ3MgbXV0dWFsbHkgZXhjbHVzaXZlIGdyb3Vwc1xuICAgICAgICAvLyBOT1RFOiBpZiBhZGRfbXV0dWFsbHlfZXhjbHVzaXZlX2dyb3VwIGV2ZXIgZ2FpbnMgdGl0bGU9IGFuZFxuICAgICAgICAvLyBkZXNjcmlwdGlvbj0gdGhlbiB0aGlzIGNvZGUgd2lsbCBuZWVkIHRvIGJlIGV4cGFuZGVkIGFzIGFib3ZlXG4gICAgICAgIGZvciAobGV0IGdyb3VwIG9mIGNvbnRhaW5lci5fbXV0dWFsbHlfZXhjbHVzaXZlX2dyb3Vwcykge1xuICAgICAgICAgICAgbGV0IG11dGV4X2dyb3VwID0gdGhpcy5hZGRfbXV0dWFsbHlfZXhjbHVzaXZlX2dyb3VwKHtcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogZ3JvdXAucmVxdWlyZWRcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vIG1hcCB0aGUgYWN0aW9ucyB0byB0aGVpciBuZXcgbXV0ZXggZ3JvdXBcbiAgICAgICAgICAgIGZvciAobGV0IGFjdGlvbiBvZiBncm91cC5fZ3JvdXBfYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGdyb3VwX21hcC5zZXQoYWN0aW9uLCBtdXRleF9ncm91cClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBhbGwgYWN0aW9ucyB0byB0aGlzIGNvbnRhaW5lciBvciB0aGVpciBncm91cFxuICAgICAgICBmb3IgKGxldCBhY3Rpb24gb2YgY29udGFpbmVyLl9hY3Rpb25zKSB7XG4gICAgICAgICAgICBncm91cF9tYXAuZ2V0KGFjdGlvbikuX2FkZF9hY3Rpb24oYWN0aW9uKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldF9wb3NpdGlvbmFsX2t3YXJncygpIHtcbiAgICAgICAgbGV0IFtcbiAgICAgICAgICAgIGRlc3QsXG4gICAgICAgICAgICBrd2FyZ3NcbiAgICAgICAgXSA9IF9wYXJzZV9vcHRzKGFyZ3VtZW50cywge1xuICAgICAgICAgICAgZGVzdDogbm9fZGVmYXVsdCxcbiAgICAgICAgICAgICcqKmt3YXJncyc6IG5vX2RlZmF1bHRcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBtYWtlIHN1cmUgcmVxdWlyZWQgaXMgbm90IHNwZWNpZmllZFxuICAgICAgICBpZiAoJ3JlcXVpcmVkJyBpbiBrd2FyZ3MpIHtcbiAgICAgICAgICAgIGxldCBtc2cgPSBcIidyZXF1aXJlZCcgaXMgYW4gaW52YWxpZCBhcmd1bWVudCBmb3IgcG9zaXRpb25hbHNcIlxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2cpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYXJrIHBvc2l0aW9uYWwgYXJndW1lbnRzIGFzIHJlcXVpcmVkIGlmIGF0IGxlYXN0IG9uZSBpc1xuICAgICAgICAvLyBhbHdheXMgcmVxdWlyZWRcbiAgICAgICAgaWYgKCFbT1BUSU9OQUwsIFpFUk9fT1JfTU9SRV0uaW5jbHVkZXMoa3dhcmdzLm5hcmdzKSkge1xuICAgICAgICAgICAga3dhcmdzLnJlcXVpcmVkID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChrd2FyZ3MubmFyZ3MgPT09IFpFUk9fT1JfTU9SRSAmJiAhKCdkZWZhdWx0JyBpbiBrd2FyZ3MpKSB7XG4gICAgICAgICAgICBrd2FyZ3MucmVxdWlyZWQgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gdGhlIGtleXdvcmQgYXJndW1lbnRzIHdpdGggbm8gb3B0aW9uIHN0cmluZ3NcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oa3dhcmdzLCB7IGRlc3QsIG9wdGlvbl9zdHJpbmdzOiBbXSB9KVxuICAgIH1cblxuICAgIF9nZXRfb3B0aW9uYWxfa3dhcmdzKCkge1xuICAgICAgICBsZXQgW1xuICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgIGt3YXJnc1xuICAgICAgICBdID0gX3BhcnNlX29wdHMoYXJndW1lbnRzLCB7XG4gICAgICAgICAgICAnKmFyZ3MnOiBub19kZWZhdWx0LFxuICAgICAgICAgICAgJyoqa3dhcmdzJzogbm9fZGVmYXVsdFxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIGRldGVybWluZSBzaG9ydCBhbmQgbG9uZyBvcHRpb24gc3RyaW5nc1xuICAgICAgICBsZXQgb3B0aW9uX3N0cmluZ3MgPSBbXVxuICAgICAgICBsZXQgbG9uZ19vcHRpb25fc3RyaW5ncyA9IFtdXG4gICAgICAgIGxldCBvcHRpb25fc3RyaW5nXG4gICAgICAgIGZvciAob3B0aW9uX3N0cmluZyBvZiBhcmdzKSB7XG4gICAgICAgICAgICAvLyBlcnJvciBvbiBzdHJpbmdzIHRoYXQgZG9uJ3Qgc3RhcnQgd2l0aCBhbiBhcHByb3ByaWF0ZSBwcmVmaXhcbiAgICAgICAgICAgIGlmICghdGhpcy5wcmVmaXhfY2hhcnMuaW5jbHVkZXMob3B0aW9uX3N0cmluZ1swXSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXJncyA9IHtvcHRpb246IG9wdGlvbl9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZml4X2NoYXJzOiB0aGlzLnByZWZpeF9jaGFyc31cbiAgICAgICAgICAgICAgICBsZXQgbXNnID0gJ2ludmFsaWQgb3B0aW9uIHN0cmluZyAlKG9wdGlvbilyOiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ211c3Qgc3RhcnQgd2l0aCBhIGNoYXJhY3RlciAlKHByZWZpeF9jaGFycylyJ1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc3ViKG1zZywgYXJncykpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHN0cmluZ3Mgc3RhcnRpbmcgd2l0aCB0d28gcHJlZml4IGNoYXJhY3RlcnMgYXJlIGxvbmcgb3B0aW9uc1xuICAgICAgICAgICAgb3B0aW9uX3N0cmluZ3MucHVzaChvcHRpb25fc3RyaW5nKVxuICAgICAgICAgICAgaWYgKG9wdGlvbl9zdHJpbmcubGVuZ3RoID4gMSAmJiB0aGlzLnByZWZpeF9jaGFycy5pbmNsdWRlcyhvcHRpb25fc3RyaW5nWzFdKSkge1xuICAgICAgICAgICAgICAgIGxvbmdfb3B0aW9uX3N0cmluZ3MucHVzaChvcHRpb25fc3RyaW5nKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW5mZXIgZGVzdGluYXRpb24sICctLWZvby1iYXInIC0+ICdmb29fYmFyJyBhbmQgJy14JyAtPiAneCdcbiAgICAgICAgbGV0IGRlc3QgPSBrd2FyZ3MuZGVzdFxuICAgICAgICBkZWxldGUga3dhcmdzLmRlc3RcbiAgICAgICAgaWYgKGRlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGRlc3Rfb3B0aW9uX3N0cmluZ1xuICAgICAgICAgICAgaWYgKGxvbmdfb3B0aW9uX3N0cmluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVzdF9vcHRpb25fc3RyaW5nID0gbG9uZ19vcHRpb25fc3RyaW5nc1swXVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXN0X29wdGlvbl9zdHJpbmcgPSBvcHRpb25fc3RyaW5nc1swXVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdCA9IF9zdHJpbmdfbHN0cmlwKGRlc3Rfb3B0aW9uX3N0cmluZywgdGhpcy5wcmVmaXhfY2hhcnMpXG4gICAgICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgICAgICBsZXQgbXNnID0gJ2Rlc3Q9IGlzIHJlcXVpcmVkIGZvciBvcHRpb25zIGxpa2UgJXInXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzdWIobXNnLCBvcHRpb25fc3RyaW5nKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlc3QgPSBkZXN0LnJlcGxhY2UoLy0vZywgJ18nKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIHRoZSB1cGRhdGVkIGtleXdvcmQgYXJndW1lbnRzXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGt3YXJncywgeyBkZXN0LCBvcHRpb25fc3RyaW5ncyB9KVxuICAgIH1cblxuICAgIF9wb3BfYWN0aW9uX2NsYXNzKGt3YXJncywgZGVmYXVsdF92YWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgYWN0aW9uID0gZ2V0YXR0cihrd2FyZ3MsICdhY3Rpb24nLCBkZWZhdWx0X3ZhbHVlKVxuICAgICAgICBkZWxldGUga3dhcmdzLmFjdGlvblxuICAgICAgICByZXR1cm4gdGhpcy5fcmVnaXN0cnlfZ2V0KCdhY3Rpb24nLCBhY3Rpb24sIGFjdGlvbilcbiAgICB9XG5cbiAgICBfZ2V0X2hhbmRsZXIoKSB7XG4gICAgICAgIC8vIGRldGVybWluZSBmdW5jdGlvbiBmcm9tIGNvbmZsaWN0IGhhbmRsZXIgc3RyaW5nXG4gICAgICAgIGxldCBoYW5kbGVyX2Z1bmNfbmFtZSA9IHN1YignX2hhbmRsZV9jb25mbGljdF8lcycsIHRoaXMuY29uZmxpY3RfaGFuZGxlcilcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2hhbmRsZXJfZnVuY19uYW1lXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbaGFuZGxlcl9mdW5jX25hbWVdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgbXNnID0gJ2ludmFsaWQgY29uZmxpY3RfcmVzb2x1dGlvbiB2YWx1ZTogJXInXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHN1Yihtc2csIHRoaXMuY29uZmxpY3RfaGFuZGxlcikpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfY2hlY2tfY29uZmxpY3QoYWN0aW9uKSB7XG5cbiAgICAgICAgLy8gZmluZCBhbGwgb3B0aW9ucyB0aGF0IGNvbmZsaWN0IHdpdGggdGhpcyBvcHRpb25cbiAgICAgICAgbGV0IGNvbmZsX29wdGlvbmFscyA9IFtdXG4gICAgICAgIGZvciAobGV0IG9wdGlvbl9zdHJpbmcgb2YgYWN0aW9uLm9wdGlvbl9zdHJpbmdzKSB7XG4gICAgICAgICAgICBpZiAoaGFzYXR0cih0aGlzLl9vcHRpb25fc3RyaW5nX2FjdGlvbnMsIG9wdGlvbl9zdHJpbmcpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbmZsX29wdGlvbmFsID0gdGhpcy5fb3B0aW9uX3N0cmluZ19hY3Rpb25zW29wdGlvbl9zdHJpbmddXG4gICAgICAgICAgICAgICAgY29uZmxfb3B0aW9uYWxzLnB1c2goWyBvcHRpb25fc3RyaW5nLCBjb25mbF9vcHRpb25hbCBdKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVzb2x2ZSBhbnkgY29uZmxpY3RzXG4gICAgICAgIGlmIChjb25mbF9vcHRpb25hbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY29uZmxpY3RfaGFuZGxlciA9IHRoaXMuX2dldF9oYW5kbGVyKClcbiAgICAgICAgICAgIGNvbmZsaWN0X2hhbmRsZXIuY2FsbCh0aGlzLCBhY3Rpb24sIGNvbmZsX29wdGlvbmFscylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9oYW5kbGVfY29uZmxpY3RfZXJyb3IoYWN0aW9uLCBjb25mbGljdGluZ19hY3Rpb25zKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gY29uZmxpY3RpbmdfYWN0aW9ucy5sZW5ndGggPT09IDEgP1xuICAgICAgICAgICAgJ2NvbmZsaWN0aW5nIG9wdGlvbiBzdHJpbmc6ICVzJyA6XG4gICAgICAgICAgICAnY29uZmxpY3Rpbmcgb3B0aW9uIHN0cmluZ3M6ICVzJ1xuICAgICAgICBsZXQgY29uZmxpY3Rfc3RyaW5nID0gY29uZmxpY3RpbmdfYWN0aW9ucy5tYXAoKFsgb3B0aW9uX3N0cmluZy8qLCBhY3Rpb24qLyBdKSA9PiBvcHRpb25fc3RyaW5nKS5qb2luKCcsICcpXG4gICAgICAgIHRocm93IG5ldyBBcmd1bWVudEVycm9yKGFjdGlvbiwgc3ViKG1lc3NhZ2UsIGNvbmZsaWN0X3N0cmluZykpXG4gICAgfVxuXG4gICAgX2hhbmRsZV9jb25mbGljdF9yZXNvbHZlKGFjdGlvbiwgY29uZmxpY3RpbmdfYWN0aW9ucykge1xuXG4gICAgICAgIC8vIHJlbW92ZSBhbGwgY29uZmxpY3Rpbmcgb3B0aW9uc1xuICAgICAgICBmb3IgKGxldCBbIG9wdGlvbl9zdHJpbmcsIGFjdGlvbiBdIG9mIGNvbmZsaWN0aW5nX2FjdGlvbnMpIHtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBjb25mbGljdGluZyBvcHRpb25cbiAgICAgICAgICAgIF9hcnJheV9yZW1vdmUoYWN0aW9uLm9wdGlvbl9zdHJpbmdzLCBvcHRpb25fc3RyaW5nKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX29wdGlvbl9zdHJpbmdfYWN0aW9uc1tvcHRpb25fc3RyaW5nXVxuXG4gICAgICAgICAgICAvLyBpZiB0aGUgb3B0aW9uIG5vdyBoYXMgbm8gb3B0aW9uIHN0cmluZywgcmVtb3ZlIGl0IGZyb20gdGhlXG4gICAgICAgICAgICAvLyBjb250YWluZXIgaG9sZGluZyBpdFxuICAgICAgICAgICAgaWYgKCFhY3Rpb24ub3B0aW9uX3N0cmluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uLmNvbnRhaW5lci5fcmVtb3ZlX2FjdGlvbihhY3Rpb24pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KSlcblxuXG5jb25zdCBfQXJndW1lbnRHcm91cCA9IF9jYWxsYWJsZShjbGFzcyBfQXJndW1lbnRHcm91cCBleHRlbmRzIF9BY3Rpb25zQ29udGFpbmVyIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBsZXQgW1xuICAgICAgICAgICAgY29udGFpbmVyLFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgIGt3YXJnc1xuICAgICAgICBdID0gX3BhcnNlX29wdHMoYXJndW1lbnRzLCB7XG4gICAgICAgICAgICBjb250YWluZXI6IG5vX2RlZmF1bHQsXG4gICAgICAgICAgICB0aXRsZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICcqKmt3YXJncyc6IG5vX2RlZmF1bHRcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBhZGQgYW55IG1pc3Npbmcga2V5d29yZCBhcmd1bWVudHMgYnkgY2hlY2tpbmcgdGhlIGNvbnRhaW5lclxuICAgICAgICBzZXRkZWZhdWx0KGt3YXJncywgJ2NvbmZsaWN0X2hhbmRsZXInLCBjb250YWluZXIuY29uZmxpY3RfaGFuZGxlcilcbiAgICAgICAgc2V0ZGVmYXVsdChrd2FyZ3MsICdwcmVmaXhfY2hhcnMnLCBjb250YWluZXIucHJlZml4X2NoYXJzKVxuICAgICAgICBzZXRkZWZhdWx0KGt3YXJncywgJ2FyZ3VtZW50X2RlZmF1bHQnLCBjb250YWluZXIuYXJndW1lbnRfZGVmYXVsdClcbiAgICAgICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7IGRlc2NyaXB0aW9uIH0sIGt3YXJncykpXG5cbiAgICAgICAgLy8gZ3JvdXAgYXR0cmlidXRlc1xuICAgICAgICB0aGlzLnRpdGxlID0gdGl0bGVcbiAgICAgICAgdGhpcy5fZ3JvdXBfYWN0aW9ucyA9IFtdXG5cbiAgICAgICAgLy8gc2hhcmUgbW9zdCBhdHRyaWJ1dGVzIHdpdGggdGhlIGNvbnRhaW5lclxuICAgICAgICB0aGlzLl9yZWdpc3RyaWVzID0gY29udGFpbmVyLl9yZWdpc3RyaWVzXG4gICAgICAgIHRoaXMuX2FjdGlvbnMgPSBjb250YWluZXIuX2FjdGlvbnNcbiAgICAgICAgdGhpcy5fb3B0aW9uX3N0cmluZ19hY3Rpb25zID0gY29udGFpbmVyLl9vcHRpb25fc3RyaW5nX2FjdGlvbnNcbiAgICAgICAgdGhpcy5fZGVmYXVsdHMgPSBjb250YWluZXIuX2RlZmF1bHRzXG4gICAgICAgIHRoaXMuX2hhc19uZWdhdGl2ZV9udW1iZXJfb3B0aW9uYWxzID1cbiAgICAgICAgICAgIGNvbnRhaW5lci5faGFzX25lZ2F0aXZlX251bWJlcl9vcHRpb25hbHNcbiAgICAgICAgdGhpcy5fbXV0dWFsbHlfZXhjbHVzaXZlX2dyb3VwcyA9IGNvbnRhaW5lci5fbXV0dWFsbHlfZXhjbHVzaXZlX2dyb3Vwc1xuICAgIH1cblxuICAgIF9hZGRfYWN0aW9uKGFjdGlvbikge1xuICAgICAgICBhY3Rpb24gPSBzdXBlci5fYWRkX2FjdGlvbihhY3Rpb24pXG4gICAgICAgIHRoaXMuX2dyb3VwX2FjdGlvbnMucHVzaChhY3Rpb24pXG4gICAgICAgIHJldHVybiBhY3Rpb25cbiAgICB9XG5cbiAgICBfcmVtb3ZlX2FjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgc3VwZXIuX3JlbW92ZV9hY3Rpb24oYWN0aW9uKVxuICAgICAgICBfYXJyYXlfcmVtb3ZlKHRoaXMuX2dyb3VwX2FjdGlvbnMsIGFjdGlvbilcbiAgICB9XG59KVxuXG5cbmNvbnN0IF9NdXR1YWxseUV4Y2x1c2l2ZUdyb3VwID0gX2NhbGxhYmxlKGNsYXNzIF9NdXR1YWxseUV4Y2x1c2l2ZUdyb3VwIGV4dGVuZHMgX0FyZ3VtZW50R3JvdXAge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGxldCBbXG4gICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICByZXF1aXJlZFxuICAgICAgICBdID0gX3BhcnNlX29wdHMoYXJndW1lbnRzLCB7XG4gICAgICAgICAgICBjb250YWluZXI6IG5vX2RlZmF1bHQsXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2VcbiAgICAgICAgfSlcblxuICAgICAgICBzdXBlcihjb250YWluZXIpXG4gICAgICAgIHRoaXMucmVxdWlyZWQgPSByZXF1aXJlZFxuICAgICAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXJcbiAgICB9XG5cbiAgICBfYWRkX2FjdGlvbihhY3Rpb24pIHtcbiAgICAgICAgaWYgKGFjdGlvbi5yZXF1aXJlZCkge1xuICAgICAgICAgICAgbGV0IG1zZyA9ICdtdXR1YWxseSBleGNsdXNpdmUgYXJndW1lbnRzIG11c3QgYmUgb3B0aW9uYWwnXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG1zZylcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb24gPSB0aGlzLl9jb250YWluZXIuX2FkZF9hY3Rpb24oYWN0aW9uKVxuICAgICAgICB0aGlzLl9ncm91cF9hY3Rpb25zLnB1c2goYWN0aW9uKVxuICAgICAgICByZXR1cm4gYWN0aW9uXG4gICAgfVxuXG4gICAgX3JlbW92ZV9hY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5fcmVtb3ZlX2FjdGlvbihhY3Rpb24pXG4gICAgICAgIF9hcnJheV9yZW1vdmUodGhpcy5fZ3JvdXBfYWN0aW9ucywgYWN0aW9uKVxuICAgIH1cbn0pXG5cblxuY29uc3QgQXJndW1lbnRQYXJzZXIgPSBfY2FtZWxjYXNlX2FsaWFzKF9jYWxsYWJsZShjbGFzcyBBcmd1bWVudFBhcnNlciBleHRlbmRzIF9BdHRyaWJ1dGVIb2xkZXIoX0FjdGlvbnNDb250YWluZXIpIHtcbiAgICAvKlxuICAgICAqICBPYmplY3QgZm9yIHBhcnNpbmcgY29tbWFuZCBsaW5lIHN0cmluZ3MgaW50byBQeXRob24gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqICBLZXl3b3JkIEFyZ3VtZW50czpcbiAgICAgKiAgICAgIC0gcHJvZyAtLSBUaGUgbmFtZSBvZiB0aGUgcHJvZ3JhbSAoZGVmYXVsdDogc3lzLmFyZ3ZbMF0pXG4gICAgICogICAgICAtIHVzYWdlIC0tIEEgdXNhZ2UgbWVzc2FnZSAoZGVmYXVsdDogYXV0by1nZW5lcmF0ZWQgZnJvbSBhcmd1bWVudHMpXG4gICAgICogICAgICAtIGRlc2NyaXB0aW9uIC0tIEEgZGVzY3JpcHRpb24gb2Ygd2hhdCB0aGUgcHJvZ3JhbSBkb2VzXG4gICAgICogICAgICAtIGVwaWxvZyAtLSBUZXh0IGZvbGxvd2luZyB0aGUgYXJndW1lbnQgZGVzY3JpcHRpb25zXG4gICAgICogICAgICAtIHBhcmVudHMgLS0gUGFyc2VycyB3aG9zZSBhcmd1bWVudHMgc2hvdWxkIGJlIGNvcGllZCBpbnRvIHRoaXMgb25lXG4gICAgICogICAgICAtIGZvcm1hdHRlcl9jbGFzcyAtLSBIZWxwRm9ybWF0dGVyIGNsYXNzIGZvciBwcmludGluZyBoZWxwIG1lc3NhZ2VzXG4gICAgICogICAgICAtIHByZWZpeF9jaGFycyAtLSBDaGFyYWN0ZXJzIHRoYXQgcHJlZml4IG9wdGlvbmFsIGFyZ3VtZW50c1xuICAgICAqICAgICAgLSBmcm9tZmlsZV9wcmVmaXhfY2hhcnMgLS0gQ2hhcmFjdGVycyB0aGF0IHByZWZpeCBmaWxlcyBjb250YWluaW5nXG4gICAgICogICAgICAgICAgYWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICAgKiAgICAgIC0gYXJndW1lbnRfZGVmYXVsdCAtLSBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgYWxsIGFyZ3VtZW50c1xuICAgICAqICAgICAgLSBjb25mbGljdF9oYW5kbGVyIC0tIFN0cmluZyBpbmRpY2F0aW5nIGhvdyB0byBoYW5kbGUgY29uZmxpY3RzXG4gICAgICogICAgICAtIGFkZF9oZWxwIC0tIEFkZCBhIC1oLy1oZWxwIG9wdGlvblxuICAgICAqICAgICAgLSBhbGxvd19hYmJyZXYgLS0gQWxsb3cgbG9uZyBvcHRpb25zIHRvIGJlIGFiYnJldmlhdGVkIHVuYW1iaWd1b3VzbHlcbiAgICAgKiAgICAgIC0gZXhpdF9vbl9lcnJvciAtLSBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IEFyZ3VtZW50UGFyc2VyIGV4aXRzIHdpdGhcbiAgICAgKiAgICAgICAgICBlcnJvciBpbmZvIHdoZW4gYW4gZXJyb3Igb2NjdXJzXG4gICAgICovXG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbGV0IFtcbiAgICAgICAgICAgIHByb2csXG4gICAgICAgICAgICB1c2FnZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgZXBpbG9nLFxuICAgICAgICAgICAgcGFyZW50cyxcbiAgICAgICAgICAgIGZvcm1hdHRlcl9jbGFzcyxcbiAgICAgICAgICAgIHByZWZpeF9jaGFycyxcbiAgICAgICAgICAgIGZyb21maWxlX3ByZWZpeF9jaGFycyxcbiAgICAgICAgICAgIGFyZ3VtZW50X2RlZmF1bHQsXG4gICAgICAgICAgICBjb25mbGljdF9oYW5kbGVyLFxuICAgICAgICAgICAgYWRkX2hlbHAsXG4gICAgICAgICAgICBhbGxvd19hYmJyZXYsXG4gICAgICAgICAgICBleGl0X29uX2Vycm9yLFxuICAgICAgICAgICAgZGVidWcsIC8vIExFR0FDWSAodjEgY29tcGF0aWJpbGl0eSksIGRlYnVnIG1vZGVcbiAgICAgICAgICAgIHZlcnNpb24gLy8gTEVHQUNZICh2MSBjb21wYXRpYmlsaXR5KSwgdmVyc2lvblxuICAgICAgICBdID0gX3BhcnNlX29wdHMoYXJndW1lbnRzLCB7XG4gICAgICAgICAgICBwcm9nOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB1c2FnZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGVwaWxvZzogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGFyZW50czogW10sXG4gICAgICAgICAgICBmb3JtYXR0ZXJfY2xhc3M6IEhlbHBGb3JtYXR0ZXIsXG4gICAgICAgICAgICBwcmVmaXhfY2hhcnM6ICctJyxcbiAgICAgICAgICAgIGZyb21maWxlX3ByZWZpeF9jaGFyczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYXJndW1lbnRfZGVmYXVsdDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29uZmxpY3RfaGFuZGxlcjogJ2Vycm9yJyxcbiAgICAgICAgICAgIGFkZF9oZWxwOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dfYWJicmV2OiB0cnVlLFxuICAgICAgICAgICAgZXhpdF9vbl9lcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgIGRlYnVnOiB1bmRlZmluZWQsIC8vIExFR0FDWSAodjEgY29tcGF0aWJpbGl0eSksIGRlYnVnIG1vZGVcbiAgICAgICAgICAgIHZlcnNpb246IHVuZGVmaW5lZCAvLyBMRUdBQ1kgKHYxIGNvbXBhdGliaWxpdHkpLCB2ZXJzaW9uXG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gTEVHQUNZICh2MSBjb21wYXRpYmlsaXR5KVxuICAgICAgICBpZiAoZGVidWcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVwcmVjYXRlKCdkZWJ1ZycsXG4gICAgICAgICAgICAgICAgJ1RoZSBcImRlYnVnXCIgYXJndW1lbnQgdG8gQXJndW1lbnRQYXJzZXIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlICcgK1xuICAgICAgICAgICAgICAgICdvdmVycmlkZSBBcmd1bWVudFBhcnNlci5leGl0IGZ1bmN0aW9uIGluc3RlYWQuJ1xuICAgICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGVwcmVjYXRlKCd2ZXJzaW9uJyxcbiAgICAgICAgICAgICAgICAnVGhlIFwidmVyc2lvblwiIGFyZ3VtZW50IHRvIEFyZ3VtZW50UGFyc2VyIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgJyArXG4gICAgICAgICAgICAgICAgXCJhZGRfYXJndW1lbnQoLi4uLCB7IGFjdGlvbjogJ3ZlcnNpb24nLCB2ZXJzaW9uOiAnTicsIC4uLiB9KSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5kXG5cbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBwcmVmaXhfY2hhcnMsXG4gICAgICAgICAgICBhcmd1bWVudF9kZWZhdWx0LFxuICAgICAgICAgICAgY29uZmxpY3RfaGFuZGxlclxuICAgICAgICB9KVxuXG4gICAgICAgIC8vIGRlZmF1bHQgc2V0dGluZyBmb3IgcHJvZ1xuICAgICAgICBpZiAocHJvZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcm9nID0gcGF0aC5iYXNlbmFtZShnZXRfYXJndigpWzBdIHx8ICcnKVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wcm9nID0gcHJvZ1xuICAgICAgICB0aGlzLnVzYWdlID0gdXNhZ2VcbiAgICAgICAgdGhpcy5lcGlsb2cgPSBlcGlsb2dcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXJfY2xhc3MgPSBmb3JtYXR0ZXJfY2xhc3NcbiAgICAgICAgdGhpcy5mcm9tZmlsZV9wcmVmaXhfY2hhcnMgPSBmcm9tZmlsZV9wcmVmaXhfY2hhcnNcbiAgICAgICAgdGhpcy5hZGRfaGVscCA9IGFkZF9oZWxwXG4gICAgICAgIHRoaXMuYWxsb3dfYWJicmV2ID0gYWxsb3dfYWJicmV2XG4gICAgICAgIHRoaXMuZXhpdF9vbl9lcnJvciA9IGV4aXRfb25fZXJyb3JcbiAgICAgICAgLy8gTEVHQUNZICh2MSBjb21wYXRpYmlsaXR5KSwgZGVidWcgbW9kZVxuICAgICAgICB0aGlzLmRlYnVnID0gZGVidWdcbiAgICAgICAgLy8gZW5kXG5cbiAgICAgICAgdGhpcy5fcG9zaXRpb25hbHMgPSB0aGlzLmFkZF9hcmd1bWVudF9ncm91cCgncG9zaXRpb25hbCBhcmd1bWVudHMnKVxuICAgICAgICB0aGlzLl9vcHRpb25hbHMgPSB0aGlzLmFkZF9hcmd1bWVudF9ncm91cCgnb3B0aW9uYWwgYXJndW1lbnRzJylcbiAgICAgICAgdGhpcy5fc3VicGFyc2VycyA9IHVuZGVmaW5lZFxuXG4gICAgICAgIC8vIHJlZ2lzdGVyIHR5cGVzXG4gICAgICAgIGZ1bmN0aW9uIGlkZW50aXR5KHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoJ3R5cGUnLCB1bmRlZmluZWQsIGlkZW50aXR5KVxuICAgICAgICB0aGlzLnJlZ2lzdGVyKCd0eXBlJywgbnVsbCwgaWRlbnRpdHkpXG4gICAgICAgIHRoaXMucmVnaXN0ZXIoJ3R5cGUnLCAnYXV0bycsIGlkZW50aXR5KVxuICAgICAgICB0aGlzLnJlZ2lzdGVyKCd0eXBlJywgJ2ludCcsIGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gTnVtYmVyKHgpXG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc3ViKCdjb3VsZCBub3QgY29udmVydCBzdHJpbmcgdG8gaW50OiAlcicsIHgpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICB9KVxuICAgICAgICB0aGlzLnJlZ2lzdGVyKCd0eXBlJywgJ2Zsb2F0JywgZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBOdW1iZXIoeClcbiAgICAgICAgICAgIGlmIChpc05hTihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzdWIoJ2NvdWxkIG5vdCBjb252ZXJ0IHN0cmluZyB0byBmbG9hdDogJXInLCB4KSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5yZWdpc3RlcigndHlwZScsICdzdHInLCBTdHJpbmcpXG4gICAgICAgIC8vIExFR0FDWSAodjEgY29tcGF0aWJpbGl0eSk6IGN1c3RvbSB0eXBlc1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKCd0eXBlJywgJ3N0cmluZycsXG4gICAgICAgICAgICB1dGlsLmRlcHJlY2F0ZShTdHJpbmcsICd1c2Uge3R5cGU6XCJzdHJcIn0gb3Ige3R5cGU6U3RyaW5nfSBpbnN0ZWFkIG9mIHt0eXBlOlwic3RyaW5nXCJ9JykpXG4gICAgICAgIC8vIGVuZFxuXG4gICAgICAgIC8vIGFkZCBoZWxwIGFyZ3VtZW50IGlmIG5lY2Vzc2FyeVxuICAgICAgICAvLyAodXNpbmcgZXhwbGljaXQgZGVmYXVsdCB0byBvdmVycmlkZSBnbG9iYWwgYXJndW1lbnRfZGVmYXVsdClcbiAgICAgICAgbGV0IGRlZmF1bHRfcHJlZml4ID0gcHJlZml4X2NoYXJzLmluY2x1ZGVzKCctJykgPyAnLScgOiBwcmVmaXhfY2hhcnNbMF1cbiAgICAgICAgaWYgKHRoaXMuYWRkX2hlbHApIHtcbiAgICAgICAgICAgIHRoaXMuYWRkX2FyZ3VtZW50KFxuICAgICAgICAgICAgICAgIGRlZmF1bHRfcHJlZml4ICsgJ2gnLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRfcHJlZml4LnJlcGVhdCgyKSArICdoZWxwJyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ2hlbHAnLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBTVVBQUkVTUyxcbiAgICAgICAgICAgICAgICAgICAgaGVscDogJ3Nob3cgdGhpcyBoZWxwIG1lc3NhZ2UgYW5kIGV4aXQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIC8vIExFR0FDWSAodjEgY29tcGF0aWJpbGl0eSksIHZlcnNpb25cbiAgICAgICAgaWYgKHZlcnNpb24pIHtcbiAgICAgICAgICAgIHRoaXMuYWRkX2FyZ3VtZW50KFxuICAgICAgICAgICAgICAgIGRlZmF1bHRfcHJlZml4ICsgJ3YnLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRfcHJlZml4LnJlcGVhdCgyKSArICd2ZXJzaW9uJyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogJ3ZlcnNpb24nLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBTVVBQUkVTUyxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICBoZWxwOiBcInNob3cgcHJvZ3JhbSdzIHZlcnNpb24gbnVtYmVyIGFuZCBleGl0XCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgLy8gZW5kXG5cbiAgICAgICAgLy8gYWRkIHBhcmVudCBhcmd1bWVudHMgYW5kIGRlZmF1bHRzXG4gICAgICAgIGZvciAobGV0IHBhcmVudCBvZiBwYXJlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLl9hZGRfY29udGFpbmVyX2FjdGlvbnMocGFyZW50KVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLl9kZWZhdWx0cywgcGFyZW50Ll9kZWZhdWx0cylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gUHJldHR5IF9fcmVwcl9fIG1ldGhvZHNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuICAgIF9nZXRfa3dhcmdzKCkge1xuICAgICAgICBsZXQgbmFtZXMgPSBbXG4gICAgICAgICAgICAncHJvZycsXG4gICAgICAgICAgICAndXNhZ2UnLFxuICAgICAgICAgICAgJ2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICAgICdmb3JtYXR0ZXJfY2xhc3MnLFxuICAgICAgICAgICAgJ2NvbmZsaWN0X2hhbmRsZXInLFxuICAgICAgICAgICAgJ2FkZF9oZWxwJ1xuICAgICAgICBdXG4gICAgICAgIHJldHVybiBuYW1lcy5tYXAobmFtZSA9PiBbIG5hbWUsIGdldGF0dHIodGhpcywgbmFtZSkgXSlcbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gT3B0aW9uYWwvUG9zaXRpb25hbCBhZGRpbmcgbWV0aG9kc1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBhZGRfc3VicGFyc2VycygpIHtcbiAgICAgICAgbGV0IFtcbiAgICAgICAgICAgIGt3YXJnc1xuICAgICAgICBdID0gX3BhcnNlX29wdHMoYXJndW1lbnRzLCB7XG4gICAgICAgICAgICAnKiprd2FyZ3MnOiBub19kZWZhdWx0XG4gICAgICAgIH0pXG5cbiAgICAgICAgaWYgKHRoaXMuX3N1YnBhcnNlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lcnJvcignY2Fubm90IGhhdmUgbXVsdGlwbGUgc3VicGFyc2VyIGFyZ3VtZW50cycpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgdGhlIHBhcnNlciBjbGFzcyB0byB0aGUgYXJndW1lbnRzIGlmIGl0J3Mgbm90IHByZXNlbnRcbiAgICAgICAgc2V0ZGVmYXVsdChrd2FyZ3MsICdwYXJzZXJfY2xhc3MnLCB0aGlzLmNvbnN0cnVjdG9yKVxuXG4gICAgICAgIGlmICgndGl0bGUnIGluIGt3YXJncyB8fCAnZGVzY3JpcHRpb24nIGluIGt3YXJncykge1xuICAgICAgICAgICAgbGV0IHRpdGxlID0gZ2V0YXR0cihrd2FyZ3MsICd0aXRsZScsICdzdWJjb21tYW5kcycpXG4gICAgICAgICAgICBsZXQgZGVzY3JpcHRpb24gPSBnZXRhdHRyKGt3YXJncywgJ2Rlc2NyaXB0aW9uJywgdW5kZWZpbmVkKVxuICAgICAgICAgICAgZGVsZXRlIGt3YXJncy50aXRsZVxuICAgICAgICAgICAgZGVsZXRlIGt3YXJncy5kZXNjcmlwdGlvblxuICAgICAgICAgICAgdGhpcy5fc3VicGFyc2VycyA9IHRoaXMuYWRkX2FyZ3VtZW50X2dyb3VwKHRpdGxlLCBkZXNjcmlwdGlvbilcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnBhcnNlcnMgPSB0aGlzLl9wb3NpdGlvbmFsc1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJvZyBkZWZhdWx0cyB0byB0aGUgdXNhZ2UgbWVzc2FnZSBvZiB0aGlzIHBhcnNlciwgc2tpcHBpbmdcbiAgICAgICAgLy8gb3B0aW9uYWwgYXJndW1lbnRzIGFuZCB3aXRoIG5vIFwidXNhZ2U6XCIgcHJlZml4XG4gICAgICAgIGlmIChrd2FyZ3MucHJvZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgZm9ybWF0dGVyID0gdGhpcy5fZ2V0X2Zvcm1hdHRlcigpXG4gICAgICAgICAgICBsZXQgcG9zaXRpb25hbHMgPSB0aGlzLl9nZXRfcG9zaXRpb25hbF9hY3Rpb25zKClcbiAgICAgICAgICAgIGxldCBncm91cHMgPSB0aGlzLl9tdXR1YWxseV9leGNsdXNpdmVfZ3JvdXBzXG4gICAgICAgICAgICBmb3JtYXR0ZXIuYWRkX3VzYWdlKHRoaXMudXNhZ2UsIHBvc2l0aW9uYWxzLCBncm91cHMsICcnKVxuICAgICAgICAgICAga3dhcmdzLnByb2cgPSBmb3JtYXR0ZXIuZm9ybWF0X2hlbHAoKS50cmltKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgcGFyc2VycyBhY3Rpb24gYW5kIGFkZCBpdCB0byB0aGUgcG9zaXRpb25hbHMgbGlzdFxuICAgICAgICBsZXQgcGFyc2Vyc19jbGFzcyA9IHRoaXMuX3BvcF9hY3Rpb25fY2xhc3Moa3dhcmdzLCAncGFyc2VycycpXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gICAgICAgIGxldCBhY3Rpb24gPSBuZXcgcGFyc2Vyc19jbGFzcyhPYmplY3QuYXNzaWduKHsgb3B0aW9uX3N0cmluZ3M6IFtdIH0sIGt3YXJncykpXG4gICAgICAgIHRoaXMuX3N1YnBhcnNlcnMuX2FkZF9hY3Rpb24oYWN0aW9uKVxuXG4gICAgICAgIC8vIHJldHVybiB0aGUgY3JlYXRlZCBwYXJzZXJzIGFjdGlvblxuICAgICAgICByZXR1cm4gYWN0aW9uXG4gICAgfVxuXG4gICAgX2FkZF9hY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIGlmIChhY3Rpb24ub3B0aW9uX3N0cmluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25hbHMuX2FkZF9hY3Rpb24oYWN0aW9uKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25hbHMuX2FkZF9hY3Rpb24oYWN0aW9uKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3Rpb25cbiAgICB9XG5cbiAgICBfZ2V0X29wdGlvbmFsX2FjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25zLmZpbHRlcihhY3Rpb24gPT4gYWN0aW9uLm9wdGlvbl9zdHJpbmdzLmxlbmd0aClcbiAgICB9XG5cbiAgICBfZ2V0X3Bvc2l0aW9uYWxfYWN0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnMuZmlsdGVyKGFjdGlvbiA9PiAhYWN0aW9uLm9wdGlvbl9zdHJpbmdzLmxlbmd0aClcbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gQ29tbWFuZCBsaW5lIGFyZ3VtZW50IHBhcnNpbmcgbWV0aG9kc1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBwYXJzZV9hcmdzKGFyZ3MgPSB1bmRlZmluZWQsIG5hbWVzcGFjZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBsZXQgYXJndlxuICAgICAgICBbIGFyZ3MsIGFyZ3YgXSA9IHRoaXMucGFyc2Vfa25vd25fYXJncyhhcmdzLCBuYW1lc3BhY2UpXG4gICAgICAgIGlmIChhcmd2ICYmIGFyZ3YubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IG1zZyA9ICd1bnJlY29nbml6ZWQgYXJndW1lbnRzOiAlcydcbiAgICAgICAgICAgIHRoaXMuZXJyb3Ioc3ViKG1zZywgYXJndi5qb2luKCcgJykpKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmdzXG4gICAgfVxuXG4gICAgcGFyc2Vfa25vd25fYXJncyhhcmdzID0gdW5kZWZpbmVkLCBuYW1lc3BhY2UgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXJncyA9IGdldF9hcmd2KCkuc2xpY2UoMSlcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRlZmF1bHQgTmFtZXNwYWNlIGJ1aWx0IGZyb20gcGFyc2VyIGRlZmF1bHRzXG4gICAgICAgIGlmIChuYW1lc3BhY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmFtZXNwYWNlID0gbmV3IE5hbWVzcGFjZSgpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgYW55IGFjdGlvbiBkZWZhdWx0cyB0aGF0IGFyZW4ndCBwcmVzZW50XG4gICAgICAgIGZvciAobGV0IGFjdGlvbiBvZiB0aGlzLl9hY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAoYWN0aW9uLmRlc3QgIT09IFNVUFBSRVNTKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNhdHRyKG5hbWVzcGFjZSwgYWN0aW9uLmRlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24uZGVmYXVsdCAhPT0gU1VQUFJFU1MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldGF0dHIobmFtZXNwYWNlLCBhY3Rpb24uZGVzdCwgYWN0aW9uLmRlZmF1bHQpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGQgYW55IHBhcnNlciBkZWZhdWx0cyB0aGF0IGFyZW4ndCBwcmVzZW50XG4gICAgICAgIGZvciAobGV0IGRlc3Qgb2YgT2JqZWN0LmtleXModGhpcy5fZGVmYXVsdHMpKSB7XG4gICAgICAgICAgICBpZiAoIWhhc2F0dHIobmFtZXNwYWNlLCBkZXN0KSkge1xuICAgICAgICAgICAgICAgIHNldGF0dHIobmFtZXNwYWNlLCBkZXN0LCB0aGlzLl9kZWZhdWx0c1tkZXN0XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhcnNlIHRoZSBhcmd1bWVudHMgYW5kIGV4aXQgaWYgdGhlcmUgYXJlIGFueSBlcnJvcnNcbiAgICAgICAgaWYgKHRoaXMuZXhpdF9vbl9lcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBbIG5hbWVzcGFjZSwgYXJncyBdID0gdGhpcy5fcGFyc2Vfa25vd25fYXJncyhhcmdzLCBuYW1lc3BhY2UpXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQXJndW1lbnRFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVyci5tZXNzYWdlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVyclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFsgbmFtZXNwYWNlLCBhcmdzIF0gPSB0aGlzLl9wYXJzZV9rbm93bl9hcmdzKGFyZ3MsIG5hbWVzcGFjZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNhdHRyKG5hbWVzcGFjZSwgX1VOUkVDT0dOSVpFRF9BUkdTX0FUVFIpKSB7XG4gICAgICAgICAgICBhcmdzID0gYXJncy5jb25jYXQoZ2V0YXR0cihuYW1lc3BhY2UsIF9VTlJFQ09HTklaRURfQVJHU19BVFRSKSlcbiAgICAgICAgICAgIGRlbGF0dHIobmFtZXNwYWNlLCBfVU5SRUNPR05JWkVEX0FSR1NfQVRUUilcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbIG5hbWVzcGFjZSwgYXJncyBdXG4gICAgfVxuXG4gICAgX3BhcnNlX2tub3duX2FyZ3MoYXJnX3N0cmluZ3MsIG5hbWVzcGFjZSkge1xuICAgICAgICAvLyByZXBsYWNlIGFyZyBzdHJpbmdzIHRoYXQgYXJlIGZpbGUgcmVmZXJlbmNlc1xuICAgICAgICBpZiAodGhpcy5mcm9tZmlsZV9wcmVmaXhfY2hhcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYXJnX3N0cmluZ3MgPSB0aGlzLl9yZWFkX2FyZ3NfZnJvbV9maWxlcyhhcmdfc3RyaW5ncylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1hcCBhbGwgbXV0dWFsbHkgZXhjbHVzaXZlIGFyZ3VtZW50cyB0byB0aGUgb3RoZXIgYXJndW1lbnRzXG4gICAgICAgIC8vIHRoZXkgY2FuJ3Qgb2NjdXIgd2l0aFxuICAgICAgICBsZXQgYWN0aW9uX2NvbmZsaWN0cyA9IG5ldyBNYXAoKVxuICAgICAgICBmb3IgKGxldCBtdXRleF9ncm91cCBvZiB0aGlzLl9tdXR1YWxseV9leGNsdXNpdmVfZ3JvdXBzKSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBfYWN0aW9ucyA9IG11dGV4X2dyb3VwLl9ncm91cF9hY3Rpb25zXG4gICAgICAgICAgICBmb3IgKGxldCBbIGksIG11dGV4X2FjdGlvbiBdIG9mIE9iamVjdC5lbnRyaWVzKG11dGV4X2dyb3VwLl9ncm91cF9hY3Rpb25zKSkge1xuICAgICAgICAgICAgICAgIGxldCBjb25mbGljdHMgPSBhY3Rpb25fY29uZmxpY3RzLmdldChtdXRleF9hY3Rpb24pIHx8IFtdXG4gICAgICAgICAgICAgICAgY29uZmxpY3RzID0gY29uZmxpY3RzLmNvbmNhdChncm91cF9hY3Rpb25zLnNsaWNlKDAsICtpKSlcbiAgICAgICAgICAgICAgICBjb25mbGljdHMgPSBjb25mbGljdHMuY29uY2F0KGdyb3VwX2FjdGlvbnMuc2xpY2UoK2kgKyAxKSlcbiAgICAgICAgICAgICAgICBhY3Rpb25fY29uZmxpY3RzLnNldChtdXRleF9hY3Rpb24sIGNvbmZsaWN0cylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmQgYWxsIG9wdGlvbiBpbmRpY2VzLCBhbmQgZGV0ZXJtaW5lIHRoZSBhcmdfc3RyaW5nX3BhdHRlcm5cbiAgICAgICAgLy8gd2hpY2ggaGFzIGFuICdPJyBpZiB0aGVyZSBpcyBhbiBvcHRpb24gYXQgYW4gaW5kZXgsXG4gICAgICAgIC8vIGFuICdBJyBpZiB0aGVyZSBpcyBhbiBhcmd1bWVudCwgb3IgYSAnLScgaWYgdGhlcmUgaXMgYSAnLS0nXG4gICAgICAgIGxldCBvcHRpb25fc3RyaW5nX2luZGljZXMgPSB7fVxuICAgICAgICBsZXQgYXJnX3N0cmluZ19wYXR0ZXJuX3BhcnRzID0gW11cbiAgICAgICAgbGV0IGFyZ19zdHJpbmdzX2l0ZXIgPSBPYmplY3QuZW50cmllcyhhcmdfc3RyaW5ncylbU3ltYm9sLml0ZXJhdG9yXSgpXG4gICAgICAgIGZvciAobGV0IFsgaSwgYXJnX3N0cmluZyBdIG9mIGFyZ19zdHJpbmdzX2l0ZXIpIHtcblxuICAgICAgICAgICAgLy8gYWxsIGFyZ3MgYWZ0ZXIgLS0gYXJlIG5vbi1vcHRpb25zXG4gICAgICAgICAgICBpZiAoYXJnX3N0cmluZyA9PT0gJy0tJykge1xuICAgICAgICAgICAgICAgIGFyZ19zdHJpbmdfcGF0dGVybl9wYXJ0cy5wdXNoKCctJylcbiAgICAgICAgICAgICAgICBmb3IgKFsgaSwgYXJnX3N0cmluZyBdIG9mIGFyZ19zdHJpbmdzX2l0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnX3N0cmluZ19wYXR0ZXJuX3BhcnRzLnB1c2goJ0EnKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBhZGQgdGhlIGFyZyB0byB0aGUgYXJnIHN0cmluZ3NcbiAgICAgICAgICAgIC8vIGFuZCBub3RlIHRoZSBpbmRleCBpZiBpdCB3YXMgYW4gb3B0aW9uXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBvcHRpb25fdHVwbGUgPSB0aGlzLl9wYXJzZV9vcHRpb25hbChhcmdfc3RyaW5nKVxuICAgICAgICAgICAgICAgIGxldCBwYXR0ZXJuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbl90dXBsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gPSAnQSdcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25fc3RyaW5nX2luZGljZXNbaV0gPSBvcHRpb25fdHVwbGVcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybiA9ICdPJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcmdfc3RyaW5nX3BhdHRlcm5fcGFydHMucHVzaChwYXR0ZXJuKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gam9pbiB0aGUgcGllY2VzIHRvZ2V0aGVyIHRvIGZvcm0gdGhlIHBhdHRlcm5cbiAgICAgICAgbGV0IGFyZ19zdHJpbmdzX3BhdHRlcm4gPSBhcmdfc3RyaW5nX3BhdHRlcm5fcGFydHMuam9pbignJylcblxuICAgICAgICAvLyBjb252ZXJ0cyBhcmcgc3RyaW5ncyB0byB0aGUgYXBwcm9wcmlhdGUgYW5kIHRoZW4gdGFrZXMgdGhlIGFjdGlvblxuICAgICAgICBsZXQgc2Vlbl9hY3Rpb25zID0gbmV3IFNldCgpXG4gICAgICAgIGxldCBzZWVuX25vbl9kZWZhdWx0X2FjdGlvbnMgPSBuZXcgU2V0KClcbiAgICAgICAgbGV0IGV4dHJhc1xuXG4gICAgICAgIGxldCB0YWtlX2FjdGlvbiA9IChhY3Rpb24sIGFyZ3VtZW50X3N0cmluZ3MsIG9wdGlvbl9zdHJpbmcgPSB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgIHNlZW5fYWN0aW9ucy5hZGQoYWN0aW9uKVxuICAgICAgICAgICAgbGV0IGFyZ3VtZW50X3ZhbHVlcyA9IHRoaXMuX2dldF92YWx1ZXMoYWN0aW9uLCBhcmd1bWVudF9zdHJpbmdzKVxuXG4gICAgICAgICAgICAvLyBlcnJvciBpZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBhbGxvd2VkIHdpdGggb3RoZXIgcHJldmlvdXNseVxuICAgICAgICAgICAgLy8gc2VlbiBhcmd1bWVudHMsIGFzc3VtaW5nIHRoYXQgYWN0aW9ucyB0aGF0IHVzZSB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgLy8gdmFsdWUgZG9uJ3QgcmVhbGx5IGNvdW50IGFzIFwicHJlc2VudFwiXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRfdmFsdWVzICE9PSBhY3Rpb24uZGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHNlZW5fbm9uX2RlZmF1bHRfYWN0aW9ucy5hZGQoYWN0aW9uKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbmZsaWN0X2FjdGlvbiBvZiBhY3Rpb25fY29uZmxpY3RzLmdldChhY3Rpb24pIHx8IFtdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVuX25vbl9kZWZhdWx0X2FjdGlvbnMuaGFzKGNvbmZsaWN0X2FjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtc2cgPSAnbm90IGFsbG93ZWQgd2l0aCBhcmd1bWVudCAlcydcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhY3Rpb25fbmFtZSA9IF9nZXRfYWN0aW9uX25hbWUoY29uZmxpY3RfYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXJyb3IoYWN0aW9uLCBzdWIobXNnLCBhY3Rpb25fbmFtZSkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRha2UgdGhlIGFjdGlvbiBpZiB3ZSBkaWRuJ3QgcmVjZWl2ZSBhIFNVUFBSRVNTIHZhbHVlXG4gICAgICAgICAgICAvLyAoZS5nLiBmcm9tIGEgZGVmYXVsdClcbiAgICAgICAgICAgIGlmIChhcmd1bWVudF92YWx1ZXMgIT09IFNVUFBSRVNTKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uKHRoaXMsIG5hbWVzcGFjZSwgYXJndW1lbnRfdmFsdWVzLCBvcHRpb25fc3RyaW5nKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZnVuY3Rpb24gdG8gY29udmVydCBhcmdfc3RyaW5ncyBpbnRvIGFuIG9wdGlvbmFsIGFjdGlvblxuICAgICAgICBsZXQgY29uc3VtZV9vcHRpb25hbCA9IHN0YXJ0X2luZGV4ID0+IHtcblxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBvcHRpb25hbCBpZGVudGlmaWVkIGF0IHRoaXMgaW5kZXhcbiAgICAgICAgICAgIGxldCBvcHRpb25fdHVwbGUgPSBvcHRpb25fc3RyaW5nX2luZGljZXNbc3RhcnRfaW5kZXhdXG4gICAgICAgICAgICBsZXQgWyBhY3Rpb24sIG9wdGlvbl9zdHJpbmcsIGV4cGxpY2l0X2FyZyBdID0gb3B0aW9uX3R1cGxlXG5cbiAgICAgICAgICAgIC8vIGlkZW50aWZ5IGFkZGl0aW9uYWwgb3B0aW9uYWxzIGluIHRoZSBzYW1lIGFyZyBzdHJpbmdcbiAgICAgICAgICAgIC8vIChlLmcuIC14eXogaXMgdGhlIHNhbWUgYXMgLXggLXkgLXogaWYgbm8gYXJncyBhcmUgcmVxdWlyZWQpXG4gICAgICAgICAgICBsZXQgYWN0aW9uX3R1cGxlcyA9IFtdXG4gICAgICAgICAgICBsZXQgc3RvcFxuICAgICAgICAgICAgZm9yICg7Oykge1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgZm91bmQgbm8gb3B0aW9uYWwgYWN0aW9uLCBza2lwIGl0XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhcy5wdXNoKGFyZ19zdHJpbmdzW3N0YXJ0X2luZGV4XSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0X2luZGV4ICsgMVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFuIGV4cGxpY2l0IGFyZ3VtZW50LCB0cnkgdG8gbWF0Y2ggdGhlXG4gICAgICAgICAgICAgICAgLy8gb3B0aW9uYWwncyBzdHJpbmcgYXJndW1lbnRzIHRvIG9ubHkgdGhpc1xuICAgICAgICAgICAgICAgIGlmIChleHBsaWNpdF9hcmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXJnX2NvdW50ID0gdGhpcy5fbWF0Y2hfYXJndW1lbnQoYWN0aW9uLCAnQScpXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGFjdGlvbiBpcyBhIHNpbmdsZS1kYXNoIG9wdGlvbiBhbmQgdGFrZXMgbm9cbiAgICAgICAgICAgICAgICAgICAgLy8gYXJndW1lbnRzLCB0cnkgdG8gcGFyc2UgbW9yZSBzaW5nbGUtZGFzaCBvcHRpb25zIG91dFxuICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgdGFpbCBvZiB0aGUgb3B0aW9uIHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hhcnMgPSB0aGlzLnByZWZpeF9jaGFyc1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnX2NvdW50ID09PSAwICYmICFjaGFycy5pbmNsdWRlcyhvcHRpb25fc3RyaW5nWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uX3R1cGxlcy5wdXNoKFsgYWN0aW9uLCBbXSwgb3B0aW9uX3N0cmluZyBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNoYXIgPSBvcHRpb25fc3RyaW5nWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25fc3RyaW5nID0gY2hhciArIGV4cGxpY2l0X2FyZ1swXVxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld19leHBsaWNpdF9hcmcgPSBleHBsaWNpdF9hcmcuc2xpY2UoMSkgfHwgdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3B0aW9uYWxzX21hcCA9IHRoaXMuX29wdGlvbl9zdHJpbmdfYWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2F0dHIob3B0aW9uYWxzX21hcCwgb3B0aW9uX3N0cmluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb24gPSBvcHRpb25hbHNfbWFwW29wdGlvbl9zdHJpbmddXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwbGljaXRfYXJnID0gbmV3X2V4cGxpY2l0X2FyZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgbXNnID0gJ2lnbm9yZWQgZXhwbGljaXQgYXJndW1lbnQgJXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXJyb3IoYWN0aW9uLCBzdWIobXNnLCBleHBsaWNpdF9hcmcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBhY3Rpb24gZXhwZWN0IGV4YWN0bHkgb25lIGFyZ3VtZW50LCB3ZSd2ZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzZnVsbHkgbWF0Y2hlZCB0aGUgb3B0aW9uOyBleGl0IHRoZSBsb29wXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnX2NvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gc3RhcnRfaW5kZXggKyAxXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgYXJncyA9IFsgZXhwbGljaXRfYXJnIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbl90dXBsZXMucHVzaChbIGFjdGlvbiwgYXJncywgb3B0aW9uX3N0cmluZyBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcblxuICAgICAgICAgICAgICAgICAgICAvLyBlcnJvciBpZiBhIGRvdWJsZS1kYXNoIG9wdGlvbiBkaWQgbm90IHVzZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwbGljaXQgYXJndW1lbnRcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtc2cgPSAnaWdub3JlZCBleHBsaWNpdCBhcmd1bWVudCAlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBcmd1bWVudEVycm9yKGFjdGlvbiwgc3ViKG1zZywgZXhwbGljaXRfYXJnKSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gZXhwbGljaXQgYXJndW1lbnQsIHRyeSB0byBtYXRjaCB0aGVcbiAgICAgICAgICAgICAgICAvLyBvcHRpb25hbCdzIHN0cmluZyBhcmd1bWVudHMgd2l0aCB0aGUgZm9sbG93aW5nIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAvLyBpZiBzdWNjZXNzZnVsLCBleGl0IHRoZSBsb29wXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gc3RhcnRfaW5kZXggKyAxXG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3RlZF9wYXR0ZXJucyA9IGFyZ19zdHJpbmdzX3BhdHRlcm4uc2xpY2Uoc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIGxldCBhcmdfY291bnQgPSB0aGlzLl9tYXRjaF9hcmd1bWVudChhY3Rpb24sIHNlbGVjdGVkX3BhdHRlcm5zKVxuICAgICAgICAgICAgICAgICAgICBzdG9wID0gc3RhcnQgKyBhcmdfY291bnRcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFyZ3MgPSBhcmdfc3RyaW5ncy5zbGljZShzdGFydCwgc3RvcClcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uX3R1cGxlcy5wdXNoKFsgYWN0aW9uLCBhcmdzLCBvcHRpb25fc3RyaW5nIF0pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBhZGQgdGhlIE9wdGlvbmFsIHRvIHRoZSBsaXN0IGFuZCByZXR1cm4gdGhlIGluZGV4IGF0IHdoaWNoXG4gICAgICAgICAgICAvLyB0aGUgT3B0aW9uYWwncyBzdHJpbmcgYXJncyBzdG9wcGVkXG4gICAgICAgICAgICBhc3NlcnQoYWN0aW9uX3R1cGxlcy5sZW5ndGgpXG4gICAgICAgICAgICBmb3IgKGxldCBbIGFjdGlvbiwgYXJncywgb3B0aW9uX3N0cmluZyBdIG9mIGFjdGlvbl90dXBsZXMpIHtcbiAgICAgICAgICAgICAgICB0YWtlX2FjdGlvbihhY3Rpb24sIGFyZ3MsIG9wdGlvbl9zdHJpbmcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RvcFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIGxpc3Qgb2YgUG9zaXRpb25hbHMgbGVmdCB0byBiZSBwYXJzZWQ7IHRoaXMgaXMgbW9kaWZpZWRcbiAgICAgICAgLy8gYnkgY29uc3VtZV9wb3NpdGlvbmFscygpXG4gICAgICAgIGxldCBwb3NpdGlvbmFscyA9IHRoaXMuX2dldF9wb3NpdGlvbmFsX2FjdGlvbnMoKVxuXG4gICAgICAgIC8vIGZ1bmN0aW9uIHRvIGNvbnZlcnQgYXJnX3N0cmluZ3MgaW50byBwb3NpdGlvbmFsIGFjdGlvbnNcbiAgICAgICAgbGV0IGNvbnN1bWVfcG9zaXRpb25hbHMgPSBzdGFydF9pbmRleCA9PiB7XG4gICAgICAgICAgICAvLyBtYXRjaCBhcyBtYW55IFBvc2l0aW9uYWxzIGFzIHBvc3NpYmxlXG4gICAgICAgICAgICBsZXQgc2VsZWN0ZWRfcGF0dGVybiA9IGFyZ19zdHJpbmdzX3BhdHRlcm4uc2xpY2Uoc3RhcnRfaW5kZXgpXG4gICAgICAgICAgICBsZXQgYXJnX2NvdW50cyA9IHRoaXMuX21hdGNoX2FyZ3VtZW50c19wYXJ0aWFsKHBvc2l0aW9uYWxzLCBzZWxlY3RlZF9wYXR0ZXJuKVxuXG4gICAgICAgICAgICAvLyBzbGljZSBvZmYgdGhlIGFwcHJvcHJpYXRlIGFyZyBzdHJpbmdzIGZvciBlYWNoIFBvc2l0aW9uYWxcbiAgICAgICAgICAgIC8vIGFuZCBhZGQgdGhlIFBvc2l0aW9uYWwgYW5kIGl0cyBhcmdzIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvc2l0aW9uYWxzLmxlbmd0aCAmJiBpIDwgYXJnX2NvdW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBhY3Rpb24gPSBwb3NpdGlvbmFsc1tpXVxuICAgICAgICAgICAgICAgIGxldCBhcmdfY291bnQgPSBhcmdfY291bnRzW2ldXG4gICAgICAgICAgICAgICAgbGV0IGFyZ3MgPSBhcmdfc3RyaW5ncy5zbGljZShzdGFydF9pbmRleCwgc3RhcnRfaW5kZXggKyBhcmdfY291bnQpXG4gICAgICAgICAgICAgICAgc3RhcnRfaW5kZXggKz0gYXJnX2NvdW50XG4gICAgICAgICAgICAgICAgdGFrZV9hY3Rpb24oYWN0aW9uLCBhcmdzKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBzbGljZSBvZmYgdGhlIFBvc2l0aW9uYWxzIHRoYXQgd2UganVzdCBwYXJzZWQgYW5kIHJldHVybiB0aGVcbiAgICAgICAgICAgIC8vIGluZGV4IGF0IHdoaWNoIHRoZSBQb3NpdGlvbmFscycgc3RyaW5nIGFyZ3Mgc3RvcHBlZFxuICAgICAgICAgICAgcG9zaXRpb25hbHMgPSBwb3NpdGlvbmFscy5zbGljZShhcmdfY291bnRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBzdGFydF9pbmRleFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc3VtZSBQb3NpdGlvbmFscyBhbmQgT3B0aW9uYWxzIGFsdGVybmF0ZWx5LCB1bnRpbCB3ZSBoYXZlXG4gICAgICAgIC8vIHBhc3NlZCB0aGUgbGFzdCBvcHRpb24gc3RyaW5nXG4gICAgICAgIGV4dHJhcyA9IFtdXG4gICAgICAgIGxldCBzdGFydF9pbmRleCA9IDBcbiAgICAgICAgbGV0IG1heF9vcHRpb25fc3RyaW5nX2luZGV4ID0gTWF0aC5tYXgoLTEsIC4uLk9iamVjdC5rZXlzKG9wdGlvbl9zdHJpbmdfaW5kaWNlcykubWFwKE51bWJlcikpXG4gICAgICAgIHdoaWxlIChzdGFydF9pbmRleCA8PSBtYXhfb3B0aW9uX3N0cmluZ19pbmRleCkge1xuXG4gICAgICAgICAgICAvLyBjb25zdW1lIGFueSBQb3NpdGlvbmFscyBwcmVjZWRpbmcgdGhlIG5leHQgb3B0aW9uXG4gICAgICAgICAgICBsZXQgbmV4dF9vcHRpb25fc3RyaW5nX2luZGV4ID0gTWF0aC5taW4oXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvb3AtZnVuY1xuICAgICAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKG9wdGlvbl9zdHJpbmdfaW5kaWNlcykubWFwKE51bWJlcikuZmlsdGVyKGluZGV4ID0+IGluZGV4ID49IHN0YXJ0X2luZGV4KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKHN0YXJ0X2luZGV4ICE9PSBuZXh0X29wdGlvbl9zdHJpbmdfaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb25hbHNfZW5kX2luZGV4ID0gY29uc3VtZV9wb3NpdGlvbmFscyhzdGFydF9pbmRleClcblxuICAgICAgICAgICAgICAgIC8vIG9ubHkgdHJ5IHRvIHBhcnNlIHRoZSBuZXh0IG9wdGlvbmFsIGlmIHdlIGRpZG4ndCBjb25zdW1lXG4gICAgICAgICAgICAgICAgLy8gdGhlIG9wdGlvbiBzdHJpbmcgZHVyaW5nIHRoZSBwb3NpdGlvbmFscyBwYXJzaW5nXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uYWxzX2VuZF9pbmRleCA+IHN0YXJ0X2luZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0X2luZGV4ID0gcG9zaXRpb25hbHNfZW5kX2luZGV4XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfaW5kZXggPSBwb3NpdGlvbmFsc19lbmRfaW5kZXhcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIGNvbnN1bWVkIGFsbCB0aGUgcG9zaXRpb25hbHMgd2UgY291bGQgYW5kIHdlJ3JlIG5vdFxuICAgICAgICAgICAgLy8gYXQgdGhlIGluZGV4IG9mIGFuIG9wdGlvbiBzdHJpbmcsIHRoZXJlIHdlcmUgZXh0cmEgYXJndW1lbnRzXG4gICAgICAgICAgICBpZiAoIShzdGFydF9pbmRleCBpbiBvcHRpb25fc3RyaW5nX2luZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0cmluZ3MgPSBhcmdfc3RyaW5ncy5zbGljZShzdGFydF9pbmRleCwgbmV4dF9vcHRpb25fc3RyaW5nX2luZGV4KVxuICAgICAgICAgICAgICAgIGV4dHJhcyA9IGV4dHJhcy5jb25jYXQoc3RyaW5ncylcbiAgICAgICAgICAgICAgICBzdGFydF9pbmRleCA9IG5leHRfb3B0aW9uX3N0cmluZ19pbmRleFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjb25zdW1lIHRoZSBuZXh0IG9wdGlvbmFsIGFuZCBhbnkgYXJndW1lbnRzIGZvciBpdFxuICAgICAgICAgICAgc3RhcnRfaW5kZXggPSBjb25zdW1lX29wdGlvbmFsKHN0YXJ0X2luZGV4KVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc3VtZSBhbnkgcG9zaXRpb25hbHMgZm9sbG93aW5nIHRoZSBsYXN0IE9wdGlvbmFsXG4gICAgICAgIGxldCBzdG9wX2luZGV4ID0gY29uc3VtZV9wb3NpdGlvbmFscyhzdGFydF9pbmRleClcblxuICAgICAgICAvLyBpZiB3ZSBkaWRuJ3QgY29uc3VtZSBhbGwgdGhlIGFyZ3VtZW50IHN0cmluZ3MsIHRoZXJlIHdlcmUgZXh0cmFzXG4gICAgICAgIGV4dHJhcyA9IGV4dHJhcy5jb25jYXQoYXJnX3N0cmluZ3Muc2xpY2Uoc3RvcF9pbmRleCkpXG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIGFsbCByZXF1aXJlZCBhY3Rpb25zIHdlcmUgcHJlc2VudCBhbmQgYWxzbyBjb252ZXJ0XG4gICAgICAgIC8vIGFjdGlvbiBkZWZhdWx0cyB3aGljaCB3ZXJlIG5vdCBnaXZlbiBhcyBhcmd1bWVudHNcbiAgICAgICAgbGV0IHJlcXVpcmVkX2FjdGlvbnMgPSBbXVxuICAgICAgICBmb3IgKGxldCBhY3Rpb24gb2YgdGhpcy5fYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFzZWVuX2FjdGlvbnMuaGFzKGFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkX2FjdGlvbnMucHVzaChfZ2V0X2FjdGlvbl9uYW1lKGFjdGlvbikpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBhY3Rpb24gZGVmYXVsdCBub3cgaW5zdGVhZCBvZiBkb2luZyBpdCBiZWZvcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFyc2luZyBhcmd1bWVudHMgdG8gYXZvaWQgY2FsbGluZyBjb252ZXJ0IGZ1bmN0aW9uc1xuICAgICAgICAgICAgICAgICAgICAvLyB0d2ljZSAod2hpY2ggbWF5IGZhaWwpIGlmIHRoZSBhcmd1bWVudCB3YXMgZ2l2ZW4sIGJ1dFxuICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGlmIGl0IHdhcyBkZWZpbmVkIGFscmVhZHkgaW4gdGhlIG5hbWVzcGFjZVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uLmRlZmF1bHQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGFjdGlvbi5kZWZhdWx0ID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzYXR0cihuYW1lc3BhY2UsIGFjdGlvbi5kZXN0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uLmRlZmF1bHQgPT09IGdldGF0dHIobmFtZXNwYWNlLCBhY3Rpb24uZGVzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldGF0dHIobmFtZXNwYWNlLCBhY3Rpb24uZGVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2V0X3ZhbHVlKGFjdGlvbiwgYWN0aW9uLmRlZmF1bHQpKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlcXVpcmVkX2FjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yKHN1YigndGhlIGZvbGxvd2luZyBhcmd1bWVudHMgYXJlIHJlcXVpcmVkOiAlcycsXG4gICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkX2FjdGlvbnMuam9pbignLCAnKSkpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHN1cmUgYWxsIHJlcXVpcmVkIGdyb3VwcyBoYWQgb25lIG9wdGlvbiBwcmVzZW50XG4gICAgICAgIGZvciAobGV0IGdyb3VwIG9mIHRoaXMuX211dHVhbGx5X2V4Y2x1c2l2ZV9ncm91cHMpIHtcbiAgICAgICAgICAgIGlmIChncm91cC5yZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgIGxldCBub19hY3Rpb25zX3VzZWQgPSB0cnVlXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYWN0aW9uIG9mIGdyb3VwLl9ncm91cF9hY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWVuX25vbl9kZWZhdWx0X2FjdGlvbnMuaGFzKGFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vX2FjdGlvbnNfdXNlZCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gYWN0aW9ucyB3ZXJlIHVzZWQsIHJlcG9ydCB0aGUgZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAobm9fYWN0aW9uc191c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuYW1lcyA9IGdyb3VwLl9ncm91cF9hY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGFjdGlvbiA9PiBhY3Rpb24uaGVscCAhPT0gU1VQUFJFU1MpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKGFjdGlvbiA9PiBfZ2V0X2FjdGlvbl9uYW1lKGFjdGlvbikpXG4gICAgICAgICAgICAgICAgICAgIGxldCBtc2cgPSAnb25lIG9mIHRoZSBhcmd1bWVudHMgJXMgaXMgcmVxdWlyZWQnXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3Ioc3ViKG1zZywgbmFtZXMuam9pbignICcpKSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gdGhlIHVwZGF0ZWQgbmFtZXNwYWNlIGFuZCB0aGUgZXh0cmEgYXJndW1lbnRzXG4gICAgICAgIHJldHVybiBbIG5hbWVzcGFjZSwgZXh0cmFzIF1cbiAgICB9XG5cbiAgICBfcmVhZF9hcmdzX2Zyb21fZmlsZXMoYXJnX3N0cmluZ3MpIHtcbiAgICAgICAgLy8gZXhwYW5kIGFyZ3VtZW50cyByZWZlcmVuY2luZyBmaWxlc1xuICAgICAgICBsZXQgbmV3X2FyZ19zdHJpbmdzID0gW11cbiAgICAgICAgZm9yIChsZXQgYXJnX3N0cmluZyBvZiBhcmdfc3RyaW5ncykge1xuXG4gICAgICAgICAgICAvLyBmb3IgcmVndWxhciBhcmd1bWVudHMsIGp1c3QgYWRkIHRoZW0gYmFjayBpbnRvIHRoZSBsaXN0XG4gICAgICAgICAgICBpZiAoIWFyZ19zdHJpbmcgfHwgIXRoaXMuZnJvbWZpbGVfcHJlZml4X2NoYXJzLmluY2x1ZGVzKGFyZ19zdHJpbmdbMF0pKSB7XG4gICAgICAgICAgICAgICAgbmV3X2FyZ19zdHJpbmdzLnB1c2goYXJnX3N0cmluZylcblxuICAgICAgICAgICAgLy8gcmVwbGFjZSBhcmd1bWVudHMgcmVmZXJlbmNpbmcgZmlsZXMgd2l0aCB0aGUgZmlsZSBjb250ZW50XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhcmdzX2ZpbGUgPSBmcy5yZWFkRmlsZVN5bmMoYXJnX3N0cmluZy5zbGljZSgxKSwgJ3V0ZjgnKVxuICAgICAgICAgICAgICAgICAgICBsZXQgYXJnX3N0cmluZ3MgPSBbXVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBhcmdfbGluZSBvZiBzcGxpdGxpbmVzKGFyZ3NfZmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGFyZyBvZiB0aGlzLmNvbnZlcnRfYXJnX2xpbmVfdG9fYXJncyhhcmdfbGluZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdfc3RyaW5ncy5wdXNoKGFyZylcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdfc3RyaW5ncyA9IHRoaXMuX3JlYWRfYXJnc19mcm9tX2ZpbGVzKGFyZ19zdHJpbmdzKVxuICAgICAgICAgICAgICAgICAgICBuZXdfYXJnX3N0cmluZ3MgPSBuZXdfYXJnX3N0cmluZ3MuY29uY2F0KGFyZ19zdHJpbmdzKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKGVyci5tZXNzYWdlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiB0aGUgbW9kaWZpZWQgYXJndW1lbnQgbGlzdFxuICAgICAgICByZXR1cm4gbmV3X2FyZ19zdHJpbmdzXG4gICAgfVxuXG4gICAgY29udmVydF9hcmdfbGluZV90b19hcmdzKGFyZ19saW5lKSB7XG4gICAgICAgIHJldHVybiBbYXJnX2xpbmVdXG4gICAgfVxuXG4gICAgX21hdGNoX2FyZ3VtZW50KGFjdGlvbiwgYXJnX3N0cmluZ3NfcGF0dGVybikge1xuICAgICAgICAvLyBtYXRjaCB0aGUgcGF0dGVybiBmb3IgdGhpcyBhY3Rpb24gdG8gdGhlIGFyZyBzdHJpbmdzXG4gICAgICAgIGxldCBuYXJnc19wYXR0ZXJuID0gdGhpcy5fZ2V0X25hcmdzX3BhdHRlcm4oYWN0aW9uKVxuICAgICAgICBsZXQgbWF0Y2ggPSBhcmdfc3RyaW5nc19wYXR0ZXJuLm1hdGNoKG5ldyBSZWdFeHAoJ14nICsgbmFyZ3NfcGF0dGVybikpXG5cbiAgICAgICAgLy8gcmFpc2UgYW4gZXhjZXB0aW9uIGlmIHdlIHdlcmVuJ3QgYWJsZSB0byBmaW5kIGEgbWF0Y2hcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgbmFyZ3NfZXJyb3JzID0ge1xuICAgICAgICAgICAgICAgIHVuZGVmaW5lZDogJ2V4cGVjdGVkIG9uZSBhcmd1bWVudCcsXG4gICAgICAgICAgICAgICAgW09QVElPTkFMXTogJ2V4cGVjdGVkIGF0IG1vc3Qgb25lIGFyZ3VtZW50JyxcbiAgICAgICAgICAgICAgICBbT05FX09SX01PUkVdOiAnZXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGFyZ3VtZW50J1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1zZyA9IG5hcmdzX2Vycm9yc1thY3Rpb24ubmFyZ3NdXG4gICAgICAgICAgICBpZiAobXNnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSBzdWIoYWN0aW9uLm5hcmdzID09PSAxID8gJ2V4cGVjdGVkICVzIGFyZ3VtZW50JyA6ICdleHBlY3RlZCAlcyBhcmd1bWVudHMnLCBhY3Rpb24ubmFyZ3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFcnJvcihhY3Rpb24sIG1zZylcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiB0aGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBtYXRjaGVkXG4gICAgICAgIHJldHVybiBtYXRjaFsxXS5sZW5ndGhcbiAgICB9XG5cbiAgICBfbWF0Y2hfYXJndW1lbnRzX3BhcnRpYWwoYWN0aW9ucywgYXJnX3N0cmluZ3NfcGF0dGVybikge1xuICAgICAgICAvLyBwcm9ncmVzc2l2ZWx5IHNob3J0ZW4gdGhlIGFjdGlvbnMgbGlzdCBieSBzbGljaW5nIG9mZiB0aGVcbiAgICAgICAgLy8gZmluYWwgYWN0aW9ucyB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2hcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdXG4gICAgICAgIGZvciAobGV0IGkgb2YgcmFuZ2UoYWN0aW9ucy5sZW5ndGgsIDAsIC0xKSkge1xuICAgICAgICAgICAgbGV0IGFjdGlvbnNfc2xpY2UgPSBhY3Rpb25zLnNsaWNlKDAsIGkpXG4gICAgICAgICAgICBsZXQgcGF0dGVybiA9IGFjdGlvbnNfc2xpY2UubWFwKGFjdGlvbiA9PiB0aGlzLl9nZXRfbmFyZ3NfcGF0dGVybihhY3Rpb24pKS5qb2luKCcnKVxuICAgICAgICAgICAgbGV0IG1hdGNoID0gYXJnX3N0cmluZ3NfcGF0dGVybi5tYXRjaChuZXcgUmVnRXhwKCdeJyArIHBhdHRlcm4pKVxuICAgICAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdChtYXRjaC5zbGljZSgxKS5tYXAoc3RyaW5nID0+IHN0cmluZy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgYXJnIHN0cmluZyBjb3VudHNcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cblxuICAgIF9wYXJzZV9vcHRpb25hbChhcmdfc3RyaW5nKSB7XG4gICAgICAgIC8vIGlmIGl0J3MgYW4gZW1wdHkgc3RyaW5nLCBpdCB3YXMgbWVhbnQgdG8gYmUgYSBwb3NpdGlvbmFsXG4gICAgICAgIGlmICghYXJnX3N0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXQgZG9lc24ndCBzdGFydCB3aXRoIGEgcHJlZml4LCBpdCB3YXMgbWVhbnQgdG8gYmUgcG9zaXRpb25hbFxuICAgICAgICBpZiAoIXRoaXMucHJlZml4X2NoYXJzLmluY2x1ZGVzKGFyZ19zdHJpbmdbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgb3B0aW9uIHN0cmluZyBpcyBwcmVzZW50IGluIHRoZSBwYXJzZXIsIHJldHVybiB0aGUgYWN0aW9uXG4gICAgICAgIGlmIChhcmdfc3RyaW5nIGluIHRoaXMuX29wdGlvbl9zdHJpbmdfYWN0aW9ucykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IHRoaXMuX29wdGlvbl9zdHJpbmdfYWN0aW9uc1thcmdfc3RyaW5nXVxuICAgICAgICAgICAgcmV0dXJuIFsgYWN0aW9uLCBhcmdfc3RyaW5nLCB1bmRlZmluZWQgXVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgaXQncyBqdXN0IGEgc2luZ2xlIGNoYXJhY3RlciwgaXQgd2FzIG1lYW50IHRvIGJlIHBvc2l0aW9uYWxcbiAgICAgICAgaWYgKGFyZ19zdHJpbmcubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgb3B0aW9uIHN0cmluZyBiZWZvcmUgdGhlIFwiPVwiIGlzIHByZXNlbnQsIHJldHVybiB0aGUgYWN0aW9uXG4gICAgICAgIGlmIChhcmdfc3RyaW5nLmluY2x1ZGVzKCc9JykpIHtcbiAgICAgICAgICAgIGxldCBbIG9wdGlvbl9zdHJpbmcsIGV4cGxpY2l0X2FyZyBdID0gX3N0cmluZ19zcGxpdChhcmdfc3RyaW5nLCAnPScsIDEpXG4gICAgICAgICAgICBpZiAob3B0aW9uX3N0cmluZyBpbiB0aGlzLl9vcHRpb25fc3RyaW5nX2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgYWN0aW9uID0gdGhpcy5fb3B0aW9uX3N0cmluZ19hY3Rpb25zW29wdGlvbl9zdHJpbmddXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsgYWN0aW9uLCBvcHRpb25fc3RyaW5nLCBleHBsaWNpdF9hcmcgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2VhcmNoIHRocm91Z2ggYWxsIHBvc3NpYmxlIHByZWZpeGVzIG9mIHRoZSBvcHRpb24gc3RyaW5nXG4gICAgICAgIC8vIGFuZCBhbGwgYWN0aW9ucyBpbiB0aGUgcGFyc2VyIGZvciBwb3NzaWJsZSBpbnRlcnByZXRhdGlvbnNcbiAgICAgICAgbGV0IG9wdGlvbl90dXBsZXMgPSB0aGlzLl9nZXRfb3B0aW9uX3R1cGxlcyhhcmdfc3RyaW5nKVxuXG4gICAgICAgIC8vIGlmIG11bHRpcGxlIGFjdGlvbnMgbWF0Y2gsIHRoZSBvcHRpb24gc3RyaW5nIHdhcyBhbWJpZ3VvdXNcbiAgICAgICAgaWYgKG9wdGlvbl90dXBsZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSBvcHRpb25fdHVwbGVzLm1hcCgoWyAvKmFjdGlvbiovLCBvcHRpb25fc3RyaW5nLyosIGV4cGxpY2l0X2FyZyovIF0pID0+IG9wdGlvbl9zdHJpbmcpLmpvaW4oJywgJylcbiAgICAgICAgICAgIGxldCBhcmdzID0ge29wdGlvbjogYXJnX3N0cmluZywgbWF0Y2hlczogb3B0aW9uc31cbiAgICAgICAgICAgIGxldCBtc2cgPSAnYW1iaWd1b3VzIG9wdGlvbjogJShvcHRpb24pcyBjb3VsZCBtYXRjaCAlKG1hdGNoZXMpcydcbiAgICAgICAgICAgIHRoaXMuZXJyb3Ioc3ViKG1zZywgYXJncykpXG5cbiAgICAgICAgLy8gaWYgZXhhY3RseSBvbmUgYWN0aW9uIG1hdGNoZWQsIHRoaXMgc2VnbWVudGF0aW9uIGlzIGdvb2QsXG4gICAgICAgIC8vIHNvIHJldHVybiB0aGUgcGFyc2VkIGFjdGlvblxuICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbl90dXBsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBsZXQgWyBvcHRpb25fdHVwbGUgXSA9IG9wdGlvbl90dXBsZXNcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25fdHVwbGVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGl0IHdhcyBub3QgZm91bmQgYXMgYW4gb3B0aW9uLCBidXQgaXQgbG9va3MgbGlrZSBhIG5lZ2F0aXZlXG4gICAgICAgIC8vIG51bWJlciwgaXQgd2FzIG1lYW50IHRvIGJlIHBvc2l0aW9uYWxcbiAgICAgICAgLy8gdW5sZXNzIHRoZXJlIGFyZSBuZWdhdGl2ZS1udW1iZXItbGlrZSBvcHRpb25zXG4gICAgICAgIGlmICh0aGlzLl9uZWdhdGl2ZV9udW1iZXJfbWF0Y2hlci50ZXN0KGFyZ19zdHJpbmcpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hhc19uZWdhdGl2ZV9udW1iZXJfb3B0aW9uYWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIGl0IGNvbnRhaW5zIGEgc3BhY2UsIGl0IHdhcyBtZWFudCB0byBiZSBhIHBvc2l0aW9uYWxcbiAgICAgICAgaWYgKGFyZ19zdHJpbmcuaW5jbHVkZXMoJyAnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXQgd2FzIG1lYW50IHRvIGJlIGFuIG9wdGlvbmFsIGJ1dCB0aGVyZSBpcyBubyBzdWNoIG9wdGlvblxuICAgICAgICAvLyBpbiB0aGlzIHBhcnNlciAodGhvdWdoIGl0IG1pZ2h0IGJlIGEgdmFsaWQgb3B0aW9uIGluIGEgc3VicGFyc2VyKVxuICAgICAgICByZXR1cm4gWyB1bmRlZmluZWQsIGFyZ19zdHJpbmcsIHVuZGVmaW5lZCBdXG4gICAgfVxuXG4gICAgX2dldF9vcHRpb25fdHVwbGVzKG9wdGlvbl9zdHJpbmcpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdXG5cbiAgICAgICAgLy8gb3B0aW9uIHN0cmluZ3Mgc3RhcnRpbmcgd2l0aCB0d28gcHJlZml4IGNoYXJhY3RlcnMgYXJlIG9ubHlcbiAgICAgICAgLy8gc3BsaXQgYXQgdGhlICc9J1xuICAgICAgICBsZXQgY2hhcnMgPSB0aGlzLnByZWZpeF9jaGFyc1xuICAgICAgICBpZiAoY2hhcnMuaW5jbHVkZXMob3B0aW9uX3N0cmluZ1swXSkgJiYgY2hhcnMuaW5jbHVkZXMob3B0aW9uX3N0cmluZ1sxXSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFsbG93X2FiYnJldikge1xuICAgICAgICAgICAgICAgIGxldCBvcHRpb25fcHJlZml4LCBleHBsaWNpdF9hcmdcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uX3N0cmluZy5pbmNsdWRlcygnPScpKSB7XG4gICAgICAgICAgICAgICAgICAgIFsgb3B0aW9uX3ByZWZpeCwgZXhwbGljaXRfYXJnIF0gPSBfc3RyaW5nX3NwbGl0KG9wdGlvbl9zdHJpbmcsICc9JywgMSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25fcHJlZml4ID0gb3B0aW9uX3N0cmluZ1xuICAgICAgICAgICAgICAgICAgICBleHBsaWNpdF9hcmcgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb3B0aW9uX3N0cmluZyBvZiBPYmplY3Qua2V5cyh0aGlzLl9vcHRpb25fc3RyaW5nX2FjdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25fc3RyaW5nLnN0YXJ0c1dpdGgob3B0aW9uX3ByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhY3Rpb24gPSB0aGlzLl9vcHRpb25fc3RyaW5nX2FjdGlvbnNbb3B0aW9uX3N0cmluZ11cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0dXAgPSBbIGFjdGlvbiwgb3B0aW9uX3N0cmluZywgZXhwbGljaXRfYXJnIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHR1cClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAvLyBzaW5nbGUgY2hhcmFjdGVyIG9wdGlvbnMgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIHRoZWlyIGFyZ3VtZW50c1xuICAgICAgICAvLyBidXQgbXVsdGlwbGUgY2hhcmFjdGVyIG9wdGlvbnMgYWx3YXlzIGhhdmUgdG8gaGF2ZSB0aGVpciBhcmd1bWVudFxuICAgICAgICAvLyBzZXBhcmF0ZVxuICAgICAgICB9IGVsc2UgaWYgKGNoYXJzLmluY2x1ZGVzKG9wdGlvbl9zdHJpbmdbMF0pICYmICFjaGFycy5pbmNsdWRlcyhvcHRpb25fc3RyaW5nWzFdKSkge1xuICAgICAgICAgICAgbGV0IG9wdGlvbl9wcmVmaXggPSBvcHRpb25fc3RyaW5nXG4gICAgICAgICAgICBsZXQgZXhwbGljaXRfYXJnID0gdW5kZWZpbmVkXG4gICAgICAgICAgICBsZXQgc2hvcnRfb3B0aW9uX3ByZWZpeCA9IG9wdGlvbl9zdHJpbmcuc2xpY2UoMCwgMilcbiAgICAgICAgICAgIGxldCBzaG9ydF9leHBsaWNpdF9hcmcgPSBvcHRpb25fc3RyaW5nLnNsaWNlKDIpXG5cbiAgICAgICAgICAgIGZvciAobGV0IG9wdGlvbl9zdHJpbmcgb2YgT2JqZWN0LmtleXModGhpcy5fb3B0aW9uX3N0cmluZ19hY3Rpb25zKSkge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25fc3RyaW5nID09PSBzaG9ydF9vcHRpb25fcHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhY3Rpb24gPSB0aGlzLl9vcHRpb25fc3RyaW5nX2FjdGlvbnNbb3B0aW9uX3N0cmluZ11cbiAgICAgICAgICAgICAgICAgICAgbGV0IHR1cCA9IFsgYWN0aW9uLCBvcHRpb25fc3RyaW5nLCBzaG9ydF9leHBsaWNpdF9hcmcgXVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0dXApXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25fc3RyaW5nLnN0YXJ0c1dpdGgob3B0aW9uX3ByZWZpeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGlvbiA9IHRoaXMuX29wdGlvbl9zdHJpbmdfYWN0aW9uc1tvcHRpb25fc3RyaW5nXVxuICAgICAgICAgICAgICAgICAgICBsZXQgdHVwID0gWyBhY3Rpb24sIG9wdGlvbl9zdHJpbmcsIGV4cGxpY2l0X2FyZyBdXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHR1cClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgLy8gc2hvdWxkbid0IGV2ZXIgZ2V0IGhlcmVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3Ioc3ViKCd1bmV4cGVjdGVkIG9wdGlvbiBzdHJpbmc6ICVzJywgb3B0aW9uX3N0cmluZykpXG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gdGhlIGNvbGxlY3RlZCBvcHRpb24gdHVwbGVzXG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG5cbiAgICBfZ2V0X25hcmdzX3BhdHRlcm4oYWN0aW9uKSB7XG4gICAgICAgIC8vIGluIGFsbCBleGFtcGxlcyBiZWxvdywgd2UgaGF2ZSB0byBhbGxvdyBmb3IgJy0tJyBhcmdzXG4gICAgICAgIC8vIHdoaWNoIGFyZSByZXByZXNlbnRlZCBhcyAnLScgaW4gdGhlIHBhdHRlcm5cbiAgICAgICAgbGV0IG5hcmdzID0gYWN0aW9uLm5hcmdzXG4gICAgICAgIGxldCBuYXJnc19wYXR0ZXJuXG5cbiAgICAgICAgLy8gdGhlIGRlZmF1bHQgKE5vbmUpIGlzIGFzc3VtZWQgdG8gYmUgYSBzaW5nbGUgYXJndW1lbnRcbiAgICAgICAgaWYgKG5hcmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5hcmdzX3BhdHRlcm4gPSAnKC0qQS0qKSdcblxuICAgICAgICAvLyBhbGxvdyB6ZXJvIG9yIG9uZSBhcmd1bWVudHNcbiAgICAgICAgfSBlbHNlIGlmIChuYXJncyA9PT0gT1BUSU9OQUwpIHtcbiAgICAgICAgICAgIG5hcmdzX3BhdHRlcm4gPSAnKC0qQT8tKiknXG5cbiAgICAgICAgLy8gYWxsb3cgemVybyBvciBtb3JlIGFyZ3VtZW50c1xuICAgICAgICB9IGVsc2UgaWYgKG5hcmdzID09PSBaRVJPX09SX01PUkUpIHtcbiAgICAgICAgICAgIG5hcmdzX3BhdHRlcm4gPSAnKC0qW0EtXSopJ1xuXG4gICAgICAgIC8vIGFsbG93IG9uZSBvciBtb3JlIGFyZ3VtZW50c1xuICAgICAgICB9IGVsc2UgaWYgKG5hcmdzID09PSBPTkVfT1JfTU9SRSkge1xuICAgICAgICAgICAgbmFyZ3NfcGF0dGVybiA9ICcoLSpBW0EtXSopJ1xuXG4gICAgICAgIC8vIGFsbG93IGFueSBudW1iZXIgb2Ygb3B0aW9ucyBvciBhcmd1bWVudHNcbiAgICAgICAgfSBlbHNlIGlmIChuYXJncyA9PT0gUkVNQUlOREVSKSB7XG4gICAgICAgICAgICBuYXJnc19wYXR0ZXJuID0gJyhbLUFPXSopJ1xuXG4gICAgICAgIC8vIGFsbG93IG9uZSBhcmd1bWVudCBmb2xsb3dlZCBieSBhbnkgbnVtYmVyIG9mIG9wdGlvbnMgb3IgYXJndW1lbnRzXG4gICAgICAgIH0gZWxzZSBpZiAobmFyZ3MgPT09IFBBUlNFUikge1xuICAgICAgICAgICAgbmFyZ3NfcGF0dGVybiA9ICcoLSpBWy1BT10qKSdcblxuICAgICAgICAvLyBzdXBwcmVzcyBhY3Rpb24sIGxpa2UgbmFyZ3M9MFxuICAgICAgICB9IGVsc2UgaWYgKG5hcmdzID09PSBTVVBQUkVTUykge1xuICAgICAgICAgICAgbmFyZ3NfcGF0dGVybiA9ICcoLSotKiknXG5cbiAgICAgICAgLy8gYWxsIG90aGVycyBzaG91bGQgYmUgaW50ZWdlcnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hcmdzX3BhdHRlcm4gPSBzdWIoJygtKiVzLSopJywgJ0EnLnJlcGVhdChuYXJncykuc3BsaXQoJycpLmpvaW4oJy0qJykpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIG9wdGlvbmFsIGFjdGlvbiwgLS0gaXMgbm90IGFsbG93ZWRcbiAgICAgICAgaWYgKGFjdGlvbi5vcHRpb25fc3RyaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG5hcmdzX3BhdHRlcm4gPSBuYXJnc19wYXR0ZXJuLnJlcGxhY2UoLy1cXCovZywgJycpXG4gICAgICAgICAgICBuYXJnc19wYXR0ZXJuID0gbmFyZ3NfcGF0dGVybi5yZXBsYWNlKC8tL2csICcnKVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBwYXR0ZXJuXG4gICAgICAgIHJldHVybiBuYXJnc19wYXR0ZXJuXG4gICAgfVxuXG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gQWx0IGNvbW1hbmQgbGluZSBhcmd1bWVudCBwYXJzaW5nLCBhbGxvd2luZyBmcmVlIGludGVybWl4XG4gICAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgICBwYXJzZV9pbnRlcm1peGVkX2FyZ3MoYXJncyA9IHVuZGVmaW5lZCwgbmFtZXNwYWNlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxldCBhcmd2XG4gICAgICAgIFsgYXJncywgYXJndiBdID0gdGhpcy5wYXJzZV9rbm93bl9pbnRlcm1peGVkX2FyZ3MoYXJncywgbmFtZXNwYWNlKVxuICAgICAgICBpZiAoYXJndi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBtc2cgPSAndW5yZWNvZ25pemVkIGFyZ3VtZW50czogJXMnXG4gICAgICAgICAgICB0aGlzLmVycm9yKHN1Yihtc2csIGFyZ3Yuam9pbignICcpKSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1xuICAgIH1cblxuICAgIHBhcnNlX2tub3duX2ludGVybWl4ZWRfYXJncyhhcmdzID0gdW5kZWZpbmVkLCBuYW1lc3BhY2UgPSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gcmV0dXJucyBhIG5hbWVzcGFjZSBhbmQgbGlzdCBvZiBleHRyYXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gcG9zaXRpb25hbCBjYW4gYmUgZnJlZWx5IGludGVybWl4ZWQgd2l0aCBvcHRpb25hbHMuICBvcHRpb25hbHMgYXJlXG4gICAgICAgIC8vIGZpcnN0IHBhcnNlZCB3aXRoIGFsbCBwb3NpdGlvbmFsIGFyZ3VtZW50cyBkZWFjdGl2YXRlZC4gIFRoZSAnZXh0cmFzJ1xuICAgICAgICAvLyBhcmUgdGhlbiBwYXJzZWQuICBJZiB0aGUgcGFyc2VyIGRlZmluaXRpb24gaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlXG4gICAgICAgIC8vIGludGVybWl4ZWQgYXNzdW1wdGlvbnMgKGUuZy4gdXNlIG9mIFJFTUFJTkRFUiwgc3VicGFyc2VycykgYVxuICAgICAgICAvLyBUeXBlRXJyb3IgaXMgcmFpc2VkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBwb3NpdGlvbmFscyBhcmUgJ2RlYWN0aXZhdGVkJyBieSBzZXR0aW5nIG5hcmdzIGFuZCBkZWZhdWx0IHRvXG4gICAgICAgIC8vIFNVUFBSRVNTLiAgVGhpcyBibG9ja3MgdGhlIGFkZGl0aW9uIG9mIHRoYXQgcG9zaXRpb25hbCB0byB0aGVcbiAgICAgICAgLy8gbmFtZXNwYWNlXG5cbiAgICAgICAgbGV0IGV4dHJhc1xuICAgICAgICBsZXQgcG9zaXRpb25hbHMgPSB0aGlzLl9nZXRfcG9zaXRpb25hbF9hY3Rpb25zKClcbiAgICAgICAgbGV0IGEgPSBwb3NpdGlvbmFscy5maWx0ZXIoYWN0aW9uID0+IFsgUEFSU0VSLCBSRU1BSU5ERVIgXS5pbmNsdWRlcyhhY3Rpb24ubmFyZ3MpKVxuICAgICAgICBpZiAoYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3Ioc3ViKCdwYXJzZV9pbnRlcm1peGVkX2FyZ3M6IHBvc2l0aW9uYWwgYXJnJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnIHdpdGggbmFyZ3M9JXMnLCBhWzBdLm5hcmdzKSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGdyb3VwIG9mIHRoaXMuX211dHVhbGx5X2V4Y2x1c2l2ZV9ncm91cHMpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGFjdGlvbiBvZiBncm91cC5fZ3JvdXBfYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbmFscy5pbmNsdWRlcyhhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcnNlX2ludGVybWl4ZWRfYXJnczogcG9zaXRpb25hbCBpbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgbXV0dWFsbHlFeGNsdXNpdmVHcm91cCcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHNhdmVfdXNhZ2VcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNhdmVfdXNhZ2UgPSB0aGlzLnVzYWdlXG4gICAgICAgICAgICBsZXQgcmVtYWluaW5nX2FyZ3NcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudXNhZ2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYXB0dXJlIHRoZSBmdWxsIHVzYWdlIGZvciB1c2UgaW4gZXJyb3IgbWVzc2FnZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51c2FnZSA9IHRoaXMuZm9ybWF0X3VzYWdlKCkuc2xpY2UoNylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYWN0aW9uIG9mIHBvc2l0aW9uYWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRlYWN0aXZhdGUgcG9zaXRpb25hbHNcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uLnNhdmVfbmFyZ3MgPSBhY3Rpb24ubmFyZ3NcbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0aW9uLm5hcmdzID0gMFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24ubmFyZ3MgPSBTVVBQUkVTU1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24uc2F2ZV9kZWZhdWx0ID0gYWN0aW9uLmRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uLmRlZmF1bHQgPSBTVVBQUkVTU1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBbIG5hbWVzcGFjZSwgcmVtYWluaW5nX2FyZ3MgXSA9IHRoaXMucGFyc2Vfa25vd25fYXJncyhhcmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZSlcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhY3Rpb24gb2YgcG9zaXRpb25hbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBlbXB0eSBwb3NpdGlvbmFsIHZhbHVlcyBmcm9tIG5hbWVzcGFjZVxuICAgICAgICAgICAgICAgICAgICBsZXQgYXR0ciA9IGdldGF0dHIobmFtZXNwYWNlLCBhY3Rpb24uZGVzdClcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cikgJiYgYXR0ci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oc3ViKCdEbyBub3QgZXhwZWN0ICVzIGluICVzJywgYWN0aW9uLmRlc3QsIG5hbWVzcGFjZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxhdHRyKG5hbWVzcGFjZSwgYWN0aW9uLmRlc3QpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgbmFyZ3MgYW5kIHVzYWdlIGJlZm9yZSBleGl0aW5nXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYWN0aW9uIG9mIHBvc2l0aW9uYWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbi5uYXJncyA9IGFjdGlvbi5zYXZlX25hcmdzXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbi5kZWZhdWx0ID0gYWN0aW9uLnNhdmVfZGVmYXVsdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBvcHRpb25hbHMgPSB0aGlzLl9nZXRfb3B0aW9uYWxfYWN0aW9ucygpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIHBhcnNlIHBvc2l0aW9uYWxzLiAgb3B0aW9uYWxzIGFyZW4ndCBub3JtYWxseSByZXF1aXJlZCwgYnV0XG4gICAgICAgICAgICAgICAgLy8gdGhleSBjb3VsZCBiZSwgc28gbWFrZSBzdXJlIHRoZXkgYXJlbid0LlxuICAgICAgICAgICAgICAgIGZvciAobGV0IGFjdGlvbiBvZiBvcHRpb25hbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uLnNhdmVfcmVxdWlyZWQgPSBhY3Rpb24ucmVxdWlyZWRcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uLnJlcXVpcmVkID0gZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXAgb2YgdGhpcy5fbXV0dWFsbHlfZXhjbHVzaXZlX2dyb3Vwcykge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5zYXZlX3JlcXVpcmVkID0gZ3JvdXAucmVxdWlyZWRcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXAucmVxdWlyZWQgPSBmYWxzZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBbIG5hbWVzcGFjZSwgZXh0cmFzIF0gPSB0aGlzLnBhcnNlX2tub3duX2FyZ3MocmVtYWluaW5nX2FyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWVzcGFjZSlcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLy8gcmVzdG9yZSBwYXJzZXIgdmFsdWVzIGJlZm9yZSBleGl0aW5nXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYWN0aW9uIG9mIG9wdGlvbmFscykge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb24ucmVxdWlyZWQgPSBhY3Rpb24uc2F2ZV9yZXF1aXJlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBncm91cCBvZiB0aGlzLl9tdXR1YWxseV9leGNsdXNpdmVfZ3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnJlcXVpcmVkID0gZ3JvdXAuc2F2ZV9yZXF1aXJlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMudXNhZ2UgPSBzYXZlX3VzYWdlXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsgbmFtZXNwYWNlLCBleHRyYXMgXVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIFZhbHVlIGNvbnZlcnNpb24gbWV0aG9kc1xuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIF9nZXRfdmFsdWVzKGFjdGlvbiwgYXJnX3N0cmluZ3MpIHtcbiAgICAgICAgLy8gZm9yIGV2ZXJ5dGhpbmcgYnV0IFBBUlNFUiwgUkVNQUlOREVSIGFyZ3MsIHN0cmlwIG91dCBmaXJzdCAnLS0nXG4gICAgICAgIGlmICghW1BBUlNFUiwgUkVNQUlOREVSXS5pbmNsdWRlcyhhY3Rpb24ubmFyZ3MpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9hcnJheV9yZW1vdmUoYXJnX3N0cmluZ3MsICctLScpXG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgdmFsdWVcbiAgICAgICAgLy8gb3B0aW9uYWwgYXJndW1lbnQgcHJvZHVjZXMgYSBkZWZhdWx0IHdoZW4gbm90IHByZXNlbnRcbiAgICAgICAgaWYgKCFhcmdfc3RyaW5ncy5sZW5ndGggJiYgYWN0aW9uLm5hcmdzID09PSBPUFRJT05BTCkge1xuICAgICAgICAgICAgaWYgKGFjdGlvbi5vcHRpb25fc3RyaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFjdGlvbi5jb25zdFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGFjdGlvbi5kZWZhdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fZ2V0X3ZhbHVlKGFjdGlvbiwgdmFsdWUpXG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tfdmFsdWUoYWN0aW9uLCB2YWx1ZSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAvLyB3aGVuIG5hcmdzPScqJyBvbiBhIHBvc2l0aW9uYWwsIGlmIHRoZXJlIHdlcmUgbm8gY29tbWFuZC1saW5lXG4gICAgICAgIC8vIGFyZ3MsIHVzZSB0aGUgZGVmYXVsdCBpZiBpdCBpcyBhbnl0aGluZyBvdGhlciB0aGFuIE5vbmVcbiAgICAgICAgfSBlbHNlIGlmICghYXJnX3N0cmluZ3MubGVuZ3RoICYmIGFjdGlvbi5uYXJncyA9PT0gWkVST19PUl9NT1JFICYmXG4gICAgICAgICAgICAgICFhY3Rpb24ub3B0aW9uX3N0cmluZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoYWN0aW9uLmRlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gYWN0aW9uLmRlZmF1bHRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhcmdfc3RyaW5nc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fY2hlY2tfdmFsdWUoYWN0aW9uLCB2YWx1ZSlcblxuICAgICAgICAvLyBzaW5nbGUgYXJndW1lbnQgb3Igb3B0aW9uYWwgYXJndW1lbnQgcHJvZHVjZXMgYSBzaW5nbGUgdmFsdWVcbiAgICAgICAgfSBlbHNlIGlmIChhcmdfc3RyaW5ncy5sZW5ndGggPT09IDEgJiYgW3VuZGVmaW5lZCwgT1BUSU9OQUxdLmluY2x1ZGVzKGFjdGlvbi5uYXJncykpIHtcbiAgICAgICAgICAgIGxldCBhcmdfc3RyaW5nID0gYXJnX3N0cmluZ3NbMF1cbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5fZ2V0X3ZhbHVlKGFjdGlvbiwgYXJnX3N0cmluZylcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrX3ZhbHVlKGFjdGlvbiwgdmFsdWUpXG5cbiAgICAgICAgLy8gUkVNQUlOREVSIGFyZ3VtZW50cyBjb252ZXJ0IGFsbCB2YWx1ZXMsIGNoZWNraW5nIG5vbmVcbiAgICAgICAgfSBlbHNlIGlmIChhY3Rpb24ubmFyZ3MgPT09IFJFTUFJTkRFUikge1xuICAgICAgICAgICAgdmFsdWUgPSBhcmdfc3RyaW5ncy5tYXAodiA9PiB0aGlzLl9nZXRfdmFsdWUoYWN0aW9uLCB2KSlcblxuICAgICAgICAvLyBQQVJTRVIgYXJndW1lbnRzIGNvbnZlcnQgYWxsIHZhbHVlcywgYnV0IGNoZWNrIG9ubHkgdGhlIGZpcnN0XG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uLm5hcmdzID09PSBQQVJTRVIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYXJnX3N0cmluZ3MubWFwKHYgPT4gdGhpcy5fZ2V0X3ZhbHVlKGFjdGlvbiwgdikpXG4gICAgICAgICAgICB0aGlzLl9jaGVja192YWx1ZShhY3Rpb24sIHZhbHVlWzBdKVxuXG4gICAgICAgIC8vIFNVUFBSRVNTIGFyZ3VtZW50IGRvZXMgbm90IHB1dCBhbnl0aGluZyBpbiB0aGUgbmFtZXNwYWNlXG4gICAgICAgIH0gZWxzZSBpZiAoYWN0aW9uLm5hcmdzID09PSBTVVBQUkVTUykge1xuICAgICAgICAgICAgdmFsdWUgPSBTVVBQUkVTU1xuXG4gICAgICAgIC8vIGFsbCBvdGhlciB0eXBlcyBvZiBuYXJncyBwcm9kdWNlIGEgbGlzdFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBhcmdfc3RyaW5ncy5tYXAodiA9PiB0aGlzLl9nZXRfdmFsdWUoYWN0aW9uLCB2KSlcbiAgICAgICAgICAgIGZvciAobGV0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja192YWx1ZShhY3Rpb24sIHYpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gdGhlIGNvbnZlcnRlZCB2YWx1ZVxuICAgICAgICByZXR1cm4gdmFsdWVcbiAgICB9XG5cbiAgICBfZ2V0X3ZhbHVlKGFjdGlvbiwgYXJnX3N0cmluZykge1xuICAgICAgICBsZXQgdHlwZV9mdW5jID0gdGhpcy5fcmVnaXN0cnlfZ2V0KCd0eXBlJywgYWN0aW9uLnR5cGUsIGFjdGlvbi50eXBlKVxuICAgICAgICBpZiAodHlwZW9mIHR5cGVfZnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbGV0IG1zZyA9ICclciBpcyBub3QgY2FsbGFibGUnXG4gICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFcnJvcihhY3Rpb24sIHN1Yihtc2csIHR5cGVfZnVuYykpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb252ZXJ0IHRoZSB2YWx1ZSB0byB0aGUgYXBwcm9wcmlhdGUgdHlwZVxuICAgICAgICBsZXQgcmVzdWx0XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHR5cGVfZnVuYyhhcmdfc3RyaW5nKVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gRGVhciBUQzM5LCB3aHkgd291bGQgeW91IGV2ZXIgY29uc2lkZXIgbWFraW5nIGVzNiBjbGFzc2VzIG5vdCBjYWxsYWJsZT9cbiAgICAgICAgICAgICAgICAvLyBXZSBoYWQgb25lIHVuaXZlcnNhbCBpbnRlcmZhY2UsIFtbQ2FsbF1dLCB3aGljaCB3b3JrZWQgZm9yIGFueXRoaW5nXG4gICAgICAgICAgICAgICAgLy8gKHdpdGggZmFtaWxpYXIgdGhpcy1pbnN0YW5jZW9mIGd1YXJkIGZvciBjbGFzc2VzKS4gTm93IHdlIGhhdmUgdHdvLlxuICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgL0NsYXNzIGNvbnN0cnVjdG9yIC4qIGNhbm5vdCBiZSBpbnZva2VkIHdpdGhvdXQgJ25ldycvLnRlc3QoZXJyLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyB0eXBlX2Z1bmMoYXJnX3N0cmluZylcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBBcmd1bWVudFR5cGVFcnJvcnMgaW5kaWNhdGUgZXJyb3JzXG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQXJndW1lbnRUeXBlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvL2xldCBuYW1lID0gZ2V0YXR0cihhY3Rpb24udHlwZSwgJ25hbWUnLCByZXByKGFjdGlvbi50eXBlKSlcbiAgICAgICAgICAgICAgICBsZXQgbXNnID0gZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXJndW1lbnRFcnJvcihhY3Rpb24sIG1zZylcblxuICAgICAgICAgICAgLy8gVHlwZUVycm9ycyBvciBWYWx1ZUVycm9ycyBhbHNvIGluZGljYXRlIGVycm9yc1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmFtZSA9IGdldGF0dHIoYWN0aW9uLnR5cGUsICduYW1lJywgcmVwcihhY3Rpb24udHlwZSkpXG4gICAgICAgICAgICAgICAgbGV0IGFyZ3MgPSB7dHlwZTogbmFtZSwgdmFsdWU6IGFyZ19zdHJpbmd9XG4gICAgICAgICAgICAgICAgbGV0IG1zZyA9ICdpbnZhbGlkICUodHlwZSlzIHZhbHVlOiAlKHZhbHVlKXInXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXJyb3IoYWN0aW9uLCBzdWIobXNnLCBhcmdzKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXR1cm4gdGhlIGNvbnZlcnRlZCB2YWx1ZVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgX2NoZWNrX3ZhbHVlKGFjdGlvbiwgdmFsdWUpIHtcbiAgICAgICAgLy8gY29udmVydGVkIHZhbHVlIG11c3QgYmUgb25lIG9mIHRoZSBjaG9pY2VzIChpZiBzcGVjaWZpZWQpXG4gICAgICAgIGlmIChhY3Rpb24uY2hvaWNlcyAhPT0gdW5kZWZpbmVkICYmICFfY2hvaWNlc190b19hcnJheShhY3Rpb24uY2hvaWNlcykuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICBsZXQgYXJncyA9IHt2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNob2ljZXM6IF9jaG9pY2VzX3RvX2FycmF5KGFjdGlvbi5jaG9pY2VzKS5tYXAocmVwcikuam9pbignLCAnKX1cbiAgICAgICAgICAgIGxldCBtc2cgPSAnaW52YWxpZCBjaG9pY2U6ICUodmFsdWUpciAoY2hvb3NlIGZyb20gJShjaG9pY2VzKXMpJ1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFyZ3VtZW50RXJyb3IoYWN0aW9uLCBzdWIobXNnLCBhcmdzKSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PT09PT09PT09XG4gICAgLy8gSGVscC1mb3JtYXR0aW5nIG1ldGhvZHNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT09PVxuICAgIGZvcm1hdF91c2FnZSgpIHtcbiAgICAgICAgbGV0IGZvcm1hdHRlciA9IHRoaXMuX2dldF9mb3JtYXR0ZXIoKVxuICAgICAgICBmb3JtYXR0ZXIuYWRkX3VzYWdlKHRoaXMudXNhZ2UsIHRoaXMuX2FjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXV0dWFsbHlfZXhjbHVzaXZlX2dyb3VwcylcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXRfaGVscCgpXG4gICAgfVxuXG4gICAgZm9ybWF0X2hlbHAoKSB7XG4gICAgICAgIGxldCBmb3JtYXR0ZXIgPSB0aGlzLl9nZXRfZm9ybWF0dGVyKClcblxuICAgICAgICAvLyB1c2FnZVxuICAgICAgICBmb3JtYXR0ZXIuYWRkX3VzYWdlKHRoaXMudXNhZ2UsIHRoaXMuX2FjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbXV0dWFsbHlfZXhjbHVzaXZlX2dyb3VwcylcblxuICAgICAgICAvLyBkZXNjcmlwdGlvblxuICAgICAgICBmb3JtYXR0ZXIuYWRkX3RleHQodGhpcy5kZXNjcmlwdGlvbilcblxuICAgICAgICAvLyBwb3NpdGlvbmFscywgb3B0aW9uYWxzIGFuZCB1c2VyLWRlZmluZWQgZ3JvdXBzXG4gICAgICAgIGZvciAobGV0IGFjdGlvbl9ncm91cCBvZiB0aGlzLl9hY3Rpb25fZ3JvdXBzKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZXIuc3RhcnRfc2VjdGlvbihhY3Rpb25fZ3JvdXAudGl0bGUpXG4gICAgICAgICAgICBmb3JtYXR0ZXIuYWRkX3RleHQoYWN0aW9uX2dyb3VwLmRlc2NyaXB0aW9uKVxuICAgICAgICAgICAgZm9ybWF0dGVyLmFkZF9hcmd1bWVudHMoYWN0aW9uX2dyb3VwLl9ncm91cF9hY3Rpb25zKVxuICAgICAgICAgICAgZm9ybWF0dGVyLmVuZF9zZWN0aW9uKClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVwaWxvZ1xuICAgICAgICBmb3JtYXR0ZXIuYWRkX3RleHQodGhpcy5lcGlsb2cpXG5cbiAgICAgICAgLy8gZGV0ZXJtaW5lIGhlbHAgZnJvbSBmb3JtYXQgYWJvdmVcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXRfaGVscCgpXG4gICAgfVxuXG4gICAgX2dldF9mb3JtYXR0ZXIoKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuZXctY2FwXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5mb3JtYXR0ZXJfY2xhc3MoeyBwcm9nOiB0aGlzLnByb2cgfSlcbiAgICB9XG5cbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBIZWxwLXByaW50aW5nIG1ldGhvZHNcbiAgICAvLyA9PT09PT09PT09PT09PT09PT09PT1cbiAgICBwcmludF91c2FnZShmaWxlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChmaWxlID09PSB1bmRlZmluZWQpIGZpbGUgPSBwcm9jZXNzLnN0ZG91dFxuICAgICAgICB0aGlzLl9wcmludF9tZXNzYWdlKHRoaXMuZm9ybWF0X3VzYWdlKCksIGZpbGUpXG4gICAgfVxuXG4gICAgcHJpbnRfaGVscChmaWxlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChmaWxlID09PSB1bmRlZmluZWQpIGZpbGUgPSBwcm9jZXNzLnN0ZG91dFxuICAgICAgICB0aGlzLl9wcmludF9tZXNzYWdlKHRoaXMuZm9ybWF0X2hlbHAoKSwgZmlsZSlcbiAgICB9XG5cbiAgICBfcHJpbnRfbWVzc2FnZShtZXNzYWdlLCBmaWxlID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoZmlsZSA9PT0gdW5kZWZpbmVkKSBmaWxlID0gcHJvY2Vzcy5zdGRlcnJcbiAgICAgICAgICAgIGZpbGUud3JpdGUobWVzc2FnZSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vID09PT09PT09PT09PT09PVxuICAgIC8vIEV4aXRpbmcgbWV0aG9kc1xuICAgIC8vID09PT09PT09PT09PT09PVxuICAgIGV4aXQoc3RhdHVzID0gMCwgbWVzc2FnZSA9IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgdGhpcy5fcHJpbnRfbWVzc2FnZShtZXNzYWdlLCBwcm9jZXNzLnN0ZGVycilcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLmV4aXQoc3RhdHVzKVxuICAgIH1cblxuICAgIGVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogIGVycm9yKG1lc3NhZ2U6IHN0cmluZylcbiAgICAgICAgICpcbiAgICAgICAgICogIFByaW50cyBhIHVzYWdlIG1lc3NhZ2UgaW5jb3Jwb3JhdGluZyB0aGUgbWVzc2FnZSB0byBzdGRlcnIgYW5kXG4gICAgICAgICAqICBleGl0cy5cbiAgICAgICAgICpcbiAgICAgICAgICogIElmIHlvdSBvdmVycmlkZSB0aGlzIGluIGEgc3ViY2xhc3MsIGl0IHNob3VsZCBub3QgcmV0dXJuIC0tIGl0XG4gICAgICAgICAqICBzaG91bGQgZWl0aGVyIGV4aXQgb3IgcmFpc2UgYW4gZXhjZXB0aW9uLlxuICAgICAgICAgKi9cblxuICAgICAgICAvLyBMRUdBQ1kgKHYxIGNvbXBhdGliaWxpdHkpLCBkZWJ1ZyBtb2RlXG4gICAgICAgIGlmICh0aGlzLmRlYnVnID09PSB0cnVlKSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICAgICAgLy8gZW5kXG4gICAgICAgIHRoaXMucHJpbnRfdXNhZ2UocHJvY2Vzcy5zdGRlcnIpXG4gICAgICAgIGxldCBhcmdzID0ge3Byb2c6IHRoaXMucHJvZywgbWVzc2FnZTogbWVzc2FnZX1cbiAgICAgICAgdGhpcy5leGl0KDIsIHN1YignJShwcm9nKXM6IGVycm9yOiAlKG1lc3NhZ2Upc1xcbicsIGFyZ3MpKVxuICAgIH1cbn0pKVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEFyZ3VtZW50UGFyc2VyLFxuICAgIEFyZ3VtZW50RXJyb3IsXG4gICAgQXJndW1lbnRUeXBlRXJyb3IsXG4gICAgQm9vbGVhbk9wdGlvbmFsQWN0aW9uLFxuICAgIEZpbGVUeXBlLFxuICAgIEhlbHBGb3JtYXR0ZXIsXG4gICAgQXJndW1lbnREZWZhdWx0c0hlbHBGb3JtYXR0ZXIsXG4gICAgUmF3RGVzY3JpcHRpb25IZWxwRm9ybWF0dGVyLFxuICAgIFJhd1RleHRIZWxwRm9ybWF0dGVyLFxuICAgIE1ldGF2YXJUeXBlSGVscEZvcm1hdHRlcixcbiAgICBOYW1lc3BhY2UsXG4gICAgQWN0aW9uLFxuICAgIE9ORV9PUl9NT1JFLFxuICAgIE9QVElPTkFMLFxuICAgIFBBUlNFUixcbiAgICBSRU1BSU5ERVIsXG4gICAgU1VQUFJFU1MsXG4gICAgWkVST19PUl9NT1JFXG59XG5cbi8vIExFR0FDWSAodjEgY29tcGF0aWJpbGl0eSksIENvbnN0IGFsaWFzXG5PYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdDb25zdCcsIHtcbiAgICBnZXQoKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7fVxuICAgICAgICBPYmplY3QuZW50cmllcyh7IE9ORV9PUl9NT1JFLCBPUFRJT05BTCwgUEFSU0VSLCBSRU1BSU5ERVIsIFNVUFBSRVNTLCBaRVJPX09SX01PUkUgfSkuZm9yRWFjaCgoWyBuLCB2IF0pID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIG4sIHtcbiAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlcHJlY2F0ZShuLCBzdWIoJ3VzZSBhcmdwYXJzZS4lcyBpbnN0ZWFkIG9mIGFyZ3BhcnNlLkNvbnN0LiVzJywgbiwgbikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoeyBfVU5SRUNPR05JWkVEX0FSR1NfQVRUUiB9KS5mb3JFYWNoKChbIG4sIHYgXSkgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgbiwge1xuICAgICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwcmVjYXRlKG4sIHN1YignYXJncGFyc2UuQ29uc3QuJXMgaXMgYW4gaW50ZXJuYWwgc3ltYm9sIGFuZCB3aWxsIG5vIGxvbmdlciBiZSBhdmFpbGFibGUnLCBuKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxufSlcbi8vIGVuZFxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiYXNzZXJ0XCIpOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInV0aWxcIik7IiwiLy8gTGltaXRlZCBpbXBsZW1lbnRhdGlvbiBvZiBweXRob24gJSBzdHJpbmcgb3BlcmF0b3IsIHN1cHBvcnRzIG9ubHkgJXMgYW5kICVyIGZvciBub3dcbi8vIChvdGhlciBmb3JtYXRzIGFyZSBub3QgdXNlZCBoZXJlLCBidXQgbWF5IGFwcGVhciBpbiBjdXN0b20gdGVtcGxhdGVzKVxuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgeyBpbnNwZWN0IH0gPSByZXF1aXJlKCd1dGlsJylcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN1YihwYXR0ZXJuLCAuLi52YWx1ZXMpIHtcbiAgICBsZXQgcmVnZXggPSAvJSg/OiglKXwoLSk/KFxcKik/KD86XFwoKFxcdyspXFwpKT8oW0EtWmEtel0pKS9nXG5cbiAgICBsZXQgcmVzdWx0ID0gcGF0dGVybi5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbiAoXywgaXNfbGl0ZXJhbCwgaXNfbGVmdF9hbGlnbiwgaXNfcGFkZGVkLCBuYW1lLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKGlzX2xpdGVyYWwpIHJldHVybiAnJSdcblxuICAgICAgICBsZXQgcGFkZGVkX2NvdW50ID0gMFxuICAgICAgICBpZiAoaXNfcGFkZGVkKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGVub3VnaCBhcmd1bWVudHMgZm9yIGZvcm1hdCBzdHJpbmcnKVxuICAgICAgICAgICAgcGFkZGVkX2NvdW50ID0gdmFsdWVzLnNoaWZ0KClcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihwYWRkZWRfY291bnQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCcqIHdhbnRzIGludCcpXG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RyXG4gICAgICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBkaWN0ID0gdmFsdWVzWzBdXG4gICAgICAgICAgICBpZiAodHlwZW9mIGRpY3QgIT09ICdvYmplY3QnIHx8IGRpY3QgPT09IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Zvcm1hdCByZXF1aXJlcyBhIG1hcHBpbmcnKVxuICAgICAgICAgICAgaWYgKCEobmFtZSBpbiBkaWN0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihgbm8gc3VjaCBrZXk6ICcke25hbWV9J2ApXG4gICAgICAgICAgICBzdHIgPSBkaWN0W25hbWVdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGVub3VnaCBhcmd1bWVudHMgZm9yIGZvcm1hdCBzdHJpbmcnKVxuICAgICAgICAgICAgc3RyID0gdmFsdWVzLnNoaWZ0KClcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICBzdHIgPSBTdHJpbmcoc3RyKVxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICBzdHIgPSBpbnNwZWN0KHN0cilcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJSR7Zm9ybWF0fSBmb3JtYXQ6IGEgbnVtYmVyIGlzIHJlcXVpcmVkLCBub3QgJHt0eXBlb2Ygc3RyfWApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0ciA9IFN0cmluZyhzdHIudG9GaXhlZCgwKSlcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCBmb3JtYXQgY2hhcmFjdGVyICcke2Zvcm1hdH0nYClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYWRkZWRfY291bnQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNfbGVmdF9hbGlnbiA/IHN0ci5wYWRFbmQocGFkZGVkX2NvdW50KSA6IHN0ci5wYWRTdGFydChwYWRkZWRfY291bnQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyXG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIHZhbHVlc1swXSA9PT0gJ29iamVjdCcgJiYgdmFsdWVzWzBdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBtYXBwaW5nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYWxsIGFyZ3VtZW50cyBjb252ZXJ0ZWQgZHVyaW5nIHN0cmluZyBmb3JtYXR0aW5nJylcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInBhdGhcIik7IiwiLy8gUGFydGlhbCBwb3J0IG9mIHB5dGhvbidzIGFyZ3BhcnNlIG1vZHVsZSwgdmVyc2lvbiAzLjkuMCAob25seSB3cmFwIGFuZCBmaWxsIGZ1bmN0aW9ucyk6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vcHl0aG9uL2NweXRob24vYmxvYi92My45LjBiNC9MaWIvdGV4dHdyYXAucHlcblxuJ3VzZSBzdHJpY3QnXG5cbi8qXG4gKiBUZXh0IHdyYXBwaW5nIGFuZCBmaWxsaW5nLlxuICovXG5cbi8vIENvcHlyaWdodCAoQykgMTk5OS0yMDAxIEdyZWdvcnkgUC4gV2FyZC5cbi8vIENvcHlyaWdodCAoQykgMjAwMiwgMjAwMyBQeXRob24gU29mdHdhcmUgRm91bmRhdGlvbi5cbi8vIENvcHlyaWdodCAoQykgMjAyMCBhcmdwYXJzZS5qcyBhdXRob3JzXG4vLyBPcmlnaW5hbGx5IHdyaXR0ZW4gYnkgR3JlZyBXYXJkIDxnd2FyZEBweXRob24ubmV0PlxuXG4vLyBIYXJkY29kZSB0aGUgcmVjb2duaXplZCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMgdG8gdGhlIFVTLUFTQ0lJXG4vLyB3aGl0ZXNwYWNlIGNoYXJhY3RlcnMuICBUaGUgbWFpbiByZWFzb24gZm9yIGRvaW5nIHRoaXMgaXMgdGhhdFxuLy8gc29tZSBVbmljb2RlIHNwYWNlcyAobGlrZSBcXHUwMGEwKSBhcmUgbm9uLWJyZWFraW5nIHdoaXRlc3BhY2VzLlxuLy9cbi8vIFRoaXMgbGVzcyBmdW5reSBsaXR0bGUgcmVnZXgganVzdCBzcGxpdCBvbiByZWNvZ25pemVkIHNwYWNlcy4gRS5nLlxuLy8gICBcIkhlbGxvIHRoZXJlIC0tIHlvdSBnb29mLWJhbGwsIHVzZSB0aGUgLWIgb3B0aW9uIVwiXG4vLyBzcGxpdHMgaW50b1xuLy8gICBIZWxsby8gL3RoZXJlLyAvLS0vIC95b3UvIC9nb29mLWJhbGwsLyAvdXNlLyAvdGhlLyAvLWIvIC9vcHRpb24hL1xuY29uc3Qgd29yZHNlcF9zaW1wbGVfcmUgPSAvKFtcXHRcXG5cXHgwYlxceDBjXFxyIF0rKS9cblxuY2xhc3MgVGV4dFdyYXBwZXIge1xuICAgIC8qXG4gICAgICogIE9iamVjdCBmb3Igd3JhcHBpbmcvZmlsbGluZyB0ZXh0LiAgVGhlIHB1YmxpYyBpbnRlcmZhY2UgY29uc2lzdHMgb2ZcbiAgICAgKiAgdGhlIHdyYXAoKSBhbmQgZmlsbCgpIG1ldGhvZHM7IHRoZSBvdGhlciBtZXRob2RzIGFyZSBqdXN0IHRoZXJlIGZvclxuICAgICAqICBzdWJjbGFzc2VzIHRvIG92ZXJyaWRlIGluIG9yZGVyIHRvIHR3ZWFrIHRoZSBkZWZhdWx0IGJlaGF2aW91ci5cbiAgICAgKiAgSWYgeW91IHdhbnQgdG8gY29tcGxldGVseSByZXBsYWNlIHRoZSBtYWluIHdyYXBwaW5nIGFsZ29yaXRobSxcbiAgICAgKiAgeW91J2xsIHByb2JhYmx5IGhhdmUgdG8gb3ZlcnJpZGUgX3dyYXBfY2h1bmtzKCkuXG4gICAgICpcbiAgICAgKiAgU2V2ZXJhbCBpbnN0YW5jZSBhdHRyaWJ1dGVzIGNvbnRyb2wgdmFyaW91cyBhc3BlY3RzIG9mIHdyYXBwaW5nOlxuICAgICAqICAgIHdpZHRoIChkZWZhdWx0OiA3MClcbiAgICAgKiAgICAgIHRoZSBtYXhpbXVtIHdpZHRoIG9mIHdyYXBwZWQgbGluZXMgKHVubGVzcyBicmVha19sb25nX3dvcmRzXG4gICAgICogICAgICBpcyBmYWxzZSlcbiAgICAgKiAgICBpbml0aWFsX2luZGVudCAoZGVmYXVsdDogXCJcIilcbiAgICAgKiAgICAgIHN0cmluZyB0aGF0IHdpbGwgYmUgcHJlcGVuZGVkIHRvIHRoZSBmaXJzdCBsaW5lIG9mIHdyYXBwZWRcbiAgICAgKiAgICAgIG91dHB1dC4gIENvdW50cyB0b3dhcmRzIHRoZSBsaW5lJ3Mgd2lkdGguXG4gICAgICogICAgc3Vic2VxdWVudF9pbmRlbnQgKGRlZmF1bHQ6IFwiXCIpXG4gICAgICogICAgICBzdHJpbmcgdGhhdCB3aWxsIGJlIHByZXBlbmRlZCB0byBhbGwgbGluZXMgc2F2ZSB0aGUgZmlyc3RcbiAgICAgKiAgICAgIG9mIHdyYXBwZWQgb3V0cHV0OyBhbHNvIGNvdW50cyB0b3dhcmRzIGVhY2ggbGluZSdzIHdpZHRoLlxuICAgICAqICAgIGV4cGFuZF90YWJzIChkZWZhdWx0OiB0cnVlKVxuICAgICAqICAgICAgRXhwYW5kIHRhYnMgaW4gaW5wdXQgdGV4dCB0byBzcGFjZXMgYmVmb3JlIGZ1cnRoZXIgcHJvY2Vzc2luZy5cbiAgICAgKiAgICAgIEVhY2ggdGFiIHdpbGwgYmVjb21lIDAgLi4gJ3RhYnNpemUnIHNwYWNlcywgZGVwZW5kaW5nIG9uIGl0cyBwb3NpdGlvblxuICAgICAqICAgICAgaW4gaXRzIGxpbmUuICBJZiBmYWxzZSwgZWFjaCB0YWIgaXMgdHJlYXRlZCBhcyBhIHNpbmdsZSBjaGFyYWN0ZXIuXG4gICAgICogICAgdGFic2l6ZSAoZGVmYXVsdDogOClcbiAgICAgKiAgICAgIEV4cGFuZCB0YWJzIGluIGlucHV0IHRleHQgdG8gMCAuLiAndGFic2l6ZScgc3BhY2VzLCB1bmxlc3NcbiAgICAgKiAgICAgICdleHBhbmRfdGFicycgaXMgZmFsc2UuXG4gICAgICogICAgcmVwbGFjZV93aGl0ZXNwYWNlIChkZWZhdWx0OiB0cnVlKVxuICAgICAqICAgICAgUmVwbGFjZSBhbGwgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGluIHRoZSBpbnB1dCB0ZXh0IGJ5IHNwYWNlc1xuICAgICAqICAgICAgYWZ0ZXIgdGFiIGV4cGFuc2lvbi4gIE5vdGUgdGhhdCBpZiBleHBhbmRfdGFicyBpcyBmYWxzZSBhbmRcbiAgICAgKiAgICAgIHJlcGxhY2Vfd2hpdGVzcGFjZSBpcyB0cnVlLCBldmVyeSB0YWIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYVxuICAgICAqICAgICAgc2luZ2xlIHNwYWNlIVxuICAgICAqICAgIGZpeF9zZW50ZW5jZV9lbmRpbmdzIChkZWZhdWx0OiBmYWxzZSlcbiAgICAgKiAgICAgIEVuc3VyZSB0aGF0IHNlbnRlbmNlLWVuZGluZyBwdW5jdHVhdGlvbiBpcyBhbHdheXMgZm9sbG93ZWRcbiAgICAgKiAgICAgIGJ5IHR3byBzcGFjZXMuICBPZmYgYnkgZGVmYXVsdCBiZWNhdXNlIHRoZSBhbGdvcml0aG0gaXNcbiAgICAgKiAgICAgICh1bmF2b2lkYWJseSkgaW1wZXJmZWN0LlxuICAgICAqICAgIGJyZWFrX2xvbmdfd29yZHMgKGRlZmF1bHQ6IHRydWUpXG4gICAgICogICAgICBCcmVhayB3b3JkcyBsb25nZXIgdGhhbiAnd2lkdGgnLiAgSWYgZmFsc2UsIHRob3NlIHdvcmRzIHdpbGwgbm90XG4gICAgICogICAgICBiZSBicm9rZW4sIGFuZCBzb21lIGxpbmVzIG1pZ2h0IGJlIGxvbmdlciB0aGFuICd3aWR0aCcuXG4gICAgICogICAgYnJlYWtfb25faHlwaGVucyAoZGVmYXVsdDogdHJ1ZSlcbiAgICAgKiAgICAgIEFsbG93IGJyZWFraW5nIGh5cGhlbmF0ZWQgd29yZHMuIElmIHRydWUsIHdyYXBwaW5nIHdpbGwgb2NjdXJcbiAgICAgKiAgICAgIHByZWZlcmFibHkgb24gd2hpdGVzcGFjZXMgYW5kIHJpZ2h0IGFmdGVyIGh5cGhlbnMgcGFydCBvZlxuICAgICAqICAgICAgY29tcG91bmQgd29yZHMuXG4gICAgICogICAgZHJvcF93aGl0ZXNwYWNlIChkZWZhdWx0OiB0cnVlKVxuICAgICAqICAgICAgRHJvcCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlIGZyb20gbGluZXMuXG4gICAgICogICAgbWF4X2xpbmVzIChkZWZhdWx0OiBOb25lKVxuICAgICAqICAgICAgVHJ1bmNhdGUgd3JhcHBlZCBsaW5lcy5cbiAgICAgKiAgICBwbGFjZWhvbGRlciAoZGVmYXVsdDogJyBbLi4uXScpXG4gICAgICogICAgICBBcHBlbmQgdG8gdGhlIGxhc3QgbGluZSBvZiB0cnVuY2F0ZWQgdGV4dC5cbiAgICAgKi9cblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQge1xuICAgICAgICAgICAgd2lkdGggPSA3MCxcbiAgICAgICAgICAgIGluaXRpYWxfaW5kZW50ID0gJycsXG4gICAgICAgICAgICBzdWJzZXF1ZW50X2luZGVudCA9ICcnLFxuICAgICAgICAgICAgZXhwYW5kX3RhYnMgPSB0cnVlLFxuICAgICAgICAgICAgcmVwbGFjZV93aGl0ZXNwYWNlID0gdHJ1ZSxcbiAgICAgICAgICAgIGZpeF9zZW50ZW5jZV9lbmRpbmdzID0gZmFsc2UsXG4gICAgICAgICAgICBicmVha19sb25nX3dvcmRzID0gdHJ1ZSxcbiAgICAgICAgICAgIGRyb3Bfd2hpdGVzcGFjZSA9IHRydWUsXG4gICAgICAgICAgICBicmVha19vbl9oeXBoZW5zID0gdHJ1ZSxcbiAgICAgICAgICAgIHRhYnNpemUgPSA4LFxuICAgICAgICAgICAgbWF4X2xpbmVzID0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGxhY2Vob2xkZXI9JyBbLi4uXSdcbiAgICAgICAgfSA9IG9wdGlvbnNcblxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGhcbiAgICAgICAgdGhpcy5pbml0aWFsX2luZGVudCA9IGluaXRpYWxfaW5kZW50XG4gICAgICAgIHRoaXMuc3Vic2VxdWVudF9pbmRlbnQgPSBzdWJzZXF1ZW50X2luZGVudFxuICAgICAgICB0aGlzLmV4cGFuZF90YWJzID0gZXhwYW5kX3RhYnNcbiAgICAgICAgdGhpcy5yZXBsYWNlX3doaXRlc3BhY2UgPSByZXBsYWNlX3doaXRlc3BhY2VcbiAgICAgICAgdGhpcy5maXhfc2VudGVuY2VfZW5kaW5ncyA9IGZpeF9zZW50ZW5jZV9lbmRpbmdzXG4gICAgICAgIHRoaXMuYnJlYWtfbG9uZ193b3JkcyA9IGJyZWFrX2xvbmdfd29yZHNcbiAgICAgICAgdGhpcy5kcm9wX3doaXRlc3BhY2UgPSBkcm9wX3doaXRlc3BhY2VcbiAgICAgICAgdGhpcy5icmVha19vbl9oeXBoZW5zID0gYnJlYWtfb25faHlwaGVuc1xuICAgICAgICB0aGlzLnRhYnNpemUgPSB0YWJzaXplXG4gICAgICAgIHRoaXMubWF4X2xpbmVzID0gbWF4X2xpbmVzXG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlclxuICAgIH1cblxuXG4gICAgLy8gLS0gUHJpdmF0ZSBtZXRob2RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gKHBvc3NpYmx5IHVzZWZ1bCBmb3Igc3ViY2xhc3NlcyB0byBvdmVycmlkZSlcblxuICAgIF9tdW5nZV93aGl0ZXNwYWNlKHRleHQpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogIF9tdW5nZV93aGl0ZXNwYWNlKHRleHQgOiBzdHJpbmcpIC0+IHN0cmluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiAgTXVuZ2Ugd2hpdGVzcGFjZSBpbiB0ZXh0OiBleHBhbmQgdGFicyBhbmQgY29udmVydCBhbGwgb3RoZXJcbiAgICAgICAgICogIHdoaXRlc3BhY2UgY2hhcmFjdGVycyB0byBzcGFjZXMuICBFZy4gXCIgZm9vXFxcXHRiYXJcXFxcblxcXFxuYmF6XCJcbiAgICAgICAgICogIGJlY29tZXMgXCIgZm9vICAgIGJhciAgYmF6XCIuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5leHBhbmRfdGFicykge1xuICAgICAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXFx0L2csICcgJy5yZXBlYXQodGhpcy50YWJzaXplKSkgLy8gbm90IHN0cmljdGx5IGNvcnJlY3QgaW4ganNcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZXBsYWNlX3doaXRlc3BhY2UpIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1tcXHRcXG5cXHgwYlxceDBjXFxyXS9nLCAnICcpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHRcbiAgICB9XG5cbiAgICBfc3BsaXQodGV4dCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiAgX3NwbGl0KHRleHQgOiBzdHJpbmcpIC0+IFtzdHJpbmddXG4gICAgICAgICAqXG4gICAgICAgICAqICBTcGxpdCB0aGUgdGV4dCB0byB3cmFwIGludG8gaW5kaXZpc2libGUgY2h1bmtzLiAgQ2h1bmtzIGFyZVxuICAgICAgICAgKiAgbm90IHF1aXRlIHRoZSBzYW1lIGFzIHdvcmRzOyBzZWUgX3dyYXBfY2h1bmtzKCkgZm9yIGZ1bGxcbiAgICAgICAgICogIGRldGFpbHMuICBBcyBhbiBleGFtcGxlLCB0aGUgdGV4dFxuICAgICAgICAgKiAgICBMb29rLCBnb29mLWJhbGwgLS0gdXNlIHRoZSAtYiBvcHRpb24hXG4gICAgICAgICAqICBicmVha3MgaW50byB0aGUgZm9sbG93aW5nIGNodW5rczpcbiAgICAgICAgICogICAgJ0xvb2ssJywgJyAnLCAnZ29vZi0nLCAnYmFsbCcsICcgJywgJy0tJywgJyAnLFxuICAgICAgICAgKiAgICAndXNlJywgJyAnLCAndGhlJywgJyAnLCAnLWInLCAnICcsICdvcHRpb24hJ1xuICAgICAgICAgKiAgaWYgYnJlYWtfb25faHlwaGVucyBpcyBUcnVlLCBvciBpbjpcbiAgICAgICAgICogICAgJ0xvb2ssJywgJyAnLCAnZ29vZi1iYWxsJywgJyAnLCAnLS0nLCAnICcsXG4gICAgICAgICAqICAgICd1c2UnLCAnICcsICd0aGUnLCAnICcsICctYicsICcgJywgb3B0aW9uISdcbiAgICAgICAgICogIG90aGVyd2lzZS5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBjaHVua3MgPSB0ZXh0LnNwbGl0KHdvcmRzZXBfc2ltcGxlX3JlKVxuICAgICAgICBjaHVua3MgPSBjaHVua3MuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgIHJldHVybiBjaHVua3NcbiAgICB9XG5cbiAgICBfaGFuZGxlX2xvbmdfd29yZChyZXZlcnNlZF9jaHVua3MsIGN1cl9saW5lLCBjdXJfbGVuLCB3aWR0aCkge1xuICAgICAgICAvKlxuICAgICAgICAgKiAgX2hhbmRsZV9sb25nX3dvcmQoY2h1bmtzIDogW3N0cmluZ10sXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICBjdXJfbGluZSA6IFtzdHJpbmddLFxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgY3VyX2xlbiA6IGludCwgd2lkdGggOiBpbnQpXG4gICAgICAgICAqXG4gICAgICAgICAqICBIYW5kbGUgYSBjaHVuayBvZiB0ZXh0IChtb3N0IGxpa2VseSBhIHdvcmQsIG5vdCB3aGl0ZXNwYWNlKSB0aGF0XG4gICAgICAgICAqICBpcyB0b28gbG9uZyB0byBmaXQgaW4gYW55IGxpbmUuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBGaWd1cmUgb3V0IHdoZW4gaW5kZW50IGlzIGxhcmdlciB0aGFuIHRoZSBzcGVjaWZpZWQgd2lkdGgsIGFuZCBtYWtlXG4gICAgICAgIC8vIHN1cmUgYXQgbGVhc3Qgb25lIGNoYXJhY3RlciBpcyBzdHJpcHBlZCBvZmYgb24gZXZlcnkgcGFzc1xuICAgICAgICBsZXQgc3BhY2VfbGVmdFxuICAgICAgICBpZiAod2lkdGggPCAxKSB7XG4gICAgICAgICAgICBzcGFjZV9sZWZ0ID0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3BhY2VfbGVmdCA9IHdpZHRoIC0gY3VyX2xlblxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgd2UncmUgYWxsb3dlZCB0byBicmVhayBsb25nIHdvcmRzLCB0aGVuIGRvIHNvOiBwdXQgYXMgbXVjaFxuICAgICAgICAvLyBvZiB0aGUgbmV4dCBjaHVuayBvbnRvIHRoZSBjdXJyZW50IGxpbmUgYXMgd2lsbCBmaXQuXG4gICAgICAgIGlmICh0aGlzLmJyZWFrX2xvbmdfd29yZHMpIHtcbiAgICAgICAgICAgIGN1cl9saW5lLnB1c2gocmV2ZXJzZWRfY2h1bmtzW3JldmVyc2VkX2NodW5rcy5sZW5ndGggLSAxXS5zbGljZSgwLCBzcGFjZV9sZWZ0KSlcbiAgICAgICAgICAgIHJldmVyc2VkX2NodW5rc1tyZXZlcnNlZF9jaHVua3MubGVuZ3RoIC0gMV0gPSByZXZlcnNlZF9jaHVua3NbcmV2ZXJzZWRfY2h1bmtzLmxlbmd0aCAtIDFdLnNsaWNlKHNwYWNlX2xlZnQpXG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBoYXZlIHRvIHByZXNlcnZlIHRoZSBsb25nIHdvcmQgaW50YWN0LiAgT25seSBhZGRcbiAgICAgICAgLy8gaXQgdG8gdGhlIGN1cnJlbnQgbGluZSBpZiB0aGVyZSdzIG5vdGhpbmcgYWxyZWFkeSB0aGVyZSAtLVxuICAgICAgICAvLyB0aGF0IG1pbmltaXplcyBob3cgbXVjaCB3ZSB2aW9sYXRlIHRoZSB3aWR0aCBjb25zdHJhaW50LlxuICAgICAgICB9IGVsc2UgaWYgKCFjdXJfbGluZSkge1xuICAgICAgICAgICAgY3VyX2xpbmUucHVzaCguLi5yZXZlcnNlZF9jaHVua3MucG9wKCkpXG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgYWxsb3dlZCB0byBicmVhayBsb25nIHdvcmRzLCBhbmQgdGhlcmUncyBhbHJlYWR5XG4gICAgICAgIC8vIHRleHQgb24gdGhlIGN1cnJlbnQgbGluZSwgZG8gbm90aGluZy4gIE5leHQgdGltZSB0aHJvdWdoIHRoZVxuICAgICAgICAvLyBtYWluIGxvb3Agb2YgX3dyYXBfY2h1bmtzKCksIHdlJ2xsIHdpbmQgdXAgaGVyZSBhZ2FpbiwgYnV0XG4gICAgICAgIC8vIGN1cl9sZW4gd2lsbCBiZSB6ZXJvLCBzbyB0aGUgbmV4dCBsaW5lIHdpbGwgYmUgZW50aXJlbHlcbiAgICAgICAgLy8gZGV2b3RlZCB0byB0aGUgbG9uZyB3b3JkIHRoYXQgd2UgY2FuJ3QgaGFuZGxlIHJpZ2h0IG5vdy5cbiAgICB9XG5cbiAgICBfd3JhcF9jaHVua3MoY2h1bmtzKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqICBfd3JhcF9jaHVua3MoY2h1bmtzIDogW3N0cmluZ10pIC0+IFtzdHJpbmddXG4gICAgICAgICAqXG4gICAgICAgICAqICBXcmFwIGEgc2VxdWVuY2Ugb2YgdGV4dCBjaHVua3MgYW5kIHJldHVybiBhIGxpc3Qgb2YgbGluZXMgb2ZcbiAgICAgICAgICogIGxlbmd0aCAnc2VsZi53aWR0aCcgb3IgbGVzcy4gIChJZiAnYnJlYWtfbG9uZ193b3JkcycgaXMgZmFsc2UsXG4gICAgICAgICAqICBzb21lIGxpbmVzIG1heSBiZSBsb25nZXIgdGhhbiB0aGlzLikgIENodW5rcyBjb3JyZXNwb25kIHJvdWdobHlcbiAgICAgICAgICogIHRvIHdvcmRzIGFuZCB0aGUgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZW06IGVhY2ggY2h1bmsgaXNcbiAgICAgICAgICogIGluZGl2aXNpYmxlIChtb2R1bG8gJ2JyZWFrX2xvbmdfd29yZHMnKSwgYnV0IGEgbGluZSBicmVhayBjYW5cbiAgICAgICAgICogIGNvbWUgYmV0d2VlbiBhbnkgdHdvIGNodW5rcy4gIENodW5rcyBzaG91bGQgbm90IGhhdmUgaW50ZXJuYWxcbiAgICAgICAgICogIHdoaXRlc3BhY2U7IGllLiBhIGNodW5rIGlzIGVpdGhlciBhbGwgd2hpdGVzcGFjZSBvciBhIFwid29yZFwiLlxuICAgICAgICAgKiAgV2hpdGVzcGFjZSBjaHVua3Mgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mXG4gICAgICAgICAqICBsaW5lcywgYnV0IGFwYXJ0IGZyb20gdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZC5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBsaW5lcyA9IFtdXG4gICAgICAgIGxldCBpbmRlbnRcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYGludmFsaWQgd2lkdGggJHt0aGlzLndpZHRofSAobXVzdCBiZSA+IDApYClcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXhfbGluZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWF4X2xpbmVzID4gMSkge1xuICAgICAgICAgICAgICAgIGluZGVudCA9IHRoaXMuc3Vic2VxdWVudF9pbmRlbnRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5kZW50ID0gdGhpcy5pbml0aWFsX2luZGVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGVudC5sZW5ndGggKyB0aGlzLnBsYWNlaG9sZGVyLnRyaW1TdGFydCgpLmxlbmd0aCA+IHRoaXMud2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigncGxhY2Vob2xkZXIgdG9vIGxhcmdlIGZvciBtYXggd2lkdGgnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXJyYW5nZSBpbiByZXZlcnNlIG9yZGVyIHNvIGl0ZW1zIGNhbiBiZSBlZmZpY2llbnRseSBwb3BwZWRcbiAgICAgICAgLy8gZnJvbSBhIHN0YWNrIG9mIGNodWNrcy5cbiAgICAgICAgY2h1bmtzID0gY2h1bmtzLnJldmVyc2UoKVxuXG4gICAgICAgIHdoaWxlIChjaHVua3MubGVuZ3RoID4gMCkge1xuXG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgbGlzdCBvZiBjaHVua3MgdGhhdCB3aWxsIG1ha2UgdXAgdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgICAgICAgIC8vIGN1cl9sZW4gaXMganVzdCB0aGUgbGVuZ3RoIG9mIGFsbCB0aGUgY2h1bmtzIGluIGN1cl9saW5lLlxuICAgICAgICAgICAgbGV0IGN1cl9saW5lID0gW11cbiAgICAgICAgICAgIGxldCBjdXJfbGVuID0gMFxuXG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIHN0YXRpYyBzdHJpbmcgd2lsbCBwcmVmaXggdGhpcyBsaW5lLlxuICAgICAgICAgICAgbGV0IGluZGVudFxuICAgICAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgaW5kZW50ID0gdGhpcy5zdWJzZXF1ZW50X2luZGVudFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbmRlbnQgPSB0aGlzLmluaXRpYWxfaW5kZW50XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1heGltdW0gd2lkdGggZm9yIHRoaXMgbGluZS5cbiAgICAgICAgICAgIGxldCB3aWR0aCA9IHRoaXMud2lkdGggLSBpbmRlbnQubGVuZ3RoXG5cbiAgICAgICAgICAgIC8vIEZpcnN0IGNodW5rIG9uIGxpbmUgaXMgd2hpdGVzcGFjZSAtLSBkcm9wIGl0LCB1bmxlc3MgdGhpc1xuICAgICAgICAgICAgLy8gaXMgdGhlIHZlcnkgYmVnaW5uaW5nIG9mIHRoZSB0ZXh0IChpZS4gbm8gbGluZXMgc3RhcnRlZCB5ZXQpLlxuICAgICAgICAgICAgaWYgKHRoaXMuZHJvcF93aGl0ZXNwYWNlICYmIGNodW5rc1tjaHVua3MubGVuZ3RoIC0gMV0udHJpbSgpID09PSAnJyAmJiBsaW5lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY2h1bmtzLnBvcCgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdoaWxlIChjaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGxldCBsID0gY2h1bmtzW2NodW5rcy5sZW5ndGggLSAxXS5sZW5ndGhcblxuICAgICAgICAgICAgICAgIC8vIENhbiBhdCBsZWFzdCBzcXVlZXplIHRoaXMgY2h1bmsgb250byB0aGUgY3VycmVudCBsaW5lLlxuICAgICAgICAgICAgICAgIGlmIChjdXJfbGVuICsgbCA8PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJfbGluZS5wdXNoKGNodW5rcy5wb3AoKSlcbiAgICAgICAgICAgICAgICAgICAgY3VyX2xlbiArPSBsXG5cbiAgICAgICAgICAgICAgICAvLyBOb3BlLCB0aGlzIGxpbmUgaXMgZnVsbC5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgbGluZSBpcyBmdWxsLCBhbmQgdGhlIG5leHQgY2h1bmsgaXMgdG9vIGJpZyB0b1xuICAgICAgICAgICAgLy8gZml0IG9uICphbnkqIGxpbmUgKG5vdCBqdXN0IHRoaXMgb25lKS5cbiAgICAgICAgICAgIGlmIChjaHVua3MubGVuZ3RoICYmIGNodW5rc1tjaHVua3MubGVuZ3RoIC0gMV0ubGVuZ3RoID4gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVfbG9uZ193b3JkKGNodW5rcywgY3VyX2xpbmUsIGN1cl9sZW4sIHdpZHRoKVxuICAgICAgICAgICAgICAgIGN1cl9sZW4gPSBjdXJfbGluZS5tYXAobCA9PiBsLmxlbmd0aCkucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIGxhc3QgY2h1bmsgb24gdGhpcyBsaW5lIGlzIGFsbCB3aGl0ZXNwYWNlLCBkcm9wIGl0LlxuICAgICAgICAgICAgaWYgKHRoaXMuZHJvcF93aGl0ZXNwYWNlICYmIGN1cl9saW5lLmxlbmd0aCA+IDAgJiYgY3VyX2xpbmVbY3VyX2xpbmUubGVuZ3RoIC0gMV0udHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgIGN1cl9sZW4gLT0gY3VyX2xpbmVbY3VyX2xpbmUubGVuZ3RoIC0gMV0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgY3VyX2xpbmUucG9wKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cl9saW5lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWF4X2xpbmVzID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgbGluZXMubGVuZ3RoICsgMSA8IHRoaXMubWF4X2xpbmVzIHx8XG4gICAgICAgICAgICAgICAgICAgIChjaHVua3MubGVuZ3RoID09PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3Bfd2hpdGVzcGFjZSAmJlxuICAgICAgICAgICAgICAgICAgICAgY2h1bmtzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICAgIWNodW5rc1swXS50cmltKCkpICYmIGN1cl9sZW4gPD0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCBjdXJyZW50IGxpbmUgYmFjayB0byBhIHN0cmluZyBhbmQgc3RvcmUgaXQgaW5cbiAgICAgICAgICAgICAgICAgICAgLy8gbGlzdCBvZiBhbGwgbGluZXMgKHJldHVybiB2YWx1ZSkuXG4gICAgICAgICAgICAgICAgICAgIGxpbmVzLnB1c2goaW5kZW50ICsgY3VyX2xpbmUuam9pbignJykpXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhhZF9icmVhayA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJfbGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cl9saW5lW2N1cl9saW5lLmxlbmd0aCAtIDFdLnRyaW0oKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cl9sZW4gKyB0aGlzLnBsYWNlaG9sZGVyLmxlbmd0aCA8PSB3aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cl9saW5lLnB1c2godGhpcy5wbGFjZWhvbGRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGluZGVudCArIGN1cl9saW5lLmpvaW4oJycpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhZF9icmVhayA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyX2xlbiAtPSBjdXJfbGluZVstMV0ubGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJfbGluZS5wb3AoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFkX2JyZWFrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcHJldl9saW5lID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0udHJpbUVuZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZfbGluZS5sZW5ndGggKyB0aGlzLnBsYWNlaG9sZGVyLmxlbmd0aCA8PVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXSA9IHByZXZfbGluZSArIHRoaXMucGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKGluZGVudCArIHRoaXMucGxhY2Vob2xkZXIubHN0cmlwKCkpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGluZXNcbiAgICB9XG5cbiAgICBfc3BsaXRfY2h1bmtzKHRleHQpIHtcbiAgICAgICAgdGV4dCA9IHRoaXMuX211bmdlX3doaXRlc3BhY2UodGV4dClcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NwbGl0KHRleHQpXG4gICAgfVxuXG4gICAgLy8gLS0gUHVibGljIGludGVyZmFjZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICB3cmFwKHRleHQpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogIHdyYXAodGV4dCA6IHN0cmluZykgLT4gW3N0cmluZ11cbiAgICAgICAgICpcbiAgICAgICAgICogIFJlZm9ybWF0IHRoZSBzaW5nbGUgcGFyYWdyYXBoIGluICd0ZXh0JyBzbyBpdCBmaXRzIGluIGxpbmVzIG9mXG4gICAgICAgICAqICBubyBtb3JlIHRoYW4gJ3NlbGYud2lkdGgnIGNvbHVtbnMsIGFuZCByZXR1cm4gYSBsaXN0IG9mIHdyYXBwZWRcbiAgICAgICAgICogIGxpbmVzLiAgVGFicyBpbiAndGV4dCcgYXJlIGV4cGFuZGVkIHdpdGggc3RyaW5nLmV4cGFuZHRhYnMoKSxcbiAgICAgICAgICogIGFuZCBhbGwgb3RoZXIgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIChpbmNsdWRpbmcgbmV3bGluZSkgYXJlXG4gICAgICAgICAqICBjb252ZXJ0ZWQgdG8gc3BhY2UuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgY2h1bmtzID0gdGhpcy5fc3BsaXRfY2h1bmtzKHRleHQpXG4gICAgICAgIC8vIG5vdCBpbXBsZW1lbnRlZCBpbiBqc1xuICAgICAgICAvL2lmICh0aGlzLmZpeF9zZW50ZW5jZV9lbmRpbmdzKSB7XG4gICAgICAgIC8vICAgIHRoaXMuX2ZpeF9zZW50ZW5jZV9lbmRpbmdzKGNodW5rcylcbiAgICAgICAgLy99XG4gICAgICAgIHJldHVybiB0aGlzLl93cmFwX2NodW5rcyhjaHVua3MpXG4gICAgfVxuXG4gICAgZmlsbCh0ZXh0KSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqICBmaWxsKHRleHQgOiBzdHJpbmcpIC0+IHN0cmluZ1xuICAgICAgICAgKlxuICAgICAgICAgKiAgUmVmb3JtYXQgdGhlIHNpbmdsZSBwYXJhZ3JhcGggaW4gJ3RleHQnIHRvIGZpdCBpbiBsaW5lcyBvZiBub1xuICAgICAgICAgKiAgbW9yZSB0aGFuICdzZWxmLndpZHRoJyBjb2x1bW5zLCBhbmQgcmV0dXJuIGEgbmV3IHN0cmluZ1xuICAgICAgICAgKiAgY29udGFpbmluZyB0aGUgZW50aXJlIHdyYXBwZWQgcGFyYWdyYXBoLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIHRoaXMud3JhcCh0ZXh0KS5qb2luKCdcXG4nKVxuICAgIH1cbn1cblxuXG4vLyAtLSBDb252ZW5pZW5jZSBpbnRlcmZhY2UgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHdyYXAodGV4dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLypcbiAgICAgKiAgV3JhcCBhIHNpbmdsZSBwYXJhZ3JhcGggb2YgdGV4dCwgcmV0dXJuaW5nIGEgbGlzdCBvZiB3cmFwcGVkIGxpbmVzLlxuICAgICAqXG4gICAgICogIFJlZm9ybWF0IHRoZSBzaW5nbGUgcGFyYWdyYXBoIGluICd0ZXh0JyBzbyBpdCBmaXRzIGluIGxpbmVzIG9mIG5vXG4gICAgICogIG1vcmUgdGhhbiAnd2lkdGgnIGNvbHVtbnMsIGFuZCByZXR1cm4gYSBsaXN0IG9mIHdyYXBwZWQgbGluZXMuICBCeVxuICAgICAqICBkZWZhdWx0LCB0YWJzIGluICd0ZXh0JyBhcmUgZXhwYW5kZWQgd2l0aCBzdHJpbmcuZXhwYW5kdGFicygpLCBhbmRcbiAgICAgKiAgYWxsIG90aGVyIHdoaXRlc3BhY2UgY2hhcmFjdGVycyAoaW5jbHVkaW5nIG5ld2xpbmUpIGFyZSBjb252ZXJ0ZWQgdG9cbiAgICAgKiAgc3BhY2UuICBTZWUgVGV4dFdyYXBwZXIgY2xhc3MgZm9yIGF2YWlsYWJsZSBrZXl3b3JkIGFyZ3MgdG8gY3VzdG9taXplXG4gICAgICogIHdyYXBwaW5nIGJlaGF2aW91ci5cbiAgICAgKi9cbiAgICBsZXQgeyB3aWR0aCA9IDcwLCAuLi5rd2FyZ3MgfSA9IG9wdGlvbnNcbiAgICBsZXQgdyA9IG5ldyBUZXh0V3JhcHBlcihPYmplY3QuYXNzaWduKHsgd2lkdGggfSwga3dhcmdzKSlcbiAgICByZXR1cm4gdy53cmFwKHRleHQpXG59XG5cbmZ1bmN0aW9uIGZpbGwodGV4dCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgLypcbiAgICAgKiAgRmlsbCBhIHNpbmdsZSBwYXJhZ3JhcGggb2YgdGV4dCwgcmV0dXJuaW5nIGEgbmV3IHN0cmluZy5cbiAgICAgKlxuICAgICAqICBSZWZvcm1hdCB0aGUgc2luZ2xlIHBhcmFncmFwaCBpbiAndGV4dCcgdG8gZml0IGluIGxpbmVzIG9mIG5vIG1vcmVcbiAgICAgKiAgdGhhbiAnd2lkdGgnIGNvbHVtbnMsIGFuZCByZXR1cm4gYSBuZXcgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIGVudGlyZVxuICAgICAqICB3cmFwcGVkIHBhcmFncmFwaC4gIEFzIHdpdGggd3JhcCgpLCB0YWJzIGFyZSBleHBhbmRlZCBhbmQgb3RoZXJcbiAgICAgKiAgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGNvbnZlcnRlZCB0byBzcGFjZS4gIFNlZSBUZXh0V3JhcHBlciBjbGFzcyBmb3JcbiAgICAgKiAgYXZhaWxhYmxlIGtleXdvcmQgYXJncyB0byBjdXN0b21pemUgd3JhcHBpbmcgYmVoYXZpb3VyLlxuICAgICAqL1xuICAgIGxldCB7IHdpZHRoID0gNzAsIC4uLmt3YXJncyB9ID0gb3B0aW9uc1xuICAgIGxldCB3ID0gbmV3IFRleHRXcmFwcGVyKE9iamVjdC5hc3NpZ24oeyB3aWR0aCB9LCBrd2FyZ3MpKVxuICAgIHJldHVybiB3LmZpbGwodGV4dClcbn1cblxuLy8gLS0gTG9vc2VseSByZWxhdGVkIGZ1bmN0aW9uYWxpdHkgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5sZXQgX3doaXRlc3BhY2Vfb25seV9yZSA9IC9eWyBcXHRdKyQvbWdcbmxldCBfbGVhZGluZ193aGl0ZXNwYWNlX3JlID0gLyheWyBcXHRdKikoPzpbXiBcXHRcXG5dKS9tZ1xuXG5mdW5jdGlvbiBkZWRlbnQodGV4dCkge1xuICAgIC8qXG4gICAgICogIFJlbW92ZSBhbnkgY29tbW9uIGxlYWRpbmcgd2hpdGVzcGFjZSBmcm9tIGV2ZXJ5IGxpbmUgaW4gYHRleHRgLlxuICAgICAqXG4gICAgICogIFRoaXMgY2FuIGJlIHVzZWQgdG8gbWFrZSB0cmlwbGUtcXVvdGVkIHN0cmluZ3MgbGluZSB1cCB3aXRoIHRoZSBsZWZ0XG4gICAgICogIGVkZ2Ugb2YgdGhlIGRpc3BsYXksIHdoaWxlIHN0aWxsIHByZXNlbnRpbmcgdGhlbSBpbiB0aGUgc291cmNlIGNvZGVcbiAgICAgKiAgaW4gaW5kZW50ZWQgZm9ybS5cbiAgICAgKlxuICAgICAqICBOb3RlIHRoYXQgdGFicyBhbmQgc3BhY2VzIGFyZSBib3RoIHRyZWF0ZWQgYXMgd2hpdGVzcGFjZSwgYnV0IHRoZXlcbiAgICAgKiAgYXJlIG5vdCBlcXVhbDogdGhlIGxpbmVzIFwiICBoZWxsb1wiIGFuZCBcIlxcXFx0aGVsbG9cIiBhcmVcbiAgICAgKiAgY29uc2lkZXJlZCB0byBoYXZlIG5vIGNvbW1vbiBsZWFkaW5nIHdoaXRlc3BhY2UuXG4gICAgICpcbiAgICAgKiAgRW50aXJlbHkgYmxhbmsgbGluZXMgYXJlIG5vcm1hbGl6ZWQgdG8gYSBuZXdsaW5lIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICAvLyBMb29rIGZvciB0aGUgbG9uZ2VzdCBsZWFkaW5nIHN0cmluZyBvZiBzcGFjZXMgYW5kIHRhYnMgY29tbW9uIHRvXG4gICAgLy8gYWxsIGxpbmVzLlxuICAgIGxldCBtYXJnaW4gPSB1bmRlZmluZWRcbiAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlKF93aGl0ZXNwYWNlX29ubHlfcmUsICcnKVxuICAgIGxldCBpbmRlbnRzID0gdGV4dC5tYXRjaChfbGVhZGluZ193aGl0ZXNwYWNlX3JlKSB8fCBbXVxuICAgIGZvciAobGV0IGluZGVudCBvZiBpbmRlbnRzKSB7XG4gICAgICAgIGluZGVudCA9IGluZGVudC5zbGljZSgwLCAtMSlcblxuICAgICAgICBpZiAobWFyZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1hcmdpbiA9IGluZGVudFxuXG4gICAgICAgIC8vIEN1cnJlbnQgbGluZSBtb3JlIGRlZXBseSBpbmRlbnRlZCB0aGFuIHByZXZpb3VzIHdpbm5lcjpcbiAgICAgICAgLy8gbm8gY2hhbmdlIChwcmV2aW91cyB3aW5uZXIgaXMgc3RpbGwgb24gdG9wKS5cbiAgICAgICAgfSBlbHNlIGlmIChpbmRlbnQuc3RhcnRzV2l0aChtYXJnaW4pKSB7XG4gICAgICAgICAgICAvLyBwYXNzXG5cbiAgICAgICAgLy8gQ3VycmVudCBsaW5lIGNvbnNpc3RlbnQgd2l0aCBhbmQgbm8gZGVlcGVyIHRoYW4gcHJldmlvdXMgd2lubmVyOlxuICAgICAgICAvLyBpdCdzIHRoZSBuZXcgd2lubmVyLlxuICAgICAgICB9IGVsc2UgaWYgKG1hcmdpbi5zdGFydHNXaXRoKGluZGVudCkpIHtcbiAgICAgICAgICAgIG1hcmdpbiA9IGluZGVudFxuXG4gICAgICAgIC8vIEZpbmQgdGhlIGxhcmdlc3QgY29tbW9uIHdoaXRlc3BhY2UgYmV0d2VlbiBjdXJyZW50IGxpbmUgYW5kIHByZXZpb3VzXG4gICAgICAgIC8vIHdpbm5lci5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFyZ2luLmxlbmd0aCAmJiBpIDwgaW5kZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmdpbltpXSAhPT0gaW5kZW50W2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmdpbiA9IG1hcmdpbi5zbGljZSgwLCBpKVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXJnaW4pIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZShuZXcgUmVnRXhwKCdeJyArIG1hcmdpbiwgJ21nJyksICcnKVxuICAgIH1cbiAgICByZXR1cm4gdGV4dFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgd3JhcCwgZmlsbCwgZGVkZW50IH1cbiIsImV4cG9ydCB7IEltYWdlTWFwIH0gZnJvbSBcIi4vaW1hZ2VfbWFwXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9qc29uX21hcFwiOyIsIi8qKlxuICogQHBhcmFtIG5hbWUgLSBUaGUgaW1hZ2UgbmFtZSBhcyBkZWZpbmVkIGluIHRoZSBQREZcbiAqIEBwYXJhbSB3aWR0aCAtIFBpeGVsIHdpZHRoIG9mIHRoZSByYXcgaW1hZ2VcbiAqIEBwYXJhbSBoZWlnaHQgLSBQaXhlbCBoZWlnaHQgb2YgdGhlIHJhdyBpbWFnZVxuICogQHBhcmFtIGRhdGEgLSBUaGUgcmF3IGltYWdlIGRhdGEgZXh0cmFjdGVkIGZyb20gdGhlIFBERlxuICogQHBhcmFtIGJ5dGVzXG4gKi9cbmV4cG9ydCBjbGFzcyBJbWFnZU1hcCB7XG5cbiAgICBwdWJsaWMgYnl0ZXM6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBpbWFnZSBuYW1lIGFzIGRlZmluZWQgaW4gdGhlIFBERlxuICAgICAqIEBwYXJhbSB3aWR0aCAtIFBpeGVsIHdpZHRoIG9mIHRoZSByYXcgaW1hZ2VcbiAgICAgKiBAcGFyYW0gaGVpZ2h0IC0gUGl4ZWwgaGVpZ2h0IG9mIHRoZSByYXcgaW1hZ2VcbiAgICAgKiBAcGFyYW0gZGF0YSAtIFRoZSByYXcgaW1hZ2UgZGF0YSBleHRyYWN0ZWQgZnJvbSB0aGUgUERGXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBuYW1lOiBzdHJpbmcsXG4gICAgICAgIHB1YmxpYyB3aWR0aDogbnVtYmVyLFxuICAgICAgICBwdWJsaWMgaGVpZ2h0OiBudW1iZXIsXG4gICAgICAgIHB1YmxpYyBkYXRhOiBVaW50OENsYW1wZWRBcnJheVxuICAgICkge1xuICAgICAgICB0aGlzLmJ5dGVzID0gZGF0YS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjaGFubmVsIHRvIHVzZSBpbiBnZW5lcmF0aW5nIGEgUmF3IGltYWdlXG4gICAgICovXG4gICAgcHVibGljIGNoYW5uZWxzKCkge1xuICAgICAgICBsZXQgY2hhbm5lbHM6IDEgfCAyIHwgMyB8IDQgPSAxO1xuICAgICAgICBsZXQgYyA9IHRoaXMuYnl0ZXMgLyB0aGlzLndpZHRoIC8gdGhpcy5oZWlnaHQ7XG4gICAgICAgIGlmIChjID4gNCkge1xuICAgICAgICAgICAgY2hhbm5lbHMgPSA0O1xuICAgICAgICB9IGVsc2UgaWYgKGMgPCAxKSB7XG4gICAgICAgICAgICBjaGFubmVscyA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGFubmVscyA9IGMgYXMgMSB8IDIgfCAzIHwgNDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbm5lbHM7XG4gICAgfTtcblxufSIsImV4cG9ydCBlbnVtIEdhbWVTeXN0ZW0ge1xuICAgIERuRDVlLFxuICAgIFBhdGhmaW5kZXIsXG4gICAgUGF0ZmhpbmRlcjJlLFxuICAgIFN0YXJmaW5kZXIsXG59XG5cbi8vIEludGVyZmFjZXMgZm9yIEpTT04gZmlsZXNcblxuLyoqXG4gKiBJdGVyZmFjZSBmb3IgZGljdGlvbmFyeVxuICogQHByb3BlcnR5IFtrZXldOiB2YWx1ZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIGlEaWN0aW9uYXJ5IHtcbiAgICBba2V5OnN0cmluZ106IGlJbWFnZTtcbn1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIFBERiBkb2N1bWVudFxuICogQHByb3BlcnR5IHRpdGxlIC0gUERGIHRpdGxlXG4gKiBAcHJvcGVydHkgYXV0aG9yIC0gUERGIEF1dGhvclxuICogQHByb3BlcnR5IGNyZWF0aW9uX2RhdGUgLSBkYXRlIGZpbGUgd2FzIGNyZWF0ZWRcbiAqIEBwcm9wZXJ0eSBucGMyIC0gbW9uc3RlcnMvbm9uIHBsYXlhYmxlIGNoYXJhY3RlcnNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBpRG9jdW1lbnQge1xuICAgIG5hbWU6IHN0cmluZyxcbiAgICB0aXRsZTogc3RyaW5nO1xuICAgIGF1dGhvcjogc3RyaW5nO1xuICAgIGNyZWF0aW9uX2RhdGU6IHN0cmluZztcbiAgICBhc3NldHM6IGlBc3NldHM7XG4gICAgLy8gVE9ETzogYWRkIHNjZW5lIGltYWdlcywgY2hhcmFjdGVyIGltYWdlcywgbWF5YmUgb2JqZWN0IGltYWdlcz9cbn1cblxuLyoqXG4gKiBJdGVyZmFjZSBmb3IgaW1hZ2VcbiAqIEBwcm9wZXJ0eSBpZFxuICogQHByb3BlcnR5IG9yaWdcbiAqIEBwcm9wZXJ0eSBpY29uXG4gKiBAcHJvcGVydHkgYWRkaXRpb25hbCAtIE90aGVyIGNvb2wgYWRkaXRpb25hbCBpbWFnZXNcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBpSW1hZ2Uge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgb3JpZzogc3RyaW5nO1xuICAgIGljb24/OiBzdHJpbmc7XG4gICAgYWRkaXRpb25hbD86IHN0cmluZ1tdXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgaUFzc2V0cyB7IH1cblxuLyoqXG4gKiBJbnRlcmZhY2UgZm9yIGEgU3RhcmZpbmRlciBQREZcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBpU3RhcmZpbmRlckFzc2V0cyBleHRlbmRzIGlBc3NldHMge1xuICAgIGFsaWVuX2FyY2hpdmVzPyA6IGlEaWN0aW9uYXJ5O1xuICAgIGFyY2hldHlwZV9mZWF0dXJlcz8gOiBpRGljdGlvbmFyeTtcbiAgICBhcmNoZXR5cGVzPzogaURpY3Rpb25hcnk7XG4gICAgY2hhcmFjdGVycz86IGlEaWN0aW9uYXJ5O1xuICAgIGNsYXNzZXM/OiBpRGljdGlvbmFyeTtcbiAgICBjbGFzc19mZWF0dXJlcz86IGlEaWN0aW9uYXJ5O1xuICAgIGNvbmRpdGlvbnM/OiBpRGljdGlvbmFyeTtcbiAgICBjcmVhdHVyZV9jb21wYW5pb25zPzogaURpY3Rpb25hcnk7XG4gICAgZXF1aXBtZW50PzogaURpY3Rpb25hcnk7XG4gICAgZmVhdHM/OiBpRGljdGlvbmFyeTtcbiAgICBoYXphcmRzPzogaURpY3Rpb25hcnk7XG4gICAgcmFjZXM/OiBpRGljdGlvbmFyeTtcbiAgICByYWNpYWxfZmVhdHVyZXM/OiBpRGljdGlvbmFyeTtcbiAgICBydWxlcz86IGlEaWN0aW9uYXJ5O1xuICAgIHNldHRpbmc/OiBpRGljdGlvbmFyeTtcbiAgICBzcGVsbHM/OiBpRGljdGlvbmFyeTtcbiAgICBzdGFyc2hpcF9hY3Rpb25zPzogaURpY3Rpb25hcnk7XG4gICAgc3RhcnNoaXBfY29tcG9uZW50cz86IGlEaWN0aW9uYXJ5O1xuICAgIHN0YXJzaGlwcz86IGlEaWN0aW9uYXJ5O1xuICAgIHRhYmxlcz86IGlEaWN0aW9uYXJ5O1xuICAgIHRoZW1lcz86IGlEaWN0aW9uYXJ5O1xuICAgIHVuaXZlcnNhbF9jcmVhdHVyZV9ydWxlcz86IGlEaWN0aW9uYXJ5O1xuICAgIHZlaGljbGVzPzogaURpY3Rpb25hcnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgaVN0YXJmaW5kZXJEb2MgZXh0ZW5kcyBpRG9jdW1lbnQge1xuICAgIGFzc2V0czogaVN0YXJmaW5kZXJBc3NldHM7XG59XG5cbi8vIFRlc3QgdGhlIERvY3VtZW50IGpzb25cbmxldCB0ZXN0SnNvbjogaURvY3VtZW50ID0ge1xuICAgIG5hbWU6ICd0ZXN0JyxcbiAgICB0aXRsZTogJ3Rlc3QnLFxuICAgIGF1dGhvcjogJ3Rlc3QnLFxuICAgIGNyZWF0aW9uX2RhdGU6ICd0ZXN0JyxcbiAgICBhc3NldHM6W1xuICAgIF1cbn0iLCJleHBvcnQgeyBKc29uRXh0cmFjdG9yIH0gZnJvbSBcIi4vanNvbl9leHRyYWN0b3JcIjtcbmV4cG9ydCB7IEdldFBkZkRhZmEgfSBmcm9tIFwiLi9wZGZfZXh0cmFjdG9yXCI7XG5leHBvcnQgKiBhcyBJbWFnZVNhdmVyIGZyb20gXCIuL2ltYWdlX3NhdmVyXCI7XG4iLCJpbXBvcnQgeyBHYW1lU3lzdGVtIH0gZnJvbSBcIkBtYXBwaW5nc1wiO1xuaW1wb3J0IHsgU3RhcmZpbmRlckxpc3QgfSBmcm9tIFwiQHNjaGVtYXNcIjtcblxuLyoqXG4gKiBcbiAqIEBwYXJhbSBzeXN0ZW0gLSBTcGVjaWZ5IHRoZSBnYW1pbmcgc3lzdGVtIG9mIGNob2ljZVxuICogQHBhcmFtIGRvY05hbWUgLSBTcGVjaWZ5IHRoZSBuYW1lIG9mIHRoZSBmaWxlXG4gKiBAcmV0dXJucyBUaGUgSlNPTiBzY2hlbWEgZm9yIHRoZSBQREYgaWYgZm91bmRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEpzb25FeHRyYWN0b3Ioc3lzdGVtOiBHYW1lU3lzdGVtLCBkb2NOYW1lOiBzdHJpbmcpIHtcbiAgICBzd2l0Y2ggKHN5c3RlbSkge1xuICAgICAgICAvLyBSaWdodCBub3cgU3RhcmZpbmRlciBpcyB0aGUgb25seSBzeXN0ZW0gc28gcHV0dGluZyB0aGlzIGF0IHRoZSB0b3BcbiAgICAgICAgY2FzZSBHYW1lU3lzdGVtLlN0YXJmaW5kZXI6XG4gICAgICAgICAgICByZXR1cm4gc3RhcmZpbmRlckZhY3RvcnkoZG9jTmFtZSk7XG4gICAgICAgIGNhc2UgR2FtZVN5c3RlbS5EbkQ1ZTpcbiAgICAgICAgY2FzZSBHYW1lU3lzdGVtLlBhdGhmaW5kZXI6XG4gICAgICAgIGNhc2UgR2FtZVN5c3RlbS5QYXRmaGluZGVyMmU6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgc3lzdGVtIGZhY3RvcnkgdG8gcmV0cmlldmUgYSBTdGFyZmluZGVyIHNjaGVtYVxuICogQHBhcmFtIGRvY05hbWUgVGhlIG5hbWUgb2YgdGhlIFBERiBkb2N1bWVudFxuICogQHJldHVybnMgVGhlIEpTT04gZmlsZSBzY2hlbWEgaWYgZm91bmRcbiAqL1xuZnVuY3Rpb24gc3RhcmZpbmRlckZhY3RvcnkoZG9jTmFtZTogc3RyaW5nKSAge1xuICAgIHJldHVybiBTdGFyZmluZGVyTGlzdC5maW5kKHNjaGVtYSA9PiBzY2hlbWEudGl0bGUgPT09IGRvY05hbWUpO1xufVxuXG4vLyBUT0RPOiBBZGQgb3RoZXIgZ2FtaW5nIHN5c3RlbSBmYWN0b3JpZXMiLCJpbXBvcnQgeyBpU3RhcmZpbmRlckRvYyB9IGZyb20gXCJAbWFwcGluZ3NcIjtcbi8vIFN0YXJmaW5kZXIgaW1wb3J0c1xuaW1wb3J0IGFsaWVuX2FyY2hpdmVfMSBmcm9tIFwiLi9zZnJwZy9hbGllbl9hcmNoaXZlXzEuanNvblwiO1xuaW1wb3J0IGFsaWVuX2FyY2hpdmVfMiBmcm9tIFwiLi9zZnJwZy9hbGllbl9hcmNoaXZlXzIuanNvblwiO1xuaW1wb3J0IGFsaWVuX2FyY2hpdmVfMyBmcm9tIFwiLi9zZnJwZy9hbGllbl9hcmNoaXZlXzMuanNvblwiO1xuXG5leHBvcnQgY29uc3QgU3RhcmZpbmRlckxpc3Q6IGlTdGFyZmluZGVyRG9jW10gPSBbXG4gICAgYWxpZW5fYXJjaGl2ZV8xLFxuICAgIGFsaWVuX2FyY2hpdmVfMixcbiAgICBhbGllbl9hcmNoaXZlXzMsXG5dOyIsImltcG9ydCB7IFBERkRvY3VtZW50UHJveHksIFBERlBhZ2VQcm94eSwgZ2V0RG9jdW1lbnQsIE9QUywgR2xvYmFsV29ya2VyT3B0aW9ucyB9IGZyb20gXCJwZGZqcy1kaXN0XCI7XG5pbXBvcnQgeyBJbWFnZU1hcCB9IGZyb20gXCJAbWFwcGluZ3NcIjtcblxuY2xhc3MgUGRmRGF0YSB7XG4gICAgcHVibGljIGltYWdlczogSW1hZ2VNYXBbXTtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHVibGljIHRpdGxlOiBzdHJpbmcsXG4gICAgICAgIHB1YmxpYyBhdXRob3I6IHN0cmluZyxcbiAgICAgICAgcHVibGljIGNyZWF0aW9uRGF0ZTogc3RyaW5nLFxuICAgICkge1xuICAgICAgICB0aGlzLmltYWdlcyA9IFtdO1xuICAgIH1cbn1cblxuLy8gU2V0dGluZyB3b3JrZXIgcGF0aCB0byB3b3JrZXIgYnVuZGxlLlxuLy8gRG8gbm90IGhhdmUgd2VicGFjayB0cnkgdG8gYnVuZGxlIHdpdGggcHJvamVjdC4gVGhpcyBqdXN0IGNhdXNlcyBlcnJvcnNcbkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjID1cbiAgICBcIi4uLy4uL25vZGVfbW9kdWxlcy9wZGZqcy1kaXN0L2J1aWxkL3BkZi53b3JrZXIuanNcIjtcblxuLyoqXG4gKiBFeHRyYWN0IGFsbCBpbWFnZXMgYW5kIG1ldGFkYXRhIGZyb20gYSBQREZcbiAqIFxuICogQHBhcmFtIHBhdGggLSBBYnNvbHV0ZSBmaWxlIHBhdGggdG8gUERGXG4gKiBAcmV0dXJucyBBIHByb21pc2VkIGxpc3Qgb2YgaW1hZ2VzIGFuZCBtZXRhZGF0YSBmcm9tIHRoZSBQREYgXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBHZXRQZGZEYWZhKHBhdGg6IHN0cmluZykge1xuICAgIGxldCBwZGY6IFBERkRvY3VtZW50UHJveHkgPSBhd2FpdCBnZXREb2N1bWVudChwYXRoKS5wcm9taXNlO1xuXG4gICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBwZGYuZ2V0TWV0YWRhdGEoKTtcbiAgICBsZXQgcGRmX2RhdGEgPSBuZXcgUGRmRGF0YShcbiAgICAgICAgKG1ldGFkYXRhLmluZm8gYXMgYW55KVsnVGl0bGUnXSxcbiAgICAgICAgKG1ldGFkYXRhLmluZm8gYXMgYW55KVsnQXV0aG9yJ10sXG4gICAgICAgIChtZXRhZGF0YS5pbmZvIGFzIGFueSlbJ0NyZWF0aW9uRGF0ZSddXG4gICAgKTtcbiAgICBjb25zdCB0b3RhbE51bVBhZ2VzID0gcGRmLm51bVBhZ2VzO1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFsbCBwYWdlcyBhbmQgcHVzaCBpbWFnZXMgdG8gcGFnZVByb21pc2VzXG4gICAgZm9yIChsZXQgY3VycmVudFBhZ2UgPSAxOyBjdXJyZW50UGFnZSA8PSB0b3RhbE51bVBhZ2VzOyBjdXJyZW50UGFnZSArPSAxKSB7XG4gICAgICAgIGNvbnN0IGltYWdlcyA9IGdldFBhZ2VJbWFnZXMoY3VycmVudFBhZ2UsIHBkZik7XG4gICAgICAgIHBkZl9kYXRhLmltYWdlcy5wdXNoKC4uLmF3YWl0IGltYWdlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF3YWl0IHBkZl9kYXRhO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgYWxsIGltYWdlcyBmcm9tIHRoZSBjdXJyZW50IFBERiBwYWdlXG4gKiBcbiAqIEBwYXJhbSBwYWdlTnVtIC0gVGhlIHBhZ2UgbnVtYmVyIHRvIGdyYWJcbiAqIEBwYXJhbSBwZGYgLSBSZWZlcmVuY2UgdG8gdGhlIFBERlxuICogQHJldHVybnMgTGlzdCBvZiBpbWFnZXMgZnJvbSB0aGUgUERGIHBhZ2VcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0UGFnZUltYWdlcyhwYWdlTnVtOiBudW1iZXIsIHBkZjogUERGRG9jdW1lbnRQcm94eSkge1xuICAgIGNvbnN0IGltYWdlczogSW1hZ2VNYXBbXSA9IFtdO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBkZlBhZ2U6IFBERlBhZ2VQcm94eSA9IGF3YWl0IHBkZi5nZXRQYWdlKHBhZ2VOdW0pO1xuICAgICAgICBjb25zdCBvcGVyYXRvckxpc3QgPSBhd2FpdCBwZGZQYWdlLmdldE9wZXJhdG9yTGlzdCgpO1xuXG4gICAgICAgIC8vIFRoZXNlIGluZGljYXRlIHRoZSBlbGVtZW50IGlzIGFuIGltYWdlXG4gICAgICAgIGNvbnN0IHZhbGlkT2JqZWN0VHlwZXMgPSBbXG4gICAgICAgICAgICBPUFMucGFpbnRKcGVnWE9iamVjdCxcbiAgICAgICAgICAgIE9QUy5wYWludEltYWdlWE9iamVjdCxcbiAgICAgICAgICAgIE9QUy5wYWludElubGluZUltYWdlWE9iamVjdFxuICAgICAgICBdO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBlYWNoIGVsZW1lbnQgaW4gdGhlIHBhZ2UgYW5kIHN0b3JlIGFueSBlbGVtZW50IGluZmVycmVkIHRvIGJlIGFuIGltYWdlXG4gICAgICAgIG9wZXJhdG9yTGlzdC5mbkFycmF5XG4gICAgICAgICAgICAuZm9yRWFjaCgoZWxlbWVudCwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkT2JqZWN0VHlwZXMuaW5jbHVkZXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VOYW1lID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheVtpZHhdWzBdO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncGFnZScsIHBhZ2VOdW0sICdpbWFnZU5hbWUnLCBpbWFnZU5hbWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBkZlBhZ2Uub2Jqcy5nZXQoaW1hZ2VOYW1lLCBhc3luYyAoaW1hZ2U6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBfa2luZCB9ID0gaW1hZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZXMucHVzaChuZXcgSW1hZ2VNYXAoaW1hZ2VOYW1lLCB3aWR0aCwgaGVpZ2h0LCBpbWFnZS5kYXRhKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGltYWdlcztcbn1cbiIsIi8qKlxuICogQGxpY3N0YXJ0IFRoZSBmb2xsb3dpbmcgaXMgdGhlIGVudGlyZSBsaWNlbnNlIG5vdGljZSBmb3IgdGhlXG4gKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMjIgTW96aWxsYSBGb3VuZGF0aW9uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBsaWNlbmQgVGhlIGFib3ZlIGlzIHRoZSBlbnRpcmUgbGljZW5zZSBub3RpY2UgZm9yIHRoZVxuICogSmF2YVNjcmlwdCBjb2RlIGluIHRoaXMgcGFnZVxuICovXG5cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwicGRmanMtZGlzdC9idWlsZC9wZGZcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wicGRmanMtZGlzdC9idWlsZC9wZGZcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicGRmanMtZGlzdC9idWlsZC9wZGZcIl0gPSByb290LnBkZmpzTGliID0gZmFjdG9yeSgpO1xufSkoZ2xvYmFsVGhpcywgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKFtcbi8qIDAgKi8sXG4vKiAxICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlZlcmJvc2l0eUxldmVsID0gZXhwb3J0cy5VdGlsID0gZXhwb3J0cy5Vbmtub3duRXJyb3JFeGNlcHRpb24gPSBleHBvcnRzLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiA9IGV4cG9ydHMuVU5TVVBQT1JURURfRkVBVFVSRVMgPSBleHBvcnRzLlRleHRSZW5kZXJpbmdNb2RlID0gZXhwb3J0cy5TdHJlYW1UeXBlID0gZXhwb3J0cy5SZW5kZXJpbmdJbnRlbnRGbGFnID0gZXhwb3J0cy5QZXJtaXNzaW9uRmxhZyA9IGV4cG9ydHMuUGFzc3dvcmRSZXNwb25zZXMgPSBleHBvcnRzLlBhc3N3b3JkRXhjZXB0aW9uID0gZXhwb3J0cy5QYWdlQWN0aW9uRXZlbnRUeXBlID0gZXhwb3J0cy5PUFMgPSBleHBvcnRzLk1pc3NpbmdQREZFeGNlcHRpb24gPSBleHBvcnRzLkxJTkVfRkFDVE9SID0gZXhwb3J0cy5MSU5FX0RFU0NFTlRfRkFDVE9SID0gZXhwb3J0cy5JbnZhbGlkUERGRXhjZXB0aW9uID0gZXhwb3J0cy5JbWFnZUtpbmQgPSBleHBvcnRzLklERU5USVRZX01BVFJJWCA9IGV4cG9ydHMuRm9ybWF0RXJyb3IgPSBleHBvcnRzLkZvbnRUeXBlID0gZXhwb3J0cy5GZWF0dXJlVGVzdCA9IGV4cG9ydHMuRk9OVF9JREVOVElUWV9NQVRSSVggPSBleHBvcnRzLkRvY3VtZW50QWN0aW9uRXZlbnRUeXBlID0gZXhwb3J0cy5DTWFwQ29tcHJlc3Npb25UeXBlID0gZXhwb3J0cy5CYXNlRXhjZXB0aW9uID0gZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZSA9IGV4cG9ydHMuQW5ub3RhdGlvblN0YXRlTW9kZWxUeXBlID0gZXhwb3J0cy5Bbm5vdGF0aW9uUmV2aWV3U3RhdGUgPSBleHBvcnRzLkFubm90YXRpb25SZXBseVR5cGUgPSBleHBvcnRzLkFubm90YXRpb25Nb2RlID0gZXhwb3J0cy5Bbm5vdGF0aW9uTWFya2VkU3RhdGUgPSBleHBvcnRzLkFubm90YXRpb25GbGFnID0gZXhwb3J0cy5Bbm5vdGF0aW9uRmllbGRGbGFnID0gZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yVHlwZSA9IGV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvclByZWZpeCA9IGV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUgPSBleHBvcnRzLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUgPSBleHBvcnRzLkFubm90YXRpb25BY3Rpb25FdmVudFR5cGUgPSBleHBvcnRzLkFib3J0RXhjZXB0aW9uID0gdm9pZCAwO1xuZXhwb3J0cy5hcnJheUJ5dGVMZW5ndGggPSBhcnJheUJ5dGVMZW5ndGg7XG5leHBvcnRzLmFycmF5c1RvQnl0ZXMgPSBhcnJheXNUb0J5dGVzO1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5leHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBieXRlc1RvU3RyaW5nO1xuZXhwb3J0cy5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSA9IGNyZWF0ZVByb21pc2VDYXBhYmlsaXR5O1xuZXhwb3J0cy5jcmVhdGVWYWxpZEFic29sdXRlVXJsID0gY3JlYXRlVmFsaWRBYnNvbHV0ZVVybDtcbmV4cG9ydHMuZXNjYXBlU3RyaW5nID0gZXNjYXBlU3RyaW5nO1xuZXhwb3J0cy5nZXRNb2RpZmljYXRpb25EYXRlID0gZ2V0TW9kaWZpY2F0aW9uRGF0ZTtcbmV4cG9ydHMuZ2V0VmVyYm9zaXR5TGV2ZWwgPSBnZXRWZXJib3NpdHlMZXZlbDtcbmV4cG9ydHMuaW5mbyA9IGluZm87XG5leHBvcnRzLmlzQXJyYXlCdWZmZXIgPSBpc0FycmF5QnVmZmVyO1xuZXhwb3J0cy5pc0FycmF5RXF1YWwgPSBpc0FycmF5RXF1YWw7XG5leHBvcnRzLmlzQXNjaWkgPSBpc0FzY2lpO1xuZXhwb3J0cy5vYmplY3RGcm9tTWFwID0gb2JqZWN0RnJvbU1hcDtcbmV4cG9ydHMub2JqZWN0U2l6ZSA9IG9iamVjdFNpemU7XG5leHBvcnRzLnNldFZlcmJvc2l0eUxldmVsID0gc2V0VmVyYm9zaXR5TGV2ZWw7XG5leHBvcnRzLnNoYWRvdyA9IHNoYWRvdztcbmV4cG9ydHMuc3RyaW5nMzIgPSBzdHJpbmczMjtcbmV4cG9ydHMuc3RyaW5nVG9CeXRlcyA9IHN0cmluZ1RvQnl0ZXM7XG5leHBvcnRzLnN0cmluZ1RvUERGU3RyaW5nID0gc3RyaW5nVG9QREZTdHJpbmc7XG5leHBvcnRzLnN0cmluZ1RvVVRGMTZCRVN0cmluZyA9IHN0cmluZ1RvVVRGMTZCRVN0cmluZztcbmV4cG9ydHMuc3RyaW5nVG9VVEY4U3RyaW5nID0gc3RyaW5nVG9VVEY4U3RyaW5nO1xuZXhwb3J0cy51bnJlYWNoYWJsZSA9IHVucmVhY2hhYmxlO1xuZXhwb3J0cy51dGY4U3RyaW5nVG9TdHJpbmcgPSB1dGY4U3RyaW5nVG9TdHJpbmc7XG5leHBvcnRzLndhcm4gPSB3YXJuO1xuXG5fX3dfcGRmanNfcmVxdWlyZV9fKDIpO1xuXG5jb25zdCBJREVOVElUWV9NQVRSSVggPSBbMSwgMCwgMCwgMSwgMCwgMF07XG5leHBvcnRzLklERU5USVRZX01BVFJJWCA9IElERU5USVRZX01BVFJJWDtcbmNvbnN0IEZPTlRfSURFTlRJVFlfTUFUUklYID0gWzAuMDAxLCAwLCAwLCAwLjAwMSwgMCwgMF07XG5leHBvcnRzLkZPTlRfSURFTlRJVFlfTUFUUklYID0gRk9OVF9JREVOVElUWV9NQVRSSVg7XG5jb25zdCBMSU5FX0ZBQ1RPUiA9IDEuMzU7XG5leHBvcnRzLkxJTkVfRkFDVE9SID0gTElORV9GQUNUT1I7XG5jb25zdCBMSU5FX0RFU0NFTlRfRkFDVE9SID0gMC4zNTtcbmV4cG9ydHMuTElORV9ERVNDRU5UX0ZBQ1RPUiA9IExJTkVfREVTQ0VOVF9GQUNUT1I7XG5jb25zdCBSZW5kZXJpbmdJbnRlbnRGbGFnID0ge1xuICBBTlk6IDB4MDEsXG4gIERJU1BMQVk6IDB4MDIsXG4gIFBSSU5UOiAweDA0LFxuICBBTk5PVEFUSU9OU19GT1JNUzogMHgxMCxcbiAgQU5OT1RBVElPTlNfU1RPUkFHRTogMHgyMCxcbiAgQU5OT1RBVElPTlNfRElTQUJMRTogMHg0MCxcbiAgT1BMSVNUOiAweDEwMFxufTtcbmV4cG9ydHMuUmVuZGVyaW5nSW50ZW50RmxhZyA9IFJlbmRlcmluZ0ludGVudEZsYWc7XG5jb25zdCBBbm5vdGF0aW9uTW9kZSA9IHtcbiAgRElTQUJMRTogMCxcbiAgRU5BQkxFOiAxLFxuICBFTkFCTEVfRk9STVM6IDIsXG4gIEVOQUJMRV9TVE9SQUdFOiAzXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uTW9kZSA9IEFubm90YXRpb25Nb2RlO1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclByZWZpeCA9IFwicGRmanNfaW50ZXJuYWxfZWRpdG9yX1wiO1xuZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yUHJlZml4ID0gQW5ub3RhdGlvbkVkaXRvclByZWZpeDtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JUeXBlID0ge1xuICBESVNBQkxFOiAtMSxcbiAgTk9ORTogMCxcbiAgRlJFRVRFWFQ6IDMsXG4gIElOSzogMTVcbn07XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3JUeXBlID0gQW5ub3RhdGlvbkVkaXRvclR5cGU7XG5jb25zdCBBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSA9IHtcbiAgRlJFRVRFWFRfU0laRTogMSxcbiAgRlJFRVRFWFRfQ09MT1I6IDIsXG4gIEZSRUVURVhUX09QQUNJVFk6IDMsXG4gIElOS19DT0xPUjogMTEsXG4gIElOS19USElDS05FU1M6IDEyLFxuICBJTktfT1BBQ0lUWTogMTNcbn07XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlID0gQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGU7XG5jb25zdCBQZXJtaXNzaW9uRmxhZyA9IHtcbiAgUFJJTlQ6IDB4MDQsXG4gIE1PRElGWV9DT05URU5UUzogMHgwOCxcbiAgQ09QWTogMHgxMCxcbiAgTU9ESUZZX0FOTk9UQVRJT05TOiAweDIwLFxuICBGSUxMX0lOVEVSQUNUSVZFX0ZPUk1TOiAweDEwMCxcbiAgQ09QWV9GT1JfQUNDRVNTSUJJTElUWTogMHgyMDAsXG4gIEFTU0VNQkxFOiAweDQwMCxcbiAgUFJJTlRfSElHSF9RVUFMSVRZOiAweDgwMFxufTtcbmV4cG9ydHMuUGVybWlzc2lvbkZsYWcgPSBQZXJtaXNzaW9uRmxhZztcbmNvbnN0IFRleHRSZW5kZXJpbmdNb2RlID0ge1xuICBGSUxMOiAwLFxuICBTVFJPS0U6IDEsXG4gIEZJTExfU1RST0tFOiAyLFxuICBJTlZJU0lCTEU6IDMsXG4gIEZJTExfQUREX1RPX1BBVEg6IDQsXG4gIFNUUk9LRV9BRERfVE9fUEFUSDogNSxcbiAgRklMTF9TVFJPS0VfQUREX1RPX1BBVEg6IDYsXG4gIEFERF9UT19QQVRIOiA3LFxuICBGSUxMX1NUUk9LRV9NQVNLOiAzLFxuICBBRERfVE9fUEFUSF9GTEFHOiA0XG59O1xuZXhwb3J0cy5UZXh0UmVuZGVyaW5nTW9kZSA9IFRleHRSZW5kZXJpbmdNb2RlO1xuY29uc3QgSW1hZ2VLaW5kID0ge1xuICBHUkFZU0NBTEVfMUJQUDogMSxcbiAgUkdCXzI0QlBQOiAyLFxuICBSR0JBXzMyQlBQOiAzXG59O1xuZXhwb3J0cy5JbWFnZUtpbmQgPSBJbWFnZUtpbmQ7XG5jb25zdCBBbm5vdGF0aW9uVHlwZSA9IHtcbiAgVEVYVDogMSxcbiAgTElOSzogMixcbiAgRlJFRVRFWFQ6IDMsXG4gIExJTkU6IDQsXG4gIFNRVUFSRTogNSxcbiAgQ0lSQ0xFOiA2LFxuICBQT0xZR09OOiA3LFxuICBQT0xZTElORTogOCxcbiAgSElHSExJR0hUOiA5LFxuICBVTkRFUkxJTkU6IDEwLFxuICBTUVVJR0dMWTogMTEsXG4gIFNUUklLRU9VVDogMTIsXG4gIFNUQU1QOiAxMyxcbiAgQ0FSRVQ6IDE0LFxuICBJTks6IDE1LFxuICBQT1BVUDogMTYsXG4gIEZJTEVBVFRBQ0hNRU5UOiAxNyxcbiAgU09VTkQ6IDE4LFxuICBNT1ZJRTogMTksXG4gIFdJREdFVDogMjAsXG4gIFNDUkVFTjogMjEsXG4gIFBSSU5URVJNQVJLOiAyMixcbiAgVFJBUE5FVDogMjMsXG4gIFdBVEVSTUFSSzogMjQsXG4gIFRIUkVFRDogMjUsXG4gIFJFREFDVDogMjZcbn07XG5leHBvcnRzLkFubm90YXRpb25UeXBlID0gQW5ub3RhdGlvblR5cGU7XG5jb25zdCBBbm5vdGF0aW9uU3RhdGVNb2RlbFR5cGUgPSB7XG4gIE1BUktFRDogXCJNYXJrZWRcIixcbiAgUkVWSUVXOiBcIlJldmlld1wiXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uU3RhdGVNb2RlbFR5cGUgPSBBbm5vdGF0aW9uU3RhdGVNb2RlbFR5cGU7XG5jb25zdCBBbm5vdGF0aW9uTWFya2VkU3RhdGUgPSB7XG4gIE1BUktFRDogXCJNYXJrZWRcIixcbiAgVU5NQVJLRUQ6IFwiVW5tYXJrZWRcIlxufTtcbmV4cG9ydHMuQW5ub3RhdGlvbk1hcmtlZFN0YXRlID0gQW5ub3RhdGlvbk1hcmtlZFN0YXRlO1xuY29uc3QgQW5ub3RhdGlvblJldmlld1N0YXRlID0ge1xuICBBQ0NFUFRFRDogXCJBY2NlcHRlZFwiLFxuICBSRUpFQ1RFRDogXCJSZWplY3RlZFwiLFxuICBDQU5DRUxMRUQ6IFwiQ2FuY2VsbGVkXCIsXG4gIENPTVBMRVRFRDogXCJDb21wbGV0ZWRcIixcbiAgTk9ORTogXCJOb25lXCJcbn07XG5leHBvcnRzLkFubm90YXRpb25SZXZpZXdTdGF0ZSA9IEFubm90YXRpb25SZXZpZXdTdGF0ZTtcbmNvbnN0IEFubm90YXRpb25SZXBseVR5cGUgPSB7XG4gIEdST1VQOiBcIkdyb3VwXCIsXG4gIFJFUExZOiBcIlJcIlxufTtcbmV4cG9ydHMuQW5ub3RhdGlvblJlcGx5VHlwZSA9IEFubm90YXRpb25SZXBseVR5cGU7XG5jb25zdCBBbm5vdGF0aW9uRmxhZyA9IHtcbiAgSU5WSVNJQkxFOiAweDAxLFxuICBISURERU46IDB4MDIsXG4gIFBSSU5UOiAweDA0LFxuICBOT1pPT006IDB4MDgsXG4gIE5PUk9UQVRFOiAweDEwLFxuICBOT1ZJRVc6IDB4MjAsXG4gIFJFQURPTkxZOiAweDQwLFxuICBMT0NLRUQ6IDB4ODAsXG4gIFRPR0dMRU5PVklFVzogMHgxMDAsXG4gIExPQ0tFRENPTlRFTlRTOiAweDIwMFxufTtcbmV4cG9ydHMuQW5ub3RhdGlvbkZsYWcgPSBBbm5vdGF0aW9uRmxhZztcbmNvbnN0IEFubm90YXRpb25GaWVsZEZsYWcgPSB7XG4gIFJFQURPTkxZOiAweDAwMDAwMDEsXG4gIFJFUVVJUkVEOiAweDAwMDAwMDIsXG4gIE5PRVhQT1JUOiAweDAwMDAwMDQsXG4gIE1VTFRJTElORTogMHgwMDAxMDAwLFxuICBQQVNTV09SRDogMHgwMDAyMDAwLFxuICBOT1RPR0dMRVRPT0ZGOiAweDAwMDQwMDAsXG4gIFJBRElPOiAweDAwMDgwMDAsXG4gIFBVU0hCVVRUT046IDB4MDAxMDAwMCxcbiAgQ09NQk86IDB4MDAyMDAwMCxcbiAgRURJVDogMHgwMDQwMDAwLFxuICBTT1JUOiAweDAwODAwMDAsXG4gIEZJTEVTRUxFQ1Q6IDB4MDEwMDAwMCxcbiAgTVVMVElTRUxFQ1Q6IDB4MDIwMDAwMCxcbiAgRE9OT1RTUEVMTENIRUNLOiAweDA0MDAwMDAsXG4gIERPTk9UU0NST0xMOiAweDA4MDAwMDAsXG4gIENPTUI6IDB4MTAwMDAwMCxcbiAgUklDSFRFWFQ6IDB4MjAwMDAwMCxcbiAgUkFESU9TSU5VTklTT046IDB4MjAwMDAwMCxcbiAgQ09NTUlUT05TRUxDSEFOR0U6IDB4NDAwMDAwMFxufTtcbmV4cG9ydHMuQW5ub3RhdGlvbkZpZWxkRmxhZyA9IEFubm90YXRpb25GaWVsZEZsYWc7XG5jb25zdCBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlID0ge1xuICBTT0xJRDogMSxcbiAgREFTSEVEOiAyLFxuICBCRVZFTEVEOiAzLFxuICBJTlNFVDogNCxcbiAgVU5ERVJMSU5FOiA1XG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlID0gQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZTtcbmNvbnN0IEFubm90YXRpb25BY3Rpb25FdmVudFR5cGUgPSB7XG4gIEU6IFwiTW91c2UgRW50ZXJcIixcbiAgWDogXCJNb3VzZSBFeGl0XCIsXG4gIEQ6IFwiTW91c2UgRG93blwiLFxuICBVOiBcIk1vdXNlIFVwXCIsXG4gIEZvOiBcIkZvY3VzXCIsXG4gIEJsOiBcIkJsdXJcIixcbiAgUE86IFwiUGFnZU9wZW5cIixcbiAgUEM6IFwiUGFnZUNsb3NlXCIsXG4gIFBWOiBcIlBhZ2VWaXNpYmxlXCIsXG4gIFBJOiBcIlBhZ2VJbnZpc2libGVcIixcbiAgSzogXCJLZXlzdHJva2VcIixcbiAgRjogXCJGb3JtYXRcIixcbiAgVjogXCJWYWxpZGF0ZVwiLFxuICBDOiBcIkNhbGN1bGF0ZVwiXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlID0gQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZTtcbmNvbnN0IERvY3VtZW50QWN0aW9uRXZlbnRUeXBlID0ge1xuICBXQzogXCJXaWxsQ2xvc2VcIixcbiAgV1M6IFwiV2lsbFNhdmVcIixcbiAgRFM6IFwiRGlkU2F2ZVwiLFxuICBXUDogXCJXaWxsUHJpbnRcIixcbiAgRFA6IFwiRGlkUHJpbnRcIlxufTtcbmV4cG9ydHMuRG9jdW1lbnRBY3Rpb25FdmVudFR5cGUgPSBEb2N1bWVudEFjdGlvbkV2ZW50VHlwZTtcbmNvbnN0IFBhZ2VBY3Rpb25FdmVudFR5cGUgPSB7XG4gIE86IFwiUGFnZU9wZW5cIixcbiAgQzogXCJQYWdlQ2xvc2VcIlxufTtcbmV4cG9ydHMuUGFnZUFjdGlvbkV2ZW50VHlwZSA9IFBhZ2VBY3Rpb25FdmVudFR5cGU7XG5jb25zdCBTdHJlYW1UeXBlID0ge1xuICBVTktOT1dOOiBcIlVOS05PV05cIixcbiAgRkxBVEU6IFwiRkxBVEVcIixcbiAgTFpXOiBcIkxaV1wiLFxuICBEQ1Q6IFwiRENUXCIsXG4gIEpQWDogXCJKUFhcIixcbiAgSkJJRzogXCJKQklHXCIsXG4gIEE4NTogXCJBODVcIixcbiAgQUhYOiBcIkFIWFwiLFxuICBDQ0Y6IFwiQ0NGXCIsXG4gIFJMWDogXCJSTFhcIlxufTtcbmV4cG9ydHMuU3RyZWFtVHlwZSA9IFN0cmVhbVR5cGU7XG5jb25zdCBGb250VHlwZSA9IHtcbiAgVU5LTk9XTjogXCJVTktOT1dOXCIsXG4gIFRZUEUxOiBcIlRZUEUxXCIsXG4gIFRZUEUxU1RBTkRBUkQ6IFwiVFlQRTFTVEFOREFSRFwiLFxuICBUWVBFMUM6IFwiVFlQRTFDXCIsXG4gIENJREZPTlRUWVBFMDogXCJDSURGT05UVFlQRTBcIixcbiAgQ0lERk9OVFRZUEUwQzogXCJDSURGT05UVFlQRTBDXCIsXG4gIFRSVUVUWVBFOiBcIlRSVUVUWVBFXCIsXG4gIENJREZPTlRUWVBFMjogXCJDSURGT05UVFlQRTJcIixcbiAgVFlQRTM6IFwiVFlQRTNcIixcbiAgT1BFTlRZUEU6IFwiT1BFTlRZUEVcIixcbiAgVFlQRTA6IFwiVFlQRTBcIixcbiAgTU1UWVBFMTogXCJNTVRZUEUxXCJcbn07XG5leHBvcnRzLkZvbnRUeXBlID0gRm9udFR5cGU7XG5jb25zdCBWZXJib3NpdHlMZXZlbCA9IHtcbiAgRVJST1JTOiAwLFxuICBXQVJOSU5HUzogMSxcbiAgSU5GT1M6IDVcbn07XG5leHBvcnRzLlZlcmJvc2l0eUxldmVsID0gVmVyYm9zaXR5TGV2ZWw7XG5jb25zdCBDTWFwQ29tcHJlc3Npb25UeXBlID0ge1xuICBOT05FOiAwLFxuICBCSU5BUlk6IDEsXG4gIFNUUkVBTTogMlxufTtcbmV4cG9ydHMuQ01hcENvbXByZXNzaW9uVHlwZSA9IENNYXBDb21wcmVzc2lvblR5cGU7XG5jb25zdCBPUFMgPSB7XG4gIGRlcGVuZGVuY3k6IDEsXG4gIHNldExpbmVXaWR0aDogMixcbiAgc2V0TGluZUNhcDogMyxcbiAgc2V0TGluZUpvaW46IDQsXG4gIHNldE1pdGVyTGltaXQ6IDUsXG4gIHNldERhc2g6IDYsXG4gIHNldFJlbmRlcmluZ0ludGVudDogNyxcbiAgc2V0RmxhdG5lc3M6IDgsXG4gIHNldEdTdGF0ZTogOSxcbiAgc2F2ZTogMTAsXG4gIHJlc3RvcmU6IDExLFxuICB0cmFuc2Zvcm06IDEyLFxuICBtb3ZlVG86IDEzLFxuICBsaW5lVG86IDE0LFxuICBjdXJ2ZVRvOiAxNSxcbiAgY3VydmVUbzI6IDE2LFxuICBjdXJ2ZVRvMzogMTcsXG4gIGNsb3NlUGF0aDogMTgsXG4gIHJlY3RhbmdsZTogMTksXG4gIHN0cm9rZTogMjAsXG4gIGNsb3NlU3Ryb2tlOiAyMSxcbiAgZmlsbDogMjIsXG4gIGVvRmlsbDogMjMsXG4gIGZpbGxTdHJva2U6IDI0LFxuICBlb0ZpbGxTdHJva2U6IDI1LFxuICBjbG9zZUZpbGxTdHJva2U6IDI2LFxuICBjbG9zZUVPRmlsbFN0cm9rZTogMjcsXG4gIGVuZFBhdGg6IDI4LFxuICBjbGlwOiAyOSxcbiAgZW9DbGlwOiAzMCxcbiAgYmVnaW5UZXh0OiAzMSxcbiAgZW5kVGV4dDogMzIsXG4gIHNldENoYXJTcGFjaW5nOiAzMyxcbiAgc2V0V29yZFNwYWNpbmc6IDM0LFxuICBzZXRIU2NhbGU6IDM1LFxuICBzZXRMZWFkaW5nOiAzNixcbiAgc2V0Rm9udDogMzcsXG4gIHNldFRleHRSZW5kZXJpbmdNb2RlOiAzOCxcbiAgc2V0VGV4dFJpc2U6IDM5LFxuICBtb3ZlVGV4dDogNDAsXG4gIHNldExlYWRpbmdNb3ZlVGV4dDogNDEsXG4gIHNldFRleHRNYXRyaXg6IDQyLFxuICBuZXh0TGluZTogNDMsXG4gIHNob3dUZXh0OiA0NCxcbiAgc2hvd1NwYWNlZFRleHQ6IDQ1LFxuICBuZXh0TGluZVNob3dUZXh0OiA0NixcbiAgbmV4dExpbmVTZXRTcGFjaW5nU2hvd1RleHQ6IDQ3LFxuICBzZXRDaGFyV2lkdGg6IDQ4LFxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IDQ5LFxuICBzZXRTdHJva2VDb2xvclNwYWNlOiA1MCxcbiAgc2V0RmlsbENvbG9yU3BhY2U6IDUxLFxuICBzZXRTdHJva2VDb2xvcjogNTIsXG4gIHNldFN0cm9rZUNvbG9yTjogNTMsXG4gIHNldEZpbGxDb2xvcjogNTQsXG4gIHNldEZpbGxDb2xvck46IDU1LFxuICBzZXRTdHJva2VHcmF5OiA1NixcbiAgc2V0RmlsbEdyYXk6IDU3LFxuICBzZXRTdHJva2VSR0JDb2xvcjogNTgsXG4gIHNldEZpbGxSR0JDb2xvcjogNTksXG4gIHNldFN0cm9rZUNNWUtDb2xvcjogNjAsXG4gIHNldEZpbGxDTVlLQ29sb3I6IDYxLFxuICBzaGFkaW5nRmlsbDogNjIsXG4gIGJlZ2luSW5saW5lSW1hZ2U6IDYzLFxuICBiZWdpbkltYWdlRGF0YTogNjQsXG4gIGVuZElubGluZUltYWdlOiA2NSxcbiAgcGFpbnRYT2JqZWN0OiA2NixcbiAgbWFya1BvaW50OiA2NyxcbiAgbWFya1BvaW50UHJvcHM6IDY4LFxuICBiZWdpbk1hcmtlZENvbnRlbnQ6IDY5LFxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wczogNzAsXG4gIGVuZE1hcmtlZENvbnRlbnQ6IDcxLFxuICBiZWdpbkNvbXBhdDogNzIsXG4gIGVuZENvbXBhdDogNzMsXG4gIHBhaW50Rm9ybVhPYmplY3RCZWdpbjogNzQsXG4gIHBhaW50Rm9ybVhPYmplY3RFbmQ6IDc1LFxuICBiZWdpbkdyb3VwOiA3NixcbiAgZW5kR3JvdXA6IDc3LFxuICBiZWdpbkFubm90YXRpb25zOiA3OCxcbiAgZW5kQW5ub3RhdGlvbnM6IDc5LFxuICBiZWdpbkFubm90YXRpb246IDgwLFxuICBlbmRBbm5vdGF0aW9uOiA4MSxcbiAgcGFpbnRKcGVnWE9iamVjdDogODIsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdDogODMsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwOiA4NCxcbiAgcGFpbnRJbWFnZVhPYmplY3Q6IDg1LFxuICBwYWludElubGluZUltYWdlWE9iamVjdDogODYsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0R3JvdXA6IDg3LFxuICBwYWludEltYWdlWE9iamVjdFJlcGVhdDogODgsXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdFJlcGVhdDogODksXG4gIHBhaW50U29saWRDb2xvckltYWdlTWFzazogOTAsXG4gIGNvbnN0cnVjdFBhdGg6IDkxXG59O1xuZXhwb3J0cy5PUFMgPSBPUFM7XG5jb25zdCBVTlNVUFBPUlRFRF9GRUFUVVJFUyA9IHtcbiAgdW5rbm93bjogXCJ1bmtub3duXCIsXG4gIGZvcm1zOiBcImZvcm1zXCIsXG4gIGphdmFTY3JpcHQ6IFwiamF2YVNjcmlwdFwiLFxuICBzaWduYXR1cmVzOiBcInNpZ25hdHVyZXNcIixcbiAgc21hc2s6IFwic21hc2tcIixcbiAgc2hhZGluZ1BhdHRlcm46IFwic2hhZGluZ1BhdHRlcm5cIixcbiAgZm9udDogXCJmb250XCIsXG4gIGVycm9yVGlsaW5nUGF0dGVybjogXCJlcnJvclRpbGluZ1BhdHRlcm5cIixcbiAgZXJyb3JFeHRHU3RhdGU6IFwiZXJyb3JFeHRHU3RhdGVcIixcbiAgZXJyb3JYT2JqZWN0OiBcImVycm9yWE9iamVjdFwiLFxuICBlcnJvckZvbnRMb2FkVHlwZTM6IFwiZXJyb3JGb250TG9hZFR5cGUzXCIsXG4gIGVycm9yRm9udFN0YXRlOiBcImVycm9yRm9udFN0YXRlXCIsXG4gIGVycm9yRm9udE1pc3Npbmc6IFwiZXJyb3JGb250TWlzc2luZ1wiLFxuICBlcnJvckZvbnRUcmFuc2xhdGU6IFwiZXJyb3JGb250VHJhbnNsYXRlXCIsXG4gIGVycm9yQ29sb3JTcGFjZTogXCJlcnJvckNvbG9yU3BhY2VcIixcbiAgZXJyb3JPcGVyYXRvckxpc3Q6IFwiZXJyb3JPcGVyYXRvckxpc3RcIixcbiAgZXJyb3JGb250VG9Vbmljb2RlOiBcImVycm9yRm9udFRvVW5pY29kZVwiLFxuICBlcnJvckZvbnRMb2FkTmF0aXZlOiBcImVycm9yRm9udExvYWROYXRpdmVcIixcbiAgZXJyb3JGb250QnVpbGRQYXRoOiBcImVycm9yRm9udEJ1aWxkUGF0aFwiLFxuICBlcnJvckZvbnRHZXRQYXRoOiBcImVycm9yRm9udEdldFBhdGhcIixcbiAgZXJyb3JNYXJrZWRDb250ZW50OiBcImVycm9yTWFya2VkQ29udGVudFwiLFxuICBlcnJvckNvbnRlbnRTdWJTdHJlYW06IFwiZXJyb3JDb250ZW50U3ViU3RyZWFtXCJcbn07XG5leHBvcnRzLlVOU1VQUE9SVEVEX0ZFQVRVUkVTID0gVU5TVVBQT1JURURfRkVBVFVSRVM7XG5jb25zdCBQYXNzd29yZFJlc3BvbnNlcyA9IHtcbiAgTkVFRF9QQVNTV09SRDogMSxcbiAgSU5DT1JSRUNUX1BBU1NXT1JEOiAyXG59O1xuZXhwb3J0cy5QYXNzd29yZFJlc3BvbnNlcyA9IFBhc3N3b3JkUmVzcG9uc2VzO1xubGV0IHZlcmJvc2l0eSA9IFZlcmJvc2l0eUxldmVsLldBUk5JTkdTO1xuXG5mdW5jdGlvbiBzZXRWZXJib3NpdHlMZXZlbChsZXZlbCkge1xuICBpZiAoTnVtYmVyLmlzSW50ZWdlcihsZXZlbCkpIHtcbiAgICB2ZXJib3NpdHkgPSBsZXZlbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRWZXJib3NpdHlMZXZlbCgpIHtcbiAgcmV0dXJuIHZlcmJvc2l0eTtcbn1cblxuZnVuY3Rpb24gaW5mbyhtc2cpIHtcbiAgaWYgKHZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbC5JTkZPUykge1xuICAgIGNvbnNvbGUubG9nKGBJbmZvOiAke21zZ31gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLldBUk5JTkdTKSB7XG4gICAgY29uc29sZS5sb2coYFdhcm5pbmc6ICR7bXNnfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVucmVhY2hhYmxlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIG1zZykge1xuICBpZiAoIWNvbmQpIHtcbiAgICB1bnJlYWNoYWJsZShtc2cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pc1ZhbGlkUHJvdG9jb2wodXJsKSB7XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3dpdGNoICh1cmwucHJvdG9jb2wpIHtcbiAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICBjYXNlIFwiaHR0cHM6XCI6XG4gICAgY2FzZSBcImZ0cDpcIjpcbiAgICBjYXNlIFwibWFpbHRvOlwiOlxuICAgIGNhc2UgXCJ0ZWw6XCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCh1cmwsIGJhc2VVcmwgPSBudWxsLCBvcHRpb25zID0gbnVsbCkge1xuICBpZiAoIXVybCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBpZiAob3B0aW9ucy5hZGREZWZhdWx0UHJvdG9jb2wgJiYgdXJsLnN0YXJ0c1dpdGgoXCJ3d3cuXCIpKSB7XG4gICAgICAgIGNvbnN0IGRvdHMgPSB1cmwubWF0Y2goL1xcLi9nKTtcblxuICAgICAgICBpZiAoZG90cyAmJiBkb3RzLmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgdXJsID0gYGh0dHA6Ly8ke3VybH1gO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnRyeUNvbnZlcnRFbmNvZGluZykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHVybCA9IHN0cmluZ1RvVVRGOFN0cmluZyh1cmwpO1xuICAgICAgICB9IGNhdGNoIChleCkge31cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBhYnNvbHV0ZVVybCA9IGJhc2VVcmwgPyBuZXcgVVJMKHVybCwgYmFzZVVybCkgOiBuZXcgVVJMKHVybCk7XG5cbiAgICBpZiAoX2lzVmFsaWRQcm90b2NvbChhYnNvbHV0ZVVybCkpIHtcbiAgICAgIHJldHVybiBhYnNvbHV0ZVVybDtcbiAgICB9XG4gIH0gY2F0Y2ggKGV4KSB7fVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBzaGFkb3cob2JqLCBwcm9wLCB2YWx1ZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgdmFsdWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmNvbnN0IEJhc2VFeGNlcHRpb24gPSBmdW5jdGlvbiBCYXNlRXhjZXB0aW9uQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VFeGNlcHRpb24pIHtcbiAgICAgIHVucmVhY2hhYmxlKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZUV4Y2VwdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICB9XG5cbiAgQmFzZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgQmFzZUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IEJhc2VFeGNlcHRpb247XG4gIHJldHVybiBCYXNlRXhjZXB0aW9uO1xufSgpO1xuXG5leHBvcnRzLkJhc2VFeGNlcHRpb24gPSBCYXNlRXhjZXB0aW9uO1xuXG5jbGFzcyBQYXNzd29yZEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIGNvZGUpIHtcbiAgICBzdXBlcihtc2csIFwiUGFzc3dvcmRFeGNlcHRpb25cIik7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuUGFzc3dvcmRFeGNlcHRpb24gPSBQYXNzd29yZEV4Y2VwdGlvbjtcblxuY2xhc3MgVW5rbm93bkVycm9yRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgZGV0YWlscykge1xuICAgIHN1cGVyKG1zZywgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIik7XG4gICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgfVxuXG59XG5cbmV4cG9ydHMuVW5rbm93bkVycm9yRXhjZXB0aW9uID0gVW5rbm93bkVycm9yRXhjZXB0aW9uO1xuXG5jbGFzcyBJbnZhbGlkUERGRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCIpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5JbnZhbGlkUERGRXhjZXB0aW9uID0gSW52YWxpZFBERkV4Y2VwdGlvbjtcblxuY2xhc3MgTWlzc2luZ1BERkV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuTWlzc2luZ1BERkV4Y2VwdGlvbiA9IE1pc3NpbmdQREZFeGNlcHRpb247XG5cbmNsYXNzIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2csIHN0YXR1cykge1xuICAgIHN1cGVyKG1zZywgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIik7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gIH1cblxufVxuXG5leHBvcnRzLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiA9IFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjtcblxuY2xhc3MgRm9ybWF0RXJyb3IgZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkZvcm1hdEVycm9yXCIpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5Gb3JtYXRFcnJvciA9IEZvcm1hdEVycm9yO1xuXG5jbGFzcyBBYm9ydEV4Y2VwdGlvbiBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiQWJvcnRFeGNlcHRpb25cIik7XG4gIH1cblxufVxuXG5leHBvcnRzLkFib3J0RXhjZXB0aW9uID0gQWJvcnRFeGNlcHRpb247XG5cbmZ1bmN0aW9uIGJ5dGVzVG9TdHJpbmcoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBieXRlcyAhPT0gXCJvYmplY3RcIiB8fCBieXRlcyA9PT0gbnVsbCB8fCBieXRlcy5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHVucmVhY2hhYmxlKFwiSW52YWxpZCBhcmd1bWVudCBmb3IgYnl0ZXNUb1N0cmluZ1wiKTtcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgY29uc3QgTUFYX0FSR1VNRU5UX0NPVU5UID0gODE5MjtcblxuICBpZiAobGVuZ3RoIDwgTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnl0ZXMpO1xuICB9XG5cbiAgY29uc3Qgc3RyQnVmID0gW107XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gTUFYX0FSR1VNRU5UX0NPVU5UKSB7XG4gICAgY29uc3QgY2h1bmtFbmQgPSBNYXRoLm1pbihpICsgTUFYX0FSR1VNRU5UX0NPVU5ULCBsZW5ndGgpO1xuICAgIGNvbnN0IGNodW5rID0gYnl0ZXMuc3ViYXJyYXkoaSwgY2h1bmtFbmQpO1xuICAgIHN0ckJ1Zi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY2h1bmspKTtcbiAgfVxuXG4gIHJldHVybiBzdHJCdWYuam9pbihcIlwiKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHtcbiAgICB1bnJlYWNoYWJsZShcIkludmFsaWQgYXJndW1lbnQgZm9yIHN0cmluZ1RvQnl0ZXNcIik7XG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzW2ldID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5mdW5jdGlvbiBhcnJheUJ5dGVMZW5ndGgoYXJyKSB7XG4gIGlmIChhcnIubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYXJyLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChhcnIuYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFyci5ieXRlTGVuZ3RoO1xuICB9XG5cbiAgdW5yZWFjaGFibGUoXCJJbnZhbGlkIGFyZ3VtZW50IGZvciBhcnJheUJ5dGVMZW5ndGhcIik7XG59XG5cbmZ1bmN0aW9uIGFycmF5c1RvQnl0ZXMoYXJyKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFyci5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMSAmJiBhcnJbMF0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGFyclswXTtcbiAgfVxuXG4gIGxldCByZXN1bHRMZW5ndGggPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRMZW5ndGggKz0gYXJyYXlCeXRlTGVuZ3RoKGFycltpXSk7XG4gIH1cblxuICBsZXQgcG9zID0gMDtcbiAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KHJlc3VsdExlbmd0aCk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGxldCBpdGVtID0gYXJyW2ldO1xuXG4gICAgaWYgKCEoaXRlbSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaXRlbSA9IHN0cmluZ1RvQnl0ZXMoaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtID0gbmV3IFVpbnQ4QXJyYXkoaXRlbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaXRlbUxlbmd0aCA9IGl0ZW0uYnl0ZUxlbmd0aDtcbiAgICBkYXRhLnNldChpdGVtLCBwb3MpO1xuICAgIHBvcyArPSBpdGVtTGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIHN0cmluZzMyKHZhbHVlKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHZhbHVlID4+IDI0ICYgMHhmZiwgdmFsdWUgPj4gMTYgJiAweGZmLCB2YWx1ZSA+PiA4ICYgMHhmZiwgdmFsdWUgJiAweGZmKTtcbn1cblxuZnVuY3Rpb24gb2JqZWN0U2l6ZShvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBvYmplY3RGcm9tTWFwKG1hcCkge1xuICBjb25zdCBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcCkge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBpc0xpdHRsZUVuZGlhbigpIHtcbiAgY29uc3QgYnVmZmVyOCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICBidWZmZXI4WzBdID0gMTtcbiAgY29uc3QgdmlldzMyID0gbmV3IFVpbnQzMkFycmF5KGJ1ZmZlcjguYnVmZmVyLCAwLCAxKTtcbiAgcmV0dXJuIHZpZXczMlswXSA9PT0gMTtcbn1cblxuZnVuY3Rpb24gaXNFdmFsU3VwcG9ydGVkKCkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihcIlwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5jbGFzcyBGZWF0dXJlVGVzdCB7XG4gIHN0YXRpYyBnZXQgaXNMaXR0bGVFbmRpYW4oKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzTGl0dGxlRW5kaWFuXCIsIGlzTGl0dGxlRW5kaWFuKCkpO1xuICB9XG5cbiAgc3RhdGljIGdldCBpc0V2YWxTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzRXZhbFN1cHBvcnRlZFwiLCBpc0V2YWxTdXBwb3J0ZWQoKSk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBzaGFkb3codGhpcywgXCJpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZFwiLCB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSBcInVuZGVmaW5lZFwiKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuRmVhdHVyZVRlc3QgPSBGZWF0dXJlVGVzdDtcbmNvbnN0IGhleE51bWJlcnMgPSBbLi4uQXJyYXkoMjU2KS5rZXlzKCldLm1hcChuID0+IG4udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSk7XG5cbmNsYXNzIFV0aWwge1xuICBzdGF0aWMgbWFrZUhleENvbG9yKHIsIGcsIGIpIHtcbiAgICByZXR1cm4gYCMke2hleE51bWJlcnNbcl19JHtoZXhOdW1iZXJzW2ddfSR7aGV4TnVtYmVyc1tiXX1gO1xuICB9XG5cbiAgc3RhdGljIHNjYWxlTWluTWF4KHRyYW5zZm9ybSwgbWluTWF4KSB7XG4gICAgbGV0IHRlbXA7XG5cbiAgICBpZiAodHJhbnNmb3JtWzBdKSB7XG4gICAgICBpZiAodHJhbnNmb3JtWzBdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMV07XG4gICAgICAgIG1pbk1heFsxXSA9IHRlbXA7XG4gICAgICB9XG5cbiAgICAgIG1pbk1heFswXSAqPSB0cmFuc2Zvcm1bMF07XG4gICAgICBtaW5NYXhbMV0gKj0gdHJhbnNmb3JtWzBdO1xuXG4gICAgICBpZiAodHJhbnNmb3JtWzNdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzJdO1xuICAgICAgICBtaW5NYXhbMl0gPSBtaW5NYXhbM107XG4gICAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICB9XG5cbiAgICAgIG1pbk1heFsyXSAqPSB0cmFuc2Zvcm1bM107XG4gICAgICBtaW5NYXhbM10gKj0gdHJhbnNmb3JtWzNdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgbWluTWF4WzBdID0gbWluTWF4WzJdO1xuICAgICAgbWluTWF4WzJdID0gdGVtcDtcbiAgICAgIHRlbXAgPSBtaW5NYXhbMV07XG4gICAgICBtaW5NYXhbMV0gPSBtaW5NYXhbM107XG4gICAgICBtaW5NYXhbM10gPSB0ZW1wO1xuXG4gICAgICBpZiAodHJhbnNmb3JtWzFdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzJdO1xuICAgICAgICBtaW5NYXhbMl0gPSBtaW5NYXhbM107XG4gICAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICB9XG5cbiAgICAgIG1pbk1heFsyXSAqPSB0cmFuc2Zvcm1bMV07XG4gICAgICBtaW5NYXhbM10gKj0gdHJhbnNmb3JtWzFdO1xuXG4gICAgICBpZiAodHJhbnNmb3JtWzJdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzBdO1xuICAgICAgICBtaW5NYXhbMF0gPSBtaW5NYXhbMV07XG4gICAgICAgIG1pbk1heFsxXSA9IHRlbXA7XG4gICAgICB9XG5cbiAgICAgIG1pbk1heFswXSAqPSB0cmFuc2Zvcm1bMl07XG4gICAgICBtaW5NYXhbMV0gKj0gdHJhbnNmb3JtWzJdO1xuICAgIH1cblxuICAgIG1pbk1heFswXSArPSB0cmFuc2Zvcm1bNF07XG4gICAgbWluTWF4WzFdICs9IHRyYW5zZm9ybVs0XTtcbiAgICBtaW5NYXhbMl0gKz0gdHJhbnNmb3JtWzVdO1xuICAgIG1pbk1heFszXSArPSB0cmFuc2Zvcm1bNV07XG4gIH1cblxuICBzdGF0aWMgdHJhbnNmb3JtKG0xLCBtMikge1xuICAgIHJldHVybiBbbTFbMF0gKiBtMlswXSArIG0xWzJdICogbTJbMV0sIG0xWzFdICogbTJbMF0gKyBtMVszXSAqIG0yWzFdLCBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXSwgbTFbMV0gKiBtMlsyXSArIG0xWzNdICogbTJbM10sIG0xWzBdICogbTJbNF0gKyBtMVsyXSAqIG0yWzVdICsgbTFbNF0sIG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV1dO1xuICB9XG5cbiAgc3RhdGljIGFwcGx5VHJhbnNmb3JtKHAsIG0pIHtcbiAgICBjb25zdCB4dCA9IHBbMF0gKiBtWzBdICsgcFsxXSAqIG1bMl0gKyBtWzRdO1xuICAgIGNvbnN0IHl0ID0gcFswXSAqIG1bMV0gKyBwWzFdICogbVszXSArIG1bNV07XG4gICAgcmV0dXJuIFt4dCwgeXRdO1xuICB9XG5cbiAgc3RhdGljIGFwcGx5SW52ZXJzZVRyYW5zZm9ybShwLCBtKSB7XG4gICAgY29uc3QgZCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XG4gICAgY29uc3QgeHQgPSAocFswXSAqIG1bM10gLSBwWzFdICogbVsyXSArIG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZDtcbiAgICBjb25zdCB5dCA9ICgtcFswXSAqIG1bMV0gKyBwWzFdICogbVswXSArIG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZDtcbiAgICByZXR1cm4gW3h0LCB5dF07XG4gIH1cblxuICBzdGF0aWMgZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3gociwgbSkge1xuICAgIGNvbnN0IHAxID0gVXRpbC5hcHBseVRyYW5zZm9ybShyLCBtKTtcbiAgICBjb25zdCBwMiA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0oci5zbGljZSgyLCA0KSwgbSk7XG4gICAgY29uc3QgcDMgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtyWzBdLCByWzNdXSwgbSk7XG4gICAgY29uc3QgcDQgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKFtyWzJdLCByWzFdXSwgbSk7XG4gICAgcmV0dXJuIFtNYXRoLm1pbihwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSksIE1hdGgubWluKHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKSwgTWF0aC5tYXgocDFbMF0sIHAyWzBdLCBwM1swXSwgcDRbMF0pLCBNYXRoLm1heChwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSldO1xuICB9XG5cbiAgc3RhdGljIGludmVyc2VUcmFuc2Zvcm0obSkge1xuICAgIGNvbnN0IGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgIHJldHVybiBbbVszXSAvIGQsIC1tWzFdIC8gZCwgLW1bMl0gLyBkLCBtWzBdIC8gZCwgKG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZCwgKG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZF07XG4gIH1cblxuICBzdGF0aWMgYXBwbHkzZFRyYW5zZm9ybShtLCB2KSB7XG4gICAgcmV0dXJuIFttWzBdICogdlswXSArIG1bMV0gKiB2WzFdICsgbVsyXSAqIHZbMl0sIG1bM10gKiB2WzBdICsgbVs0XSAqIHZbMV0gKyBtWzVdICogdlsyXSwgbVs2XSAqIHZbMF0gKyBtWzddICogdlsxXSArIG1bOF0gKiB2WzJdXTtcbiAgfVxuXG4gIHN0YXRpYyBzaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShtKSB7XG4gICAgY29uc3QgdHJhbnNwb3NlID0gW21bMF0sIG1bMl0sIG1bMV0sIG1bM11dO1xuICAgIGNvbnN0IGEgPSBtWzBdICogdHJhbnNwb3NlWzBdICsgbVsxXSAqIHRyYW5zcG9zZVsyXTtcbiAgICBjb25zdCBiID0gbVswXSAqIHRyYW5zcG9zZVsxXSArIG1bMV0gKiB0cmFuc3Bvc2VbM107XG4gICAgY29uc3QgYyA9IG1bMl0gKiB0cmFuc3Bvc2VbMF0gKyBtWzNdICogdHJhbnNwb3NlWzJdO1xuICAgIGNvbnN0IGQgPSBtWzJdICogdHJhbnNwb3NlWzFdICsgbVszXSAqIHRyYW5zcG9zZVszXTtcbiAgICBjb25zdCBmaXJzdCA9IChhICsgZCkgLyAyO1xuICAgIGNvbnN0IHNlY29uZCA9IE1hdGguc3FydCgoYSArIGQpICoqIDIgLSA0ICogKGEgKiBkIC0gYyAqIGIpKSAvIDI7XG4gICAgY29uc3Qgc3ggPSBmaXJzdCArIHNlY29uZCB8fCAxO1xuICAgIGNvbnN0IHN5ID0gZmlyc3QgLSBzZWNvbmQgfHwgMTtcbiAgICByZXR1cm4gW01hdGguc3FydChzeCksIE1hdGguc3FydChzeSldO1xuICB9XG5cbiAgc3RhdGljIG5vcm1hbGl6ZVJlY3QocmVjdCkge1xuICAgIGNvbnN0IHIgPSByZWN0LnNsaWNlKDApO1xuXG4gICAgaWYgKHJlY3RbMF0gPiByZWN0WzJdKSB7XG4gICAgICByWzBdID0gcmVjdFsyXTtcbiAgICAgIHJbMl0gPSByZWN0WzBdO1xuICAgIH1cblxuICAgIGlmIChyZWN0WzFdID4gcmVjdFszXSkge1xuICAgICAgclsxXSA9IHJlY3RbM107XG4gICAgICByWzNdID0gcmVjdFsxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIHN0YXRpYyBpbnRlcnNlY3QocmVjdDEsIHJlY3QyKSB7XG4gICAgY29uc3QgeExvdyA9IE1hdGgubWF4KE1hdGgubWluKHJlY3QxWzBdLCByZWN0MVsyXSksIE1hdGgubWluKHJlY3QyWzBdLCByZWN0MlsyXSkpO1xuICAgIGNvbnN0IHhIaWdoID0gTWF0aC5taW4oTWF0aC5tYXgocmVjdDFbMF0sIHJlY3QxWzJdKSwgTWF0aC5tYXgocmVjdDJbMF0sIHJlY3QyWzJdKSk7XG5cbiAgICBpZiAoeExvdyA+IHhIaWdoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB5TG93ID0gTWF0aC5tYXgoTWF0aC5taW4ocmVjdDFbMV0sIHJlY3QxWzNdKSwgTWF0aC5taW4ocmVjdDJbMV0sIHJlY3QyWzNdKSk7XG4gICAgY29uc3QgeUhpZ2ggPSBNYXRoLm1pbihNYXRoLm1heChyZWN0MVsxXSwgcmVjdDFbM10pLCBNYXRoLm1heChyZWN0MlsxXSwgcmVjdDJbM10pKTtcblxuICAgIGlmICh5TG93ID4geUhpZ2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBbeExvdywgeUxvdywgeEhpZ2gsIHlIaWdoXTtcbiAgfVxuXG4gIHN0YXRpYyBiZXppZXJCb3VuZGluZ0JveCh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICBjb25zdCB0dmFsdWVzID0gW10sXG4gICAgICAgICAgYm91bmRzID0gW1tdLCBbXV07XG4gICAgbGV0IGEsIGIsIGMsIHQsIHQxLCB0MiwgYjJhYywgc3FydGIyYWM7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgYiA9IDYgKiB4MCAtIDEyICogeDEgKyA2ICogeDI7XG4gICAgICAgIGEgPSAtMyAqIHgwICsgOSAqIHgxIC0gOSAqIHgyICsgMyAqIHgzO1xuICAgICAgICBjID0gMyAqIHgxIC0gMyAqIHgwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYiA9IDYgKiB5MCAtIDEyICogeTEgKyA2ICogeTI7XG4gICAgICAgIGEgPSAtMyAqIHkwICsgOSAqIHkxIC0gOSAqIHkyICsgMyAqIHkzO1xuICAgICAgICBjID0gMyAqIHkxIC0gMyAqIHkwO1xuICAgICAgfVxuXG4gICAgICBpZiAoTWF0aC5hYnMoYSkgPCAxZS0xMikge1xuICAgICAgICBpZiAoTWF0aC5hYnMoYikgPCAxZS0xMikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdCA9IC1jIC8gYjtcblxuICAgICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgICB0dmFsdWVzLnB1c2godCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuICAgICAgc3FydGIyYWMgPSBNYXRoLnNxcnQoYjJhYyk7XG5cbiAgICAgIGlmIChiMmFjIDwgMCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuXG4gICAgICBpZiAoMCA8IHQxICYmIHQxIDwgMSkge1xuICAgICAgICB0dmFsdWVzLnB1c2godDEpO1xuICAgICAgfVxuXG4gICAgICB0MiA9ICgtYiAtIHNxcnRiMmFjKSAvICgyICogYSk7XG5cbiAgICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICAgIHR2YWx1ZXMucHVzaCh0Mik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGogPSB0dmFsdWVzLmxlbmd0aCxcbiAgICAgICAgbXQ7XG4gICAgY29uc3QgamxlbiA9IGo7XG5cbiAgICB3aGlsZSAoai0tKSB7XG4gICAgICB0ID0gdHZhbHVlc1tqXTtcbiAgICAgIG10ID0gMSAtIHQ7XG4gICAgICBib3VuZHNbMF1bal0gPSBtdCAqIG10ICogbXQgKiB4MCArIDMgKiBtdCAqIG10ICogdCAqIHgxICsgMyAqIG10ICogdCAqIHQgKiB4MiArIHQgKiB0ICogdCAqIHgzO1xuICAgICAgYm91bmRzWzFdW2pdID0gbXQgKiBtdCAqIG10ICogeTAgKyAzICogbXQgKiBtdCAqIHQgKiB5MSArIDMgKiBtdCAqIHQgKiB0ICogeTIgKyB0ICogdCAqIHQgKiB5MztcbiAgICB9XG5cbiAgICBib3VuZHNbMF1bamxlbl0gPSB4MDtcbiAgICBib3VuZHNbMV1bamxlbl0gPSB5MDtcbiAgICBib3VuZHNbMF1bamxlbiArIDFdID0geDM7XG4gICAgYm91bmRzWzFdW2psZW4gKyAxXSA9IHkzO1xuICAgIGJvdW5kc1swXS5sZW5ndGggPSBib3VuZHNbMV0ubGVuZ3RoID0gamxlbiArIDI7XG4gICAgcmV0dXJuIFtNYXRoLm1pbiguLi5ib3VuZHNbMF0pLCBNYXRoLm1pbiguLi5ib3VuZHNbMV0pLCBNYXRoLm1heCguLi5ib3VuZHNbMF0pLCBNYXRoLm1heCguLi5ib3VuZHNbMV0pXTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuVXRpbCA9IFV0aWw7XG5jb25zdCBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDJkOCwgMHgyYzcsIDB4MmM2LCAweDJkOSwgMHgyZGQsIDB4MmRiLCAweDJkYSwgMHgyZGMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MjAyMiwgMHgyMDIwLCAweDIwMjEsIDB4MjAyNiwgMHgyMDE0LCAweDIwMTMsIDB4MTkyLCAweDIwNDQsIDB4MjAzOSwgMHgyMDNhLCAweDIyMTIsIDB4MjAzMCwgMHgyMDFlLCAweDIwMWMsIDB4MjAxZCwgMHgyMDE4LCAweDIwMTksIDB4MjAxYSwgMHgyMTIyLCAweGZiMDEsIDB4ZmIwMiwgMHgxNDEsIDB4MTUyLCAweDE2MCwgMHgxNzgsIDB4MTdkLCAweDEzMSwgMHgxNDIsIDB4MTUzLCAweDE2MSwgMHgxN2UsIDAsIDB4MjBhY107XG5cbmZ1bmN0aW9uIHN0cmluZ1RvUERGU3RyaW5nKHN0cikge1xuICBpZiAoc3RyWzBdID49IFwiXFx4RUZcIikge1xuICAgIGxldCBlbmNvZGluZztcblxuICAgIGlmIChzdHJbMF0gPT09IFwiXFx4RkVcIiAmJiBzdHJbMV0gPT09IFwiXFx4RkZcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi0xNmJlXCI7XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RkZcIiAmJiBzdHJbMV0gPT09IFwiXFx4RkVcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi0xNmxlXCI7XG4gICAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RUZcIiAmJiBzdHJbMV0gPT09IFwiXFx4QkJcIiAmJiBzdHJbMl0gPT09IFwiXFx4QkZcIikge1xuICAgICAgZW5jb2RpbmcgPSBcInV0Zi04XCI7XG4gICAgfVxuXG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nLCB7XG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHN0cmluZ1RvQnl0ZXMoc3RyKTtcbiAgICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB3YXJuKGBzdHJpbmdUb1BERlN0cmluZzogXCIke2V4fVwiLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0ckJ1ZiA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IHN0ci5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IFBERlN0cmluZ1RyYW5zbGF0ZVRhYmxlW3N0ci5jaGFyQ29kZUF0KGkpXTtcbiAgICBzdHJCdWYucHVzaChjb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSA6IHN0ci5jaGFyQXQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIHN0ckJ1Zi5qb2luKFwiXCIpO1xufVxuXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvKFsoKVxcXFxcXG5cXHJdKS9nLCBtYXRjaCA9PiB7XG4gICAgaWYgKG1hdGNoID09PSBcIlxcblwiKSB7XG4gICAgICByZXR1cm4gXCJcXFxcblwiO1xuICAgIH0gZWxzZSBpZiAobWF0Y2ggPT09IFwiXFxyXCIpIHtcbiAgICAgIHJldHVybiBcIlxcXFxyXCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGBcXFxcJHttYXRjaH1gO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNBc2NpaShzdHIpIHtcbiAgcmV0dXJuIC9eW1xceDAwLVxceDdGXSokLy50ZXN0KHN0cik7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGMTZCRVN0cmluZyhzdHIpIHtcbiAgY29uc3QgYnVmID0gW1wiXFx4RkVcXHhGRlwiXTtcblxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBzdHIubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBidWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXIgPj4gOCAmIDB4ZmYpLCBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXIgJiAweGZmKSk7XG4gIH1cblxuICByZXR1cm4gYnVmLmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvVVRGOFN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIHV0ZjhTdHJpbmdUb1N0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbn1cblxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2ICE9PSBudWxsICYmIHYuYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5RXF1YWwoYXJyMSwgYXJyMikge1xuICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gYXJyMS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgaWYgKGFycjFbaV0gIT09IGFycjJbaV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZ2V0TW9kaWZpY2F0aW9uRGF0ZShkYXRlID0gbmV3IERhdGUoKSkge1xuICBjb25zdCBidWZmZXIgPSBbZGF0ZS5nZXRVVENGdWxsWWVhcigpLnRvU3RyaW5nKCksIChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENEYXRlKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDSG91cnMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDU2Vjb25kcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpXTtcbiAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiXCIpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSgpIHtcbiAgY29uc3QgY2FwYWJpbGl0eSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBpc1NldHRsZWQgPSBmYWxzZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNhcGFiaWxpdHksIFwic2V0dGxlZFwiLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIGlzU2V0dGxlZDtcbiAgICB9XG5cbiAgfSk7XG4gIGNhcGFiaWxpdHkucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBjYXBhYmlsaXR5LnJlc29sdmUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaXNTZXR0bGVkID0gdHJ1ZTtcbiAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgfTtcblxuICAgIGNhcGFiaWxpdHkucmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaXNTZXR0bGVkID0gdHJ1ZTtcbiAgICAgIHJlamVjdChyZWFzb24pO1xuICAgIH07XG4gIH0pO1xuICByZXR1cm4gY2FwYWJpbGl0eTtcbn1cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbnZhciBfaXNfbm9kZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMyk7XG5cbjtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmlzTm9kZUpTID0gdm9pZCAwO1xuY29uc3QgaXNOb2RlSlMgPSB0eXBlb2YgcHJvY2VzcyA9PT0gXCJvYmplY3RcIiAmJiBwcm9jZXNzICsgXCJcIiA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIgJiYgIXByb2Nlc3MudmVyc2lvbnMubncgJiYgIShwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uICYmIHByb2Nlc3MudHlwZSAmJiBwcm9jZXNzLnR5cGUgIT09IFwiYnJvd3NlclwiKTtcbmV4cG9ydHMuaXNOb2RlSlMgPSBpc05vZGVKUztcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmJ1aWxkID0gZXhwb3J0cy5SZW5kZXJUYXNrID0gZXhwb3J0cy5QREZXb3JrZXJVdGlsID0gZXhwb3J0cy5QREZXb3JrZXIgPSBleHBvcnRzLlBERlBhZ2VQcm94eSA9IGV4cG9ydHMuUERGRG9jdW1lbnRQcm94eSA9IGV4cG9ydHMuUERGRG9jdW1lbnRMb2FkaW5nVGFzayA9IGV4cG9ydHMuUERGRGF0YVJhbmdlVHJhbnNwb3J0ID0gZXhwb3J0cy5Mb29wYmFja1BvcnQgPSBleHBvcnRzLkRlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IGV4cG9ydHMuRGVmYXVsdENhbnZhc0ZhY3RvcnkgPSBleHBvcnRzLkRlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeSA9IHZvaWQgMDtcbmV4cG9ydHMuZ2V0RG9jdW1lbnQgPSBnZXREb2N1bWVudDtcbmV4cG9ydHMuc2V0UERGTmV0d29ya1N0cmVhbUZhY3RvcnkgPSBzZXRQREZOZXR3b3JrU3RyZWFtRmFjdG9yeTtcbmV4cG9ydHMudmVyc2lvbiA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcblxudmFyIF9hbm5vdGF0aW9uX3N0b3JhZ2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgpO1xuXG52YXIgX2ZvbnRfbG9hZGVyID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG5cbnZhciBfY2FudmFzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMik7XG5cbnZhciBfd29ya2VyX29wdGlvbnMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE1KTtcblxudmFyIF9pc19ub2RlID0gX193X3BkZmpzX3JlcXVpcmVfXygzKTtcblxudmFyIF9tZXNzYWdlX2hhbmRsZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9tZXRhZGF0YSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTcpO1xuXG52YXIgX29wdGlvbmFsX2NvbnRlbnRfY29uZmlnID0gX193X3BkZmpzX3JlcXVpcmVfXygxOCk7XG5cbnZhciBfdHJhbnNwb3J0X3N0cmVhbSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTkpO1xuXG52YXIgX3hmYV90ZXh0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMCk7XG5cbmNvbnN0IERFRkFVTFRfUkFOR0VfQ0hVTktfU0laRSA9IDY1NTM2O1xuY29uc3QgUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUID0gMTAwO1xubGV0IERlZmF1bHRDYW52YXNGYWN0b3J5ID0gX2Rpc3BsYXlfdXRpbHMuRE9NQ2FudmFzRmFjdG9yeTtcbmV4cG9ydHMuRGVmYXVsdENhbnZhc0ZhY3RvcnkgPSBEZWZhdWx0Q2FudmFzRmFjdG9yeTtcbmxldCBEZWZhdWx0Q01hcFJlYWRlckZhY3RvcnkgPSBfZGlzcGxheV91dGlscy5ET01DTWFwUmVhZGVyRmFjdG9yeTtcbmV4cG9ydHMuRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5ID0gRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5O1xubGV0IERlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IF9kaXNwbGF5X3V0aWxzLkRPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuZXhwb3J0cy5EZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG5cbmlmIChfaXNfbm9kZS5pc05vZGVKUykge1xuICBjb25zdCB7XG4gICAgTm9kZUNhbnZhc0ZhY3RvcnksXG4gICAgTm9kZUNNYXBSZWFkZXJGYWN0b3J5LFxuICAgIE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeVxuICB9ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMSk7XG5cbiAgZXhwb3J0cy5EZWZhdWx0Q2FudmFzRmFjdG9yeSA9IERlZmF1bHRDYW52YXNGYWN0b3J5ID0gTm9kZUNhbnZhc0ZhY3Rvcnk7XG4gIGV4cG9ydHMuRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5ID0gRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5ID0gTm9kZUNNYXBSZWFkZXJGYWN0b3J5O1xuICBleHBvcnRzLkRlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IERlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbn1cblxubGV0IGNyZWF0ZVBERk5ldHdvcmtTdHJlYW07XG5cbmZ1bmN0aW9uIHNldFBERk5ldHdvcmtTdHJlYW1GYWN0b3J5KHBkZk5ldHdvcmtTdHJlYW1GYWN0b3J5KSB7XG4gIGNyZWF0ZVBERk5ldHdvcmtTdHJlYW0gPSBwZGZOZXR3b3JrU3RyZWFtRmFjdG9yeTtcbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoc3JjKSB7XG4gIGNvbnN0IHRhc2sgPSBuZXcgUERGRG9jdW1lbnRMb2FkaW5nVGFzaygpO1xuICBsZXQgc291cmNlO1xuXG4gIGlmICh0eXBlb2Ygc3JjID09PSBcInN0cmluZ1wiIHx8IHNyYyBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHNvdXJjZSA9IHtcbiAgICAgIHVybDogc3JjXG4gICAgfTtcbiAgfSBlbHNlIGlmICgoMCwgX3V0aWwuaXNBcnJheUJ1ZmZlcikoc3JjKSkge1xuICAgIHNvdXJjZSA9IHtcbiAgICAgIGRhdGE6IHNyY1xuICAgIH07XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgUERGRGF0YVJhbmdlVHJhbnNwb3J0KSB7XG4gICAgc291cmNlID0ge1xuICAgICAgcmFuZ2U6IHNyY1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBzcmMgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFyYW1ldGVyIGluIGdldERvY3VtZW50LCBcIiArIFwibmVlZCBlaXRoZXIgc3RyaW5nLCBVUkwsIFR5cGVkQXJyYXksIG9yIHBhcmFtZXRlciBvYmplY3QuXCIpO1xuICAgIH1cblxuICAgIGlmICghc3JjLnVybCAmJiAhc3JjLmRhdGEgJiYgIXNyYy5yYW5nZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgb2JqZWN0OiBuZWVkIGVpdGhlciAuZGF0YSwgLnJhbmdlIG9yIC51cmxcIik7XG4gICAgfVxuXG4gICAgc291cmNlID0gc3JjO1xuICB9XG5cbiAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHJhbmdlVHJhbnNwb3J0ID0gbnVsbCxcbiAgICAgIHdvcmtlciA9IG51bGw7XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcblxuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlIFwidXJsXCI6XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcmFtc1trZXldID0gbmV3IFVSTCh2YWx1ZSwgd2luZG93LmxvY2F0aW9uKS5ocmVmO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgQ2Fubm90IGNyZWF0ZSB2YWxpZCBVUkw6IFwiJHtleH1cIi5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHZhbHVlIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQREYgdXJsIGRhdGE6IFwiICsgXCJlaXRoZXIgc3RyaW5nIG9yIFVSTC1vYmplY3QgaXMgZXhwZWN0ZWQgaW4gdGhlIHVybCBwcm9wZXJ0eS5cIik7XG5cbiAgICAgIGNhc2UgXCJyYW5nZVwiOlxuICAgICAgICByYW5nZVRyYW5zcG9ydCA9IHZhbHVlO1xuICAgICAgICBjb250aW51ZTtcblxuICAgICAgY2FzZSBcIndvcmtlclwiOlxuICAgICAgICB3b3JrZXIgPSB2YWx1ZTtcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgIGlmIChfaXNfbm9kZS5pc05vZGVKUyAmJiB0eXBlb2YgQnVmZmVyICE9PSBcInVuZGVmaW5lZFwiICYmIHZhbHVlIGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICAgICAgcGFyYW1zW2tleV0gPSBuZXcgVWludDhBcnJheSh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcGFyYW1zW2tleV0gPSAoMCwgX3V0aWwuc3RyaW5nVG9CeXRlcykodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhaXNOYU4odmFsdWUubGVuZ3RoKSkge1xuICAgICAgICAgIHBhcmFtc1trZXldID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKCgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKSh2YWx1ZSkpIHtcbiAgICAgICAgICBwYXJhbXNba2V5XSA9IG5ldyBVaW50OEFycmF5KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiBiaW5hcnkgZGF0YTogZWl0aGVyIFR5cGVkQXJyYXksIFwiICsgXCJzdHJpbmcsIG9yIGFycmF5LWxpa2Ugb2JqZWN0IGlzIGV4cGVjdGVkIGluIHRoZSBkYXRhIHByb3BlcnR5LlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG4gIH1cblxuICBwYXJhbXMuQ01hcFJlYWRlckZhY3RvcnkgPSBwYXJhbXMuQ01hcFJlYWRlckZhY3RvcnkgfHwgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5O1xuICBwYXJhbXMuU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBwYXJhbXMuU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgfHwgRGVmYXVsdFN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuICBwYXJhbXMuaWdub3JlRXJyb3JzID0gcGFyYW1zLnN0b3BBdEVycm9ycyAhPT0gdHJ1ZTtcbiAgcGFyYW1zLmZvbnRFeHRyYVByb3BlcnRpZXMgPSBwYXJhbXMuZm9udEV4dHJhUHJvcGVydGllcyA9PT0gdHJ1ZTtcbiAgcGFyYW1zLnBkZkJ1ZyA9IHBhcmFtcy5wZGZCdWcgPT09IHRydWU7XG4gIHBhcmFtcy5lbmFibGVYZmEgPSBwYXJhbXMuZW5hYmxlWGZhID09PSB0cnVlO1xuXG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihwYXJhbXMucmFuZ2VDaHVua1NpemUpIHx8IHBhcmFtcy5yYW5nZUNodW5rU2l6ZSA8IDEpIHtcbiAgICBwYXJhbXMucmFuZ2VDaHVua1NpemUgPSBERUZBVUxUX1JBTkdFX0NIVU5LX1NJWkU7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhcmFtcy5kb2NCYXNlVXJsICE9PSBcInN0cmluZ1wiIHx8ICgwLCBfZGlzcGxheV91dGlscy5pc0RhdGFTY2hlbWUpKHBhcmFtcy5kb2NCYXNlVXJsKSkge1xuICAgIHBhcmFtcy5kb2NCYXNlVXJsID0gbnVsbDtcbiAgfVxuXG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihwYXJhbXMubWF4SW1hZ2VTaXplKSB8fCBwYXJhbXMubWF4SW1hZ2VTaXplIDwgLTEpIHtcbiAgICBwYXJhbXMubWF4SW1hZ2VTaXplID0gLTE7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhcmFtcy5jTWFwVXJsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcGFyYW1zLmNNYXBVcmwgPSBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXJhbXMuc3RhbmRhcmRGb250RGF0YVVybCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHBhcmFtcy5zdGFuZGFyZEZvbnREYXRhVXJsID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyYW1zLnVzZVdvcmtlckZldGNoICE9PSBcImJvb2xlYW5cIikge1xuICAgIHBhcmFtcy51c2VXb3JrZXJGZXRjaCA9IHBhcmFtcy5DTWFwUmVhZGVyRmFjdG9yeSA9PT0gX2Rpc3BsYXlfdXRpbHMuRE9NQ01hcFJlYWRlckZhY3RvcnkgJiYgcGFyYW1zLlN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID09PSBfZGlzcGxheV91dGlscy5ET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyYW1zLmlzRXZhbFN1cHBvcnRlZCAhPT0gXCJib29sZWFuXCIpIHtcbiAgICBwYXJhbXMuaXNFdmFsU3VwcG9ydGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyYW1zLmRpc2FibGVGb250RmFjZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICBwYXJhbXMuZGlzYWJsZUZvbnRGYWNlID0gX2lzX25vZGUuaXNOb2RlSlM7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhcmFtcy51c2VTeXN0ZW1Gb250cyAhPT0gXCJib29sZWFuXCIpIHtcbiAgICBwYXJhbXMudXNlU3lzdGVtRm9udHMgPSAhX2lzX25vZGUuaXNOb2RlSlMgJiYgIXBhcmFtcy5kaXNhYmxlRm9udEZhY2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhcmFtcy5vd25lckRvY3VtZW50ICE9PSBcIm9iamVjdFwiIHx8IHBhcmFtcy5vd25lckRvY3VtZW50ID09PSBudWxsKSB7XG4gICAgcGFyYW1zLm93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXJhbXMuZGlzYWJsZVJhbmdlICE9PSBcImJvb2xlYW5cIikge1xuICAgIHBhcmFtcy5kaXNhYmxlUmFuZ2UgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyYW1zLmRpc2FibGVTdHJlYW0gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgcGFyYW1zLmRpc2FibGVTdHJlYW0gPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyYW1zLmRpc2FibGVBdXRvRmV0Y2ggIT09IFwiYm9vbGVhblwiKSB7XG4gICAgcGFyYW1zLmRpc2FibGVBdXRvRmV0Y2ggPSBmYWxzZTtcbiAgfVxuXG4gICgwLCBfdXRpbC5zZXRWZXJib3NpdHlMZXZlbCkocGFyYW1zLnZlcmJvc2l0eSk7XG5cbiAgaWYgKCF3b3JrZXIpIHtcbiAgICBjb25zdCB3b3JrZXJQYXJhbXMgPSB7XG4gICAgICB2ZXJib3NpdHk6IHBhcmFtcy52ZXJib3NpdHksXG4gICAgICBwb3J0OiBfd29ya2VyX29wdGlvbnMuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJQb3J0XG4gICAgfTtcbiAgICB3b3JrZXIgPSB3b3JrZXJQYXJhbXMucG9ydCA/IFBERldvcmtlci5mcm9tUG9ydCh3b3JrZXJQYXJhbXMpIDogbmV3IFBERldvcmtlcih3b3JrZXJQYXJhbXMpO1xuICAgIHRhc2suX3dvcmtlciA9IHdvcmtlcjtcbiAgfVxuXG4gIGNvbnN0IGRvY0lkID0gdGFzay5kb2NJZDtcbiAgd29ya2VyLnByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRhc2suZGVzdHJveWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGFib3J0ZWRcIik7XG4gICAgfVxuXG4gICAgY29uc3Qgd29ya2VySWRQcm9taXNlID0gX2ZldGNoRG9jdW1lbnQod29ya2VyLCBwYXJhbXMsIHJhbmdlVHJhbnNwb3J0LCBkb2NJZCk7XG5cbiAgICBjb25zdCBuZXR3b3JrU3RyZWFtUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBsZXQgbmV0d29ya1N0cmVhbTtcblxuICAgICAgaWYgKHJhbmdlVHJhbnNwb3J0KSB7XG4gICAgICAgIG5ldHdvcmtTdHJlYW0gPSBuZXcgX3RyYW5zcG9ydF9zdHJlYW0uUERGRGF0YVRyYW5zcG9ydFN0cmVhbSh7XG4gICAgICAgICAgbGVuZ3RoOiBwYXJhbXMubGVuZ3RoLFxuICAgICAgICAgIGluaXRpYWxEYXRhOiBwYXJhbXMuaW5pdGlhbERhdGEsXG4gICAgICAgICAgcHJvZ3Jlc3NpdmVEb25lOiBwYXJhbXMucHJvZ3Jlc3NpdmVEb25lLFxuICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lOiBwYXJhbXMuY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUsXG4gICAgICAgICAgZGlzYWJsZVJhbmdlOiBwYXJhbXMuZGlzYWJsZVJhbmdlLFxuICAgICAgICAgIGRpc2FibGVTdHJlYW06IHBhcmFtcy5kaXNhYmxlU3RyZWFtXG4gICAgICAgIH0sIHJhbmdlVHJhbnNwb3J0KTtcbiAgICAgIH0gZWxzZSBpZiAoIXBhcmFtcy5kYXRhKSB7XG4gICAgICAgIG5ldHdvcmtTdHJlYW0gPSBjcmVhdGVQREZOZXR3b3JrU3RyZWFtKHtcbiAgICAgICAgICB1cmw6IHBhcmFtcy51cmwsXG4gICAgICAgICAgbGVuZ3RoOiBwYXJhbXMubGVuZ3RoLFxuICAgICAgICAgIGh0dHBIZWFkZXJzOiBwYXJhbXMuaHR0cEhlYWRlcnMsXG4gICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBwYXJhbXMud2l0aENyZWRlbnRpYWxzLFxuICAgICAgICAgIHJhbmdlQ2h1bmtTaXplOiBwYXJhbXMucmFuZ2VDaHVua1NpemUsXG4gICAgICAgICAgZGlzYWJsZVJhbmdlOiBwYXJhbXMuZGlzYWJsZVJhbmdlLFxuICAgICAgICAgIGRpc2FibGVTdHJlYW06IHBhcmFtcy5kaXNhYmxlU3RyZWFtXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKG5ldHdvcmtTdHJlYW0pO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbd29ya2VySWRQcm9taXNlLCBuZXR3b3JrU3RyZWFtUHJvbWlzZV0pLnRoZW4oZnVuY3Rpb24gKFt3b3JrZXJJZCwgbmV0d29ya1N0cmVhbV0pIHtcbiAgICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGFib3J0ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoZG9jSWQsIHdvcmtlcklkLCB3b3JrZXIucG9ydCk7XG4gICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgV29ya2VyVHJhbnNwb3J0KG1lc3NhZ2VIYW5kbGVyLCB0YXNrLCBuZXR3b3JrU3RyZWFtLCBwYXJhbXMpO1xuICAgICAgdGFzay5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcIlJlYWR5XCIsIG51bGwpO1xuICAgIH0pO1xuICB9KS5jYXRjaCh0YXNrLl9jYXBhYmlsaXR5LnJlamVjdCk7XG4gIHJldHVybiB0YXNrO1xufVxuXG5hc3luYyBmdW5jdGlvbiBfZmV0Y2hEb2N1bWVudCh3b3JrZXIsIHNvdXJjZSwgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LCBkb2NJZCkge1xuICBpZiAod29ya2VyLmRlc3Ryb3llZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpO1xuICB9XG5cbiAgaWYgKHBkZkRhdGFSYW5nZVRyYW5zcG9ydCkge1xuICAgIHNvdXJjZS5sZW5ndGggPSBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQubGVuZ3RoO1xuICAgIHNvdXJjZS5pbml0aWFsRGF0YSA9IHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5pbml0aWFsRGF0YTtcbiAgICBzb3VyY2UucHJvZ3Jlc3NpdmVEb25lID0gcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnByb2dyZXNzaXZlRG9uZTtcbiAgICBzb3VyY2UuY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQuY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU7XG4gIH1cblxuICBjb25zdCB3b3JrZXJJZCA9IGF3YWl0IHdvcmtlci5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREb2NSZXF1ZXN0XCIsIHtcbiAgICBkb2NJZCxcbiAgICBhcGlWZXJzaW9uOiAnMi4xNi4xMDUnLFxuICAgIHNvdXJjZToge1xuICAgICAgZGF0YTogc291cmNlLmRhdGEsXG4gICAgICB1cmw6IHNvdXJjZS51cmwsXG4gICAgICBwYXNzd29yZDogc291cmNlLnBhc3N3b3JkLFxuICAgICAgZGlzYWJsZUF1dG9GZXRjaDogc291cmNlLmRpc2FibGVBdXRvRmV0Y2gsXG4gICAgICByYW5nZUNodW5rU2l6ZTogc291cmNlLnJhbmdlQ2h1bmtTaXplLFxuICAgICAgbGVuZ3RoOiBzb3VyY2UubGVuZ3RoXG4gICAgfSxcbiAgICBtYXhJbWFnZVNpemU6IHNvdXJjZS5tYXhJbWFnZVNpemUsXG4gICAgZGlzYWJsZUZvbnRGYWNlOiBzb3VyY2UuZGlzYWJsZUZvbnRGYWNlLFxuICAgIGRvY0Jhc2VVcmw6IHNvdXJjZS5kb2NCYXNlVXJsLFxuICAgIGlnbm9yZUVycm9yczogc291cmNlLmlnbm9yZUVycm9ycyxcbiAgICBpc0V2YWxTdXBwb3J0ZWQ6IHNvdXJjZS5pc0V2YWxTdXBwb3J0ZWQsXG4gICAgZm9udEV4dHJhUHJvcGVydGllczogc291cmNlLmZvbnRFeHRyYVByb3BlcnRpZXMsXG4gICAgZW5hYmxlWGZhOiBzb3VyY2UuZW5hYmxlWGZhLFxuICAgIHVzZVN5c3RlbUZvbnRzOiBzb3VyY2UudXNlU3lzdGVtRm9udHMsXG4gICAgY01hcFVybDogc291cmNlLnVzZVdvcmtlckZldGNoID8gc291cmNlLmNNYXBVcmwgOiBudWxsLFxuICAgIHN0YW5kYXJkRm9udERhdGFVcmw6IHNvdXJjZS51c2VXb3JrZXJGZXRjaCA/IHNvdXJjZS5zdGFuZGFyZEZvbnREYXRhVXJsIDogbnVsbFxuICB9KTtcblxuICBpZiAoc291cmNlLmRhdGEpIHtcbiAgICBzb3VyY2UuZGF0YSA9IG51bGw7XG4gIH1cblxuICBpZiAod29ya2VyLmRlc3Ryb3llZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtlcklkO1xufVxuXG5jbGFzcyBQREZEb2N1bWVudExvYWRpbmdUYXNrIHtcbiAgc3RhdGljICNkb2NJZCA9IDA7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fY2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgdGhpcy5kb2NJZCA9IGBkJHtQREZEb2N1bWVudExvYWRpbmdUYXNrLiNkb2NJZCsrfWA7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9uUGFzc3dvcmQgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5vblVuc3VwcG9ydGVkRmVhdHVyZSA9IG51bGw7XG4gIH1cblxuICBnZXQgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG5cbiAgYXN5bmMgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgYXdhaXQgdGhpcy5fdHJhbnNwb3J0Py5kZXN0cm95KCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLl93b3JrZXIpIHtcbiAgICAgIHRoaXMuX3dvcmtlci5kZXN0cm95KCk7XG5cbiAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0cy5QREZEb2N1bWVudExvYWRpbmdUYXNrID0gUERGRG9jdW1lbnRMb2FkaW5nVGFzaztcblxuY2xhc3MgUERGRGF0YVJhbmdlVHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBpbml0aWFsRGF0YSwgcHJvZ3Jlc3NpdmVEb25lID0gZmFsc2UsIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gbnVsbCkge1xuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuaW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICB0aGlzLnByb2dyZXNzaXZlRG9uZSA9IHByb2dyZXNzaXZlRG9uZTtcbiAgICB0aGlzLmNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU7XG4gICAgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc0xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgfVxuXG4gIGFkZFJhbmdlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9yYW5nZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuXG4gIGFkZFByb2dyZXNzTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9wcm9ncmVzc0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuXG4gIGFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG5cbiAgYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cblxuICBvbkRhdGFSYW5nZShiZWdpbiwgY2h1bmspIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3JhbmdlTGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcihiZWdpbiwgY2h1bmspO1xuICAgIH1cbiAgfVxuXG4gIG9uRGF0YVByb2dyZXNzKGxvYWRlZCwgdG90YWwpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIobG9hZGVkLCB0b3RhbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBvbkRhdGFQcm9ncmVzc2l2ZVJlYWQoY2h1bmspIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG9uRGF0YVByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB0cmFuc3BvcnRSZWFkeSgpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG5cbiAgcmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBQREZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZVwiKTtcbiAgfVxuXG4gIGFib3J0KCkge31cblxufVxuXG5leHBvcnRzLlBERkRhdGFSYW5nZVRyYW5zcG9ydCA9IFBERkRhdGFSYW5nZVRyYW5zcG9ydDtcblxuY2xhc3MgUERGRG9jdW1lbnRQcm94eSB7XG4gIGNvbnN0cnVjdG9yKHBkZkluZm8sIHRyYW5zcG9ydCkge1xuICAgIHRoaXMuX3BkZkluZm8gPSBwZGZJbmZvO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmaW5nZXJwcmludFwiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgICgwLCBfZGlzcGxheV91dGlscy5kZXByZWNhdGVkKShcImBQREZEb2N1bWVudFByb3h5LmZpbmdlcnByaW50YCwgXCIgKyBcInBsZWFzZSB1c2UgYFBERkRvY3VtZW50UHJveHkuZmluZ2VycHJpbnRzYCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZ2VycHJpbnRzWzBdO1xuICAgICAgfVxuXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZ2V0U3RhdHNcIiwge1xuICAgICAgdmFsdWU6IGFzeW5jICgpID0+IHtcbiAgICAgICAgKDAsIF9kaXNwbGF5X3V0aWxzLmRlcHJlY2F0ZWQpKFwiYFBERkRvY3VtZW50UHJveHkuZ2V0U3RhdHNgLCBcIiArIFwicGxlYXNlIHVzZSB0aGUgYFBERkRvY3VtZW50UHJveHkuc3RhdHNgLWdldHRlciBpbnN0ZWFkLlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdHMgfHwge1xuICAgICAgICAgIHN0cmVhbVR5cGVzOiB7fSxcbiAgICAgICAgICBmb250VHlwZXM6IHt9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXQgYW5ub3RhdGlvblN0b3JhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgfVxuXG4gIGdldCBudW1QYWdlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5udW1QYWdlcztcbiAgfVxuXG4gIGdldCBmaW5nZXJwcmludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BkZkluZm8uZmluZ2VycHJpbnRzO1xuICB9XG5cbiAgZ2V0IHN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc3RhdHM7XG4gIH1cblxuICBnZXQgaXNQdXJlWGZhKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYTtcbiAgfVxuXG4gIGdldCBhbGxYZmFIdG1sKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmE7XG4gIH1cblxuICBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2UocGFnZU51bWJlcik7XG4gIH1cblxuICBnZXRQYWdlSW5kZXgocmVmKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSW5kZXgocmVmKTtcbiAgfVxuXG4gIGdldERlc3RpbmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9ucygpO1xuICB9XG5cbiAgZ2V0RGVzdGluYXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9uKGlkKTtcbiAgfVxuXG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTGFiZWxzKCk7XG4gIH1cblxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUxheW91dCgpO1xuICB9XG5cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlTW9kZSgpO1xuICB9XG5cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRWaWV3ZXJQcmVmZXJlbmNlcygpO1xuICB9XG5cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE9wZW5BY3Rpb24oKTtcbiAgfVxuXG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QXR0YWNobWVudHMoKTtcbiAgfVxuXG4gIGdldEphdmFTY3JpcHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRKYXZhU2NyaXB0KCk7XG4gIH1cblxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREb2NKU0FjdGlvbnMoKTtcbiAgfVxuXG4gIGdldE91dGxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPdXRsaW5lKCk7XG4gIH1cblxuICBnZXRPcHRpb25hbENvbnRlbnRDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPcHRpb25hbENvbnRlbnRDb25maWcoKTtcbiAgfVxuXG4gIGdldFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGVybWlzc2lvbnMoKTtcbiAgfVxuXG4gIGdldE1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0TWV0YWRhdGEoKTtcbiAgfVxuXG4gIGdldE1hcmtJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0TWFya0luZm8oKTtcbiAgfVxuXG4gIGdldERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREYXRhKCk7XG4gIH1cblxuICBnZXREb3dubG9hZEluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cblxuICBjbGVhbnVwKGtlZXBMb2FkZWRGb250cyA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zdGFydENsZWFudXAoa2VlcExvYWRlZEZvbnRzIHx8IHRoaXMuaXNQdXJlWGZhKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZGluZ1Rhc2suZGVzdHJveSgpO1xuICB9XG5cbiAgZ2V0IGxvYWRpbmdQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5sb2FkaW5nUGFyYW1zO1xuICB9XG5cbiAgZ2V0IGxvYWRpbmdUYXNrKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubG9hZGluZ1Rhc2s7XG4gIH1cblxuICBzYXZlRG9jdW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5hbm5vdGF0aW9uU3RvcmFnZS5zaXplIDw9IDApIHtcbiAgICAgICgwLCBfZGlzcGxheV91dGlscy5kZXByZWNhdGVkKShcInNhdmVEb2N1bWVudCBjYWxsZWQgd2hpbGUgYGFubm90YXRpb25TdG9yYWdlYCBpcyBlbXB0eSwgXCIgKyBcInBsZWFzZSB1c2UgdGhlIGdldERhdGEtbWV0aG9kIGluc3RlYWQuXCIpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc2F2ZURvY3VtZW50KCk7XG4gIH1cblxuICBnZXRGaWVsZE9iamVjdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRGaWVsZE9iamVjdHMoKTtcbiAgfVxuXG4gIGhhc0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lmhhc0pTQWN0aW9ucygpO1xuICB9XG5cbiAgZ2V0Q2FsY3VsYXRpb25PcmRlcklkcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldENhbGN1bGF0aW9uT3JkZXJJZHMoKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuUERGRG9jdW1lbnRQcm94eSA9IFBERkRvY3VtZW50UHJveHk7XG5cbmNsYXNzIFBERlBhZ2VQcm94eSB7XG4gIGNvbnN0cnVjdG9yKHBhZ2VJbmRleCwgcGFnZUluZm8sIHRyYW5zcG9ydCwgb3duZXJEb2N1bWVudCwgcGRmQnVnID0gZmFsc2UpIHtcbiAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5fcGFnZUluZm8gPSBwYWdlSW5mbztcbiAgICB0aGlzLl9vd25lckRvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5fc3RhdHMgPSBwZGZCdWcgPyBuZXcgX2Rpc3BsYXlfdXRpbHMuU3RhdFRpbWVyKCkgOiBudWxsO1xuICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSB0cmFuc3BvcnQuY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBuZXcgUERGT2JqZWN0cygpO1xuICAgIHRoaXMuX2JpdG1hcHMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwQWZ0ZXJSZW5kZXIgPSBmYWxzZTtcbiAgICB0aGlzLnBlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgdGhpcy5faW50ZW50U3RhdGVzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2Fubm90YXRpb25Qcm9taXNlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICB9XG5cbiAgZ2V0IHBhZ2VOdW1iZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmRleCArIDE7XG4gIH1cblxuICBnZXQgcm90YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yb3RhdGU7XG4gIH1cblxuICBnZXQgcmVmKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yZWY7XG4gIH1cblxuICBnZXQgdXNlclVuaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnVzZXJVbml0O1xuICB9XG5cbiAgZ2V0IHZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnZpZXc7XG4gIH1cblxuICBnZXRWaWV3cG9ydCh7XG4gICAgc2NhbGUsXG4gICAgcm90YXRpb24gPSB0aGlzLnJvdGF0ZSxcbiAgICBvZmZzZXRYID0gMCxcbiAgICBvZmZzZXRZID0gMCxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgX2Rpc3BsYXlfdXRpbHMuUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlldyxcbiAgICAgIHNjYWxlLFxuICAgICAgcm90YXRpb24sXG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIGRvbnRGbGlwXG4gICAgfSk7XG4gIH1cblxuICBnZXRBbm5vdGF0aW9ucyh7XG4gICAgaW50ZW50ID0gXCJkaXNwbGF5XCJcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgaW50ZW50QXJncyA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KTtcblxuICAgIGxldCBwcm9taXNlID0gdGhpcy5fYW5ub3RhdGlvblByb21pc2VzLmdldChpbnRlbnRBcmdzLmNhY2hlS2V5KTtcblxuICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgcHJvbWlzZSA9IHRoaXMuX3RyYW5zcG9ydC5nZXRBbm5vdGF0aW9ucyh0aGlzLl9wYWdlSW5kZXgsIGludGVudEFyZ3MucmVuZGVyaW5nSW50ZW50KTtcblxuICAgICAgdGhpcy5fYW5ub3RhdGlvblByb21pc2VzLnNldChpbnRlbnRBcmdzLmNhY2hlS2V5LCBwcm9taXNlKTtcblxuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihhbm5vdGF0aW9ucyA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgYW5ub3RhdGlvbiBvZiBhbm5vdGF0aW9ucykge1xuICAgICAgICAgIGlmIChhbm5vdGF0aW9uLnRpdGxlT2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhbm5vdGF0aW9uLCBcInRpdGxlXCIsIHtcbiAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICgwLCBfZGlzcGxheV91dGlscy5kZXByZWNhdGVkKShcImB0aXRsZWAtcHJvcGVydHkgb24gYW5ub3RhdGlvbiwgcGxlYXNlIHVzZSBgdGl0bGVPYmpgIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbm5vdGF0aW9uLnRpdGxlT2JqLnN0cjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYW5ub3RhdGlvbi5jb250ZW50c09iaiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYW5ub3RhdGlvbiwgXCJjb250ZW50c1wiLCB7XG4gICAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoXCJgY29udGVudHNgLXByb3BlcnR5IG9uIGFubm90YXRpb24sIHBsZWFzZSB1c2UgYGNvbnRlbnRzT2JqYCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGlvbi5jb250ZW50c09iai5zdHI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFubm90YXRpb25zO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuICBnZXRKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2pzQWN0aW9uc1Byb21pc2UgfHw9IHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlSlNBY3Rpb25zKHRoaXMuX3BhZ2VJbmRleCk7XG4gIH1cblxuICBhc3luYyBnZXRYZmEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYT8uY2hpbGRyZW5bdGhpcy5fcGFnZUluZGV4XSB8fCBudWxsO1xuICB9XG5cbiAgcmVuZGVyKHtcbiAgICBjYW52YXNDb250ZXh0LFxuICAgIHZpZXdwb3J0LFxuICAgIGludGVudCA9IFwiZGlzcGxheVwiLFxuICAgIGFubm90YXRpb25Nb2RlID0gX3V0aWwuQW5ub3RhdGlvbk1vZGUuRU5BQkxFLFxuICAgIHRyYW5zZm9ybSA9IG51bGwsXG4gICAgaW1hZ2VMYXllciA9IG51bGwsXG4gICAgY2FudmFzRmFjdG9yeSA9IG51bGwsXG4gICAgYmFja2dyb3VuZCA9IG51bGwsXG4gICAgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSA9IG51bGwsXG4gICAgYW5ub3RhdGlvbkNhbnZhc01hcCA9IG51bGwsXG4gICAgcGFnZUNvbG9ycyA9IG51bGwsXG4gICAgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGxcbiAgfSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0/LnJlbmRlckludGVyYWN0aXZlRm9ybXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgKDAsIF9kaXNwbGF5X3V0aWxzLmRlcHJlY2F0ZWQpKFwicmVuZGVyIG5vIGxvbmdlciBhY2NlcHRzIHRoZSBgcmVuZGVySW50ZXJhY3RpdmVGb3Jtc2Atb3B0aW9uLCBcIiArIFwicGxlYXNlIHVzZSB0aGUgYGFubm90YXRpb25Nb2RlYC1vcHRpb24gaW5zdGVhZC5cIik7XG5cbiAgICAgIGlmIChhcmd1bWVudHNbMF0ucmVuZGVySW50ZXJhY3RpdmVGb3JtcyA9PT0gdHJ1ZSAmJiBhbm5vdGF0aW9uTW9kZSA9PT0gX3V0aWwuQW5ub3RhdGlvbk1vZGUuRU5BQkxFKSB7XG4gICAgICAgIGFubm90YXRpb25Nb2RlID0gX3V0aWwuQW5ub3RhdGlvbk1vZGUuRU5BQkxFX0ZPUk1TO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHNbMF0/LmluY2x1ZGVBbm5vdGF0aW9uU3RvcmFnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoXCJyZW5kZXIgbm8gbG9uZ2VyIGFjY2VwdHMgdGhlIGBpbmNsdWRlQW5ub3RhdGlvblN0b3JhZ2VgLW9wdGlvbiwgXCIgKyBcInBsZWFzZSB1c2UgdGhlIGBhbm5vdGF0aW9uTW9kZWAtb3B0aW9uIGluc3RlYWQuXCIpO1xuXG4gICAgICBpZiAoYXJndW1lbnRzWzBdLmluY2x1ZGVBbm5vdGF0aW9uU3RvcmFnZSA9PT0gdHJ1ZSAmJiBhbm5vdGF0aW9uTW9kZSA9PT0gX3V0aWwuQW5ub3RhdGlvbk1vZGUuRU5BQkxFKSB7XG4gICAgICAgIGFubm90YXRpb25Nb2RlID0gX3V0aWwuQW5ub3RhdGlvbk1vZGUuRU5BQkxFX1NUT1JBR0U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3N0YXRzKSB7XG4gICAgICB0aGlzLl9zdGF0cy50aW1lKFwiT3ZlcmFsbFwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBpbnRlbnRBcmdzID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQsIGFubm90YXRpb25Nb2RlLCBwcmludEFubm90YXRpb25TdG9yYWdlKTtcblxuICAgIHRoaXMucGVuZGluZ0NsZWFudXAgPSBmYWxzZTtcblxuICAgIGlmICghb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSkge1xuICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSA9IHRoaXMuX3RyYW5zcG9ydC5nZXRPcHRpb25hbENvbnRlbnRDb25maWcoKTtcbiAgICB9XG5cbiAgICBsZXQgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGludGVudEFyZ3MuY2FjaGVLZXkpO1xuXG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KGludGVudEFyZ3MuY2FjaGVLZXksIGludGVudFN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpO1xuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgY2FudmFzRmFjdG9yeUluc3RhbmNlID0gY2FudmFzRmFjdG9yeSB8fCBuZXcgRGVmYXVsdENhbnZhc0ZhY3Rvcnkoe1xuICAgICAgb3duZXJEb2N1bWVudDogdGhpcy5fb3duZXJEb2N1bWVudFxuICAgIH0pO1xuICAgIGNvbnN0IGludGVudFByaW50ID0gISEoaW50ZW50QXJncy5yZW5kZXJpbmdJbnRlbnQgJiBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UKTtcblxuICAgIGlmICghaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCA9IHtcbiAgICAgICAgZm5BcnJheTogW10sXG4gICAgICAgIGFyZ3NBcnJheTogW10sXG4gICAgICAgIGxhc3RDaHVuazogZmFsc2UsXG4gICAgICAgIHNlcGFyYXRlQW5ub3RzOiBudWxsXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fc3RhdHMpIHtcbiAgICAgICAgdGhpcy5fc3RhdHMudGltZShcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHVtcE9wZXJhdG9yTGlzdChpbnRlbnRBcmdzKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wbGV0ZSA9IGVycm9yID0+IHtcbiAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzLmRlbGV0ZShpbnRlcm5hbFJlbmRlclRhc2spO1xuXG4gICAgICBpZiAodGhpcy5jbGVhbnVwQWZ0ZXJSZW5kZXIgfHwgaW50ZW50UHJpbnQpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RyeUNsZWFudXAoKTtcblxuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG5cbiAgICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICAgIHJlYXNvbjogZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKGVycm9yKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3N0YXRzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRzLnRpbWVFbmQoXCJSZW5kZXJpbmdcIik7XG5cbiAgICAgICAgdGhpcy5fc3RhdHMudGltZUVuZChcIk92ZXJhbGxcIik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGludGVybmFsUmVuZGVyVGFzayA9IG5ldyBJbnRlcm5hbFJlbmRlclRhc2soe1xuICAgICAgY2FsbGJhY2s6IGNvbXBsZXRlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGNhbnZhc0NvbnRleHQsXG4gICAgICAgIHZpZXdwb3J0LFxuICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgIGltYWdlTGF5ZXIsXG4gICAgICAgIGJhY2tncm91bmRcbiAgICAgIH0sXG4gICAgICBvYmpzOiB0aGlzLm9ianMsXG4gICAgICBjb21tb25PYmpzOiB0aGlzLmNvbW1vbk9ianMsXG4gICAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgICAgb3BlcmF0b3JMaXN0OiBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGNhbnZhc0ZhY3Rvcnk6IGNhbnZhc0ZhY3RvcnlJbnN0YW5jZSxcbiAgICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZTogIWludGVudFByaW50LFxuICAgICAgcGRmQnVnOiB0aGlzLl9wZGZCdWcsXG4gICAgICBwYWdlQ29sb3JzXG4gICAgfSk7XG4gICAgKGludGVudFN0YXRlLnJlbmRlclRhc2tzIHx8PSBuZXcgU2V0KCkpLmFkZChpbnRlcm5hbFJlbmRlclRhc2spO1xuICAgIGNvbnN0IHJlbmRlclRhc2sgPSBpbnRlcm5hbFJlbmRlclRhc2sudGFzaztcbiAgICBQcm9taXNlLmFsbChbaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLCBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlXSkudGhlbigoW3RyYW5zcGFyZW5jeSwgb3B0aW9uYWxDb250ZW50Q29uZmlnXSkgPT4ge1xuICAgICAgaWYgKHRoaXMucGVuZGluZ0NsZWFudXApIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc3RhdHMpIHtcbiAgICAgICAgdGhpcy5fc3RhdHMudGltZShcIlJlbmRlcmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmluaXRpYWxpemVHcmFwaGljcyh7XG4gICAgICAgIHRyYW5zcGFyZW5jeSxcbiAgICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gICAgICB9KTtcbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgfSkuY2F0Y2goY29tcGxldGUpO1xuICAgIHJldHVybiByZW5kZXJUYXNrO1xuICB9XG5cbiAgZ2V0T3BlcmF0b3JMaXN0KHtcbiAgICBpbnRlbnQgPSBcImRpc3BsYXlcIixcbiAgICBhbm5vdGF0aW9uTW9kZSA9IF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRSxcbiAgICBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbFxuICB9ID0ge30pIHtcbiAgICBmdW5jdGlvbiBvcGVyYXRvckxpc3RDaGFuZ2VkKCkge1xuICAgICAgaWYgKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucmVzb2x2ZShpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QpO1xuICAgICAgICBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5kZWxldGUob3BMaXN0VGFzayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaW50ZW50QXJncyA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSwgdHJ1ZSk7XG5cbiAgICBsZXQgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGludGVudEFyZ3MuY2FjaGVLZXkpO1xuXG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KGludGVudEFyZ3MuY2FjaGVLZXksIGludGVudFN0YXRlKTtcbiAgICB9XG5cbiAgICBsZXQgb3BMaXN0VGFzaztcblxuICAgIGlmICghaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgIG9wTGlzdFRhc2sgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgb3BMaXN0VGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkID0gb3BlcmF0b3JMaXN0Q2hhbmdlZDtcbiAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgKGludGVudFN0YXRlLnJlbmRlclRhc2tzIHx8PSBuZXcgU2V0KCkpLmFkZChvcExpc3RUYXNrKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCA9IHtcbiAgICAgICAgZm5BcnJheTogW10sXG4gICAgICAgIGFyZ3NBcnJheTogW10sXG4gICAgICAgIGxhc3RDaHVuazogZmFsc2UsXG4gICAgICAgIHNlcGFyYXRlQW5ub3RzOiBudWxsXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fc3RhdHMpIHtcbiAgICAgICAgdGhpcy5fc3RhdHMudGltZShcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHVtcE9wZXJhdG9yTGlzdChpbnRlbnRBcmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuXG4gIHN0cmVhbVRleHRDb250ZW50KHtcbiAgICBkaXNhYmxlQ29tYmluZVRleHRJdGVtcyA9IGZhbHNlLFxuICAgIGluY2x1ZGVNYXJrZWRDb250ZW50ID0gZmFsc2VcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgVEVYVF9DT05URU5UX0NIVU5LX1NJWkUgPSAxMDA7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldFRleHRDb250ZW50XCIsIHtcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgY29tYmluZVRleHRJdGVtczogZGlzYWJsZUNvbWJpbmVUZXh0SXRlbXMgIT09IHRydWUsXG4gICAgICBpbmNsdWRlTWFya2VkQ29udGVudDogaW5jbHVkZU1hcmtlZENvbnRlbnQgPT09IHRydWVcbiAgICB9LCB7XG4gICAgICBoaWdoV2F0ZXJNYXJrOiBURVhUX0NPTlRFTlRfQ0hVTktfU0laRSxcblxuICAgICAgc2l6ZSh0ZXh0Q29udGVudCkge1xuICAgICAgICByZXR1cm4gdGV4dENvbnRlbnQuaXRlbXMubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgfSk7XG4gIH1cblxuICBnZXRUZXh0Q29udGVudChwYXJhbXMgPSB7fSkge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmEpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFhmYSgpLnRoZW4oeGZhID0+IHtcbiAgICAgICAgcmV0dXJuIF94ZmFfdGV4dC5YZmFUZXh0LnRleHRDb250ZW50KHhmYSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IHRoaXMuc3RyZWFtVGV4dENvbnRlbnQocGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIE9iamVjdC5hc3NpZ24odGV4dENvbnRlbnQuc3R5bGVzLCB2YWx1ZS5zdHlsZXMpO1xuICAgICAgICAgIHRleHRDb250ZW50Lml0ZW1zLnB1c2goLi4udmFsdWUuaXRlbXMpO1xuICAgICAgICAgIHB1bXAoKTtcbiAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVhZGVyID0gcmVhZGFibGVTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICBjb25zdCB0ZXh0Q29udGVudCA9IHtcbiAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICBzdHlsZXM6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgIH07XG4gICAgICBwdW1wKCk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRTdHJ1Y3RUcmVlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJ1Y3RUcmVlUHJvbWlzZSB8fD0gdGhpcy5fdHJhbnNwb3J0LmdldFN0cnVjdFRyZWUodGhpcy5fcGFnZUluZGV4KTtcbiAgfVxuXG4gIF9kZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBjb25zdCB3YWl0T24gPSBbXTtcblxuICAgIGZvciAoY29uc3QgaW50ZW50U3RhdGUgb2YgdGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLl9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICByZWFzb246IG5ldyBFcnJvcihcIlBhZ2Ugd2FzIGRlc3Ryb3llZC5cIiksXG4gICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgICB3YWl0T24ucHVzaChpbnRlcm5hbFJlbmRlclRhc2suY29tcGxldGVkKTtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuXG4gICAgZm9yIChjb25zdCBiaXRtYXAgb2YgdGhpcy5fYml0bWFwcykge1xuICAgICAgYml0bWFwLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYml0bWFwcy5jbGVhcigpO1xuXG4gICAgdGhpcy5fYW5ub3RhdGlvblByb21pc2VzLmNsZWFyKCk7XG5cbiAgICB0aGlzLl9qc0FjdGlvbnNQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9zdHJ1Y3RUcmVlUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHJldHVybiBQcm9taXNlLmFsbCh3YWl0T24pO1xuICB9XG5cbiAgY2xlYW51cChyZXNldFN0YXRzID0gZmFsc2UpIHtcbiAgICB0aGlzLnBlbmRpbmdDbGVhbnVwID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5fdHJ5Q2xlYW51cChyZXNldFN0YXRzKTtcbiAgfVxuXG4gIF90cnlDbGVhbnVwKHJlc2V0U3RhdHMgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy5wZW5kaW5nQ2xlYW51cCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qge1xuICAgICAgcmVuZGVyVGFza3MsXG4gICAgICBvcGVyYXRvckxpc3RcbiAgICB9IG9mIHRoaXMuX2ludGVudFN0YXRlcy52YWx1ZXMoKSkge1xuICAgICAgaWYgKHJlbmRlclRhc2tzLnNpemUgPiAwIHx8ICFvcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuY2xlYXIoKTtcblxuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuXG4gICAgdGhpcy5fYW5ub3RhdGlvblByb21pc2VzLmNsZWFyKCk7XG5cbiAgICB0aGlzLl9qc0FjdGlvbnNQcm9taXNlID0gbnVsbDtcbiAgICB0aGlzLl9zdHJ1Y3RUcmVlUHJvbWlzZSA9IG51bGw7XG5cbiAgICBpZiAocmVzZXRTdGF0cyAmJiB0aGlzLl9zdGF0cykge1xuICAgICAgdGhpcy5fc3RhdHMgPSBuZXcgX2Rpc3BsYXlfdXRpbHMuU3RhdFRpbWVyKCk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBiaXRtYXAgb2YgdGhpcy5fYml0bWFwcykge1xuICAgICAgYml0bWFwLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fYml0bWFwcy5jbGVhcigpO1xuXG4gICAgdGhpcy5wZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX3N0YXJ0UmVuZGVyUGFnZSh0cmFuc3BhcmVuY3ksIGNhY2hlS2V5KSB7XG4gICAgY29uc3QgaW50ZW50U3RhdGUgPSB0aGlzLl9pbnRlbnRTdGF0ZXMuZ2V0KGNhY2hlS2V5KTtcblxuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdHMpIHtcbiAgICAgIHRoaXMuX3N0YXRzLnRpbWVFbmQoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgfVxuXG4gICAgaWYgKGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSh0cmFuc3BhcmVuY3kpO1xuICAgIH1cbiAgfVxuXG4gIF9yZW5kZXJQYWdlQ2h1bmsob3BlcmF0b3JMaXN0Q2h1bmssIGludGVudFN0YXRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3BlcmF0b3JMaXN0Q2h1bmsubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LmZuQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5mbkFycmF5W2ldKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5hcmdzQXJyYXlbaV0pO1xuICAgIH1cblxuICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmsgPSBvcGVyYXRvckxpc3RDaHVuay5sYXN0Q2h1bms7XG4gICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LnNlcGFyYXRlQW5ub3RzID0gb3BlcmF0b3JMaXN0Q2h1bmsuc2VwYXJhdGVBbm5vdHM7XG5cbiAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICB9XG5cbiAgICBpZiAob3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rKSB7XG4gICAgICB0aGlzLl90cnlDbGVhbnVwKCk7XG4gICAgfVxuICB9XG5cbiAgX3B1bXBPcGVyYXRvckxpc3Qoe1xuICAgIHJlbmRlcmluZ0ludGVudCxcbiAgICBjYWNoZUtleSxcbiAgICBhbm5vdGF0aW9uU3RvcmFnZU1hcFxuICB9KSB7XG4gICAgY29uc3QgcmVhZGFibGVTdHJlYW0gPSB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRPcGVyYXRvckxpc3RcIiwge1xuICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICBpbnRlbnQ6IHJlbmRlcmluZ0ludGVudCxcbiAgICAgIGNhY2hlS2V5LFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IGFubm90YXRpb25TdG9yYWdlTWFwXG4gICAgfSk7XG5cbiAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcblxuICAgIGNvbnN0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChjYWNoZUtleSk7XG5cbiAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSByZWFkZXI7XG5cbiAgICBjb25zdCBwdW1wID0gKCkgPT4ge1xuICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKCh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbmRlclBhZ2VDaHVuayh2YWx1ZSwgaW50ZW50U3RhdGUpO1xuXG4gICAgICAgIHB1bXAoKTtcbiAgICAgIH0sIHJlYXNvbiA9PiB7XG4gICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuayA9IHRydWU7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl90cnlDbGVhbnVwKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgIH0gZWxzZSBpZiAoaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyByZWFzb247XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBwdW1wKCk7XG4gIH1cblxuICBfYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgIGludGVudFN0YXRlLFxuICAgIHJlYXNvbixcbiAgICBmb3JjZSA9IGZhbHNlXG4gIH0pIHtcbiAgICBpZiAoIWludGVudFN0YXRlLnN0cmVhbVJlYWRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5zaXplID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWFzb24gaW5zdGFuY2VvZiBfZGlzcGxheV91dGlscy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24pIHtcbiAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICAgIGludGVudFN0YXRlLFxuICAgICAgICAgICAgcmVhc29uLFxuICAgICAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9LCBSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyLmNhbmNlbChuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UpKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcblxuICAgIGlmICh0aGlzLl90cmFuc3BvcnQuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbY3VyQ2FjaGVLZXksIGN1ckludGVudFN0YXRlXSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMpIHtcbiAgICAgIGlmIChjdXJJbnRlbnRTdGF0ZSA9PT0gaW50ZW50U3RhdGUpIHtcbiAgICAgICAgdGhpcy5faW50ZW50U3RhdGVzLmRlbGV0ZShjdXJDYWNoZUtleSk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhbnVwKCk7XG4gIH1cblxuICBnZXQgc3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRzO1xuICB9XG5cbn1cblxuZXhwb3J0cy5QREZQYWdlUHJveHkgPSBQREZQYWdlUHJveHk7XG5cbmNsYXNzIExvb3BiYWNrUG9ydCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX2RlZmVycmVkID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICBwb3N0TWVzc2FnZShvYmosIHRyYW5zZmVycykge1xuICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgZGF0YTogc3RydWN0dXJlZENsb25lKG9iaiwgdHJhbnNmZXJzKVxuICAgIH07XG5cbiAgICB0aGlzLl9kZWZlcnJlZC50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuXG4gICAgdGhpcy5fbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgfVxuXG4gIHRlcm1pbmF0ZSgpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoID0gMDtcbiAgfVxuXG59XG5cbmV4cG9ydHMuTG9vcGJhY2tQb3J0ID0gTG9vcGJhY2tQb3J0O1xuY29uc3QgUERGV29ya2VyVXRpbCA9IHtcbiAgaXNXb3JrZXJEaXNhYmxlZDogZmFsc2UsXG4gIGZhbGxiYWNrV29ya2VyU3JjOiBudWxsLFxuICBmYWtlV29ya2VySWQ6IDBcbn07XG5leHBvcnRzLlBERldvcmtlclV0aWwgPSBQREZXb3JrZXJVdGlsO1xue1xuICBpZiAoX2lzX25vZGUuaXNOb2RlSlMgJiYgdHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIFBERldvcmtlclV0aWwuaXNXb3JrZXJEaXNhYmxlZCA9IHRydWU7XG4gICAgUERGV29ya2VyVXRpbC5mYWxsYmFja1dvcmtlclNyYyA9IFwiLi9wZGYud29ya2VyLmpzXCI7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50ID09PSBcIm9iamVjdFwiKSB7XG4gICAgY29uc3QgcGRmanNGaWxlUGF0aCA9IGRvY3VtZW50Py5jdXJyZW50U2NyaXB0Py5zcmM7XG5cbiAgICBpZiAocGRmanNGaWxlUGF0aCkge1xuICAgICAgUERGV29ya2VyVXRpbC5mYWxsYmFja1dvcmtlclNyYyA9IHBkZmpzRmlsZVBhdGgucmVwbGFjZSgvKFxcLig/Om1pblxcLik/anMpKFxcPy4qKT8kL2ksIFwiLndvcmtlciQxJDJcIik7XG4gICAgfVxuICB9XG5cbiAgUERGV29ya2VyVXRpbC5pc1NhbWVPcmlnaW4gPSBmdW5jdGlvbiAoYmFzZVVybCwgb3RoZXJVcmwpIHtcbiAgICBsZXQgYmFzZTtcblxuICAgIHRyeSB7XG4gICAgICBiYXNlID0gbmV3IFVSTChiYXNlVXJsKTtcblxuICAgICAgaWYgKCFiYXNlLm9yaWdpbiB8fCBiYXNlLm9yaWdpbiA9PT0gXCJudWxsXCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBjb25zdCBvdGhlciA9IG5ldyBVUkwob3RoZXJVcmwsIGJhc2UpO1xuICAgIHJldHVybiBiYXNlLm9yaWdpbiA9PT0gb3RoZXIub3JpZ2luO1xuICB9O1xuXG4gIFBERldvcmtlclV0aWwuY3JlYXRlQ0ROV3JhcHBlciA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gYGltcG9ydFNjcmlwdHMoXCIke3VybH1cIik7YDtcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbd3JhcHBlcl0pKTtcbiAgfTtcbn1cblxuY2xhc3MgUERGV29ya2VyIHtcbiAgc3RhdGljICN3b3JrZXJQb3J0cyA9IG5ldyBXZWFrTWFwKCk7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIG5hbWUgPSBudWxsLFxuICAgIHBvcnQgPSBudWxsLFxuICAgIHZlcmJvc2l0eSA9ICgwLCBfdXRpbC5nZXRWZXJib3NpdHlMZXZlbCkoKVxuICB9ID0ge30pIHtcbiAgICBpZiAocG9ydCAmJiBQREZXb3JrZXIuI3dvcmtlclBvcnRzLmhhcyhwb3J0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBtb3JlIHRoYW4gb25lIFBERldvcmtlciBwZXIgcG9ydC5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMudmVyYm9zaXR5ID0gdmVyYm9zaXR5O1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICB0aGlzLl9wb3J0ID0gbnVsbDtcbiAgICB0aGlzLl93ZWJXb3JrZXIgPSBudWxsO1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbnVsbDtcblxuICAgIGlmIChwb3J0KSB7XG4gICAgICBQREZXb3JrZXIuI3dvcmtlclBvcnRzLnNldChwb3J0LCB0aGlzKTtcblxuICAgICAgdGhpcy5faW5pdGlhbGl6ZUZyb21Qb3J0KHBvcnQpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICB9XG5cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG5cbiAgZ2V0IHBvcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BvcnQ7XG4gIH1cblxuICBnZXQgbWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VIYW5kbGVyO1xuICB9XG5cbiAgX2luaXRpYWxpemVGcm9tUG9ydChwb3J0KSB7XG4gICAgdGhpcy5fcG9ydCA9IHBvcnQ7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBuZXcgX21lc3NhZ2VfaGFuZGxlci5NZXNzYWdlSGFuZGxlcihcIm1haW5cIiwgXCJ3b3JrZXJcIiwgcG9ydCk7XG5cbiAgICB0aGlzLl9tZXNzYWdlSGFuZGxlci5vbihcInJlYWR5XCIsIGZ1bmN0aW9uICgpIHt9KTtcblxuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cblxuICBfaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIVBERldvcmtlclV0aWwuaXNXb3JrZXJEaXNhYmxlZCAmJiAhUERGV29ya2VyLl9tYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHdvcmtlclNyY1xuICAgICAgfSA9IFBERldvcmtlcjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFQREZXb3JrZXJVdGlsLmlzU2FtZU9yaWdpbih3aW5kb3cubG9jYXRpb24uaHJlZiwgd29ya2VyU3JjKSkge1xuICAgICAgICAgIHdvcmtlclNyYyA9IFBERldvcmtlclV0aWwuY3JlYXRlQ0ROV3JhcHBlcihuZXcgVVJMKHdvcmtlclNyYywgd2luZG93LmxvY2F0aW9uKS5ocmVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyU3JjKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgX21lc3NhZ2VfaGFuZGxlci5NZXNzYWdlSGFuZGxlcihcIm1haW5cIiwgXCJ3b3JrZXJcIiwgd29ya2VyKTtcblxuICAgICAgICBjb25zdCB0ZXJtaW5hdGVFYXJseSA9ICgpID0+IHtcbiAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3Qgb25Xb3JrZXJFcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuX3dlYldvcmtlcikge1xuICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbldvcmtlckVycm9yKTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJ0ZXN0XCIsIGRhdGEgPT4ge1xuICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Xb3JrZXJFcnJvcik7XG5cbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRlcm1pbmF0ZUVhcmx5KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gd29ya2VyO1xuICAgICAgICAgICAgdGhpcy5fd2ViV29ya2VyID0gd29ya2VyO1xuXG4gICAgICAgICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuXG4gICAgICAgICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwiY29uZmlndXJlXCIsIHtcbiAgICAgICAgICAgICAgdmVyYm9zaXR5OiB0aGlzLnZlcmJvc2l0eVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuXG4gICAgICAgICAgICBtZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJyZWFkeVwiLCBkYXRhID0+IHtcbiAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZW5kVGVzdCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY29uc3Qgc2VuZFRlc3QgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGVzdE9iaiA9IG5ldyBVaW50OEFycmF5KCk7XG4gICAgICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcInRlc3RcIiwgdGVzdE9iaiwgW3Rlc3RPYmouYnVmZmVyXSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2VuZFRlc3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAoMCwgX3V0aWwuaW5mbykoXCJUaGUgd29ya2VyIGhhcyBiZWVuIGRpc2FibGVkLlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgfVxuXG4gIF9zZXR1cEZha2VXb3JrZXIoKSB7XG4gICAgaWYgKCFQREZXb3JrZXJVdGlsLmlzV29ya2VyRGlzYWJsZWQpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcIlNldHRpbmcgdXAgZmFrZSB3b3JrZXIuXCIpO1xuICAgICAgUERGV29ya2VyVXRpbC5pc1dvcmtlckRpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBQREZXb3JrZXIuX3NldHVwRmFrZVdvcmtlckdsb2JhbC50aGVuKFdvcmtlck1lc3NhZ2VIYW5kbGVyID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBvcnQgPSBuZXcgTG9vcGJhY2tQb3J0KCk7XG4gICAgICB0aGlzLl9wb3J0ID0gcG9ydDtcbiAgICAgIGNvbnN0IGlkID0gYGZha2Uke1BERldvcmtlclV0aWwuZmFrZVdvcmtlcklkKyt9YDtcbiAgICAgIGNvbnN0IHdvcmtlckhhbmRsZXIgPSBuZXcgX21lc3NhZ2VfaGFuZGxlci5NZXNzYWdlSGFuZGxlcihpZCArIFwiX3dvcmtlclwiLCBpZCwgcG9ydCk7XG4gICAgICBXb3JrZXJNZXNzYWdlSGFuZGxlci5zZXR1cCh3b3JrZXJIYW5kbGVyLCBwb3J0KTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoaWQsIGlkICsgXCJfd29ya2VyXCIsIHBvcnQpO1xuICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcblxuICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcblxuICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcImNvbmZpZ3VyZVwiLCB7XG4gICAgICAgIHZlcmJvc2l0eTogdGhpcy52ZXJib3NpdHlcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihgU2V0dGluZyB1cCBmYWtlIHdvcmtlciBmYWlsZWQ6IFwiJHtyZWFzb24ubWVzc2FnZX1cIi5gKSk7XG4gICAgfSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLl93ZWJXb3JrZXIpIHtcbiAgICAgIHRoaXMuX3dlYldvcmtlci50ZXJtaW5hdGUoKTtcblxuICAgICAgdGhpcy5fd2ViV29ya2VyID0gbnVsbDtcbiAgICB9XG5cbiAgICBQREZXb3JrZXIuI3dvcmtlclBvcnRzLmRlbGV0ZSh0aGlzLl9wb3J0KTtcbiAgICB0aGlzLl9wb3J0ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLl9tZXNzYWdlSGFuZGxlcikge1xuICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuXG4gICAgICB0aGlzLl9tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGZyb21Qb3J0KHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zPy5wb3J0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQREZXb3JrZXIuZnJvbVBvcnQgLSBpbnZhbGlkIG1ldGhvZCBzaWduYXR1cmUuXCIpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLiN3b3JrZXJQb3J0cy5oYXMocGFyYW1zLnBvcnQpKSB7XG4gICAgICByZXR1cm4gdGhpcy4jd29ya2VyUG9ydHMuZ2V0KHBhcmFtcy5wb3J0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFBERldvcmtlcihwYXJhbXMpO1xuICB9XG5cbiAgc3RhdGljIGdldCB3b3JrZXJTcmMoKSB7XG4gICAgaWYgKF93b3JrZXJfb3B0aW9ucy5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYykge1xuICAgICAgcmV0dXJuIF93b3JrZXJfb3B0aW9ucy5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYztcbiAgICB9XG5cbiAgICBpZiAoUERGV29ya2VyVXRpbC5mYWxsYmFja1dvcmtlclNyYyAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFfaXNfbm9kZS5pc05vZGVKUykge1xuICAgICAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoJ05vIFwiR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmNcIiBzcGVjaWZpZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQREZXb3JrZXJVdGlsLmZhbGxiYWNrV29ya2VyU3JjO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyY1wiIHNwZWNpZmllZC4nKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgX21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGdsb2JhbFRoaXMucGRmanNXb3JrZXI/Lldvcmtlck1lc3NhZ2VIYW5kbGVyIHx8IG51bGw7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgX3NldHVwRmFrZVdvcmtlckdsb2JhbCgpIHtcbiAgICBjb25zdCBsb2FkZXIgPSBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBtYWluV29ya2VyTWVzc2FnZUhhbmRsZXIgPSB0aGlzLl9tYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXI7XG5cbiAgICAgIGlmIChtYWluV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIG1haW5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKF9pc19ub2RlLmlzTm9kZUpTICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3Qgd29ya2VyID0gZXZhbChcInJlcXVpcmVcIikodGhpcy53b3JrZXJTcmMpO1xuICAgICAgICByZXR1cm4gd29ya2VyLldvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgICAgfVxuXG4gICAgICBhd2FpdCAoMCwgX2Rpc3BsYXlfdXRpbHMubG9hZFNjcmlwdCkodGhpcy53b3JrZXJTcmMpO1xuICAgICAgcmV0dXJuIHdpbmRvdy5wZGZqc1dvcmtlci5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX3NldHVwRmFrZVdvcmtlckdsb2JhbFwiLCBsb2FkZXIoKSk7XG4gIH1cblxufVxuXG5leHBvcnRzLlBERldvcmtlciA9IFBERldvcmtlcjtcbntcbiAgUERGV29ya2VyLmdldFdvcmtlclNyYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoXCJgUERGV29ya2VyLmdldFdvcmtlclNyYygpYCwgcGxlYXNlIHVzZSBgUERGV29ya2VyLndvcmtlclNyY2AgaW5zdGVhZC5cIik7XG4gICAgcmV0dXJuIHRoaXMud29ya2VyU3JjO1xuICB9O1xufVxuXG5jbGFzcyBXb3JrZXJUcmFuc3BvcnQge1xuICAjZG9jU3RhdHMgPSBudWxsO1xuICAjcGFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAjcGFnZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAjbWV0YWRhdGFQcm9taXNlID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlSGFuZGxlciwgbG9hZGluZ1Rhc2ssIG5ldHdvcmtTdHJlYW0sIHBhcmFtcykge1xuICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICB0aGlzLmxvYWRpbmdUYXNrID0gbG9hZGluZ1Rhc2s7XG4gICAgdGhpcy5jb21tb25PYmpzID0gbmV3IFBERk9iamVjdHMoKTtcbiAgICB0aGlzLmZvbnRMb2FkZXIgPSBuZXcgX2ZvbnRfbG9hZGVyLkZvbnRMb2FkZXIoe1xuICAgICAgZG9jSWQ6IGxvYWRpbmdUYXNrLmRvY0lkLFxuICAgICAgb25VbnN1cHBvcnRlZEZlYXR1cmU6IHRoaXMuX29uVW5zdXBwb3J0ZWRGZWF0dXJlLmJpbmQodGhpcyksXG4gICAgICBvd25lckRvY3VtZW50OiBwYXJhbXMub3duZXJEb2N1bWVudCxcbiAgICAgIHN0eWxlRWxlbWVudDogcGFyYW1zLnN0eWxlRWxlbWVudFxuICAgIH0pO1xuICAgIHRoaXMuX3BhcmFtcyA9IHBhcmFtcztcblxuICAgIGlmICghcGFyYW1zLnVzZVdvcmtlckZldGNoKSB7XG4gICAgICB0aGlzLkNNYXBSZWFkZXJGYWN0b3J5ID0gbmV3IHBhcmFtcy5DTWFwUmVhZGVyRmFjdG9yeSh7XG4gICAgICAgIGJhc2VVcmw6IHBhcmFtcy5jTWFwVXJsLFxuICAgICAgICBpc0NvbXByZXNzZWQ6IHBhcmFtcy5jTWFwUGFja2VkXG4gICAgICB9KTtcbiAgICAgIHRoaXMuU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBuZXcgcGFyYW1zLlN0YW5kYXJkRm9udERhdGFGYWN0b3J5KHtcbiAgICAgICAgYmFzZVVybDogcGFyYW1zLnN0YW5kYXJkRm9udERhdGFVcmxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9IG51bGw7XG4gICAgdGhpcy5fcGFzc3dvcmRDYXBhYmlsaXR5ID0gbnVsbDtcbiAgICB0aGlzLl9uZXR3b3JrU3RyZWFtID0gbmV0d29ya1N0cmVhbTtcbiAgICB0aGlzLl9mdWxsUmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICB0aGlzLnNldHVwTWVzc2FnZUhhbmRsZXIoKTtcbiAgfVxuXG4gIGdldCBhbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJhbm5vdGF0aW9uU3RvcmFnZVwiLCBuZXcgX2Fubm90YXRpb25fc3RvcmFnZS5Bbm5vdGF0aW9uU3RvcmFnZSgpKTtcbiAgfVxuXG4gIGdldCBzdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy4jZG9jU3RhdHM7XG4gIH1cblxuICBnZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSA9IF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IG51bGwsIGlzT3BMaXN0ID0gZmFsc2UpIHtcbiAgICBsZXQgcmVuZGVyaW5nSW50ZW50ID0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5ESVNQTEFZO1xuICAgIGxldCBhbm5vdGF0aW9uTWFwID0gbnVsbDtcblxuICAgIHN3aXRjaCAoaW50ZW50KSB7XG4gICAgICBjYXNlIFwiYW55XCI6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCA9IF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuQU5ZO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImRpc3BsYXlcIjpcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCJwcmludFwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKGBnZXRSZW5kZXJpbmdJbnRlbnQgLSBpbnZhbGlkIGludGVudDogJHtpbnRlbnR9YCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChhbm5vdGF0aW9uTW9kZSkge1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uTW9kZS5ESVNBQkxFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19ESVNBQkxFO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uTW9kZS5FTkFCTEU6XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRV9GT1JNUzpcbiAgICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuQU5OT1RBVElPTlNfRk9STVM7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRV9TVE9SQUdFOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgKz0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5BTk5PVEFUSU9OU19TVE9SQUdFO1xuICAgICAgICBjb25zdCBhbm5vdGF0aW9uU3RvcmFnZSA9IHJlbmRlcmluZ0ludGVudCAmIF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQgJiYgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSBpbnN0YW5jZW9mIF9hbm5vdGF0aW9uX3N0b3JhZ2UuUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA/IHByaW50QW5ub3RhdGlvblN0b3JhZ2UgOiB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgICAgICBhbm5vdGF0aW9uTWFwID0gYW5ub3RhdGlvblN0b3JhZ2Uuc2VyaWFsaXphYmxlO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKGBnZXRSZW5kZXJpbmdJbnRlbnQgLSBpbnZhbGlkIGFubm90YXRpb25Nb2RlOiAke2Fubm90YXRpb25Nb2RlfWApO1xuICAgIH1cblxuICAgIGlmIChpc09wTGlzdCkge1xuICAgICAgcmVuZGVyaW5nSW50ZW50ICs9IF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuT1BMSVNUO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQsXG4gICAgICBjYWNoZUtleTogYCR7cmVuZGVyaW5nSW50ZW50fV8ke19hbm5vdGF0aW9uX3N0b3JhZ2UuQW5ub3RhdGlvblN0b3JhZ2UuZ2V0SGFzaChhbm5vdGF0aW9uTWFwKX1gLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2VNYXA6IGFubm90YXRpb25NYXBcbiAgICB9O1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5kZXN0cm95Q2FwYWJpbGl0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9XG5cbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcblxuICAgIGlmICh0aGlzLl9wYXNzd29yZENhcGFiaWxpdHkpIHtcbiAgICAgIHRoaXMuX3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQgZHVyaW5nIG9uUGFzc3dvcmQgY2FsbGJhY2tcIikpO1xuICAgIH1cblxuICAgIGNvbnN0IHdhaXRPbiA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgd2FpdE9uLnB1c2gocGFnZS5fZGVzdHJveSgpKTtcbiAgICB9XG5cbiAgICB0aGlzLiNwYWdlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLiNwYWdlUHJvbWlzZXMuY2xlYXIoKTtcblxuICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KFwiYW5ub3RhdGlvblN0b3JhZ2VcIikpIHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH1cblxuICAgIGNvbnN0IHRlcm1pbmF0ZWQgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIlRlcm1pbmF0ZVwiLCBudWxsKTtcbiAgICB3YWl0T24ucHVzaCh0ZXJtaW5hdGVkKTtcbiAgICBQcm9taXNlLmFsbCh3YWl0T24pLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy5jb21tb25PYmpzLmNsZWFyKCk7XG4gICAgICB0aGlzLmZvbnRMb2FkZXIuY2xlYXIoKTtcbiAgICAgIHRoaXMuI21ldGFkYXRhUHJvbWlzZSA9IG51bGw7XG4gICAgICB0aGlzLl9nZXRGaWVsZE9iamVjdHNQcm9taXNlID0gbnVsbDtcbiAgICAgIHRoaXMuX2hhc0pTQWN0aW9uc1Byb21pc2UgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5fbmV0d29ya1N0cmVhbSkge1xuICAgICAgICB0aGlzLl9uZXR3b3JrU3RyZWFtLmNhbmNlbEFsbFJlcXVlc3RzKG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihcIldvcmtlciB3YXMgdGVybWluYXRlZC5cIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5tZXNzYWdlSGFuZGxlcikge1xuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVqZWN0KTtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG5cbiAgc2V0dXBNZXNzYWdlSGFuZGxlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZXNzYWdlSGFuZGxlcixcbiAgICAgIGxvYWRpbmdUYXNrXG4gICAgfSA9IHRoaXM7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXRSZWFkZXJcIiwgKGRhdGEsIHNpbmspID0+IHtcbiAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHRoaXMuX25ldHdvcmtTdHJlYW0sIFwiR2V0UmVhZGVyIC0gbm8gYElQREZTdHJlYW1gIGluc3RhbmNlIGF2YWlsYWJsZS5cIik7XG4gICAgICB0aGlzLl9mdWxsUmVhZGVyID0gdGhpcy5fbmV0d29ya1N0cmVhbS5nZXRGdWxsUmVhZGVyKCk7XG5cbiAgICAgIHRoaXMuX2Z1bGxSZWFkZXIub25Qcm9ncmVzcyA9IGV2dCA9PiB7XG4gICAgICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IHtcbiAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0pIHtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKCgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKSh2YWx1ZSksIFwiR2V0UmVhZGVyIC0gZXhwZWN0ZWQgYW4gQXJyYXlCdWZmZXIuXCIpO1xuICAgICAgICAgIHNpbmsuZW5xdWV1ZShuZXcgVWludDhBcnJheSh2YWx1ZSksIDEsIFt2YWx1ZV0pO1xuICAgICAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICAgIHNpbmsuZXJyb3IocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBzaW5rLm9uQ2FuY2VsID0gcmVhc29uID0+IHtcbiAgICAgICAgdGhpcy5fZnVsbFJlYWRlci5jYW5jZWwocmVhc29uKTtcblxuICAgICAgICBzaW5rLnJlYWR5LmNhdGNoKHJlYWR5UmVhc29uID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyByZWFkeVJlYXNvbjtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiUmVhZGVySGVhZGVyc1JlYWR5XCIsIGRhdGEgPT4ge1xuICAgICAgY29uc3QgaGVhZGVyc0NhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICBjb25zdCBmdWxsUmVhZGVyID0gdGhpcy5fZnVsbFJlYWRlcjtcbiAgICAgIGZ1bGxSZWFkZXIuaGVhZGVyc1JlYWR5LnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoIWZ1bGxSZWFkZXIuaXNTdHJlYW1pbmdTdXBwb3J0ZWQgfHwgIWZ1bGxSZWFkZXIuaXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICAgIGlmICh0aGlzLl9sYXN0UHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih0aGlzLl9sYXN0UHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bGxSZWFkZXIub25Qcm9ncmVzcyA9IGV2dCA9PiB7XG4gICAgICAgICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBoZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICBpc1N0cmVhbWluZ1N1cHBvcnRlZDogZnVsbFJlYWRlci5pc1N0cmVhbWluZ1N1cHBvcnRlZCxcbiAgICAgICAgICBpc1JhbmdlU3VwcG9ydGVkOiBmdWxsUmVhZGVyLmlzUmFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgICAgY29udGVudExlbmd0aDogZnVsbFJlYWRlci5jb250ZW50TGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfSwgaGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICAgIHJldHVybiBoZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0UmFuZ2VSZWFkZXJcIiwgKGRhdGEsIHNpbmspID0+IHtcbiAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHRoaXMuX25ldHdvcmtTdHJlYW0sIFwiR2V0UmFuZ2VSZWFkZXIgLSBubyBgSVBERlN0cmVhbWAgaW5zdGFuY2UgYXZhaWxhYmxlLlwiKTtcblxuICAgICAgY29uc3QgcmFuZ2VSZWFkZXIgPSB0aGlzLl9uZXR3b3JrU3RyZWFtLmdldFJhbmdlUmVhZGVyKGRhdGEuYmVnaW4sIGRhdGEuZW5kKTtcblxuICAgICAgaWYgKCFyYW5nZVJlYWRlcikge1xuICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHJhbmdlUmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uICh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHNpbmsuY2xvc2UoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KSgoMCwgX3V0aWwuaXNBcnJheUJ1ZmZlcikodmFsdWUpLCBcIkdldFJhbmdlUmVhZGVyIC0gZXhwZWN0ZWQgYW4gQXJyYXlCdWZmZXIuXCIpO1xuICAgICAgICAgIHNpbmsuZW5xdWV1ZShuZXcgVWludDhBcnJheSh2YWx1ZSksIDEsIFt2YWx1ZV0pO1xuICAgICAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICAgIHNpbmsuZXJyb3IocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBzaW5rLm9uQ2FuY2VsID0gcmVhc29uID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICAgIHNpbmsucmVhZHkuY2F0Y2gocmVhZHlSZWFzb24gPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXREb2NcIiwgKHtcbiAgICAgIHBkZkluZm9cbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLl9udW1QYWdlcyA9IHBkZkluZm8ubnVtUGFnZXM7XG4gICAgICB0aGlzLl9odG1sRm9yWGZhID0gcGRmSW5mby5odG1sRm9yWGZhO1xuICAgICAgZGVsZXRlIHBkZkluZm8uaHRtbEZvclhmYTtcblxuICAgICAgbG9hZGluZ1Rhc2suX2NhcGFiaWxpdHkucmVzb2x2ZShuZXcgUERGRG9jdW1lbnRQcm94eShwZGZJbmZvLCB0aGlzKSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJEb2NFeGNlcHRpb25cIiwgZnVuY3Rpb24gKGV4KSB7XG4gICAgICBsZXQgcmVhc29uO1xuXG4gICAgICBzd2l0Y2ggKGV4Lm5hbWUpIHtcbiAgICAgICAgY2FzZSBcIlBhc3N3b3JkRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF91dGlsLlBhc3N3b3JkRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LmNvZGUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF91dGlsLkludmFsaWRQREZFeGNlcHRpb24oZXgubWVzc2FnZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIk1pc3NpbmdQREZFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICAgICAgcmVhc29uID0gbmV3IF91dGlsLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5zdGF0dXMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuVW5rbm93bkVycm9yRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LmRldGFpbHMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkRvY0V4Y2VwdGlvbiAtIGV4cGVjdGVkIGEgdmFsaWQgRXJyb3IuXCIpO1xuICAgICAgfVxuXG4gICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlBhc3N3b3JkUmVxdWVzdFwiLCBleGNlcHRpb24gPT4ge1xuICAgICAgdGhpcy5fcGFzc3dvcmRDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuXG4gICAgICBpZiAobG9hZGluZ1Rhc2sub25QYXNzd29yZCkge1xuICAgICAgICBjb25zdCB1cGRhdGVQYXNzd29yZCA9IHBhc3N3b3JkID0+IHtcbiAgICAgICAgICBpZiAocGFzc3dvcmQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5fcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChwYXNzd29yZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgcGFzc3dvcmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQodXBkYXRlUGFzc3dvcmQsIGV4Y2VwdGlvbi5jb2RlKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICB0aGlzLl9wYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KGV4KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChuZXcgX3V0aWwuUGFzc3dvcmRFeGNlcHRpb24oZXhjZXB0aW9uLm1lc3NhZ2UsIGV4Y2VwdGlvbi5jb2RlKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9wYXNzd29yZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRhdGFMb2FkZWRcIiwgZGF0YSA9PiB7XG4gICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGRhdGEubGVuZ3RoLFxuICAgICAgICB0b3RhbDogZGF0YS5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnJlc29sdmUoZGF0YSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJTdGFydFJlbmRlclBhZ2VcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYWdlID0gdGhpcy4jcGFnZUNhY2hlLmdldChkYXRhLnBhZ2VJbmRleCk7XG5cbiAgICAgIHBhZ2UuX3N0YXJ0UmVuZGVyUGFnZShkYXRhLnRyYW5zcGFyZW5jeSwgZGF0YS5jYWNoZUtleSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJjb21tb25vYmpcIiwgKFtpZCwgdHlwZSwgZXhwb3J0ZWREYXRhXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29tbW9uT2Jqcy5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcGFyYW1zO1xuXG4gICAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiBleHBvcnRlZERhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVkRXJyb3IgPSBleHBvcnRlZERhdGEuZXJyb3I7XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoYEVycm9yIGR1cmluZyBmb250IGxvYWRpbmc6ICR7ZXhwb3J0ZWRFcnJvcn1gKTtcbiAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZEVycm9yKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBmb250UmVnaXN0cnkgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKHBhcmFtcy5wZGZCdWcgJiYgZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yPy5lbmFibGVkKSB7XG4gICAgICAgICAgICBmb250UmVnaXN0cnkgPSB7XG4gICAgICAgICAgICAgIHJlZ2lzdGVyRm9udChmb250LCB1cmwpIHtcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLkZvbnRJbnNwZWN0b3IuZm9udEFkZGVkKGZvbnQsIHVybCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBmb250ID0gbmV3IF9mb250X2xvYWRlci5Gb250RmFjZU9iamVjdChleHBvcnRlZERhdGEsIHtcbiAgICAgICAgICAgIGlzRXZhbFN1cHBvcnRlZDogcGFyYW1zLmlzRXZhbFN1cHBvcnRlZCxcbiAgICAgICAgICAgIGRpc2FibGVGb250RmFjZTogcGFyYW1zLmRpc2FibGVGb250RmFjZSxcbiAgICAgICAgICAgIGlnbm9yZUVycm9yczogcGFyYW1zLmlnbm9yZUVycm9ycyxcbiAgICAgICAgICAgIG9uVW5zdXBwb3J0ZWRGZWF0dXJlOiB0aGlzLl9vblVuc3VwcG9ydGVkRmVhdHVyZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZm9udFJlZ2lzdHJ5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5mb250TG9hZGVyLmJpbmQoZm9udCkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJGb250RmFsbGJhY2tcIiwge1xuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXBhcmFtcy5mb250RXh0cmFQcm9wZXJ0aWVzICYmIGZvbnQuZGF0YSkge1xuICAgICAgICAgICAgICBmb250LmRhdGEgPSBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZm9udCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkZvbnRQYXRoXCI6XG4gICAgICAgIGNhc2UgXCJJbWFnZVwiOlxuICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZERhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHb3QgdW5rbm93biBjb21tb24gb2JqZWN0IHR5cGUgJHt0eXBlfWApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwib2JqXCIsIChbaWQsIHBhZ2VJbmRleCwgdHlwZSwgaW1hZ2VEYXRhXSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFnZVByb3h5ID0gdGhpcy4jcGFnZUNhY2hlLmdldChwYWdlSW5kZXgpO1xuXG4gICAgICBpZiAocGFnZVByb3h5Lm9ianMuaGFzKGlkKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgICBwYWdlUHJveHkub2Jqcy5yZXNvbHZlKGlkLCBpbWFnZURhdGEpO1xuICAgICAgICAgIGNvbnN0IE1BWF9JTUFHRV9TSVpFX1RPX1NUT1JFID0gODAwMDAwMDtcblxuICAgICAgICAgIGlmIChpbWFnZURhdGEpIHtcbiAgICAgICAgICAgIGxldCBsZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChpbWFnZURhdGEuYml0bWFwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBiaXRtYXAsXG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0XG4gICAgICAgICAgICAgIH0gPSBpbWFnZURhdGE7XG4gICAgICAgICAgICAgIGxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogNDtcblxuICAgICAgICAgICAgICBwYWdlUHJveHkuX2JpdG1hcHMuYWRkKGJpdG1hcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZW5ndGggPSBpbWFnZURhdGEuZGF0YT8ubGVuZ3RoIHx8IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiBNQVhfSU1BR0VfU0laRV9UT19TVE9SRSkge1xuICAgICAgICAgICAgICBwYWdlUHJveHkuY2xlYW51cEFmdGVyUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiUGF0dGVyblwiOlxuICAgICAgICAgIHBhZ2VQcm94eS5vYmpzLnJlc29sdmUoaWQsIGltYWdlRGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY1Byb2dyZXNzXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBkYXRhLmxvYWRlZCxcbiAgICAgICAgdG90YWw6IGRhdGEudG90YWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRG9jU3RhdHNcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiNkb2NTdGF0cyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBzdHJlYW1UeXBlczogT2JqZWN0LmZyZWV6ZShkYXRhLnN0cmVhbVR5cGVzKSxcbiAgICAgICAgZm9udFR5cGVzOiBPYmplY3QuZnJlZXplKGRhdGEuZm9udFR5cGVzKVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJVbnN1cHBvcnRlZEZlYXR1cmVcIiwgdGhpcy5fb25VbnN1cHBvcnRlZEZlYXR1cmUuYmluZCh0aGlzKSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJGZXRjaEJ1aWx0SW5DTWFwXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZC5cIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuQ01hcFJlYWRlckZhY3RvcnkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkNNYXBSZWFkZXJGYWN0b3J5IG5vdCBpbml0aWFsaXplZCwgc2VlIHRoZSBgdXNlV29ya2VyRmV0Y2hgIHBhcmFtZXRlci5cIikpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5DTWFwUmVhZGVyRmFjdG9yeS5mZXRjaChkYXRhKTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkZldGNoU3RhbmRhcmRGb250RGF0YVwiLCBkYXRhID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWQuXCIpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLlN0YW5kYXJkRm9udERhdGFGYWN0b3J5KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBub3QgaW5pdGlhbGl6ZWQsIHNlZSB0aGUgYHVzZVdvcmtlckZldGNoYCBwYXJhbWV0ZXIuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuU3RhbmRhcmRGb250RGF0YUZhY3RvcnkuZmV0Y2goZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBfb25VbnN1cHBvcnRlZEZlYXR1cmUoe1xuICAgIGZlYXR1cmVJZFxuICB9KSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkaW5nVGFzay5vblVuc3VwcG9ydGVkRmVhdHVyZT8uKGZlYXR1cmVJZCk7XG4gIH1cblxuICBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERhdGFcIiwgbnVsbCk7XG4gIH1cblxuICBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIocGFnZU51bWJlcikgfHwgcGFnZU51bWJlciA8PSAwIHx8IHBhZ2VOdW1iZXIgPiB0aGlzLl9udW1QYWdlcykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgcGFnZSByZXF1ZXN0LlwiKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDEsXG4gICAgICAgICAgY2FjaGVkUHJvbWlzZSA9IHRoaXMuI3BhZ2VQcm9taXNlcy5nZXQocGFnZUluZGV4KTtcblxuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG5cbiAgICBjb25zdCBwcm9taXNlID0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pLnRoZW4ocGFnZUluZm8gPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydCBkZXN0cm95ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhZ2UgPSBuZXcgUERGUGFnZVByb3h5KHBhZ2VJbmRleCwgcGFnZUluZm8sIHRoaXMsIHRoaXMuX3BhcmFtcy5vd25lckRvY3VtZW50LCB0aGlzLl9wYXJhbXMucGRmQnVnKTtcbiAgICAgIHRoaXMuI3BhZ2VDYWNoZS5zZXQocGFnZUluZGV4LCBwYWdlKTtcbiAgICAgIHJldHVybiBwYWdlO1xuICAgIH0pO1xuICAgIHRoaXMuI3BhZ2VQcm9taXNlcy5zZXQocGFnZUluZGV4LCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGdldFBhZ2VJbmRleChyZWYpIHtcbiAgICBpZiAodHlwZW9mIHJlZiAhPT0gXCJvYmplY3RcIiB8fCByZWYgPT09IG51bGwgfHwgIU51bWJlci5pc0ludGVnZXIocmVmLm51bSkgfHwgcmVmLm51bSA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIocmVmLmdlbikgfHwgcmVmLmdlbiA8IDApIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZ2VJbmRleCByZXF1ZXN0LlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUluZGV4XCIsIHtcbiAgICAgIG51bTogcmVmLm51bSxcbiAgICAgIGdlbjogcmVmLmdlblxuICAgIH0pO1xuICB9XG5cbiAgZ2V0QW5ub3RhdGlvbnMocGFnZUluZGV4LCBpbnRlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRBbm5vdGF0aW9uc1wiLCB7XG4gICAgICBwYWdlSW5kZXgsXG4gICAgICBpbnRlbnRcbiAgICB9KTtcbiAgfVxuXG4gIHNhdmVEb2N1bWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJTYXZlRG9jdW1lbnRcIiwge1xuICAgICAgaXNQdXJlWGZhOiAhIXRoaXMuX2h0bWxGb3JYZmEsXG4gICAgICBudW1QYWdlczogdGhpcy5fbnVtUGFnZXMsXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXJpYWxpemFibGUsXG4gICAgICBmaWxlbmFtZTogdGhpcy5fZnVsbFJlYWRlcj8uZmlsZW5hbWUgPz8gbnVsbFxuICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5yZXNldE1vZGlmaWVkKCk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRGaWVsZE9iamVjdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEZpZWxkT2JqZWN0c1Byb21pc2UgfHw9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RmllbGRPYmplY3RzXCIsIG51bGwpO1xuICB9XG5cbiAgaGFzSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9oYXNKU0FjdGlvbnNQcm9taXNlIHx8PSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkhhc0pTQWN0aW9uc1wiLCBudWxsKTtcbiAgfVxuXG4gIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Q2FsY3VsYXRpb25PcmRlcklkc1wiLCBudWxsKTtcbiAgfVxuXG4gIGdldERlc3RpbmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvbnNcIiwgbnVsbCk7XG4gIH1cblxuICBnZXREZXN0aW5hdGlvbihpZCkge1xuICAgIGlmICh0eXBlb2YgaWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIGRlc3RpbmF0aW9uIHJlcXVlc3QuXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvblwiLCB7XG4gICAgICBpZFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0UGFnZUxhYmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGFiZWxzXCIsIG51bGwpO1xuICB9XG5cbiAgZ2V0UGFnZUxheW91dCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGF5b3V0XCIsIG51bGwpO1xuICB9XG5cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZU1vZGVcIiwgbnVsbCk7XG4gIH1cblxuICBnZXRWaWV3ZXJQcmVmZXJlbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRWaWV3ZXJQcmVmZXJlbmNlc1wiLCBudWxsKTtcbiAgfVxuXG4gIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T3BlbkFjdGlvblwiLCBudWxsKTtcbiAgfVxuXG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEF0dGFjaG1lbnRzXCIsIG51bGwpO1xuICB9XG5cbiAgZ2V0SmF2YVNjcmlwdCgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRKYXZhU2NyaXB0XCIsIG51bGwpO1xuICB9XG5cbiAgZ2V0RG9jSlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldERvY0pTQWN0aW9uc1wiLCBudWxsKTtcbiAgfVxuXG4gIGdldFBhZ2VKU0FjdGlvbnMocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUpTQWN0aW9uc1wiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KTtcbiAgfVxuXG4gIGdldFN0cnVjdFRyZWUocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0U3RydWN0VHJlZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KTtcbiAgfVxuXG4gIGdldE91dGxpbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T3V0bGluZVwiLCBudWxsKTtcbiAgfVxuXG4gIGdldE9wdGlvbmFsQ29udGVudENvbmZpZygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPcHRpb25hbENvbnRlbnRDb25maWdcIiwgbnVsbCkudGhlbihyZXN1bHRzID0+IHtcbiAgICAgIHJldHVybiBuZXcgX29wdGlvbmFsX2NvbnRlbnRfY29uZmlnLk9wdGlvbmFsQ29udGVudENvbmZpZyhyZXN1bHRzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBlcm1pc3Npb25zXCIsIG51bGwpO1xuICB9XG5cbiAgZ2V0TWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21ldGFkYXRhUHJvbWlzZSB8fD0gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRNZXRhZGF0YVwiLCBudWxsKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5mbzogcmVzdWx0c1swXSxcbiAgICAgICAgbWV0YWRhdGE6IHJlc3VsdHNbMV0gPyBuZXcgX21ldGFkYXRhLk1ldGFkYXRhKHJlc3VsdHNbMV0pIDogbnVsbCxcbiAgICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU6IHRoaXMuX2Z1bGxSZWFkZXI/LmZpbGVuYW1lID8/IG51bGwsXG4gICAgICAgIGNvbnRlbnRMZW5ndGg6IHRoaXMuX2Z1bGxSZWFkZXI/LmNvbnRlbnRMZW5ndGggPz8gbnVsbFxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldE1hcmtJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE1hcmtJbmZvXCIsIG51bGwpO1xuICB9XG5cbiAgYXN5bmMgc3RhcnRDbGVhbnVwKGtlZXBMb2FkZWRGb250cyA9IGZhbHNlKSB7XG4gICAgYXdhaXQgdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJDbGVhbnVwXCIsIG51bGwpO1xuXG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwYWdlIG9mIHRoaXMuI3BhZ2VDYWNoZS52YWx1ZXMoKSkge1xuICAgICAgY29uc3QgY2xlYW51cFN1Y2Nlc3NmdWwgPSBwYWdlLmNsZWFudXAoKTtcblxuICAgICAgaWYgKCFjbGVhbnVwU3VjY2Vzc2Z1bCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0YXJ0Q2xlYW51cDogUGFnZSAke3BhZ2UucGFnZU51bWJlcn0gaXMgY3VycmVudGx5IHJlbmRlcmluZy5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbW1vbk9ianMuY2xlYXIoKTtcblxuICAgIGlmICgha2VlcExvYWRlZEZvbnRzKSB7XG4gICAgICB0aGlzLmZvbnRMb2FkZXIuY2xlYXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLiNtZXRhZGF0YVByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX2dldEZpZWxkT2JqZWN0c1Byb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX2hhc0pTQWN0aW9uc1Byb21pc2UgPSBudWxsO1xuICB9XG5cbiAgZ2V0IGxvYWRpbmdQYXJhbXMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcGFyYW1zO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImxvYWRpbmdQYXJhbXNcIiwge1xuICAgICAgZGlzYWJsZUF1dG9GZXRjaDogcGFyYW1zLmRpc2FibGVBdXRvRmV0Y2gsXG4gICAgICBlbmFibGVYZmE6IHBhcmFtcy5lbmFibGVYZmFcbiAgICB9KTtcbiAgfVxuXG59XG5cbmNsYXNzIFBERk9iamVjdHMge1xuICAjb2JqcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgI2Vuc3VyZU9iaihvYmpJZCkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuI29ianNbb2JqSWRdO1xuXG4gICAgaWYgKG9iaikge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy4jb2Jqc1tvYmpJZF0gPSB7XG4gICAgICBjYXBhYmlsaXR5OiAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCksXG4gICAgICBkYXRhOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIGdldChvYmpJZCwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBvYmogPSB0aGlzLiNlbnN1cmVPYmoob2JqSWQpO1xuICAgICAgb2JqLmNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IGNhbGxiYWNrKG9iai5kYXRhKSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcblxuICAgIGlmICghb2JqPy5jYXBhYmlsaXR5LnNldHRsZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWVzdGluZyBvYmplY3QgdGhhdCBpc24ndCByZXNvbHZlZCB5ZXQgJHtvYmpJZH0uYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iai5kYXRhO1xuICB9XG5cbiAgaGFzKG9iaklkKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgcmV0dXJuIG9iaj8uY2FwYWJpbGl0eS5zZXR0bGVkIHx8IGZhbHNlO1xuICB9XG5cbiAgcmVzb2x2ZShvYmpJZCwgZGF0YSA9IG51bGwpIHtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNlbnN1cmVPYmoob2JqSWQpO1xuICAgIG9iai5kYXRhID0gZGF0YTtcbiAgICBvYmouY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICB0aGlzLiNvYmpzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG59XG5cbmNsYXNzIFJlbmRlclRhc2sge1xuICAjaW50ZXJuYWxSZW5kZXJUYXNrID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihpbnRlcm5hbFJlbmRlclRhc2spIHtcbiAgICB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2sgPSBpbnRlcm5hbFJlbmRlclRhc2s7XG4gICAgdGhpcy5vbkNvbnRpbnVlID0gbnVsbDtcbiAgfVxuXG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5jYW5jZWwoKTtcbiAgfVxuXG4gIGdldCBzZXBhcmF0ZUFubm90cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBzZXBhcmF0ZUFubm90c1xuICAgIH0gPSB0aGlzLiNpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0O1xuXG4gICAgaWYgKCFzZXBhcmF0ZUFubm90cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGFubm90YXRpb25DYW52YXNNYXBcbiAgICB9ID0gdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrO1xuICAgIHJldHVybiBzZXBhcmF0ZUFubm90cy5mb3JtIHx8IHNlcGFyYXRlQW5ub3RzLmNhbnZhcyAmJiBhbm5vdGF0aW9uQ2FudmFzTWFwPy5zaXplID4gMDtcbiAgfVxuXG59XG5cbmV4cG9ydHMuUmVuZGVyVGFzayA9IFJlbmRlclRhc2s7XG5cbmNsYXNzIEludGVybmFsUmVuZGVyVGFzayB7XG4gIHN0YXRpYyAjY2FudmFzSW5Vc2UgPSBuZXcgV2Vha1NldCgpO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBjYWxsYmFjayxcbiAgICBwYXJhbXMsXG4gICAgb2JqcyxcbiAgICBjb21tb25PYmpzLFxuICAgIGFubm90YXRpb25DYW52YXNNYXAsXG4gICAgb3BlcmF0b3JMaXN0LFxuICAgIHBhZ2VJbmRleCxcbiAgICBjYW52YXNGYWN0b3J5LFxuICAgIHVzZVJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZhbHNlLFxuICAgIHBkZkJ1ZyA9IGZhbHNlLFxuICAgIHBhZ2VDb2xvcnMgPSBudWxsXG4gIH0pIHtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCA9IGFubm90YXRpb25DYW52YXNNYXA7XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSBudWxsO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0ID0gb3BlcmF0b3JMaXN0O1xuICAgIHRoaXMuX3BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICB0aGlzLnBhZ2VDb2xvcnMgPSBwYWdlQ29sb3JzO1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrID0gbnVsbDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLl91c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT09IHRydWUgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICB0aGlzLnRhc2sgPSBuZXcgUmVuZGVyVGFzayh0aGlzKTtcbiAgICB0aGlzLl9jYW5jZWxCb3VuZCA9IHRoaXMuY2FuY2VsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY29udGludWVCb3VuZCA9IHRoaXMuX2NvbnRpbnVlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fc2NoZWR1bGVOZXh0Qm91bmQgPSB0aGlzLl9zY2hlZHVsZU5leHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9uZXh0Qm91bmQgPSB0aGlzLl9uZXh0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY2FudmFzID0gcGFyYW1zLmNhbnZhc0NvbnRleHQuY2FudmFzO1xuICB9XG5cbiAgZ2V0IGNvbXBsZXRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jYXBhYmlsaXR5LnByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICB9XG5cbiAgaW5pdGlhbGl6ZUdyYXBoaWNzKHtcbiAgICB0cmFuc3BhcmVuY3kgPSBmYWxzZSxcbiAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgfSkge1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jYW52YXMpIHtcbiAgICAgIGlmIChJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmhhcyh0aGlzLl9jYW52YXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgdGhlIHNhbWUgY2FudmFzIGR1cmluZyBtdWx0aXBsZSByZW5kZXIoKSBvcGVyYXRpb25zLiBcIiArIFwiVXNlIGRpZmZlcmVudCBjYW52YXMgb3IgZW5zdXJlIHByZXZpb3VzIG9wZXJhdGlvbnMgd2VyZSBcIiArIFwiY2FuY2VsbGVkIG9yIGNvbXBsZXRlZC5cIik7XG4gICAgICB9XG5cbiAgICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuYWRkKHRoaXMuX2NhbnZhcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BkZkJ1ZyAmJiBnbG9iYWxUaGlzLlN0ZXBwZXJNYW5hZ2VyPy5lbmFibGVkKSB7XG4gICAgICB0aGlzLnN0ZXBwZXIgPSBnbG9iYWxUaGlzLlN0ZXBwZXJNYW5hZ2VyLmNyZWF0ZSh0aGlzLl9wYWdlSW5kZXgpO1xuICAgICAgdGhpcy5zdGVwcGVyLmluaXQodGhpcy5vcGVyYXRvckxpc3QpO1xuICAgICAgdGhpcy5zdGVwcGVyLm5leHRCcmVha1BvaW50ID0gdGhpcy5zdGVwcGVyLmdldE5leHRCcmVha1BvaW50KCk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzQ29udGV4dCxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdHJhbnNmb3JtLFxuICAgICAgaW1hZ2VMYXllcixcbiAgICAgIGJhY2tncm91bmRcbiAgICB9ID0gdGhpcy5wYXJhbXM7XG4gICAgdGhpcy5nZnggPSBuZXcgX2NhbnZhcy5DYW52YXNHcmFwaGljcyhjYW52YXNDb250ZXh0LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCBpbWFnZUxheWVyLCBvcHRpb25hbENvbnRlbnRDb25maWcsIHRoaXMuYW5ub3RhdGlvbkNhbnZhc01hcCwgdGhpcy5wYWdlQ29sb3JzKTtcbiAgICB0aGlzLmdmeC5iZWdpbkRyYXdpbmcoe1xuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc3BhcmVuY3ksXG4gICAgICBiYWNrZ3JvdW5kXG4gICAgfSk7XG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSAwO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeSA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2spIHtcbiAgICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG5cbiAgY2FuY2VsKGVycm9yID0gbnVsbCkge1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLmdmeCkge1xuICAgICAgdGhpcy5nZnguZW5kRHJhd2luZygpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jYW52YXMpIHtcbiAgICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuZGVsZXRlKHRoaXMuX2NhbnZhcyk7XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFjayhlcnJvciB8fCBuZXcgX2Rpc3BsYXlfdXRpbHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKGBSZW5kZXJpbmcgY2FuY2VsbGVkLCBwYWdlICR7dGhpcy5fcGFnZUluZGV4ICsgMX1gLCBcImNhbnZhc1wiKSk7XG4gIH1cblxuICBvcGVyYXRvckxpc3RDaGFuZ2VkKCkge1xuICAgIGlmICghdGhpcy5ncmFwaGljc1JlYWR5KSB7XG4gICAgICBpZiAoIXRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrID0gdGhpcy5fY29udGludWVCb3VuZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0ZXBwZXIpIHtcbiAgICAgIHRoaXMuc3RlcHBlci51cGRhdGVPcGVyYXRvckxpc3QodGhpcy5vcGVyYXRvckxpc3QpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJ1bm5pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9jb250aW51ZSgpO1xuICB9XG5cbiAgX2NvbnRpbnVlKCkge1xuICAgIHRoaXMucnVubmluZyA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50YXNrLm9uQ29udGludWUpIHtcbiAgICAgIHRoaXMudGFzay5vbkNvbnRpbnVlKHRoaXMuX3NjaGVkdWxlTmV4dEJvdW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2NoZWR1bGVOZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgX3NjaGVkdWxlTmV4dCgpIHtcbiAgICBpZiAodGhpcy5fdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5fbmV4dEJvdW5kKCkuY2F0Y2godGhpcy5fY2FuY2VsQm91bmQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4odGhpcy5fbmV4dEJvdW5kKS5jYXRjaCh0aGlzLl9jYW5jZWxCb3VuZCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgX25leHQoKSB7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSB0aGlzLmdmeC5leGVjdXRlT3BlcmF0b3JMaXN0KHRoaXMub3BlcmF0b3JMaXN0LCB0aGlzLm9wZXJhdG9yTGlzdElkeCwgdGhpcy5fY29udGludWVCb3VuZCwgdGhpcy5zdGVwcGVyKTtcblxuICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdElkeCA9PT0gdGhpcy5vcGVyYXRvckxpc3QuYXJnc0FycmF5Lmxlbmd0aCkge1xuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgdGhpcy5nZnguZW5kRHJhd2luZygpO1xuXG4gICAgICAgIGlmICh0aGlzLl9jYW52YXMpIHtcbiAgICAgICAgICBJbnRlcm5hbFJlbmRlclRhc2suI2NhbnZhc0luVXNlLmRlbGV0ZSh0aGlzLl9jYW52YXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbmNvbnN0IHZlcnNpb24gPSAnMi4xNi4xMDUnO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcbmNvbnN0IGJ1aWxkID0gJzE3MmNjZGJlNSc7XG5leHBvcnRzLmJ1aWxkID0gYnVpbGQ7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5QcmludEFubm90YXRpb25TdG9yYWdlID0gZXhwb3J0cy5Bbm5vdGF0aW9uU3RvcmFnZSA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcblxudmFyIF9lZGl0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xuXG52YXIgX211cm11cmhhc2ggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcblxuY2xhc3MgQW5ub3RhdGlvblN0b3JhZ2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9zdG9yYWdlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX21vZGlmaWVkID0gZmFsc2U7XG4gICAgdGhpcy5vblNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCA9IG51bGw7XG4gICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IgPSBudWxsO1xuICB9XG5cbiAgZ2V0VmFsdWUoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3N0b3JhZ2UuZ2V0KGtleSk7XG5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkZWZhdWx0VmFsdWUsIHZhbHVlKTtcbiAgfVxuXG4gIGdldFJhd1ZhbHVlKGtleSkge1xuICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLmdldChrZXkpO1xuICB9XG5cbiAgcmVtb3ZlKGtleSkge1xuICAgIHRoaXMuX3N0b3JhZ2UuZGVsZXRlKGtleSk7XG5cbiAgICBpZiAodGhpcy5fc3RvcmFnZS5zaXplID09PSAwKSB7XG4gICAgICB0aGlzLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy5fc3RvcmFnZS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5vbkFubm90YXRpb25FZGl0b3IobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgc2V0VmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgIGNvbnN0IG9iaiA9IHRoaXMuX3N0b3JhZ2UuZ2V0KGtleSk7XG5cbiAgICBsZXQgbW9kaWZpZWQgPSBmYWxzZTtcblxuICAgIGlmIChvYmogIT09IHVuZGVmaW5lZCkge1xuICAgICAgZm9yIChjb25zdCBbZW50cnksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgIGlmIChvYmpbZW50cnldICE9PSB2YWwpIHtcbiAgICAgICAgICBtb2RpZmllZCA9IHRydWU7XG4gICAgICAgICAgb2JqW2VudHJ5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtb2RpZmllZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuX3N0b3JhZ2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgdGhpcy4jc2V0TW9kaWZpZWQoKTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IgJiYgdHlwZW9mIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yKHZhbHVlLmNvbnN0cnVjdG9yLl90eXBlKTtcbiAgICB9XG4gIH1cblxuICBoYXMoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2UuaGFzKGtleSk7XG4gIH1cblxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2Uuc2l6ZSA+IDAgPyAoMCwgX3V0aWwub2JqZWN0RnJvbU1hcCkodGhpcy5fc3RvcmFnZSkgOiBudWxsO1xuICB9XG5cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2Uuc2l6ZTtcbiAgfVxuXG4gICNzZXRNb2RpZmllZCgpIHtcbiAgICBpZiAoIXRoaXMuX21vZGlmaWVkKSB7XG4gICAgICB0aGlzLl9tb2RpZmllZCA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblNldE1vZGlmaWVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vblNldE1vZGlmaWVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmVzZXRNb2RpZmllZCgpIHtcbiAgICBpZiAodGhpcy5fbW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuX21vZGlmaWVkID0gZmFsc2U7XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblJlc2V0TW9kaWZpZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBwcmludCgpIHtcbiAgICByZXR1cm4gbmV3IFByaW50QW5ub3RhdGlvblN0b3JhZ2UodGhpcyk7XG4gIH1cblxuICBnZXQgc2VyaWFsaXphYmxlKCkge1xuICAgIGlmICh0aGlzLl9zdG9yYWdlLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGNsb25lID0gbmV3IE1hcCgpO1xuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIHRoaXMuX3N0b3JhZ2UpIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB2YWwgaW5zdGFuY2VvZiBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IgPyB2YWwuc2VyaWFsaXplKCkgOiB2YWw7XG5cbiAgICAgIGlmIChzZXJpYWxpemVkKSB7XG4gICAgICAgIGNsb25lLnNldChrZXksIHNlcmlhbGl6ZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRIYXNoKG1hcCkge1xuICAgIGlmICghbWFwKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNoID0gbmV3IF9tdXJtdXJoYXNoLk11cm11ckhhc2gzXzY0KCk7XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgbWFwKSB7XG4gICAgICBoYXNoLnVwZGF0ZShgJHtrZXl9OiR7SlNPTi5zdHJpbmdpZnkodmFsKX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGFzaC5oZXhkaWdlc3QoKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuQW5ub3RhdGlvblN0b3JhZ2UgPSBBbm5vdGF0aW9uU3RvcmFnZTtcblxuY2xhc3MgUHJpbnRBbm5vdGF0aW9uU3RvcmFnZSBleHRlbmRzIEFubm90YXRpb25TdG9yYWdlIHtcbiAgI3NlcmlhbGl6YWJsZSA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNzZXJpYWxpemFibGUgPSBzdHJ1Y3R1cmVkQ2xvbmUocGFyZW50LnNlcmlhbGl6YWJsZSk7XG4gIH1cblxuICBnZXQgcHJpbnQoKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIlNob3VsZCBub3QgY2FsbCBQcmludEFubm90YXRpb25TdG9yYWdlLnByaW50XCIpO1xuICB9XG5cbiAgZ2V0IHNlcmlhbGl6YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VyaWFsaXphYmxlO1xuICB9XG5cbn1cblxuZXhwb3J0cy5QcmludEFubm90YXRpb25TdG9yYWdlID0gUHJpbnRBbm5vdGF0aW9uU3RvcmFnZTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3IgPSB2b2lkIDA7XG5cbnZhciBfdG9vbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2JvdW5kRm9jdXNpbiA9IHRoaXMuZm9jdXNpbi5iaW5kKHRoaXMpO1xuICAjYm91bmRGb2N1c291dCA9IHRoaXMuZm9jdXNvdXQuYmluZCh0aGlzKTtcbiAgI2hhc0JlZW5TZWxlY3RlZCA9IGZhbHNlO1xuICAjaXNFZGl0aW5nID0gZmFsc2U7XG4gICNpc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgI3pJbmRleCA9IEFubm90YXRpb25FZGl0b3IuX3pJbmRleCsrO1xuICBzdGF0aWMgX2NvbG9yTWFuYWdlciA9IG5ldyBfdG9vbHMuQ29sb3JNYW5hZ2VyKCk7XG4gIHN0YXRpYyBfekluZGV4ID0gMTtcblxuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEFubm90YXRpb25FZGl0b3IpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBBbm5vdGF0aW9uRWRpdG9yLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhcmVudCA9IHBhcmFtZXRlcnMucGFyZW50O1xuICAgIHRoaXMuaWQgPSBwYXJhbWV0ZXJzLmlkO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IG51bGw7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYXJhbWV0ZXJzLnBhcmVudC5wYWdlSW5kZXg7XG4gICAgdGhpcy5uYW1lID0gcGFyYW1ldGVycy5uYW1lO1xuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICBjb25zdCBbd2lkdGgsIGhlaWdodF0gPSB0aGlzLnBhcmVudC52aWV3cG9ydEJhc2VEaW1lbnNpb25zO1xuICAgIHRoaXMueCA9IHBhcmFtZXRlcnMueCAvIHdpZHRoO1xuICAgIHRoaXMueSA9IHBhcmFtZXRlcnMueSAvIGhlaWdodDtcbiAgICB0aGlzLnJvdGF0aW9uID0gdGhpcy5wYXJlbnQudmlld3BvcnQucm90YXRpb247XG4gICAgdGhpcy5pc0F0dGFjaGVkVG9ET00gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgX2RlZmF1bHRMaW5lQ29sb3IoKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX2RlZmF1bHRMaW5lQ29sb3JcIiwgdGhpcy5fY29sb3JNYW5hZ2VyLmdldEhleENvZGUoXCJDYW52YXNUZXh0XCIpKTtcbiAgfVxuXG4gIHNldEluQmFja2dyb3VuZCgpIHtcbiAgICB0aGlzLmRpdi5zdHlsZS56SW5kZXggPSAwO1xuICB9XG5cbiAgc2V0SW5Gb3JlZ3JvdW5kKCkge1xuICAgIHRoaXMuZGl2LnN0eWxlLnpJbmRleCA9IHRoaXMuI3pJbmRleDtcbiAgfVxuXG4gIGZvY3VzaW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuI2hhc0JlZW5TZWxlY3RlZCkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2hhc0JlZW5TZWxlY3RlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZvY3Vzb3V0KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQ7XG5cbiAgICBpZiAodGFyZ2V0Py5jbG9zZXN0KGAjJHt0aGlzLmlkfWApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIGlmICghdGhpcy5wYXJlbnQuaXNNdWx0aXBsZVNlbGVjdGlvbikge1xuICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIH1cbiAgfVxuXG4gIGNvbW1pdE9yUmVtb3ZlKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICB9XG4gIH1cblxuICBjb21taXQoKSB7XG4gICAgdGhpcy5wYXJlbnQuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSh0aGlzKTtcbiAgfVxuXG4gIGRyYWdzdGFydChldmVudCkge1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLnBhcmVudC5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdGhpcy5zdGFydFggPSBldmVudC5jbGllbnRYIC0gcmVjdC54O1xuICAgIHRoaXMuc3RhcnRZID0gZXZlbnQuY2xpZW50WSAtIHJlY3QueTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgdGhpcy5pZCk7XG4gICAgZXZlbnQuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSBcIm1vdmVcIjtcbiAgfVxuXG4gIHNldEF0KHgsIHksIHR4LCB0eSkge1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMucGFyZW50LnZpZXdwb3J0QmFzZURpbWVuc2lvbnM7XG4gICAgW3R4LCB0eV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHR4LCB0eSk7XG4gICAgdGhpcy54ID0gKHggKyB0eCkgLyB3aWR0aDtcbiAgICB0aGlzLnkgPSAoeSArIHR5KSAvIGhlaWdodDtcbiAgICB0aGlzLmRpdi5zdHlsZS5sZWZ0ID0gYCR7MTAwICogdGhpcy54fSVgO1xuICAgIHRoaXMuZGl2LnN0eWxlLnRvcCA9IGAkezEwMCAqIHRoaXMueX0lYDtcbiAgfVxuXG4gIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGhpcy5wYXJlbnQudmlld3BvcnRCYXNlRGltZW5zaW9ucztcbiAgICBbeCwgeV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHgsIHkpO1xuICAgIHRoaXMueCArPSB4IC8gd2lkdGg7XG4gICAgdGhpcy55ICs9IHkgLyBoZWlnaHQ7XG4gICAgdGhpcy5kaXYuc3R5bGUubGVmdCA9IGAkezEwMCAqIHRoaXMueH0lYDtcbiAgICB0aGlzLmRpdi5zdHlsZS50b3AgPSBgJHsxMDAgKiB0aGlzLnl9JWA7XG4gIH1cblxuICBzY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4LCB5KSB7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRpb25cbiAgICB9ID0gdGhpcy5wYXJlbnQudmlld3BvcnQ7XG5cbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ksIC14XTtcblxuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbLXgsIC15XTtcblxuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbLXksIHhdO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgfVxuXG4gIHNldERpbXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50LnZpZXdwb3J0QmFzZURpbWVuc2lvbnM7XG4gICAgdGhpcy5kaXYuc3R5bGUud2lkdGggPSBgJHsxMDAgKiB3aWR0aCAvIHBhcmVudFdpZHRofSVgO1xuICAgIHRoaXMuZGl2LnN0eWxlLmhlaWdodCA9IGAkezEwMCAqIGhlaWdodCAvIHBhcmVudEhlaWdodH0lYDtcbiAgfVxuXG4gIGdldEluaXRpYWxUcmFuc2xhdGlvbigpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVkaXRvci1yb3RhdGlvblwiLCAoMzYwIC0gdGhpcy5yb3RhdGlvbikgJSAzNjApO1xuICAgIHRoaXMuZGl2LmNsYXNzTmFtZSA9IHRoaXMubmFtZTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB0aGlzLmlkKTtcbiAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoXCJ0YWJJbmRleFwiLCAwKTtcbiAgICB0aGlzLnNldEluRm9yZWdyb3VuZCgpO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuI2JvdW5kRm9jdXNpbik7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuI2JvdW5kRm9jdXNvdXQpO1xuICAgIGNvbnN0IFt0eCwgdHldID0gdGhpcy5nZXRJbml0aWFsVHJhbnNsYXRpb24oKTtcbiAgICB0aGlzLnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgICgwLCBfdG9vbHMuYmluZEV2ZW50cykodGhpcywgdGhpcy5kaXYsIFtcImRyYWdzdGFydFwiLCBcInBvaW50ZXJkb3duXCJdKTtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cblxuICBwb2ludGVyZG93bihldmVudCkge1xuICAgIGNvbnN0IGlzTWFjID0gX3Rvb2xzLktleWJvYXJkTWFuYWdlci5wbGF0Zm9ybS5pc01hYztcblxuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuY3RybEtleSAmJiAhaXNNYWMgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQubWV0YUtleSAmJiBpc01hYykge1xuICAgICAgdGhpcy5wYXJlbnQudG9nZ2xlU2VsZWN0ZWQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMuI2hhc0JlZW5TZWxlY3RlZCA9IHRydWU7XG4gIH1cblxuICBnZXRSZWN0KHR4LCB0eSkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50LnZpZXdwb3J0QmFzZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhcmVudC5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBzaGlmdFggPSBwYWdlV2lkdGggKiB0eCAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHNoaWZ0WSA9IHBhZ2VIZWlnaHQgKiB0eSAvIHBhcmVudEhlaWdodDtcbiAgICBjb25zdCB4ID0gdGhpcy54ICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IHkgPSB0aGlzLnkgKiBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG5cbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIFt4ICsgc2hpZnRYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WSAtIGhlaWdodCwgeCArIHNoaWZ0WCArIHdpZHRoLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WV07XG5cbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbeCArIHNoaWZ0WSwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFgsIHggKyBzaGlmdFkgKyBoZWlnaHQsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRYICsgd2lkdGhdO1xuXG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4IC0gc2hpZnRYIC0gd2lkdGgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRZLCB4IC0gc2hpZnRYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WSArIGhlaWdodF07XG5cbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3ggLSBzaGlmdFkgLSBoZWlnaHQsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRYIC0gd2lkdGgsIHggLSBzaGlmdFksIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRYXTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gIH1cblxuICBnZXRSZWN0SW5DdXJyZW50Q29vcmRzKHJlY3QsIHBhZ2VIZWlnaHQpIHtcbiAgICBjb25zdCBbeDEsIHkxLCB4MiwgeTJdID0gcmVjdDtcbiAgICBjb25zdCB3aWR0aCA9IHgyIC0geDE7XG4gICAgY29uc3QgaGVpZ2h0ID0geTIgLSB5MTtcblxuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW3gxLCBwYWdlSGVpZ2h0IC0geTIsIHdpZHRoLCBoZWlnaHRdO1xuXG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3gxLCBwYWdlSGVpZ2h0IC0geTEsIGhlaWdodCwgd2lkdGhdO1xuXG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4MiwgcGFnZUhlaWdodCAtIHkxLCB3aWR0aCwgaGVpZ2h0XTtcblxuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeDIsIHBhZ2VIZWlnaHQgLSB5MiwgaGVpZ2h0LCB3aWR0aF07XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICB9XG5cbiAgb25jZUFkZGVkKCkge31cblxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIHRoaXMuI2lzSW5FZGl0TW9kZSA9IHRydWU7XG4gIH1cblxuICBkaXNhYmxlRWRpdE1vZGUoKSB7XG4gICAgdGhpcy4jaXNJbkVkaXRNb2RlID0gZmFsc2U7XG4gIH1cblxuICBpc0luRWRpdE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzSW5FZGl0TW9kZTtcbiAgfVxuXG4gIHNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG5lZWRzVG9CZVJlYnVpbHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2ICYmICF0aGlzLmlzQXR0YWNoZWRUb0RPTTtcbiAgfVxuXG4gIHJlYnVpbGQoKSB7XG4gICAgdGhpcy5kaXY/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuI2JvdW5kRm9jdXNpbik7XG4gIH1cblxuICBzZXJpYWxpemUoKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFuIGVkaXRvciBtdXN0IGJlIHNlcmlhbGl6YWJsZVwiKTtcbiAgfVxuXG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQpIHtcbiAgICBjb25zdCBlZGl0b3IgPSBuZXcgdGhpcy5wcm90b3R5cGUuY29uc3RydWN0b3Ioe1xuICAgICAgcGFyZW50LFxuICAgICAgaWQ6IHBhcmVudC5nZXROZXh0SWQoKVxuICAgIH0pO1xuICAgIGVkaXRvci5yb3RhdGlvbiA9IGRhdGEucm90YXRpb247XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBwYXJlbnQucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gZWRpdG9yLmdldFJlY3RJbkN1cnJlbnRDb29yZHMoZGF0YS5yZWN0LCBwYWdlSGVpZ2h0KTtcbiAgICBlZGl0b3IueCA9IHggLyBwYWdlV2lkdGg7XG4gICAgZWRpdG9yLnkgPSB5IC8gcGFnZUhlaWdodDtcbiAgICBlZGl0b3Iud2lkdGggPSB3aWR0aCAvIHBhZ2VXaWR0aDtcbiAgICBlZGl0b3IuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG5cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuZGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuI2JvdW5kRm9jdXNpbik7XG4gICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIHRoaXMuI2JvdW5kRm9jdXNvdXQpO1xuXG4gICAgaWYgKCF0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy5jb21taXQoKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhcmVudC5yZW1vdmUodGhpcyk7XG4gIH1cblxuICBzZWxlY3QoKSB7XG4gICAgdGhpcy5kaXY/LmNsYXNzTGlzdC5hZGQoXCJzZWxlY3RlZEVkaXRvclwiKTtcbiAgfVxuXG4gIHVuc2VsZWN0KCkge1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gIH1cblxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHt9XG5cbiAgZGlzYWJsZUVkaXRpbmcoKSB7fVxuXG4gIGVuYWJsZUVkaXRpbmcoKSB7fVxuXG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgZ2V0IGNvbnRlbnREaXYoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG5cbiAgZ2V0IGlzRWRpdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNFZGl0aW5nO1xuICB9XG5cbiAgc2V0IGlzRWRpdGluZyh2YWx1ZSkge1xuICAgIHRoaXMuI2lzRWRpdGluZyA9IHZhbHVlO1xuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnBhcmVudC5zZXRTZWxlY3RlZCh0aGlzKTtcbiAgICAgIHRoaXMucGFyZW50LnNldEFjdGl2ZUVkaXRvcih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvciA9IEFubm90YXRpb25FZGl0b3I7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5LZXlib2FyZE1hbmFnZXIgPSBleHBvcnRzLkNvbW1hbmRNYW5hZ2VyID0gZXhwb3J0cy5Db2xvck1hbmFnZXIgPSBleHBvcnRzLkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIgPSB2b2lkIDA7XG5leHBvcnRzLmJpbmRFdmVudHMgPSBiaW5kRXZlbnRzO1xuZXhwb3J0cy5vcGFjaXR5VG9IZXggPSBvcGFjaXR5VG9IZXg7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5cbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oOCk7XG5cbmZ1bmN0aW9uIGJpbmRFdmVudHMob2JqLCBlbGVtZW50LCBuYW1lcykge1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgb2JqW25hbWVdLmJpbmQob2JqKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb3BhY2l0eVRvSGV4KG9wYWNpdHkpIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5taW4oMjU1LCBNYXRoLm1heCgxLCAyNTUgKiBvcGFjaXR5KSkpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIik7XG59XG5cbmNsYXNzIElkTWFuYWdlciB7XG4gICNpZCA9IDA7XG5cbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuIGAke191dGlsLkFubm90YXRpb25FZGl0b3JQcmVmaXh9JHt0aGlzLiNpZCsrfWA7XG4gIH1cblxufVxuXG5jbGFzcyBDb21tYW5kTWFuYWdlciB7XG4gICNjb21tYW5kcyA9IFtdO1xuICAjbG9ja2VkID0gZmFsc2U7XG4gICNtYXhTaXplO1xuICAjcG9zaXRpb24gPSAtMTtcblxuICBjb25zdHJ1Y3RvcihtYXhTaXplID0gMTI4KSB7XG4gICAgdGhpcy4jbWF4U2l6ZSA9IG1heFNpemU7XG4gIH1cblxuICBhZGQoe1xuICAgIGNtZCxcbiAgICB1bmRvLFxuICAgIG11c3RFeGVjLFxuICAgIHR5cGUgPSBOYU4sXG4gICAgb3ZlcndyaXRlSWZTYW1lVHlwZSA9IGZhbHNlLFxuICAgIGtlZXBVbmRvID0gZmFsc2VcbiAgfSkge1xuICAgIGlmIChtdXN0RXhlYykge1xuICAgICAgY21kKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuI2xvY2tlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNhdmUgPSB7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgdHlwZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICBpZiAodGhpcy4jY29tbWFuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5sZW5ndGggPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiNwb3NpdGlvbiA9IDA7XG4gICAgICB0aGlzLiNjb21tYW5kcy5wdXNoKHNhdmUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvdmVyd3JpdGVJZlNhbWVUeXBlICYmIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS50eXBlID09PSB0eXBlKSB7XG4gICAgICBpZiAoa2VlcFVuZG8pIHtcbiAgICAgICAgc2F2ZS51bmRvID0gdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLnVuZG87XG4gICAgICB9XG5cbiAgICAgIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXSA9IHNhdmU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbmV4dCA9IHRoaXMuI3Bvc2l0aW9uICsgMTtcblxuICAgIGlmIChuZXh0ID09PSB0aGlzLiNtYXhTaXplKSB7XG4gICAgICB0aGlzLiNjb21tYW5kcy5zcGxpY2UoMCwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uID0gbmV4dDtcblxuICAgICAgaWYgKG5leHQgPCB0aGlzLiNjb21tYW5kcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKG5leHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuI2NvbW1hbmRzLnB1c2goc2F2ZSk7XG4gIH1cblxuICB1bmRvKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS51bmRvKCk7XG4gICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy4jcG9zaXRpb24gLT0gMTtcbiAgfVxuXG4gIHJlZG8oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uIDwgdGhpcy4jY29tbWFuZHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy4jcG9zaXRpb24gKz0gMTtcbiAgICAgIHRoaXMuI2xvY2tlZCA9IHRydWU7XG4gICAgICB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0uY21kKCk7XG4gICAgICB0aGlzLiNsb2NrZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBoYXNTb21ldGhpbmdUb1VuZG8oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Bvc2l0aW9uICE9PSAtMTtcbiAgfVxuXG4gIGhhc1NvbWV0aGluZ1RvUmVkbygpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gPCB0aGlzLiNjb21tYW5kcy5sZW5ndGggLSAxO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNjb21tYW5kcyA9IG51bGw7XG4gIH1cblxufVxuXG5leHBvcnRzLkNvbW1hbmRNYW5hZ2VyID0gQ29tbWFuZE1hbmFnZXI7XG5cbmNsYXNzIEtleWJvYXJkTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNhbGxiYWNrcykge1xuICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgdGhpcy5jYWxsYmFja3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbGxLZXlzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGlzTWFjID0gS2V5Ym9hcmRNYW5hZ2VyLnBsYXRmb3JtLmlzTWFjO1xuXG4gICAgZm9yIChjb25zdCBba2V5cywgY2FsbGJhY2tdIG9mIGNhbGxiYWNrcykge1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBjb25zdCBpc01hY0tleSA9IGtleS5zdGFydHNXaXRoKFwibWFjK1wiKTtcblxuICAgICAgICBpZiAoaXNNYWMgJiYgaXNNYWNLZXkpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5zZXQoa2V5LnNsaWNlKDQpLCBjYWxsYmFjayk7XG4gICAgICAgICAgdGhpcy5hbGxLZXlzLmFkZChrZXkuc3BsaXQoXCIrXCIpLmF0KC0xKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTWFjICYmICFpc01hY0tleSkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNldChrZXksIGNhbGxiYWNrKTtcbiAgICAgICAgICB0aGlzLmFsbEtleXMuYWRkKGtleS5zcGxpdChcIitcIikuYXQoLTEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgcGxhdGZvcm0oKSB7XG4gICAgY29uc3QgcGxhdGZvcm0gPSB0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiID8gbmF2aWdhdG9yLnBsYXRmb3JtIDogXCJcIjtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJwbGF0Zm9ybVwiLCB7XG4gICAgICBpc1dpbjogcGxhdGZvcm0uaW5jbHVkZXMoXCJXaW5cIiksXG4gICAgICBpc01hYzogcGxhdGZvcm0uaW5jbHVkZXMoXCJNYWNcIilcbiAgICB9KTtcbiAgfVxuXG4gICNzZXJpYWxpemUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiYWx0XCIpO1xuICAgIH1cblxuICAgIGlmIChldmVudC5jdHJsS2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwiY3RybFwiKTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQubWV0YUtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcIm1ldGFcIik7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKFwic2hpZnRcIik7XG4gICAgfVxuXG4gICAgdGhpcy5idWZmZXIucHVzaChldmVudC5rZXkpO1xuICAgIGNvbnN0IHN0ciA9IHRoaXMuYnVmZmVyLmpvaW4oXCIrXCIpO1xuICAgIHRoaXMuYnVmZmVyLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGV4ZWMoc2VsZiwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuYWxsS2V5cy5oYXMoZXZlbnQua2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5jYWxsYmFja3MuZ2V0KHRoaXMuI3NlcmlhbGl6ZShldmVudCkpO1xuXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNhbGxiYWNrLmJpbmQoc2VsZikoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5LZXlib2FyZE1hbmFnZXIgPSBLZXlib2FyZE1hbmFnZXI7XG5cbmNsYXNzIENsaXBib2FyZE1hbmFnZXIge1xuICAjZWxlbWVudHMgPSBudWxsO1xuXG4gIGNvcHkoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgICB0aGlzLiNlbGVtZW50cyA9IGVsZW1lbnQubWFwKGVsID0+IGVsLnNlcmlhbGl6ZSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZWxlbWVudHMgPSBbZWxlbWVudC5zZXJpYWxpemUoKV07XG4gICAgfVxuXG4gICAgdGhpcy4jZWxlbWVudHMgPSB0aGlzLiNlbGVtZW50cy5maWx0ZXIoZWwgPT4gISFlbCk7XG5cbiAgICBpZiAodGhpcy4jZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLiNlbGVtZW50cyA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcGFzdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2VsZW1lbnRzO1xuICB9XG5cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZWxlbWVudHMgPT09IG51bGw7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI2VsZW1lbnRzID0gbnVsbDtcbiAgfVxuXG59XG5cbmNsYXNzIENvbG9yTWFuYWdlciB7XG4gIHN0YXRpYyBfY29sb3JzTWFwcGluZyA9IG5ldyBNYXAoW1tcIkNhbnZhc1RleHRcIiwgWzAsIDAsIDBdXSwgW1wiQ2FudmFzXCIsIFsyNTUsIDI1NSwgMjU1XV1dKTtcblxuICBnZXQgX2NvbG9ycygpIHtcbiAgICBjb25zdCBjb2xvcnMgPSBuZXcgTWFwKFtbXCJDYW52YXNUZXh0XCIsIG51bGxdLCBbXCJDYW52YXNcIiwgbnVsbF1dKTtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q29sb3JWYWx1ZXMpKGNvbG9ycyk7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX2NvbG9yc1wiLCBjb2xvcnMpO1xuICB9XG5cbiAgY29udmVydChjb2xvcikge1xuICAgIGNvbnN0IHJnYiA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRSR0IpKGNvbG9yKTtcblxuICAgIGlmICghd2luZG93Lm1hdGNoTWVkaWEoXCIoZm9yY2VkLWNvbG9yczogYWN0aXZlKVwiKS5tYXRjaGVzKSB7XG4gICAgICByZXR1cm4gcmdiO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgW25hbWUsIFJHQl0gb2YgdGhpcy5fY29sb3JzKSB7XG4gICAgICBpZiAoUkdCLmV2ZXJ5KCh4LCBpKSA9PiB4ID09PSByZ2JbaV0pKSB7XG4gICAgICAgIHJldHVybiBDb2xvck1hbmFnZXIuX2NvbG9yc01hcHBpbmcuZ2V0KG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZ2I7XG4gIH1cblxuICBnZXRIZXhDb2RlKG5hbWUpIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9jb2xvcnMuZ2V0KG5hbWUpO1xuXG4gICAgaWYgKCFyZ2IpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cblxuICAgIHJldHVybiBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi5yZ2IpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5Db2xvck1hbmFnZXIgPSBDb2xvck1hbmFnZXI7XG5cbmNsYXNzIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIge1xuICAjYWN0aXZlRWRpdG9yID0gbnVsbDtcbiAgI2FsbEVkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICNhbGxMYXllcnMgPSBuZXcgTWFwKCk7XG4gICNjbGlwYm9hcmRNYW5hZ2VyID0gbmV3IENsaXBib2FyZE1hbmFnZXIoKTtcbiAgI2NvbW1hbmRNYW5hZ2VyID0gbmV3IENvbW1hbmRNYW5hZ2VyKCk7XG4gICNjdXJyZW50UGFnZUluZGV4ID0gMDtcbiAgI2VkaXRvclR5cGVzID0gbnVsbDtcbiAgI2V2ZW50QnVzID0gbnVsbDtcbiAgI2lkTWFuYWdlciA9IG5ldyBJZE1hbmFnZXIoKTtcbiAgI2lzRW5hYmxlZCA9IGZhbHNlO1xuICAjbW9kZSA9IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU7XG4gICNzZWxlY3RlZEVkaXRvcnMgPSBuZXcgU2V0KCk7XG4gICNib3VuZEtleWRvd24gPSB0aGlzLmtleWRvd24uYmluZCh0aGlzKTtcbiAgI2JvdW5kT25FZGl0aW5nQWN0aW9uID0gdGhpcy5vbkVkaXRpbmdBY3Rpb24uYmluZCh0aGlzKTtcbiAgI2JvdW5kT25QYWdlQ2hhbmdpbmcgPSB0aGlzLm9uUGFnZUNoYW5naW5nLmJpbmQodGhpcyk7XG4gICNwcmV2aW91c1N0YXRlcyA9IHtcbiAgICBpc0VkaXRpbmc6IGZhbHNlLFxuICAgIGlzRW1wdHk6IHRydWUsXG4gICAgaGFzRW1wdHlDbGlwYm9hcmQ6IHRydWUsXG4gICAgaGFzU29tZXRoaW5nVG9VbmRvOiBmYWxzZSxcbiAgICBoYXNTb21ldGhpbmdUb1JlZG86IGZhbHNlLFxuICAgIGhhc1NlbGVjdGVkRWRpdG9yOiBmYWxzZVxuICB9O1xuICAjY29udGFpbmVyID0gbnVsbDtcbiAgc3RhdGljIF9rZXlib2FyZE1hbmFnZXIgPSBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiY3RybCthXCIsIFwibWFjK21ldGErYVwiXSwgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5wcm90b3R5cGUuc2VsZWN0QWxsXSwgW1tcImN0cmwrY1wiLCBcIm1hYyttZXRhK2NcIl0sIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIucHJvdG90eXBlLmNvcHldLCBbW1wiY3RybCt2XCIsIFwibWFjK21ldGErdlwiXSwgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5wcm90b3R5cGUucGFzdGVdLCBbW1wiY3RybCt4XCIsIFwibWFjK21ldGEreFwiXSwgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5wcm90b3R5cGUuY3V0XSwgW1tcImN0cmwrelwiLCBcIm1hYyttZXRhK3pcIl0sIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIucHJvdG90eXBlLnVuZG9dLCBbW1wiY3RybCt5XCIsIFwiY3RybCtzaGlmdCtaXCIsIFwibWFjK21ldGErc2hpZnQrWlwiXSwgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5wcm90b3R5cGUucmVkb10sIFtbXCJCYWNrc3BhY2VcIiwgXCJhbHQrQmFja3NwYWNlXCIsIFwiY3RybCtCYWNrc3BhY2VcIiwgXCJzaGlmdCtCYWNrc3BhY2VcIiwgXCJtYWMrQmFja3NwYWNlXCIsIFwibWFjK2FsdCtCYWNrc3BhY2VcIiwgXCJtYWMrY3RybCtCYWNrc3BhY2VcIiwgXCJEZWxldGVcIiwgXCJjdHJsK0RlbGV0ZVwiLCBcInNoaWZ0K0RlbGV0ZVwiXSwgQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5wcm90b3R5cGUuZGVsZXRlXSwgW1tcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIucHJvdG90eXBlLnVuc2VsZWN0QWxsXV0pO1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgZXZlbnRCdXMpIHtcbiAgICB0aGlzLiNjb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy4jZXZlbnRCdXMgPSBldmVudEJ1cztcblxuICAgIHRoaXMuI2V2ZW50QnVzLl9vbihcImVkaXRpbmdhY3Rpb25cIiwgdGhpcy4jYm91bmRPbkVkaXRpbmdBY3Rpb24pO1xuXG4gICAgdGhpcy4jZXZlbnRCdXMuX29uKFwicGFnZWNoYW5naW5nXCIsIHRoaXMuI2JvdW5kT25QYWdlQ2hhbmdpbmcpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLiNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKTtcblxuICAgIHRoaXMuI2V2ZW50QnVzLl9vZmYoXCJlZGl0aW5nYWN0aW9uXCIsIHRoaXMuI2JvdW5kT25FZGl0aW5nQWN0aW9uKTtcblxuICAgIHRoaXMuI2V2ZW50QnVzLl9vZmYoXCJwYWdlY2hhbmdpbmdcIiwgdGhpcy4jYm91bmRPblBhZ2VDaGFuZ2luZyk7XG5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgbGF5ZXIuZGVzdHJveSgpO1xuICAgIH1cblxuICAgIHRoaXMuI2FsbExheWVycy5jbGVhcigpO1xuICAgIHRoaXMuI2FsbEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3IgPSBudWxsO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2NsaXBib2FyZE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgfVxuXG4gIG9uUGFnZUNoYW5naW5nKHtcbiAgICBwYWdlTnVtYmVyXG4gIH0pIHtcbiAgICB0aGlzLiNjdXJyZW50UGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDE7XG4gIH1cblxuICBmb2N1c01haW5Db250YWluZXIoKSB7XG4gICAgdGhpcy4jY29udGFpbmVyLmZvY3VzKCk7XG4gIH1cblxuICAjYWRkS2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIHRoaXMuI2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLiNib3VuZEtleWRvd24pO1xuICB9XG5cbiAgI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpIHtcbiAgICB0aGlzLiNjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlkb3duKTtcbiAgfVxuXG4gIGtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZ2V0QWN0aXZlKCk/LnNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkpIHtcbiAgICAgIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICBvbkVkaXRpbmdBY3Rpb24oZGV0YWlscykge1xuICAgIGlmIChbXCJ1bmRvXCIsIFwicmVkb1wiLCBcImN1dFwiLCBcImNvcHlcIiwgXCJwYXN0ZVwiLCBcImRlbGV0ZVwiLCBcInNlbGVjdEFsbFwiXS5pbmNsdWRlcyhkZXRhaWxzLm5hbWUpKSB7XG4gICAgICB0aGlzW2RldGFpbHMubmFtZV0oKTtcbiAgICB9XG4gIH1cblxuICAjZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoZGV0YWlscykge1xuICAgIGNvbnN0IGhhc0NoYW5nZWQgPSBPYmplY3QuZW50cmllcyhkZXRhaWxzKS5zb21lKChba2V5LCB2YWx1ZV0pID0+IHRoaXMuI3ByZXZpb3VzU3RhdGVzW2tleV0gIT09IHZhbHVlKTtcblxuICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLiNldmVudEJ1cy5kaXNwYXRjaChcImFubm90YXRpb25lZGl0b3JzdGF0ZXNjaGFuZ2VkXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBkZXRhaWxzOiBPYmplY3QuYXNzaWduKHRoaXMuI3ByZXZpb3VzU3RhdGVzLCBkZXRhaWxzKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgI2Rpc3BhdGNoVXBkYXRlVUkoZGV0YWlscykge1xuICAgIHRoaXMuI2V2ZW50QnVzLmRpc3BhdGNoKFwiYW5ub3RhdGlvbmVkaXRvcnBhcmFtc2NoYW5nZWRcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZGV0YWlsc1xuICAgIH0pO1xuICB9XG5cbiAgc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZykge1xuICAgIGlmIChpc0VkaXRpbmcpIHtcbiAgICAgIHRoaXMuI2FkZEtleWJvYXJkTWFuYWdlcigpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBpc0VkaXRpbmc6IHRoaXMuI21vZGUgIT09IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUsXG4gICAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1JlZG8oKSxcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlLFxuICAgICAgICBoYXNFbXB0eUNsaXBib2FyZDogdGhpcy4jY2xpcGJvYXJkTWFuYWdlci5pc0VtcHR5KClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaXNFZGl0aW5nOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmVnaXN0ZXJFZGl0b3JUeXBlcyh0eXBlcykge1xuICAgIHRoaXMuI2VkaXRvclR5cGVzID0gdHlwZXM7XG5cbiAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yVHlwZS5kZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB9XG4gIH1cblxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jaWRNYW5hZ2VyLmdldElkKCk7XG4gIH1cblxuICBhZGRMYXllcihsYXllcikge1xuICAgIHRoaXMuI2FsbExheWVycy5zZXQobGF5ZXIucGFnZUluZGV4LCBsYXllcik7XG5cbiAgICBpZiAodGhpcy4jaXNFbmFibGVkKSB7XG4gICAgICBsYXllci5lbmFibGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGF5ZXIuZGlzYWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZUxheWVyKGxheWVyKSB7XG4gICAgdGhpcy4jYWxsTGF5ZXJzLmRlbGV0ZShsYXllci5wYWdlSW5kZXgpO1xuICB9XG5cbiAgdXBkYXRlTW9kZShtb2RlKSB7XG4gICAgdGhpcy4jbW9kZSA9IG1vZGU7XG5cbiAgICBpZiAobW9kZSA9PT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSkge1xuICAgICAgdGhpcy5zZXRFZGl0aW5nU3RhdGUoZmFsc2UpO1xuICAgICAgdGhpcy4jZGlzYWJsZUFsbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICAgIHRoaXMuI2VuYWJsZUFsbCgpO1xuXG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBsYXllci51cGRhdGVNb2RlKG1vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVRvb2xiYXIobW9kZSkge1xuICAgIGlmIChtb2RlID09PSB0aGlzLiNtb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy4jZXZlbnRCdXMuZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICBtb2RlXG4gICAgfSk7XG4gIH1cblxuICB1cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiB0aGlzLiNlZGl0b3JUeXBlcykge1xuICAgICAgZWRpdG9yVHlwZS51cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAjZW5hYmxlQWxsKCkge1xuICAgIGlmICghdGhpcy4jaXNFbmFibGVkKSB7XG4gICAgICB0aGlzLiNpc0VuYWJsZWQgPSB0cnVlO1xuXG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBsYXllci5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAjZGlzYWJsZUFsbCgpIHtcbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG5cbiAgICBpZiAodGhpcy4jaXNFbmFibGVkKSB7XG4gICAgICB0aGlzLiNpc0VuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldEVkaXRvcnMocGFnZUluZGV4KSB7XG4gICAgY29uc3QgZWRpdG9ycyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGVkaXRvci5wYWdlSW5kZXggPT09IHBhZ2VJbmRleCkge1xuICAgICAgICBlZGl0b3JzLnB1c2goZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWRpdG9ycztcbiAgfVxuXG4gIGdldEVkaXRvcihpZCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxFZGl0b3JzLmdldChpZCk7XG4gIH1cblxuICBhZGRFZGl0b3IoZWRpdG9yKSB7XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5zZXQoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICB9XG5cbiAgcmVtb3ZlRWRpdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2FsbEVkaXRvcnMuZGVsZXRlKGVkaXRvci5pZCk7XG4gICAgdGhpcy51bnNlbGVjdChlZGl0b3IpO1xuICB9XG5cbiAgI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKSB7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLiNhbGxMYXllcnMuZ2V0KGVkaXRvci5wYWdlSW5kZXgpO1xuXG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBsYXllci5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICB9XG4gIH1cblxuICBzZXRBY3RpdmVFZGl0b3IoZWRpdG9yKSB7XG4gICAgaWYgKHRoaXMuI2FjdGl2ZUVkaXRvciA9PT0gZWRpdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yID0gZWRpdG9yO1xuXG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB9XG4gIH1cblxuICB0b2dnbGVTZWxlY3RlZChlZGl0b3IpIHtcbiAgICBpZiAodGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmhhcyhlZGl0b3IpKSB7XG4gICAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuZGVsZXRlKGVkaXRvcik7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRoaXMuaGFzU2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHNldFNlbGVjdGVkKGVkaXRvcikge1xuICAgIGZvciAoY29uc3QgZWQgb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBpZiAoZWQgIT09IGVkaXRvcikge1xuICAgICAgICBlZC51bnNlbGVjdCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgaXNTZWxlY3RlZChlZGl0b3IpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmhhcyhlZGl0b3IpO1xuICB9XG5cbiAgdW5zZWxlY3QoZWRpdG9yKSB7XG4gICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmRlbGV0ZShlZGl0b3IpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0aGlzLmhhc1NlbGVjdGlvblxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGhhc1NlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLnNpemUgIT09IDA7XG4gIH1cblxuICB1bmRvKCkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLnVuZG8oKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvVW5kbygpLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0cnVlLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cblxuICByZWRvKCkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLnJlZG8oKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRydWUsXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvUmVkbygpLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cblxuICBhZGRDb21tYW5kcyhwYXJhbXMpIHtcbiAgICB0aGlzLiNjb21tYW5kTWFuYWdlci5hZGQocGFyYW1zKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRydWUsXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IGZhbHNlLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cblxuICAjaXNFbXB0eSgpIHtcbiAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5zaXplID09PSAxKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIHJldHVybiBlZGl0b3IuaXNFbXB0eSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGRlbGV0ZSgpIHtcbiAgICBpZiAodGhpcy4jYWN0aXZlRWRpdG9yKSB7XG4gICAgICB0aGlzLiNhY3RpdmVFZGl0b3IuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZWRpdG9ycyA9IFsuLi50aGlzLiNzZWxlY3RlZEVkaXRvcnNdO1xuXG4gICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgICBlZGl0b3IucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIHRoaXMuI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIGNvcHkoKSB7XG4gICAgaWYgKHRoaXMuI2FjdGl2ZUVkaXRvcikge1xuICAgICAgdGhpcy4jYWN0aXZlRWRpdG9yLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICBjb25zdCBlZGl0b3JzID0gW107XG5cbiAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgICBpZiAoIWVkaXRvci5pc0VtcHR5KCkpIHtcbiAgICAgICAgICBlZGl0b3JzLnB1c2goZWRpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZWRpdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiNjbGlwYm9hcmRNYW5hZ2VyLmNvcHkoZWRpdG9ycyk7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgIGhhc0VtcHR5Q2xpcGJvYXJkOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgY3V0KCkge1xuICAgIHRoaXMuY29weSgpO1xuICAgIHRoaXMuZGVsZXRlKCk7XG4gIH1cblxuICBwYXN0ZSgpIHtcbiAgICBpZiAodGhpcy4jY2xpcGJvYXJkTWFuYWdlci5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnVuc2VsZWN0QWxsKCk7XG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLiNhbGxMYXllcnMuZ2V0KHRoaXMuI2N1cnJlbnRQYWdlSW5kZXgpO1xuICAgIGNvbnN0IG5ld0VkaXRvcnMgPSB0aGlzLiNjbGlwYm9hcmRNYW5hZ2VyLnBhc3RlKCkubWFwKGRhdGEgPT4gbGF5ZXIuZGVzZXJpYWxpemUoZGF0YSkpO1xuXG4gICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgbmV3RWRpdG9ycykge1xuICAgICAgICB0aGlzLiNhZGRFZGl0b3JUb0xheWVyKGVkaXRvcik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuI3NlbGVjdEVkaXRvcnMobmV3RWRpdG9ycyk7XG4gICAgfTtcblxuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBuZXdFZGl0b3JzKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gICNzZWxlY3RFZGl0b3JzKGVkaXRvcnMpIHtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcblxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgfVxuXG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHNlbGVjdEFsbCgpIHtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci5jb21taXQoKTtcbiAgICB9XG5cbiAgICB0aGlzLiNzZWxlY3RFZGl0b3JzKHRoaXMuI2FsbEVkaXRvcnMudmFsdWVzKCkpO1xuICB9XG5cbiAgdW5zZWxlY3RBbGwoKSB7XG4gICAgaWYgKHRoaXMuI2FjdGl2ZUVkaXRvcikge1xuICAgICAgdGhpcy4jYWN0aXZlRWRpdG9yLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuI3NlbGVjdEVkaXRvcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgfVxuXG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICBpc0FjdGl2ZShlZGl0b3IpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yID09PSBlZGl0b3I7XG4gIH1cblxuICBnZXRBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvcjtcbiAgfVxuXG4gIGdldE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21vZGU7XG4gIH1cblxufVxuXG5leHBvcnRzLkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIgPSBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuU3RhdFRpbWVyID0gZXhwb3J0cy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gPSBleHBvcnRzLlBpeGVsc1BlckluY2ggPSBleHBvcnRzLlBhZ2VWaWV3cG9ydCA9IGV4cG9ydHMuUERGRGF0ZVN0cmluZyA9IGV4cG9ydHMuRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBleHBvcnRzLkRPTVNWR0ZhY3RvcnkgPSBleHBvcnRzLkRPTUNhbnZhc0ZhY3RvcnkgPSBleHBvcnRzLkRPTUNNYXBSZWFkZXJGYWN0b3J5ID0gZXhwb3J0cy5Bbm5vdGF0aW9uUHJlZml4ID0gdm9pZCAwO1xuZXhwb3J0cy5kZXByZWNhdGVkID0gZGVwcmVjYXRlZDtcbmV4cG9ydHMuZ2V0Q29sb3JWYWx1ZXMgPSBnZXRDb2xvclZhbHVlcztcbmV4cG9ydHMuZ2V0Q3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm07XG5leHBvcnRzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlID0gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2U7XG5leHBvcnRzLmdldEZpbGVuYW1lRnJvbVVybCA9IGdldEZpbGVuYW1lRnJvbVVybDtcbmV4cG9ydHMuZ2V0UGRmRmlsZW5hbWVGcm9tVXJsID0gZ2V0UGRmRmlsZW5hbWVGcm9tVXJsO1xuZXhwb3J0cy5nZXRSR0IgPSBnZXRSR0I7XG5leHBvcnRzLmdldFhmYVBhZ2VWaWV3cG9ydCA9IGdldFhmYVBhZ2VWaWV3cG9ydDtcbmV4cG9ydHMuaXNEYXRhU2NoZW1lID0gaXNEYXRhU2NoZW1lO1xuZXhwb3J0cy5pc1BkZkZpbGUgPSBpc1BkZkZpbGU7XG5leHBvcnRzLmlzVmFsaWRGZXRjaFVybCA9IGlzVmFsaWRGZXRjaFVybDtcbmV4cG9ydHMubG9hZFNjcmlwdCA9IGxvYWRTY3JpcHQ7XG5cbnZhciBfYmFzZV9mYWN0b3J5ID0gX193X3BkZmpzX3JlcXVpcmVfXyg5KTtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcblxuY29uc3QgU1ZHX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuY29uc3QgQW5ub3RhdGlvblByZWZpeCA9IFwicGRmanNfaW50ZXJuYWxfaWRfXCI7XG5leHBvcnRzLkFubm90YXRpb25QcmVmaXggPSBBbm5vdGF0aW9uUHJlZml4O1xuXG5jbGFzcyBQaXhlbHNQZXJJbmNoIHtcbiAgc3RhdGljIENTUyA9IDk2LjA7XG4gIHN0YXRpYyBQREYgPSA3Mi4wO1xuICBzdGF0aWMgUERGX1RPX0NTU19VTklUUyA9IHRoaXMuQ1NTIC8gdGhpcy5QREY7XG59XG5cbmV4cG9ydHMuUGl4ZWxzUGVySW5jaCA9IFBpeGVsc1BlckluY2g7XG5cbmNsYXNzIERPTUNhbnZhc0ZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VDYW52YXNGYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50XG4gIH0gPSB7fSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICB9XG5cbiAgX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblxuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIGNhbnZhcztcbiAgfVxuXG59XG5cbmV4cG9ydHMuRE9NQ2FudmFzRmFjdG9yeSA9IERPTUNhbnZhc0ZhY3Rvcnk7XG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSh1cmwsIGFzVHlwZWRBcnJheSA9IGZhbHNlKSB7XG4gIGlmIChpc1ZhbGlkRmV0Y2hVcmwodXJsLCBkb2N1bWVudC5iYXNlVVJJKSkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXNUeXBlZEFycmF5ID8gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKSkgOiAoMCwgX3V0aWwuc3RyaW5nVG9CeXRlcykoYXdhaXQgcmVzcG9uc2UudGV4dCgpKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB1cmwsIHRydWUpO1xuXG4gICAgaWYgKGFzVHlwZWRBcnJheSkge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDAgfHwgcmVxdWVzdC5zdGF0dXMgPT09IDApIHtcbiAgICAgICAgbGV0IGRhdGE7XG5cbiAgICAgICAgaWYgKGFzVHlwZWRBcnJheSAmJiByZXF1ZXN0LnJlc3BvbnNlKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCFhc1R5cGVkQXJyYXkgJiYgcmVxdWVzdC5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgICBkYXRhID0gKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICB9O1xuXG4gICAgcmVxdWVzdC5zZW5kKG51bGwpO1xuICB9KTtcbn1cblxuY2xhc3MgRE9NQ01hcFJlYWRlckZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIF9mZXRjaERhdGEodXJsLCBjb21wcmVzc2lvblR5cGUpIHtcbiAgICByZXR1cm4gZmV0Y2hEYXRhKHVybCwgdGhpcy5pc0NvbXByZXNzZWQpLnRoZW4oZGF0YSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjTWFwRGF0YTogZGF0YSxcbiAgICAgICAgY29tcHJlc3Npb25UeXBlXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbn1cblxuZXhwb3J0cy5ET01DTWFwUmVhZGVyRmFjdG9yeSA9IERPTUNNYXBSZWFkZXJGYWN0b3J5O1xuXG5jbGFzcyBET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnkuQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgX2ZldGNoRGF0YSh1cmwpIHtcbiAgICByZXR1cm4gZmV0Y2hEYXRhKHVybCwgdHJ1ZSk7XG4gIH1cblxufVxuXG5leHBvcnRzLkRPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gRE9NU3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG5cbmNsYXNzIERPTVNWR0ZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VTVkdGYWN0b3J5IHtcbiAgX2NyZWF0ZVNWRyh0eXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIHR5cGUpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5ET01TVkdGYWN0b3J5ID0gRE9NU1ZHRmFjdG9yeTtcblxuY2xhc3MgUGFnZVZpZXdwb3J0IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHZpZXdCb3gsXG4gICAgc2NhbGUsXG4gICAgcm90YXRpb24sXG4gICAgb2Zmc2V0WCA9IDAsXG4gICAgb2Zmc2V0WSA9IDAsXG4gICAgZG9udEZsaXAgPSBmYWxzZVxuICB9KSB7XG4gICAgdGhpcy52aWV3Qm94ID0gdmlld0JveDtcbiAgICB0aGlzLnNjYWxlID0gc2NhbGU7XG4gICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgIHRoaXMub2Zmc2V0WCA9IG9mZnNldFg7XG4gICAgdGhpcy5vZmZzZXRZID0gb2Zmc2V0WTtcbiAgICBjb25zdCBjZW50ZXJYID0gKHZpZXdCb3hbMl0gKyB2aWV3Qm94WzBdKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9ICh2aWV3Qm94WzNdICsgdmlld0JveFsxXSkgLyAyO1xuICAgIGxldCByb3RhdGVBLCByb3RhdGVCLCByb3RhdGVDLCByb3RhdGVEO1xuICAgIHJvdGF0aW9uICU9IDM2MDtcblxuICAgIGlmIChyb3RhdGlvbiA8IDApIHtcbiAgICAgIHJvdGF0aW9uICs9IDM2MDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcm90YXRlQSA9IC0xO1xuICAgICAgICByb3RhdGVCID0gMDtcbiAgICAgICAgcm90YXRlQyA9IDA7XG4gICAgICAgIHJvdGF0ZUQgPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcm90YXRlQSA9IDA7XG4gICAgICAgIHJvdGF0ZUIgPSAxO1xuICAgICAgICByb3RhdGVDID0gMTtcbiAgICAgICAgcm90YXRlRCA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcm90YXRlQSA9IDA7XG4gICAgICAgIHJvdGF0ZUIgPSAtMTtcbiAgICAgICAgcm90YXRlQyA9IC0xO1xuICAgICAgICByb3RhdGVEID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcm90YXRlQSA9IDE7XG4gICAgICAgIHJvdGF0ZUIgPSAwO1xuICAgICAgICByb3RhdGVDID0gMDtcbiAgICAgICAgcm90YXRlRCA9IC0xO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGFnZVZpZXdwb3J0OiBJbnZhbGlkIHJvdGF0aW9uLCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgOTAgZGVncmVlcy5cIik7XG4gICAgfVxuXG4gICAgaWYgKGRvbnRGbGlwKSB7XG4gICAgICByb3RhdGVDID0gLXJvdGF0ZUM7XG4gICAgICByb3RhdGVEID0gLXJvdGF0ZUQ7XG4gICAgfVxuXG4gICAgbGV0IG9mZnNldENhbnZhc1gsIG9mZnNldENhbnZhc1k7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG5cbiAgICBpZiAocm90YXRlQSA9PT0gMCkge1xuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclkgLSB2aWV3Qm94WzFdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgIG9mZnNldENhbnZhc1kgPSBNYXRoLmFicyhjZW50ZXJYIC0gdmlld0JveFswXSkgKiBzY2FsZSArIG9mZnNldFk7XG4gICAgICB3aWR0aCA9IE1hdGguYWJzKHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5hYnModmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJYIC0gdmlld0JveFswXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgd2lkdGggPSBNYXRoLmFicyh2aWV3Qm94WzJdIC0gdmlld0JveFswXSkgKiBzY2FsZTtcbiAgICAgIGhlaWdodCA9IE1hdGguYWJzKHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAqIHNjYWxlO1xuICAgIH1cblxuICAgIHRoaXMudHJhbnNmb3JtID0gW3JvdGF0ZUEgKiBzY2FsZSwgcm90YXRlQiAqIHNjYWxlLCByb3RhdGVDICogc2NhbGUsIHJvdGF0ZUQgKiBzY2FsZSwgb2Zmc2V0Q2FudmFzWCAtIHJvdGF0ZUEgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVDICogc2NhbGUgKiBjZW50ZXJZLCBvZmZzZXRDYW52YXNZIC0gcm90YXRlQiAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUQgKiBzY2FsZSAqIGNlbnRlclldO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuXG4gIGNsb25lKHtcbiAgICBzY2FsZSA9IHRoaXMuc2NhbGUsXG4gICAgcm90YXRpb24gPSB0aGlzLnJvdGF0aW9uLFxuICAgIG9mZnNldFggPSB0aGlzLm9mZnNldFgsXG4gICAgb2Zmc2V0WSA9IHRoaXMub2Zmc2V0WSxcbiAgICBkb250RmxpcCA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveC5zbGljZSgpLFxuICAgICAgc2NhbGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZG9udEZsaXBcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQoeCwgeSkge1xuICAgIHJldHVybiBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt4LCB5XSwgdGhpcy50cmFuc2Zvcm0pO1xuICB9XG5cbiAgY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUocmVjdCkge1xuICAgIGNvbnN0IHRvcExlZnQgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzBdLCByZWN0WzFdXSwgdGhpcy50cmFuc2Zvcm0pO1xuXG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzJdLCByZWN0WzNdXSwgdGhpcy50cmFuc2Zvcm0pO1xuXG4gICAgcmV0dXJuIFt0b3BMZWZ0WzBdLCB0b3BMZWZ0WzFdLCBib3R0b21SaWdodFswXSwgYm90dG9tUmlnaHRbMV1dO1xuICB9XG5cbiAgY29udmVydFRvUGRmUG9pbnQoeCwgeSkge1xuICAgIHJldHVybiBfdXRpbC5VdGlsLmFwcGx5SW52ZXJzZVRyYW5zZm9ybShbeCwgeV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuUGFnZVZpZXdwb3J0ID0gUGFnZVZpZXdwb3J0O1xuXG5jbGFzcyBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gZXh0ZW5kcyBfdXRpbC5CYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCB0eXBlKSB7XG4gICAgc3VwZXIobXNnLCBcIlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICB9XG5cbn1cblxuZXhwb3J0cy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gPSBSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb247XG5cbmZ1bmN0aW9uIGlzRGF0YVNjaGVtZSh1cmwpIHtcbiAgY29uc3QgaWkgPSB1cmwubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBpaSAmJiB1cmxbaV0udHJpbSgpID09PSBcIlwiKSB7XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoaSwgaSArIDUpLnRvTG93ZXJDYXNlKCkgPT09IFwiZGF0YTpcIjtcbn1cblxuZnVuY3Rpb24gaXNQZGZGaWxlKGZpbGVuYW1lKSB7XG4gIHJldHVybiB0eXBlb2YgZmlsZW5hbWUgPT09IFwic3RyaW5nXCIgJiYgL1xcLnBkZiQvaS50ZXN0KGZpbGVuYW1lKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tVXJsKHVybCkge1xuICBjb25zdCBhbmNob3IgPSB1cmwuaW5kZXhPZihcIiNcIik7XG4gIGNvbnN0IHF1ZXJ5ID0gdXJsLmluZGV4T2YoXCI/XCIpO1xuICBjb25zdCBlbmQgPSBNYXRoLm1pbihhbmNob3IgPiAwID8gYW5jaG9yIDogdXJsLmxlbmd0aCwgcXVlcnkgPiAwID8gcXVlcnkgOiB1cmwubGVuZ3RoKTtcbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcodXJsLmxhc3RJbmRleE9mKFwiL1wiLCBlbmQpICsgMSwgZW5kKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGRmRmlsZW5hbWVGcm9tVXJsKHVybCwgZGVmYXVsdEZpbGVuYW1lID0gXCJkb2N1bWVudC5wZGZcIikge1xuICBpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG4gIH1cblxuICBpZiAoaXNEYXRhU2NoZW1lKHVybCkpIHtcbiAgICAoMCwgX3V0aWwud2FybikoJ2dldFBkZkZpbGVuYW1lRnJvbVVybDogaWdub3JlIFwiZGF0YTpcIi1VUkwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuJyk7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbiAgfVxuXG4gIGNvbnN0IHJlVVJJID0gL14oPzooPzpbXjpdKzopP1xcL1xcL1teL10rKT8oW14/I10qKShcXD9bXiNdKik/KCMuKik/JC87XG4gIGNvbnN0IHJlRmlsZW5hbWUgPSAvW14vPyM9XStcXC5wZGZcXGIoPyEuKlxcLnBkZlxcYikvaTtcbiAgY29uc3Qgc3BsaXRVUkkgPSByZVVSSS5leGVjKHVybCk7XG4gIGxldCBzdWdnZXN0ZWRGaWxlbmFtZSA9IHJlRmlsZW5hbWUuZXhlYyhzcGxpdFVSSVsxXSkgfHwgcmVGaWxlbmFtZS5leGVjKHNwbGl0VVJJWzJdKSB8fCByZUZpbGVuYW1lLmV4ZWMoc3BsaXRVUklbM10pO1xuXG4gIGlmIChzdWdnZXN0ZWRGaWxlbmFtZSkge1xuICAgIHN1Z2dlc3RlZEZpbGVuYW1lID0gc3VnZ2VzdGVkRmlsZW5hbWVbMF07XG5cbiAgICBpZiAoc3VnZ2VzdGVkRmlsZW5hbWUuaW5jbHVkZXMoXCIlXCIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdWdnZXN0ZWRGaWxlbmFtZSA9IHJlRmlsZW5hbWUuZXhlYyhkZWNvZGVVUklDb21wb25lbnQoc3VnZ2VzdGVkRmlsZW5hbWUpKVswXTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7fVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWdnZXN0ZWRGaWxlbmFtZSB8fCBkZWZhdWx0RmlsZW5hbWU7XG59XG5cbmNsYXNzIFN0YXRUaW1lciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhcnRlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy50aW1lcyA9IFtdO1xuICB9XG5cbiAgdGltZShuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4gdGhpcy5zdGFydGVkKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYFRpbWVyIGlzIGFscmVhZHkgcnVubmluZyBmb3IgJHtuYW1lfWApO1xuICAgIH1cblxuICAgIHRoaXMuc3RhcnRlZFtuYW1lXSA9IERhdGUubm93KCk7XG4gIH1cblxuICB0aW1lRW5kKG5hbWUpIHtcbiAgICBpZiAoIShuYW1lIGluIHRoaXMuc3RhcnRlZCkpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShgVGltZXIgaGFzIG5vdCBiZWVuIHN0YXJ0ZWQgZm9yICR7bmFtZX1gKTtcbiAgICB9XG5cbiAgICB0aGlzLnRpbWVzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ZWRbbmFtZV0sXG4gICAgICBlbmQ6IERhdGUubm93KClcbiAgICB9KTtcbiAgICBkZWxldGUgdGhpcy5zdGFydGVkW25hbWVdO1xuICB9XG5cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3Qgb3V0QnVmID0gW107XG4gICAgbGV0IGxvbmdlc3QgPSAwO1xuXG4gICAgZm9yIChjb25zdCB0aW1lIG9mIHRoaXMudGltZXMpIHtcbiAgICAgIGNvbnN0IG5hbWUgPSB0aW1lLm5hbWU7XG5cbiAgICAgIGlmIChuYW1lLmxlbmd0aCA+IGxvbmdlc3QpIHtcbiAgICAgICAgbG9uZ2VzdCA9IG5hbWUubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgdGltZSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IHRpbWUuZW5kIC0gdGltZS5zdGFydDtcbiAgICAgIG91dEJ1Zi5wdXNoKGAke3RpbWUubmFtZS5wYWRFbmQobG9uZ2VzdCl9ICR7ZHVyYXRpb259bXNcXG5gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0QnVmLmpvaW4oXCJcIik7XG4gIH1cblxufVxuXG5leHBvcnRzLlN0YXRUaW1lciA9IFN0YXRUaW1lcjtcblxuZnVuY3Rpb24gaXNWYWxpZEZldGNoVXJsKHVybCwgYmFzZVVybCkge1xuICB0cnkge1xuICAgIGNvbnN0IHtcbiAgICAgIHByb3RvY29sXG4gICAgfSA9IGJhc2VVcmwgPyBuZXcgVVJMKHVybCwgYmFzZVVybCkgOiBuZXcgVVJMKHVybCk7XG4gICAgcmV0dXJuIHByb3RvY29sID09PSBcImh0dHA6XCIgfHwgcHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxvYWRTY3JpcHQoc3JjLCByZW1vdmVTY3JpcHRFbGVtZW50ID0gZmFsc2UpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgIHNjcmlwdC5zcmMgPSBzcmM7XG5cbiAgICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgaWYgKHJlbW92ZVNjcmlwdEVsZW1lbnQpIHtcbiAgICAgICAgc2NyaXB0LnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICByZXNvbHZlKGV2dCk7XG4gICAgfTtcblxuICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQ2Fubm90IGxvYWQgc2NyaXB0IGF0OiAke3NjcmlwdC5zcmN9YCkpO1xuICAgIH07XG5cbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmFwcGVuZChzY3JpcHQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChkZXRhaWxzKSB7XG4gIGNvbnNvbGUubG9nKFwiRGVwcmVjYXRlZCBBUEkgdXNhZ2U6IFwiICsgZGV0YWlscyk7XG59XG5cbmxldCBwZGZEYXRlU3RyaW5nUmVnZXg7XG5cbmNsYXNzIFBERkRhdGVTdHJpbmcge1xuICBzdGF0aWMgdG9EYXRlT2JqZWN0KGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghcGRmRGF0ZVN0cmluZ1JlZ2V4KSB7XG4gICAgICBwZGZEYXRlU3RyaW5nUmVnZXggPSBuZXcgUmVnRXhwKFwiXkQ6XCIgKyBcIihcXFxcZHs0fSlcIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFtafCt8LV0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCInP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCInP1wiKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaGVzID0gcGRmRGF0ZVN0cmluZ1JlZ2V4LmV4ZWMoaW5wdXQpO1xuXG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCB5ZWFyID0gcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApO1xuICAgIGxldCBtb250aCA9IHBhcnNlSW50KG1hdGNoZXNbMl0sIDEwKTtcbiAgICBtb250aCA9IG1vbnRoID49IDEgJiYgbW9udGggPD0gMTIgPyBtb250aCAtIDEgOiAwO1xuICAgIGxldCBkYXkgPSBwYXJzZUludChtYXRjaGVzWzNdLCAxMCk7XG4gICAgZGF5ID0gZGF5ID49IDEgJiYgZGF5IDw9IDMxID8gZGF5IDogMTtcbiAgICBsZXQgaG91ciA9IHBhcnNlSW50KG1hdGNoZXNbNF0sIDEwKTtcbiAgICBob3VyID0gaG91ciA+PSAwICYmIGhvdXIgPD0gMjMgPyBob3VyIDogMDtcbiAgICBsZXQgbWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApO1xuICAgIG1pbnV0ZSA9IG1pbnV0ZSA+PSAwICYmIG1pbnV0ZSA8PSA1OSA/IG1pbnV0ZSA6IDA7XG4gICAgbGV0IHNlY29uZCA9IHBhcnNlSW50KG1hdGNoZXNbNl0sIDEwKTtcbiAgICBzZWNvbmQgPSBzZWNvbmQgPj0gMCAmJiBzZWNvbmQgPD0gNTkgPyBzZWNvbmQgOiAwO1xuICAgIGNvbnN0IHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9IG1hdGNoZXNbN10gfHwgXCJaXCI7XG4gICAgbGV0IG9mZnNldEhvdXIgPSBwYXJzZUludChtYXRjaGVzWzhdLCAxMCk7XG4gICAgb2Zmc2V0SG91ciA9IG9mZnNldEhvdXIgPj0gMCAmJiBvZmZzZXRIb3VyIDw9IDIzID8gb2Zmc2V0SG91ciA6IDA7XG4gICAgbGV0IG9mZnNldE1pbnV0ZSA9IHBhcnNlSW50KG1hdGNoZXNbOV0sIDEwKSB8fCAwO1xuICAgIG9mZnNldE1pbnV0ZSA9IG9mZnNldE1pbnV0ZSA+PSAwICYmIG9mZnNldE1pbnV0ZSA8PSA1OSA/IG9mZnNldE1pbnV0ZSA6IDA7XG5cbiAgICBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIi1cIikge1xuICAgICAgaG91ciArPSBvZmZzZXRIb3VyO1xuICAgICAgbWludXRlICs9IG9mZnNldE1pbnV0ZTtcbiAgICB9IGVsc2UgaWYgKHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9PT0gXCIrXCIpIHtcbiAgICAgIGhvdXIgLT0gb2Zmc2V0SG91cjtcbiAgICAgIG1pbnV0ZSAtPSBvZmZzZXRNaW51dGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kKSk7XG4gIH1cblxufVxuXG5leHBvcnRzLlBERkRhdGVTdHJpbmcgPSBQREZEYXRlU3RyaW5nO1xuXG5mdW5jdGlvbiBnZXRYZmFQYWdlVmlld3BvcnQoeGZhUGFnZSwge1xuICBzY2FsZSA9IDEsXG4gIHJvdGF0aW9uID0gMFxufSkge1xuICBjb25zdCB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0XG4gIH0gPSB4ZmFQYWdlLmF0dHJpYnV0ZXMuc3R5bGU7XG4gIGNvbnN0IHZpZXdCb3ggPSBbMCwgMCwgcGFyc2VJbnQod2lkdGgpLCBwYXJzZUludChoZWlnaHQpXTtcbiAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgIHZpZXdCb3gsXG4gICAgc2NhbGUsXG4gICAgcm90YXRpb25cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFJHQihjb2xvcikge1xuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBjb25zdCBjb2xvclJHQiA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLCAxNik7XG4gICAgcmV0dXJuIFsoY29sb3JSR0IgJiAweGZmMDAwMCkgPj4gMTYsIChjb2xvclJHQiAmIDB4MDBmZjAwKSA+PiA4LCBjb2xvclJHQiAmIDB4MDAwMGZmXTtcbiAgfVxuXG4gIGlmIChjb2xvci5zdGFydHNXaXRoKFwicmdiKFwiKSkge1xuICAgIHJldHVybiBjb2xvci5zbGljZSg0LCAtMSkuc3BsaXQoXCIsXCIpLm1hcCh4ID0+IHBhcnNlSW50KHgpKTtcbiAgfVxuXG4gIGlmIChjb2xvci5zdGFydHNXaXRoKFwicmdiYShcIikpIHtcbiAgICByZXR1cm4gY29sb3Iuc2xpY2UoNSwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoeCA9PiBwYXJzZUludCh4KSkuc2xpY2UoMCwgMyk7XG4gIH1cblxuICAoMCwgX3V0aWwud2FybikoYE5vdCBhIHZhbGlkIGNvbG9yIGZvcm1hdDogXCIke2NvbG9yfVwiYCk7XG4gIHJldHVybiBbMCwgMCwgMF07XG59XG5cbmZ1bmN0aW9uIGdldENvbG9yVmFsdWVzKGNvbG9ycykge1xuICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gIHNwYW4uc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kKHNwYW4pO1xuXG4gIGZvciAoY29uc3QgbmFtZSBvZiBjb2xvcnMua2V5cygpKSB7XG4gICAgc3Bhbi5zdHlsZS5jb2xvciA9IG5hbWU7XG4gICAgY29uc3QgY29tcHV0ZWRDb2xvciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNwYW4pLmNvbG9yO1xuICAgIGNvbG9ycy5zZXQobmFtZSwgZ2V0UkdCKGNvbXB1dGVkQ29sb3IpKTtcbiAgfVxuXG4gIHNwYW4ucmVtb3ZlKCk7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm0oY3R4KSB7XG4gIGNvbnN0IHtcbiAgICBhLFxuICAgIGIsXG4gICAgYyxcbiAgICBkLFxuICAgIGUsXG4gICAgZlxuICB9ID0gY3R4LmdldFRyYW5zZm9ybSgpO1xuICByZXR1cm4gW2EsIGIsIGMsIGQsIGUsIGZdO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZShjdHgpIHtcbiAgY29uc3Qge1xuICAgIGEsXG4gICAgYixcbiAgICBjLFxuICAgIGQsXG4gICAgZSxcbiAgICBmXG4gIH0gPSBjdHguZ2V0VHJhbnNmb3JtKCkuaW52ZXJ0U2VsZigpO1xuICByZXR1cm4gW2EsIGIsIGMsIGQsIGUsIGZdO1xufVxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gZXhwb3J0cy5CYXNlU1ZHRmFjdG9yeSA9IGV4cG9ydHMuQmFzZUNhbnZhc0ZhY3RvcnkgPSBleHBvcnRzLkJhc2VDTWFwUmVhZGVyRmFjdG9yeSA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcblxuY2xhc3MgQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUNhbnZhc0ZhY3RvcnkpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlQ2FudmFzRmFjdG9yeS5cIik7XG4gICAgfVxuICB9XG5cbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzLFxuICAgICAgY29udGV4dDogY2FudmFzLmdldENvbnRleHQoXCIyZFwiKVxuICAgIH07XG4gIH1cblxuICByZXNldChjYW52YXNBbmRDb250ZXh0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgfVxuXG4gICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2FudmFzIHNpemVcIik7XG4gICAgfVxuXG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cblxuICBkZXN0cm95KGNhbnZhc0FuZENvbnRleHQpIHtcbiAgICBpZiAoIWNhbnZhc0FuZENvbnRleHQuY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICB9XG5cbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy53aWR0aCA9IDA7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcyA9IG51bGw7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jb250ZXh0ID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVDYW52YXNgIGNhbGxlZC5cIik7XG4gIH1cblxufVxuXG5leHBvcnRzLkJhc2VDYW52YXNGYWN0b3J5ID0gQmFzZUNhbnZhc0ZhY3Rvcnk7XG5cbmNsYXNzIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVXJsID0gbnVsbCxcbiAgICBpc0NvbXByZXNzZWQgPSBmYWxzZVxuICB9KSB7XG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VDTWFwUmVhZGVyRmFjdG9yeSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VDTWFwUmVhZGVyRmFjdG9yeS5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICB0aGlzLmlzQ29tcHJlc3NlZCA9IGlzQ29tcHJlc3NlZDtcbiAgfVxuXG4gIGFzeW5jIGZldGNoKHtcbiAgICBuYW1lXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuYmFzZVVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgQ01hcCBcImJhc2VVcmxcIiBwYXJhbWV0ZXIgbXVzdCBiZSBzcGVjaWZpZWQsIGVuc3VyZSB0aGF0ICcgKyAndGhlIFwiY01hcFVybFwiIGFuZCBcImNNYXBQYWNrZWRcIiBBUEkgcGFyYW1ldGVycyBhcmUgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDTWFwIG5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHVybCA9IHRoaXMuYmFzZVVybCArIG5hbWUgKyAodGhpcy5pc0NvbXByZXNzZWQgPyBcIi5iY21hcFwiIDogXCJcIik7XG4gICAgY29uc3QgY29tcHJlc3Npb25UeXBlID0gdGhpcy5pc0NvbXByZXNzZWQgPyBfdXRpbC5DTWFwQ29tcHJlc3Npb25UeXBlLkJJTkFSWSA6IF91dGlsLkNNYXBDb21wcmVzc2lvblR5cGUuTk9ORTtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCAke3RoaXMuaXNDb21wcmVzc2VkID8gXCJiaW5hcnkgXCIgOiBcIlwifUNNYXAgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG5cbiAgX2ZldGNoRGF0YSh1cmwsIGNvbXByZXNzaW9uVHlwZSkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYF9mZXRjaERhdGFgIGNhbGxlZC5cIik7XG4gIH1cblxufVxuXG5leHBvcnRzLkJhc2VDTWFwUmVhZGVyRmFjdG9yeSA9IEJhc2VDTWFwUmVhZGVyRmFjdG9yeTtcblxuY2xhc3MgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGJhc2VVcmwgPSBudWxsXG4gIH0pIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5KSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5LlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB9XG5cbiAgYXN5bmMgZmV0Y2goe1xuICAgIGZpbGVuYW1lXG4gIH0pIHtcbiAgICBpZiAoIXRoaXMuYmFzZVVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3RhbmRhcmQgZm9udCBcImJhc2VVcmxcIiBwYXJhbWV0ZXIgbXVzdCBiZSBzcGVjaWZpZWQsIGVuc3VyZSB0aGF0ICcgKyAndGhlIFwic3RhbmRhcmRGb250RGF0YVVybFwiIEFQSSBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFmaWxlbmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRm9udCBmaWxlbmFtZSBtdXN0IGJlIHNwZWNpZmllZC5cIik7XG4gICAgfVxuXG4gICAgY29uc3QgdXJsID0gYCR7dGhpcy5iYXNlVXJsfSR7ZmlsZW5hbWV9YDtcbiAgICByZXR1cm4gdGhpcy5fZmV0Y2hEYXRhKHVybCkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxvYWQgZm9udCBkYXRhIGF0OiAke3VybH1gKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9mZXRjaERhdGEodXJsKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoRGF0YWAgY2FsbGVkLlwiKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5O1xuXG5jbGFzcyBCYXNlU1ZHRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlU1ZHRmFjdG9yeSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VTVkdGYWN0b3J5LlwiKTtcbiAgICB9XG4gIH1cblxuICBjcmVhdGUod2lkdGgsIGhlaWdodCwgc2tpcERpbWVuc2lvbnMgPSBmYWxzZSkge1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBkaW1lbnNpb25zXCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHN2ZyA9IHRoaXMuX2NyZWF0ZVNWRyhcInN2ZzpzdmdcIik7XG5cbiAgICBzdmcuc2V0QXR0cmlidXRlKFwidmVyc2lvblwiLCBcIjEuMVwiKTtcblxuICAgIGlmICghc2tpcERpbWVuc2lvbnMpIHtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBgJHt3aWR0aH1weGApO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBgJHtoZWlnaHR9cHhgKTtcbiAgICB9XG5cbiAgICBzdmcuc2V0QXR0cmlidXRlKFwicHJlc2VydmVBc3BlY3RSYXRpb1wiLCBcIm5vbmVcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgYDAgMCAke3dpZHRofSAke2hlaWdodH1gKTtcbiAgICByZXR1cm4gc3ZnO1xuICB9XG5cbiAgY3JlYXRlRWxlbWVudCh0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBlbGVtZW50IHR5cGVcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVNWRyh0eXBlKTtcbiAgfVxuXG4gIF9jcmVhdGVTVkcodHlwZSkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYF9jcmVhdGVTVkdgIGNhbGxlZC5cIik7XG4gIH1cblxufVxuXG5leHBvcnRzLkJhc2VTVkdGYWN0b3J5ID0gQmFzZVNWR0ZhY3Rvcnk7XG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuTXVybXVySGFzaDNfNjQgPSB2b2lkIDA7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5cbmNvbnN0IFNFRUQgPSAweGMzZDJlMWYwO1xuY29uc3QgTUFTS19ISUdIID0gMHhmZmZmMDAwMDtcbmNvbnN0IE1BU0tfTE9XID0gMHhmZmZmO1xuXG5jbGFzcyBNdXJtdXJIYXNoM182NCB7XG4gIGNvbnN0cnVjdG9yKHNlZWQpIHtcbiAgICB0aGlzLmgxID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgICB0aGlzLmgyID0gc2VlZCA/IHNlZWQgJiAweGZmZmZmZmZmIDogU0VFRDtcbiAgfVxuXG4gIHVwZGF0ZShpbnB1dCkge1xuICAgIGxldCBkYXRhLCBsZW5ndGg7XG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoICogMik7XG4gICAgICBsZW5ndGggPSAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBpbnB1dC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICAgIGlmIChjb2RlIDw9IDB4ZmYpIHtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlID4+PiA4O1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKShpbnB1dCkpIHtcbiAgICAgIGRhdGEgPSBpbnB1dC5zbGljZSgpO1xuICAgICAgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXcm9uZyBkYXRhIGZvcm1hdCBpbiBNdXJtdXJIYXNoM182NF91cGRhdGUuIFwiICsgXCJJbnB1dCBtdXN0IGJlIGEgc3RyaW5nIG9yIGFycmF5LlwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBibG9ja0NvdW50cyA9IGxlbmd0aCA+PiAyO1xuICAgIGNvbnN0IHRhaWxMZW5ndGggPSBsZW5ndGggLSBibG9ja0NvdW50cyAqIDQ7XG4gICAgY29uc3QgZGF0YVVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShkYXRhLmJ1ZmZlciwgMCwgYmxvY2tDb3VudHMpO1xuICAgIGxldCBrMSA9IDAsXG4gICAgICAgIGsyID0gMDtcbiAgICBsZXQgaDEgPSB0aGlzLmgxLFxuICAgICAgICBoMiA9IHRoaXMuaDI7XG4gICAgY29uc3QgQzEgPSAweGNjOWUyZDUxLFxuICAgICAgICAgIEMyID0gMHgxYjg3MzU5MztcbiAgICBjb25zdCBDMV9MT1cgPSBDMSAmIE1BU0tfTE9XLFxuICAgICAgICAgIEMyX0xPVyA9IEMyICYgTUFTS19MT1c7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrQ291bnRzOyBpKyspIHtcbiAgICAgIGlmIChpICYgMSkge1xuICAgICAgICBrMSA9IGRhdGFVaW50MzJbaV07XG4gICAgICAgIGsxID0gazEgKiBDMSAmIE1BU0tfSElHSCB8IGsxICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsxID0gazEgPDwgMTUgfCBrMSA+Pj4gMTc7XG4gICAgICAgIGsxID0gazEgKiBDMiAmIE1BU0tfSElHSCB8IGsxICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGgxIF49IGsxO1xuICAgICAgICBoMSA9IGgxIDw8IDEzIHwgaDEgPj4+IDE5O1xuICAgICAgICBoMSA9IGgxICogNSArIDB4ZTY1NDZiNjQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrMiA9IGRhdGFVaW50MzJbaV07XG4gICAgICAgIGsyID0gazIgKiBDMSAmIE1BU0tfSElHSCB8IGsyICogQzFfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGsyID0gazIgPDwgMTUgfCBrMiA+Pj4gMTc7XG4gICAgICAgIGsyID0gazIgKiBDMiAmIE1BU0tfSElHSCB8IGsyICogQzJfTE9XICYgTUFTS19MT1c7XG4gICAgICAgIGgyIF49IGsyO1xuICAgICAgICBoMiA9IGgyIDw8IDEzIHwgaDIgPj4+IDE5O1xuICAgICAgICBoMiA9IGgyICogNSArIDB4ZTY1NDZiNjQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgazEgPSAwO1xuXG4gICAgc3dpdGNoICh0YWlsTGVuZ3RoKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0ICsgMl0gPDwgMTY7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDQgKyAxXSA8PCA4O1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0XTtcbiAgICAgICAgazEgPSBrMSAqIEMxICYgTUFTS19ISUdIIHwgazEgKiBDMV9MT1cgJiBNQVNLX0xPVztcbiAgICAgICAgazEgPSBrMSA8PCAxNSB8IGsxID4+PiAxNztcbiAgICAgICAgazEgPSBrMSAqIEMyICYgTUFTS19ISUdIIHwgazEgKiBDMl9MT1cgJiBNQVNLX0xPVztcblxuICAgICAgICBpZiAoYmxvY2tDb3VudHMgJiAxKSB7XG4gICAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaDIgXj0gazE7XG4gICAgICAgIH1cblxuICAgIH1cblxuICAgIHRoaXMuaDEgPSBoMTtcbiAgICB0aGlzLmgyID0gaDI7XG4gIH1cblxuICBoZXhkaWdlc3QoKSB7XG4gICAgbGV0IGgxID0gdGhpcy5oMSxcbiAgICAgICAgaDIgPSB0aGlzLmgyO1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIGgxID0gaDEgKiAweGVkNTU4Y2NkICYgTUFTS19ISUdIIHwgaDEgKiAweDhjY2QgJiBNQVNLX0xPVztcbiAgICBoMiA9IGgyICogMHhmZjUxYWZkNyAmIE1BU0tfSElHSCB8ICgoaDIgPDwgMTYgfCBoMSA+Pj4gMTYpICogMHhhZmQ3ZWQ1NSAmIE1BU0tfSElHSCkgPj4+IDE2O1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIGgxID0gaDEgKiAweDFhODVlYzUzICYgTUFTS19ISUdIIHwgaDEgKiAweGVjNTMgJiBNQVNLX0xPVztcbiAgICBoMiA9IGgyICogMHhjNGNlYjlmZSAmIE1BU0tfSElHSCB8ICgoaDIgPDwgMTYgfCBoMSA+Pj4gMTYpICogMHhiOWZlMWE4NSAmIE1BU0tfSElHSCkgPj4+IDE2O1xuICAgIGgxIF49IGgyID4+PiAxO1xuICAgIGNvbnN0IGhleDEgPSAoaDEgPj4+IDApLnRvU3RyaW5nKDE2KSxcbiAgICAgICAgICBoZXgyID0gKGgyID4+PiAwKS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleDEucGFkU3RhcnQoOCwgXCIwXCIpICsgaGV4Mi5wYWRTdGFydCg4LCBcIjBcIik7XG4gIH1cblxufVxuXG5leHBvcnRzLk11cm11ckhhc2gzXzY0ID0gTXVybXVySGFzaDNfNjQ7XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuRm9udExvYWRlciA9IGV4cG9ydHMuRm9udEZhY2VPYmplY3QgPSB2b2lkIDA7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5cbmNsYXNzIEJhc2VGb250TG9hZGVyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGRvY0lkLFxuICAgIG9uVW5zdXBwb3J0ZWRGZWF0dXJlLFxuICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50LFxuICAgIHN0eWxlRWxlbWVudCA9IG51bGxcbiAgfSkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlRm9udExvYWRlcikge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VGb250TG9hZGVyLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmRvY0lkID0gZG9jSWQ7XG4gICAgdGhpcy5fb25VbnN1cHBvcnRlZEZlYXR1cmUgPSBvblVuc3VwcG9ydGVkRmVhdHVyZTtcbiAgICB0aGlzLl9kb2N1bWVudCA9IG93bmVyRG9jdW1lbnQ7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMgPSBbXTtcbiAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gIH1cblxuICBhZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSkge1xuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLnB1c2gobmF0aXZlRm9udEZhY2UpO1xuXG4gICAgdGhpcy5fZG9jdW1lbnQuZm9udHMuYWRkKG5hdGl2ZUZvbnRGYWNlKTtcbiAgfVxuXG4gIGluc2VydFJ1bGUocnVsZSkge1xuICAgIGxldCBzdHlsZUVsZW1lbnQgPSB0aGlzLnN0eWxlRWxlbWVudDtcblxuICAgIGlmICghc3R5bGVFbGVtZW50KSB7XG4gICAgICBzdHlsZUVsZW1lbnQgPSB0aGlzLnN0eWxlRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIHN0eWxlRWxlbWVudC5pZCA9IGBQREZKU19GT05UX1NUWUxFX1RBR18ke3RoaXMuZG9jSWR9YDtcblxuICAgICAgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG5cbiAgICBjb25zdCBzdHlsZVNoZWV0ID0gc3R5bGVFbGVtZW50LnNoZWV0O1xuICAgIHN0eWxlU2hlZXQuaW5zZXJ0UnVsZShydWxlLCBzdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gIH1cblxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IG5hdGl2ZUZvbnRGYWNlIG9mIHRoaXMubmF0aXZlRm9udEZhY2VzKSB7XG4gICAgICB0aGlzLl9kb2N1bWVudC5mb250cy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICAgIH1cblxuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAodGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGJpbmQoZm9udCkge1xuICAgIGlmIChmb250LmF0dGFjaGVkIHx8IGZvbnQubWlzc2luZ0ZpbGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb250LmF0dGFjaGVkID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLmlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUZvbnRGYWNlID0gZm9udC5jcmVhdGVOYXRpdmVGb250RmFjZSgpO1xuXG4gICAgICBpZiAobmF0aXZlRm9udEZhY2UpIHtcbiAgICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCBuYXRpdmVGb250RmFjZS5sb2FkZWQ7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgdGhpcy5fb25VbnN1cHBvcnRlZEZlYXR1cmUoe1xuICAgICAgICAgICAgZmVhdHVyZUlkOiBfdXRpbC5VTlNVUFBPUlRFRF9GRUFUVVJFUy5lcnJvckZvbnRMb2FkTmF0aXZlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoYEZhaWxlZCB0byBsb2FkIGZvbnQgJyR7bmF0aXZlRm9udEZhY2UuZmFtaWx5fSc6ICcke2V4fScuYCk7XG4gICAgICAgICAgZm9udC5kaXNhYmxlRm9udEZhY2UgPSB0cnVlO1xuICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBydWxlID0gZm9udC5jcmVhdGVGb250RmFjZVJ1bGUoKTtcblxuICAgIGlmIChydWxlKSB7XG4gICAgICB0aGlzLmluc2VydFJ1bGUocnVsZSk7XG5cbiAgICAgIGlmICh0aGlzLmlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB0aGlzLl9xdWV1ZUxvYWRpbmdDYWxsYmFjayhyZXNvbHZlKTtcblxuICAgICAgICB0aGlzLl9wcmVwYXJlRm9udExvYWRFdmVudChbcnVsZV0sIFtmb250XSwgcmVxdWVzdCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfcXVldWVMb2FkaW5nQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBfcXVldWVMb2FkaW5nQ2FsbGJhY2tgLlwiKTtcbiAgfVxuXG4gIGdldCBpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKCkge1xuICAgIGNvbnN0IGhhc0ZvbnRzID0gISF0aGlzLl9kb2N1bWVudD8uZm9udHM7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZFwiLCBoYXNGb250cyk7XG4gIH1cblxuICBnZXQgaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWQoKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWRgLlwiKTtcbiAgfVxuXG4gIGdldCBfbG9hZFRlc3RGb250KCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYF9sb2FkVGVzdEZvbnRgLlwiKTtcbiAgfVxuXG4gIF9wcmVwYXJlRm9udExvYWRFdmVudChydWxlcywgZm9udHNUb0xvYWQsIHJlcXVlc3QpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBfcHJlcGFyZUZvbnRMb2FkRXZlbnRgLlwiKTtcbiAgfVxuXG59XG5cbmxldCBGb250TG9hZGVyO1xuZXhwb3J0cy5Gb250TG9hZGVyID0gRm9udExvYWRlcjtcbntcbiAgZXhwb3J0cy5Gb250TG9hZGVyID0gRm9udExvYWRlciA9IGNsYXNzIEdlbmVyaWNGb250TG9hZGVyIGV4dGVuZHMgQmFzZUZvbnRMb2FkZXIge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgc3VwZXIocGFyYW1zKTtcbiAgICAgIHRoaXMubG9hZGluZ0NvbnRleHQgPSB7XG4gICAgICAgIHJlcXVlc3RzOiBbXSxcbiAgICAgICAgbmV4dFJlcXVlc3RJZDogMFxuICAgICAgfTtcbiAgICAgIHRoaXMubG9hZFRlc3RGb250SWQgPSAwO1xuICAgIH1cblxuICAgIGdldCBpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCgpIHtcbiAgICAgIGxldCBzdXBwb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG0gPSAvTW96aWxsYVxcLzUuMC4qP3J2OihcXGQrKS4qPyBHZWNrby8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICAgICAgICBpZiAobT8uWzFdID49IDE0KSB7XG4gICAgICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZFwiLCBzdXBwb3J0ZWQpO1xuICAgIH1cblxuICAgIF9xdWV1ZUxvYWRpbmdDYWxsYmFjayhjYWxsYmFjaykge1xuICAgICAgZnVuY3Rpb24gY29tcGxldGVSZXF1ZXN0KCkge1xuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KSghcmVxdWVzdC5kb25lLCBcImNvbXBsZXRlUmVxdWVzdCgpIGNhbm5vdCBiZSBjYWxsZWQgdHdpY2UuXCIpO1xuICAgICAgICByZXF1ZXN0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgIHdoaWxlIChjb250ZXh0LnJlcXVlc3RzLmxlbmd0aCA+IDAgJiYgY29udGV4dC5yZXF1ZXN0c1swXS5kb25lKSB7XG4gICAgICAgICAgY29uc3Qgb3RoZXJSZXF1ZXN0ID0gY29udGV4dC5yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgICAgIHNldFRpbWVvdXQob3RoZXJSZXF1ZXN0LmNhbGxiYWNrLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5sb2FkaW5nQ29udGV4dDtcbiAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIGlkOiBgcGRmanMtZm9udC1sb2FkaW5nLSR7Y29udGV4dC5uZXh0UmVxdWVzdElkKyt9YCxcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVJlcXVlc3QsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICB9O1xuICAgICAgY29udGV4dC5yZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgfVxuXG4gICAgZ2V0IF9sb2FkVGVzdEZvbnQoKSB7XG4gICAgICBjb25zdCBnZXRMb2FkVGVzdEZvbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhdG9iKFwiVDFSVVR3QUxBSUFBQXdBd1EwWkdJREh0Wmc0QUFBT1lBQUFBZ1VaR1ZFMWxrelp3QUFBRUhBQUFBQnhIUkVWR0FCUUFcIiArIFwiRlFBQUJEZ0FBQUFlVDFNdk1sWU5Zd2tBQUFFZ0FBQUFZR050WVhBQkRRTFVBQUFDTkFBQUFVSm9aV0ZrL3hWRkRRQUFcIiArIFwiQUx3QUFBQTJhR2hsWVFka0Erb0FBQUQwQUFBQUpHaHRkSGdENkFBQUFBQUVXQUFBQUFadFlYaHdBQUpRQUFBQUFSZ0FcIiArIFwiQUFBR2JtRnRaVmptZEg0QUFBR0FBQUFBc1hCdmMzVC9oZ0F6QUFBRGVBQUFBQ0FBQVFBQUFBRUFBTFpSRnNSZkR6ejFcIiArIFwiQUFzRDZBQUFBQURPQk9UTEFBQUFBTTRLSER3QUFBQUFBK2dESVFBQUFBZ0FBZ0FBQUFBQUFBQUJBQUFESVFBQUFGb0RcIiArIFwiNkFBQUFBQUQ2QUFCQUFBQUFBQUFBQUFBQUFBQUFBQUFBUUFBVUFBQUFnQUFBQVFENkFIMEFBVUFBQUtLQXJ3QUFBQ01cIiArIFwiQW9vQ3ZBQUFBZUFBTVFFQ0FBQUNBQVlKQUFBQUFBQUFBQUFBQVFBQUFBQUFBQUFBQUFBQUFGQm1SV1FBd0FBdUFDNERcIiArIFwiSVA4NEFGb0RJUUFBQUFBQUFRQUFBQUFBQUFBQUFDQUFJQUFCQUFBQURnQ3VBQUVBQUFBQUFBQUFBUUFBQUFFQUFBQUFcIiArIFwiQUFFQUFRQUFBQUVBQUFBQUFBSUFBUUFBQUFFQUFBQUFBQU1BQVFBQUFBRUFBQUFBQUFRQUFRQUFBQUVBQUFBQUFBVUFcIiArIFwiQVFBQUFBRUFBQUFBQUFZQUFRQUFBQU1BQVFRSkFBQUFBZ0FCQUFNQUFRUUpBQUVBQWdBQkFBTUFBUVFKQUFJQUFnQUJcIiArIFwiQUFNQUFRUUpBQU1BQWdBQkFBTUFBUVFKQUFRQUFnQUJBQU1BQVFRSkFBVUFBZ0FCQUFNQUFRUUpBQVlBQWdBQldBQllcIiArIFwiQUFBQUFBQUFBd0FBQUFNQUFBQWNBQUVBQUFBQUFEd0FBd0FCQUFBQUhBQUVBQ0FBQUFBRUFBUUFBUUFBQUM3Ly93QUFcIiArIFwiQUM3Ly8vL1RBQUVBQUFBQUFBQUJCZ0FBQVFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBRUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBTUFBQUFBQUFEL2d3QXlBQUFBQVFBQUFBQUFBQUFBQUFBQUFBQUFcIiArIFwiQUFBQkFBUUVBQUVCQVFKWUFBRUJBU0g0RHdENEd3SEVBdmdjQS9nWEJJd01BWXVMK256NXRRWGtENWozQ0JMbkVRQUNcIiArIFwiQVFFQklWaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZQUFBQkFRQUFEd0FDQVFFRUUvdDNcIiArIFwiRG92NmZBSDZmQVQrZlBwOCtud0hEb3NNQ3ZtMUN2bTFEQXo2ZkJRQUFBQUFBQUFCQUFBQUFNbUpiekVBQUFBQXpnVGpcIiArIFwiRlFBQUFBRE9CT1FwQUFFQUFBQUFBQUFBREFBVUFBUUFBQUFCQUFBQUFnQUJBQUFBQUFBQUFBQUQ2QUFBQUFBQUFBPT1cIik7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfbG9hZFRlc3RGb250XCIsIGdldExvYWRUZXN0Rm9udCgpKTtcbiAgICB9XG5cbiAgICBfcHJlcGFyZUZvbnRMb2FkRXZlbnQocnVsZXMsIGZvbnRzLCByZXF1ZXN0KSB7XG4gICAgICBmdW5jdGlvbiBpbnQzMihkYXRhLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEuY2hhckNvZGVBdChvZmZzZXQpIDw8IDI0IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDEpIDw8IDE2IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDIpIDw8IDggfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMykgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBzcGxpY2VTdHJpbmcocywgb2Zmc2V0LCByZW1vdmUsIGluc2VydCkge1xuICAgICAgICBjb25zdCBjaHVuazEgPSBzLnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBjaHVuazIgPSBzLnN1YnN0cmluZyhvZmZzZXQgKyByZW1vdmUpO1xuICAgICAgICByZXR1cm4gY2h1bmsxICsgaW5zZXJ0ICsgY2h1bmsyO1xuICAgICAgfVxuXG4gICAgICBsZXQgaSwgaWk7XG5cbiAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG5cbiAgICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gMTtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBsZXQgY2FsbGVkID0gMDtcblxuICAgICAgZnVuY3Rpb24gaXNGb250UmVhZHkobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGVkKys7XG5cbiAgICAgICAgaWYgKGNhbGxlZCA+IDMwKSB7XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiTG9hZCB0ZXN0IGZvbnQgbmV2ZXIgbG9hZGVkLlwiKTtcbiAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5mb250ID0gXCIzMHB4IFwiICsgbmFtZTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KFwiLlwiLCAwLCAyMCk7XG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSk7XG5cbiAgICAgICAgaWYgKGltYWdlRGF0YS5kYXRhWzNdID4gMCkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0VGltZW91dChpc0ZvbnRSZWFkeS5iaW5kKG51bGwsIG5hbWUsIGNhbGxiYWNrKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxvYWRUZXN0Rm9udElkID0gYGx0JHtEYXRlLm5vdygpfSR7dGhpcy5sb2FkVGVzdEZvbnRJZCsrfWA7XG4gICAgICBsZXQgZGF0YSA9IHRoaXMuX2xvYWRUZXN0Rm9udDtcbiAgICAgIGNvbnN0IENPTU1FTlRfT0ZGU0VUID0gOTc2O1xuICAgICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDT01NRU5UX09GRlNFVCwgbG9hZFRlc3RGb250SWQubGVuZ3RoLCBsb2FkVGVzdEZvbnRJZCk7XG4gICAgICBjb25zdCBDRkZfQ0hFQ0tTVU1fT0ZGU0VUID0gMTY7XG4gICAgICBjb25zdCBYWFhYX1ZBTFVFID0gMHg1ODU4NTg1ODtcbiAgICAgIGxldCBjaGVja3N1bSA9IGludDMyKGRhdGEsIENGRl9DSEVDS1NVTV9PRkZTRVQpO1xuXG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IGxvYWRUZXN0Rm9udElkLmxlbmd0aCAtIDM7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0gLSBYWFhYX1ZBTFVFICsgaW50MzIobG9hZFRlc3RGb250SWQsIGkpIHwgMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGkgPCBsb2FkVGVzdEZvbnRJZC5sZW5ndGgpIHtcbiAgICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCArIFwiWFhYXCIsIGkpIHwgMDtcbiAgICAgIH1cblxuICAgICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDRkZfQ0hFQ0tTVU1fT0ZGU0VULCA0LCAoMCwgX3V0aWwuc3RyaW5nMzIpKGNoZWNrc3VtKSk7XG4gICAgICBjb25zdCB1cmwgPSBgdXJsKGRhdGE6Zm9udC9vcGVudHlwZTtiYXNlNjQsJHtidG9hKGRhdGEpfSk7YDtcbiAgICAgIGNvbnN0IHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke2xvYWRUZXN0Rm9udElkfVwiO3NyYzoke3VybH19YDtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgIGNvbnN0IG5hbWVzID0gW107XG5cbiAgICAgIGZvciAoY29uc3QgZm9udCBvZiBmb250cykge1xuICAgICAgICBuYW1lcy5wdXNoKGZvbnQubG9hZGVkTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIG5hbWVzLnB1c2gobG9hZFRlc3RGb250SWQpO1xuXG4gICAgICBjb25zdCBkaXYgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICBkaXYuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICBkaXYuc3R5bGUud2lkdGggPSBkaXYuc3R5bGUuaGVpZ2h0ID0gXCIxMHB4XCI7XG4gICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICBkaXYuc3R5bGUudG9wID0gZGl2LnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuXG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBcIkhpXCI7XG4gICAgICAgIHNwYW4uc3R5bGUuZm9udEZhbWlseSA9IG5hbWU7XG4gICAgICAgIGRpdi5hcHBlbmQoc3Bhbik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RvY3VtZW50LmJvZHkuYXBwZW5kKGRpdik7XG5cbiAgICAgIGlzRm9udFJlYWR5KGxvYWRUZXN0Rm9udElkLCAoKSA9PiB7XG4gICAgICAgIGRpdi5yZW1vdmUoKTtcbiAgICAgICAgcmVxdWVzdC5jb21wbGV0ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gIH07XG59XG5cbmNsYXNzIEZvbnRGYWNlT2JqZWN0IHtcbiAgY29uc3RydWN0b3IodHJhbnNsYXRlZERhdGEsIHtcbiAgICBpc0V2YWxTdXBwb3J0ZWQgPSB0cnVlLFxuICAgIGRpc2FibGVGb250RmFjZSA9IGZhbHNlLFxuICAgIGlnbm9yZUVycm9ycyA9IGZhbHNlLFxuICAgIG9uVW5zdXBwb3J0ZWRGZWF0dXJlLFxuICAgIGZvbnRSZWdpc3RyeSA9IG51bGxcbiAgfSkge1xuICAgIHRoaXMuY29tcGlsZWRHbHlwaHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgZm9yIChjb25zdCBpIGluIHRyYW5zbGF0ZWREYXRhKSB7XG4gICAgICB0aGlzW2ldID0gdHJhbnNsYXRlZERhdGFbaV07XG4gICAgfVxuXG4gICAgdGhpcy5pc0V2YWxTdXBwb3J0ZWQgPSBpc0V2YWxTdXBwb3J0ZWQgIT09IGZhbHNlO1xuICAgIHRoaXMuZGlzYWJsZUZvbnRGYWNlID0gZGlzYWJsZUZvbnRGYWNlID09PSB0cnVlO1xuICAgIHRoaXMuaWdub3JlRXJyb3JzID0gaWdub3JlRXJyb3JzID09PSB0cnVlO1xuICAgIHRoaXMuX29uVW5zdXBwb3J0ZWRGZWF0dXJlID0gb25VbnN1cHBvcnRlZEZlYXR1cmU7XG4gICAgdGhpcy5mb250UmVnaXN0cnkgPSBmb250UmVnaXN0cnk7XG4gIH1cblxuICBjcmVhdGVOYXRpdmVGb250RmFjZSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YSB8fCB0aGlzLmRpc2FibGVGb250RmFjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IG5hdGl2ZUZvbnRGYWNlO1xuXG4gICAgaWYgKCF0aGlzLmNzc0ZvbnRJbmZvKSB7XG4gICAgICBuYXRpdmVGb250RmFjZSA9IG5ldyBGb250RmFjZSh0aGlzLmxvYWRlZE5hbWUsIHRoaXMuZGF0YSwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjc3MgPSB7XG4gICAgICAgIHdlaWdodDogdGhpcy5jc3NGb250SW5mby5mb250V2VpZ2h0XG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3Muc3R5bGUgPSBgb2JsaXF1ZSAke3RoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGV9ZGVnYDtcbiAgICAgIH1cblxuICAgICAgbmF0aXZlRm9udEZhY2UgPSBuZXcgRm9udEZhY2UodGhpcy5jc3NGb250SW5mby5mb250RmFtaWx5LCB0aGlzLmRhdGEsIGNzcyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZm9udFJlZ2lzdHJ5KSB7XG4gICAgICB0aGlzLmZvbnRSZWdpc3RyeS5yZWdpc3RlckZvbnQodGhpcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZUZvbnRGYWNlO1xuICB9XG5cbiAgY3JlYXRlRm9udEZhY2VSdWxlKCkge1xuICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGlzYWJsZUZvbnRGYWNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhID0gKDAsIF91dGlsLmJ5dGVzVG9TdHJpbmcpKHRoaXMuZGF0YSk7XG4gICAgY29uc3QgdXJsID0gYHVybChkYXRhOiR7dGhpcy5taW1ldHlwZX07YmFzZTY0LCR7YnRvYShkYXRhKX0pO2A7XG4gICAgbGV0IHJ1bGU7XG5cbiAgICBpZiAoIXRoaXMuY3NzRm9udEluZm8pIHtcbiAgICAgIHJ1bGUgPSBgQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XCIke3RoaXMubG9hZGVkTmFtZX1cIjtzcmM6JHt1cmx9fWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjc3MgPSBgZm9udC13ZWlnaHQ6ICR7dGhpcy5jc3NGb250SW5mby5mb250V2VpZ2h0fTtgO1xuXG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3MgKz0gYGZvbnQtc3R5bGU6IG9ibGlxdWUgJHt0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlfWRlZztgO1xuICAgICAgfVxuXG4gICAgICBydWxlID0gYEBmb250LWZhY2Uge2ZvbnQtZmFtaWx5OlwiJHt0aGlzLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHl9XCI7JHtjc3N9c3JjOiR7dXJsfX1gO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmZvbnRSZWdpc3RyeSkge1xuICAgICAgdGhpcy5mb250UmVnaXN0cnkucmVnaXN0ZXJGb250KHRoaXMsIHVybCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cblxuICBnZXRQYXRoR2VuZXJhdG9yKG9ianMsIGNoYXJhY3Rlcikge1xuICAgIGlmICh0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXTtcbiAgICB9XG5cbiAgICBsZXQgY21kcztcblxuICAgIHRyeSB7XG4gICAgICBjbWRzID0gb2Jqcy5nZXQodGhpcy5sb2FkZWROYW1lICsgXCJfcGF0aF9cIiArIGNoYXJhY3Rlcik7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmICghdGhpcy5pZ25vcmVFcnJvcnMpIHtcbiAgICAgICAgdGhyb3cgZXg7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX29uVW5zdXBwb3J0ZWRGZWF0dXJlKHtcbiAgICAgICAgZmVhdHVyZUlkOiBfdXRpbC5VTlNVUFBPUlRFRF9GRUFUVVJFUy5lcnJvckZvbnRHZXRQYXRoXG4gICAgICB9KTtcblxuICAgICAgKDAsIF91dGlsLndhcm4pKGBnZXRQYXRoR2VuZXJhdG9yIC0gaWdub3JpbmcgY2hhcmFjdGVyOiBcIiR7ZXh9XCIuYCk7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gZnVuY3Rpb24gKGMsIHNpemUpIHt9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzRXZhbFN1cHBvcnRlZCAmJiBfdXRpbC5GZWF0dXJlVGVzdC5pc0V2YWxTdXBwb3J0ZWQpIHtcbiAgICAgIGNvbnN0IGpzQnVmID0gW107XG5cbiAgICAgIGZvciAoY29uc3QgY3VycmVudCBvZiBjbWRzKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBjdXJyZW50LmFyZ3MgIT09IHVuZGVmaW5lZCA/IGN1cnJlbnQuYXJncy5qb2luKFwiLFwiKSA6IFwiXCI7XG4gICAgICAgIGpzQnVmLnB1c2goXCJjLlwiLCBjdXJyZW50LmNtZCwgXCIoXCIsIGFyZ3MsIFwiKTtcXG5cIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gPSBuZXcgRnVuY3Rpb24oXCJjXCIsIFwic2l6ZVwiLCBqc0J1Zi5qb2luKFwiXCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gZnVuY3Rpb24gKGMsIHNpemUpIHtcbiAgICAgIGZvciAoY29uc3QgY3VycmVudCBvZiBjbWRzKSB7XG4gICAgICAgIGlmIChjdXJyZW50LmNtZCA9PT0gXCJzY2FsZVwiKSB7XG4gICAgICAgICAgY3VycmVudC5hcmdzID0gW3NpemUsIC1zaXplXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNbY3VycmVudC5jbWRdLmFwcGx5KGMsIGN1cnJlbnQuYXJncyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuRm9udEZhY2VPYmplY3QgPSBGb250RmFjZU9iamVjdDtcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5DYW52YXNHcmFwaGljcyA9IHZvaWQgMDtcblxudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg4KTtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcblxudmFyIF9wYXR0ZXJuX2hlbHBlciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMpO1xuXG52YXIgX2ltYWdlX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG5cbnZhciBfaXNfbm9kZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMyk7XG5cbmNvbnN0IE1JTl9GT05UX1NJWkUgPSAxNjtcbmNvbnN0IE1BWF9GT05UX1NJWkUgPSAxMDA7XG5jb25zdCBNQVhfR1JPVVBfU0laRSA9IDQwOTY7XG5jb25zdCBFWEVDVVRJT05fVElNRSA9IDE1O1xuY29uc3QgRVhFQ1VUSU9OX1NURVBTID0gMTA7XG5jb25zdCBNQVhfU0laRV9UT19DT01QSUxFID0gX2lzX25vZGUuaXNOb2RlSlMgJiYgdHlwZW9mIFBhdGgyRCA9PT0gXCJ1bmRlZmluZWRcIiA/IC0xIDogMTAwMDtcbmNvbnN0IEZVTExfQ0hVTktfSEVJR0hUID0gMTY7XG5cbmZ1bmN0aW9uIG1pcnJvckNvbnRleHRPcGVyYXRpb25zKGN0eCwgZGVzdEN0eCkge1xuICBpZiAoY3R4Ll9yZW1vdmVNaXJyb3JpbmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250ZXh0IGlzIGFscmVhZHkgZm9yd2FyZGluZyBvcGVyYXRpb25zLlwiKTtcbiAgfVxuXG4gIGN0eC5fX29yaWdpbmFsU2F2ZSA9IGN0eC5zYXZlO1xuICBjdHguX19vcmlnaW5hbFJlc3RvcmUgPSBjdHgucmVzdG9yZTtcbiAgY3R4Ll9fb3JpZ2luYWxSb3RhdGUgPSBjdHgucm90YXRlO1xuICBjdHguX19vcmlnaW5hbFNjYWxlID0gY3R4LnNjYWxlO1xuICBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZSA9IGN0eC50cmFuc2xhdGU7XG4gIGN0eC5fX29yaWdpbmFsVHJhbnNmb3JtID0gY3R4LnRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0gPSBjdHguc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtID0gY3R4LnJlc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbENsaXAgPSBjdHguY2xpcDtcbiAgY3R4Ll9fb3JpZ2luYWxNb3ZlVG8gPSBjdHgubW92ZVRvO1xuICBjdHguX19vcmlnaW5hbExpbmVUbyA9IGN0eC5saW5lVG87XG4gIGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyA9IGN0eC5iZXppZXJDdXJ2ZVRvO1xuICBjdHguX19vcmlnaW5hbFJlY3QgPSBjdHgucmVjdDtcbiAgY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGggPSBjdHguY2xvc2VQYXRoO1xuICBjdHguX19vcmlnaW5hbEJlZ2luUGF0aCA9IGN0eC5iZWdpblBhdGg7XG5cbiAgY3R4Ll9yZW1vdmVNaXJyb3JpbmcgPSAoKSA9PiB7XG4gICAgY3R4LnNhdmUgPSBjdHguX19vcmlnaW5hbFNhdmU7XG4gICAgY3R4LnJlc3RvcmUgPSBjdHguX19vcmlnaW5hbFJlc3RvcmU7XG4gICAgY3R4LnJvdGF0ZSA9IGN0eC5fX29yaWdpbmFsUm90YXRlO1xuICAgIGN0eC5zY2FsZSA9IGN0eC5fX29yaWdpbmFsU2NhbGU7XG4gICAgY3R4LnRyYW5zbGF0ZSA9IGN0eC5fX29yaWdpbmFsVHJhbnNsYXRlO1xuICAgIGN0eC50cmFuc2Zvcm0gPSBjdHguX19vcmlnaW5hbFRyYW5zZm9ybTtcbiAgICBjdHguc2V0VHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxTZXRUcmFuc2Zvcm07XG4gICAgY3R4LnJlc2V0VHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybTtcbiAgICBjdHguY2xpcCA9IGN0eC5fX29yaWdpbmFsQ2xpcDtcbiAgICBjdHgubW92ZVRvID0gY3R4Ll9fb3JpZ2luYWxNb3ZlVG87XG4gICAgY3R4LmxpbmVUbyA9IGN0eC5fX29yaWdpbmFsTGluZVRvO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvID0gY3R4Ll9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvO1xuICAgIGN0eC5yZWN0ID0gY3R4Ll9fb3JpZ2luYWxSZWN0O1xuICAgIGN0eC5jbG9zZVBhdGggPSBjdHguX19vcmlnaW5hbENsb3NlUGF0aDtcbiAgICBjdHguYmVnaW5QYXRoID0gY3R4Ll9fb3JpZ2luYWxCZWdpblBhdGg7XG4gICAgZGVsZXRlIGN0eC5fcmVtb3ZlTWlycm9yaW5nO1xuICB9O1xuXG4gIGN0eC5zYXZlID0gZnVuY3Rpb24gY3R4U2F2ZSgpIHtcbiAgICBkZXN0Q3R4LnNhdmUoKTtcblxuICAgIHRoaXMuX19vcmlnaW5hbFNhdmUoKTtcbiAgfTtcblxuICBjdHgucmVzdG9yZSA9IGZ1bmN0aW9uIGN0eFJlc3RvcmUoKSB7XG4gICAgZGVzdEN0eC5yZXN0b3JlKCk7XG5cbiAgICB0aGlzLl9fb3JpZ2luYWxSZXN0b3JlKCk7XG4gIH07XG5cbiAgY3R4LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIGN0eFRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgZGVzdEN0eC50cmFuc2xhdGUoeCwgeSk7XG5cbiAgICB0aGlzLl9fb3JpZ2luYWxUcmFuc2xhdGUoeCwgeSk7XG4gIH07XG5cbiAgY3R4LnNjYWxlID0gZnVuY3Rpb24gY3R4U2NhbGUoeCwgeSkge1xuICAgIGRlc3RDdHguc2NhbGUoeCwgeSk7XG5cbiAgICB0aGlzLl9fb3JpZ2luYWxTY2FsZSh4LCB5KTtcbiAgfTtcblxuICBjdHgudHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcblxuICAgIHRoaXMuX19vcmlnaW5hbFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgfTtcblxuICBjdHguc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4U2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcblxuICAgIHRoaXMuX19vcmlnaW5hbFNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgfTtcblxuICBjdHgucmVzZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBjdHhSZXNldFRyYW5zZm9ybSgpIHtcbiAgICBkZXN0Q3R4LnJlc2V0VHJhbnNmb3JtKCk7XG5cbiAgICB0aGlzLl9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSgpO1xuICB9O1xuXG4gIGN0eC5yb3RhdGUgPSBmdW5jdGlvbiBjdHhSb3RhdGUoYW5nbGUpIHtcbiAgICBkZXN0Q3R4LnJvdGF0ZShhbmdsZSk7XG5cbiAgICB0aGlzLl9fb3JpZ2luYWxSb3RhdGUoYW5nbGUpO1xuICB9O1xuXG4gIGN0eC5jbGlwID0gZnVuY3Rpb24gY3R4Um90YXRlKHJ1bGUpIHtcbiAgICBkZXN0Q3R4LmNsaXAocnVsZSk7XG5cbiAgICB0aGlzLl9fb3JpZ2luYWxDbGlwKHJ1bGUpO1xuICB9O1xuXG4gIGN0eC5tb3ZlVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGRlc3RDdHgubW92ZVRvKHgsIHkpO1xuXG4gICAgdGhpcy5fX29yaWdpbmFsTW92ZVRvKHgsIHkpO1xuICB9O1xuXG4gIGN0eC5saW5lVG8gPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGRlc3RDdHgubGluZVRvKHgsIHkpO1xuXG4gICAgdGhpcy5fX29yaWdpbmFsTGluZVRvKHgsIHkpO1xuICB9O1xuXG4gIGN0eC5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24gKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcbiAgICBkZXN0Q3R4LmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG5cbiAgICB0aGlzLl9fb3JpZ2luYWxCZXppZXJDdXJ2ZVRvKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpO1xuICB9O1xuXG4gIGN0eC5yZWN0ID0gZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBkZXN0Q3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICB0aGlzLl9fb3JpZ2luYWxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuXG4gIGN0eC5jbG9zZVBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5jbG9zZVBhdGgoKTtcblxuICAgIHRoaXMuX19vcmlnaW5hbENsb3NlUGF0aCgpO1xuICB9O1xuXG4gIGN0eC5iZWdpblBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5iZWdpblBhdGgoKTtcblxuICAgIHRoaXMuX19vcmlnaW5hbEJlZ2luUGF0aCgpO1xuICB9O1xufVxuXG5jbGFzcyBDYWNoZWRDYW52YXNlcyB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhc0ZhY3RvcnkpIHtcbiAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9XG5cbiAgZ2V0Q2FudmFzKGlkLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgbGV0IGNhbnZhc0VudHJ5O1xuXG4gICAgaWYgKHRoaXMuY2FjaGVbaWRdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICB0aGlzLmNhbnZhc0ZhY3RvcnkucmVzZXQoY2FudmFzRW50cnksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYW52YXNFbnRyeSA9IHRoaXMuY2FudmFzRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmNhY2hlW2lkXSA9IGNhbnZhc0VudHJ5O1xuICAgIH1cblxuICAgIHJldHVybiBjYW52YXNFbnRyeTtcbiAgfVxuXG4gIGRlbGV0ZShpZCkge1xuICAgIGRlbGV0ZSB0aGlzLmNhY2hlW2lkXTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgaWQgaW4gdGhpcy5jYWNoZSkge1xuICAgICAgY29uc3QgY2FudmFzRW50cnkgPSB0aGlzLmNhY2hlW2lkXTtcbiAgICAgIHRoaXMuY2FudmFzRmFjdG9yeS5kZXN0cm95KGNhbnZhc0VudHJ5KTtcbiAgICAgIGRlbGV0ZSB0aGlzLmNhY2hlW2lkXTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGRlc3RYLCBkZXN0WSwgZGVzdFcsIGRlc3RIKSB7XG4gIGNvbnN0IFthLCBiLCBjLCBkLCB0eCwgdHldID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCk7XG5cbiAgaWYgKGIgPT09IDAgJiYgYyA9PT0gMCkge1xuICAgIGNvbnN0IHRsWCA9IGRlc3RYICogYSArIHR4O1xuICAgIGNvbnN0IHJUbFggPSBNYXRoLnJvdW5kKHRsWCk7XG4gICAgY29uc3QgdGxZID0gZGVzdFkgKiBkICsgdHk7XG4gICAgY29uc3QgclRsWSA9IE1hdGgucm91bmQodGxZKTtcbiAgICBjb25zdCBiclggPSAoZGVzdFggKyBkZXN0VykgKiBhICsgdHg7XG4gICAgY29uc3QgcldpZHRoID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclgpIC0gclRsWCkgfHwgMTtcbiAgICBjb25zdCBiclkgPSAoZGVzdFkgKyBkZXN0SCkgKiBkICsgdHk7XG4gICAgY29uc3QgckhlaWdodCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJZKSAtIHJUbFkpIHx8IDE7XG4gICAgY3R4LnNldFRyYW5zZm9ybShNYXRoLnNpZ24oYSksIDAsIDAsIE1hdGguc2lnbihkKSwgclRsWCwgclRsWSk7XG4gICAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIDAsIDAsIHJXaWR0aCwgckhlaWdodCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCB0eCwgdHkpO1xuICAgIHJldHVybiBbcldpZHRoLCBySGVpZ2h0XTtcbiAgfVxuXG4gIGlmIChhID09PSAwICYmIGQgPT09IDApIHtcbiAgICBjb25zdCB0bFggPSBkZXN0WSAqIGMgKyB0eDtcbiAgICBjb25zdCByVGxYID0gTWF0aC5yb3VuZCh0bFgpO1xuICAgIGNvbnN0IHRsWSA9IGRlc3RYICogYiArIHR5O1xuICAgIGNvbnN0IHJUbFkgPSBNYXRoLnJvdW5kKHRsWSk7XG4gICAgY29uc3QgYnJYID0gKGRlc3RZICsgZGVzdEgpICogYyArIHR4O1xuICAgIGNvbnN0IHJXaWR0aCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJYKSAtIHJUbFgpIHx8IDE7XG4gICAgY29uc3QgYnJZID0gKGRlc3RYICsgZGVzdFcpICogYiArIHR5O1xuICAgIGNvbnN0IHJIZWlnaHQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWSkgLSByVGxZKSB8fCAxO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMCwgTWF0aC5zaWduKGIpLCBNYXRoLnNpZ24oYyksIDAsIHJUbFgsIHJUbFkpO1xuICAgIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCAwLCAwLCBySGVpZ2h0LCByV2lkdGgpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgdHgsIHR5KTtcbiAgICByZXR1cm4gW3JIZWlnaHQsIHJXaWR0aF07XG4gIH1cblxuICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgZGVzdFgsIGRlc3RZLCBkZXN0VywgZGVzdEgpO1xuICBjb25zdCBzY2FsZVggPSBNYXRoLmh5cG90KGEsIGIpO1xuICBjb25zdCBzY2FsZVkgPSBNYXRoLmh5cG90KGMsIGQpO1xuICByZXR1cm4gW3NjYWxlWCAqIGRlc3RXLCBzY2FsZVkgKiBkZXN0SF07XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVUeXBlM0dseXBoKGltZ0RhdGEpIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gaW1nRGF0YTtcblxuICBpZiAod2lkdGggPiBNQVhfU0laRV9UT19DT01QSUxFIHx8IGhlaWdodCA+IE1BWF9TSVpFX1RPX0NPTVBJTEUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IFBPSU5UX1RPX1BST0NFU1NfTElNSVQgPSAxMDAwO1xuICBjb25zdCBQT0lOVF9UWVBFUyA9IG5ldyBVaW50OEFycmF5KFswLCAyLCA0LCAwLCAxLCAwLCA1LCA0LCA4LCAxMCwgMCwgOCwgMCwgMiwgMSwgMF0pO1xuICBjb25zdCB3aWR0aDEgPSB3aWR0aCArIDE7XG4gIGxldCBwb2ludHMgPSBuZXcgVWludDhBcnJheSh3aWR0aDEgKiAoaGVpZ2h0ICsgMSkpO1xuICBsZXQgaSwgaiwgajA7XG4gIGNvbnN0IGxpbmVTaXplID0gd2lkdGggKyA3ICYgfjc7XG4gIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobGluZVNpemUgKiBoZWlnaHQpLFxuICAgICAgcG9zID0gMDtcblxuICBmb3IgKGNvbnN0IGVsZW0gb2YgaW1nRGF0YS5kYXRhKSB7XG4gICAgbGV0IG1hc2sgPSAxMjg7XG5cbiAgICB3aGlsZSAobWFzayA+IDApIHtcbiAgICAgIGRhdGFbcG9zKytdID0gZWxlbSAmIG1hc2sgPyAwIDogMjU1O1xuICAgICAgbWFzayA+Pj0gMTtcbiAgICB9XG4gIH1cblxuICBsZXQgY291bnQgPSAwO1xuICBwb3MgPSAwO1xuXG4gIGlmIChkYXRhW3Bvc10gIT09IDApIHtcbiAgICBwb2ludHNbMF0gPSAxO1xuICAgICsrY291bnQ7XG4gIH1cblxuICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgIGlmIChkYXRhW3Bvc10gIT09IGRhdGFbcG9zICsgMV0pIHtcbiAgICAgIHBvaW50c1tqXSA9IGRhdGFbcG9zXSA/IDIgOiAxO1xuICAgICAgKytjb3VudDtcbiAgICB9XG5cbiAgICBwb3MrKztcbiAgfVxuXG4gIGlmIChkYXRhW3Bvc10gIT09IDApIHtcbiAgICBwb2ludHNbal0gPSAyO1xuICAgICsrY291bnQ7XG4gIH1cblxuICBmb3IgKGkgPSAxOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICBwb3MgPSBpICogbGluZVNpemU7XG4gICAgajAgPSBpICogd2lkdGgxO1xuXG4gICAgaWYgKGRhdGFbcG9zIC0gbGluZVNpemVdICE9PSBkYXRhW3Bvc10pIHtcbiAgICAgIHBvaW50c1tqMF0gPSBkYXRhW3Bvc10gPyAxIDogODtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuXG4gICAgbGV0IHN1bSA9IChkYXRhW3Bvc10gPyA0IDogMCkgKyAoZGF0YVtwb3MgLSBsaW5lU2l6ZV0gPyA4IDogMCk7XG5cbiAgICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgc3VtID0gKHN1bSA+PiAyKSArIChkYXRhW3BvcyArIDFdID8gNCA6IDApICsgKGRhdGFbcG9zIC0gbGluZVNpemUgKyAxXSA/IDggOiAwKTtcblxuICAgICAgaWYgKFBPSU5UX1RZUEVTW3N1bV0pIHtcbiAgICAgICAgcG9pbnRzW2owICsgal0gPSBQT0lOVF9UWVBFU1tzdW1dO1xuICAgICAgICArK2NvdW50O1xuICAgICAgfVxuXG4gICAgICBwb3MrKztcbiAgICB9XG5cbiAgICBpZiAoZGF0YVtwb3MgLSBsaW5lU2l6ZV0gIT09IGRhdGFbcG9zXSkge1xuICAgICAgcG9pbnRzW2owICsgal0gPSBkYXRhW3Bvc10gPyAyIDogNDtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50ID4gUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcG9zID0gbGluZVNpemUgKiAoaGVpZ2h0IC0gMSk7XG4gIGowID0gaSAqIHdpZHRoMTtcblxuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2owXSA9IDg7XG4gICAgKytjb3VudDtcbiAgfVxuXG4gIGZvciAoaiA9IDE7IGogPCB3aWR0aDsgaisrKSB7XG4gICAgaWYgKGRhdGFbcG9zXSAhPT0gZGF0YVtwb3MgKyAxXSkge1xuICAgICAgcG9pbnRzW2owICsgal0gPSBkYXRhW3Bvc10gPyA0IDogODtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2owICsgal0gPSA0O1xuICAgICsrY291bnQ7XG4gIH1cblxuICBpZiAoY291bnQgPiBQT0lOVF9UT19QUk9DRVNTX0xJTUlUKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCBzdGVwcyA9IG5ldyBJbnQzMkFycmF5KFswLCB3aWR0aDEsIC0xLCAwLCAtd2lkdGgxLCAwLCAwLCAwLCAxXSk7XG4gIGNvbnN0IHBhdGggPSBuZXcgUGF0aDJEKCk7XG5cbiAgZm9yIChpID0gMDsgY291bnQgJiYgaSA8PSBoZWlnaHQ7IGkrKykge1xuICAgIGxldCBwID0gaSAqIHdpZHRoMTtcbiAgICBjb25zdCBlbmQgPSBwICsgd2lkdGg7XG5cbiAgICB3aGlsZSAocCA8IGVuZCAmJiAhcG9pbnRzW3BdKSB7XG4gICAgICBwKys7XG4gICAgfVxuXG4gICAgaWYgKHAgPT09IGVuZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcGF0aC5tb3ZlVG8ocCAlIHdpZHRoMSwgaSk7XG4gICAgY29uc3QgcDAgPSBwO1xuICAgIGxldCB0eXBlID0gcG9pbnRzW3BdO1xuXG4gICAgZG8ge1xuICAgICAgY29uc3Qgc3RlcCA9IHN0ZXBzW3R5cGVdO1xuXG4gICAgICBkbyB7XG4gICAgICAgIHAgKz0gc3RlcDtcbiAgICAgIH0gd2hpbGUgKCFwb2ludHNbcF0pO1xuXG4gICAgICBjb25zdCBwcCA9IHBvaW50c1twXTtcblxuICAgICAgaWYgKHBwICE9PSA1ICYmIHBwICE9PSAxMCkge1xuICAgICAgICB0eXBlID0gcHA7XG4gICAgICAgIHBvaW50c1twXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gcHAgJiAweDMzICogdHlwZSA+PiA0O1xuICAgICAgICBwb2ludHNbcF0gJj0gdHlwZSA+PiAyIHwgdHlwZSA8PCAyO1xuICAgICAgfVxuXG4gICAgICBwYXRoLmxpbmVUbyhwICUgd2lkdGgxLCBwIC8gd2lkdGgxIHwgMCk7XG5cbiAgICAgIGlmICghcG9pbnRzW3BdKSB7XG4gICAgICAgIC0tY291bnQ7XG4gICAgICB9XG4gICAgfSB3aGlsZSAocDAgIT09IHApO1xuXG4gICAgLS1pO1xuICB9XG5cbiAgZGF0YSA9IG51bGw7XG4gIHBvaW50cyA9IG51bGw7XG5cbiAgY29uc3QgZHJhd091dGxpbmUgPSBmdW5jdGlvbiAoYykge1xuICAgIGMuc2F2ZSgpO1xuICAgIGMuc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgYy50cmFuc2xhdGUoMCwgLWhlaWdodCk7XG4gICAgYy5maWxsKHBhdGgpO1xuICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgYy5yZXN0b3JlKCk7XG4gIH07XG5cbiAgcmV0dXJuIGRyYXdPdXRsaW5lO1xufVxuXG5jbGFzcyBDYW52YXNFeHRyYVN0YXRlIHtcbiAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuYWxwaGFJc1NoYXBlID0gZmFsc2U7XG4gICAgdGhpcy5mb250U2l6ZSA9IDA7XG4gICAgdGhpcy5mb250U2l6ZVNjYWxlID0gMTtcbiAgICB0aGlzLnRleHRNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgIHRoaXMuZm9udE1hdHJpeCA9IF91dGlsLkZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMubGVhZGluZyA9IDA7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMubGluZVggPSAwO1xuICAgIHRoaXMubGluZVkgPSAwO1xuICAgIHRoaXMuY2hhclNwYWNpbmcgPSAwO1xuICAgIHRoaXMud29yZFNwYWNpbmcgPSAwO1xuICAgIHRoaXMudGV4dEhTY2FsZSA9IDE7XG4gICAgdGhpcy50ZXh0UmVuZGVyaW5nTW9kZSA9IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEw7XG4gICAgdGhpcy50ZXh0UmlzZSA9IDA7XG4gICAgdGhpcy5maWxsQ29sb3IgPSBcIiMwMDAwMDBcIjtcbiAgICB0aGlzLnN0cm9rZUNvbG9yID0gXCIjMDAwMDAwXCI7XG4gICAgdGhpcy5wYXR0ZXJuRmlsbCA9IGZhbHNlO1xuICAgIHRoaXMuZmlsbEFscGhhID0gMTtcbiAgICB0aGlzLnN0cm9rZUFscGhhID0gMTtcbiAgICB0aGlzLmxpbmVXaWR0aCA9IDE7XG4gICAgdGhpcy5hY3RpdmVTTWFzayA9IG51bGw7XG4gICAgdGhpcy50cmFuc2Zlck1hcHMgPSBudWxsO1xuICAgIHRoaXMuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChbMCwgMCwgd2lkdGgsIGhlaWdodF0pO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBPYmplY3QuY3JlYXRlKHRoaXMpO1xuICAgIGNsb25lLmNsaXBCb3ggPSB0aGlzLmNsaXBCb3guc2xpY2UoKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICBzZXRDdXJyZW50UG9pbnQoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxuXG4gIHVwZGF0ZVBhdGhNaW5NYXgodHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgW3gsIHldID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbeCwgeV0sIHRyYW5zZm9ybSk7XG4gICAgdGhpcy5taW5YID0gTWF0aC5taW4odGhpcy5taW5YLCB4KTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHkpO1xuICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgeCk7XG4gICAgdGhpcy5tYXhZID0gTWF0aC5tYXgodGhpcy5tYXhZLCB5KTtcbiAgfVxuXG4gIHVwZGF0ZVJlY3RNaW5NYXgodHJhbnNmb3JtLCByZWN0KSB7XG4gICAgY29uc3QgcDEgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKHJlY3QsIHRyYW5zZm9ybSk7XG5cbiAgICBjb25zdCBwMiA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0ocmVjdC5zbGljZSgyKSwgdHJhbnNmb3JtKTtcblxuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgcDFbMF0sIHAyWzBdKTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHAxWzFdLCBwMlsxXSk7XG4gICAgdGhpcy5tYXhYID0gTWF0aC5tYXgodGhpcy5tYXhYLCBwMVswXSwgcDJbMF0pO1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgcDFbMV0sIHAyWzFdKTtcbiAgfVxuXG4gIHVwZGF0ZVNjYWxpbmdQYXRoTWluTWF4KHRyYW5zZm9ybSwgbWluTWF4KSB7XG4gICAgX3V0aWwuVXRpbC5zY2FsZU1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCk7XG5cbiAgICB0aGlzLm1pblggPSBNYXRoLm1pbih0aGlzLm1pblgsIG1pbk1heFswXSk7XG4gICAgdGhpcy5tYXhYID0gTWF0aC5tYXgodGhpcy5tYXhYLCBtaW5NYXhbMV0pO1xuICAgIHRoaXMubWluWSA9IE1hdGgubWluKHRoaXMubWluWSwgbWluTWF4WzJdKTtcbiAgICB0aGlzLm1heFkgPSBNYXRoLm1heCh0aGlzLm1heFksIG1pbk1heFszXSk7XG4gIH1cblxuICB1cGRhdGVDdXJ2ZVBhdGhNaW5NYXgodHJhbnNmb3JtLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbk1heCkge1xuICAgIGNvbnN0IGJveCA9IF91dGlsLlV0aWwuYmV6aWVyQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcblxuICAgIGlmIChtaW5NYXgpIHtcbiAgICAgIG1pbk1heFswXSA9IE1hdGgubWluKG1pbk1heFswXSwgYm94WzBdLCBib3hbMl0pO1xuICAgICAgbWluTWF4WzFdID0gTWF0aC5tYXgobWluTWF4WzFdLCBib3hbMF0sIGJveFsyXSk7XG4gICAgICBtaW5NYXhbMl0gPSBNYXRoLm1pbihtaW5NYXhbMl0sIGJveFsxXSwgYm94WzNdKTtcbiAgICAgIG1pbk1heFszXSA9IE1hdGgubWF4KG1pbk1heFszXSwgYm94WzFdLCBib3hbM10pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlUmVjdE1pbk1heCh0cmFuc2Zvcm0sIGJveCk7XG4gIH1cblxuICBnZXRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUgPSBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuRklMTCwgdHJhbnNmb3JtID0gbnVsbCkge1xuICAgIGNvbnN0IGJveCA9IFt0aGlzLm1pblgsIHRoaXMubWluWSwgdGhpcy5tYXhYLCB0aGlzLm1heFldO1xuXG4gICAgaWYgKHBhdGhUeXBlID09PSBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuU1RST0tFKSB7XG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiU3Ryb2tlIGJvdW5kaW5nIGJveCBtdXN0IGluY2x1ZGUgdHJhbnNmb3JtLlwiKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZm9ybSk7XG5cbiAgICAgIGNvbnN0IHhTdHJva2VQYWQgPSBzY2FsZVswXSAqIHRoaXMubGluZVdpZHRoIC8gMjtcbiAgICAgIGNvbnN0IHlTdHJva2VQYWQgPSBzY2FsZVsxXSAqIHRoaXMubGluZVdpZHRoIC8gMjtcbiAgICAgIGJveFswXSAtPSB4U3Ryb2tlUGFkO1xuICAgICAgYm94WzFdIC09IHlTdHJva2VQYWQ7XG4gICAgICBib3hbMl0gKz0geFN0cm9rZVBhZDtcbiAgICAgIGJveFszXSArPSB5U3Ryb2tlUGFkO1xuICAgIH1cblxuICAgIHJldHVybiBib3g7XG4gIH1cblxuICB1cGRhdGVDbGlwRnJvbVBhdGgoKSB7XG4gICAgY29uc3QgaW50ZXJzZWN0ID0gX3V0aWwuVXRpbC5pbnRlcnNlY3QodGhpcy5jbGlwQm94LCB0aGlzLmdldFBhdGhCb3VuZGluZ0JveCgpKTtcblxuICAgIHRoaXMuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChpbnRlcnNlY3QgfHwgWzAsIDAsIDAsIDBdKTtcbiAgfVxuXG4gIGlzRW1wdHlDbGlwKCkge1xuICAgIHJldHVybiB0aGlzLm1pblggPT09IEluZmluaXR5O1xuICB9XG5cbiAgc3RhcnROZXdQYXRoQW5kQ2xpcEJveChib3gpIHtcbiAgICB0aGlzLmNsaXBCb3ggPSBib3g7XG4gICAgdGhpcy5taW5YID0gSW5maW5pdHk7XG4gICAgdGhpcy5taW5ZID0gSW5maW5pdHk7XG4gICAgdGhpcy5tYXhYID0gMDtcbiAgICB0aGlzLm1heFkgPSAwO1xuICB9XG5cbiAgZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveChwYXRoVHlwZSA9IF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5GSUxMLCB0cmFuc2Zvcm0gPSBudWxsKSB7XG4gICAgcmV0dXJuIF91dGlsLlV0aWwuaW50ZXJzZWN0KHRoaXMuY2xpcEJveCwgdGhpcy5nZXRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUsIHRyYW5zZm9ybSkpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gcHV0QmluYXJ5SW1hZ2VEYXRhKGN0eCwgaW1nRGF0YSwgdHJhbnNmZXJNYXBzID0gbnVsbCkge1xuICBpZiAodHlwZW9mIEltYWdlRGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbWdEYXRhIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSB7XG4gICAgY3R4LnB1dEltYWdlRGF0YShpbWdEYXRhLCAwLCAwKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICAgICAgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICBjb25zdCBwYXJ0aWFsQ2h1bmtIZWlnaHQgPSBoZWlnaHQgJSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgZnVsbENodW5rcyA9IChoZWlnaHQgLSBwYXJ0aWFsQ2h1bmtIZWlnaHQpIC8gRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IHRvdGFsQ2h1bmtzID0gcGFydGlhbENodW5rSGVpZ2h0ID09PSAwID8gZnVsbENodW5rcyA6IGZ1bGxDaHVua3MgKyAxO1xuICBjb25zdCBjaHVua0ltZ0RhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIGxldCBzcmNQb3MgPSAwLFxuICAgICAgZGVzdFBvcztcbiAgY29uc3Qgc3JjID0gaW1nRGF0YS5kYXRhO1xuICBjb25zdCBkZXN0ID0gY2h1bmtJbWdEYXRhLmRhdGE7XG4gIGxldCBpLCBqLCB0aGlzQ2h1bmtIZWlnaHQsIGVsZW1zSW5UaGlzQ2h1bms7XG4gIGxldCB0cmFuc2Zlck1hcFJlZCwgdHJhbnNmZXJNYXBHcmVlbiwgdHJhbnNmZXJNYXBCbHVlLCB0cmFuc2Zlck1hcEdyYXk7XG5cbiAgaWYgKHRyYW5zZmVyTWFwcykge1xuICAgIHN3aXRjaCAodHJhbnNmZXJNYXBzLmxlbmd0aCkge1xuICAgICAgY2FzZSAxOlxuICAgICAgICB0cmFuc2Zlck1hcFJlZCA9IHRyYW5zZmVyTWFwc1swXTtcbiAgICAgICAgdHJhbnNmZXJNYXBHcmVlbiA9IHRyYW5zZmVyTWFwc1swXTtcbiAgICAgICAgdHJhbnNmZXJNYXBCbHVlID0gdHJhbnNmZXJNYXBzWzBdO1xuICAgICAgICB0cmFuc2Zlck1hcEdyYXkgPSB0cmFuc2Zlck1hcHNbMF07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHRyYW5zZmVyTWFwUmVkID0gdHJhbnNmZXJNYXBzWzBdO1xuICAgICAgICB0cmFuc2Zlck1hcEdyZWVuID0gdHJhbnNmZXJNYXBzWzFdO1xuICAgICAgICB0cmFuc2Zlck1hcEJsdWUgPSB0cmFuc2Zlck1hcHNbMl07XG4gICAgICAgIHRyYW5zZmVyTWFwR3JheSA9IHRyYW5zZmVyTWFwc1szXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGltZ0RhdGEua2luZCA9PT0gX3V0aWwuSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQKSB7XG4gICAgY29uc3Qgc3JjTGVuZ3RoID0gc3JjLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgZGVzdDMyID0gbmV3IFVpbnQzMkFycmF5KGRlc3QuYnVmZmVyLCAwLCBkZXN0LmJ5dGVMZW5ndGggPj4gMik7XG4gICAgY29uc3QgZGVzdDMyRGF0YUxlbmd0aCA9IGRlc3QzMi5sZW5ndGg7XG4gICAgY29uc3QgZnVsbFNyY0RpZmYgPSB3aWR0aCArIDcgPj4gMztcbiAgICBsZXQgd2hpdGUgPSAweGZmZmZmZmZmO1xuICAgIGxldCBibGFjayA9IF91dGlsLkZlYXR1cmVUZXN0LmlzTGl0dGxlRW5kaWFuID8gMHhmZjAwMDAwMCA6IDB4MDAwMDAwZmY7XG5cbiAgICBpZiAodHJhbnNmZXJNYXBHcmF5KSB7XG4gICAgICBpZiAodHJhbnNmZXJNYXBHcmF5WzBdID09PSAweGZmICYmIHRyYW5zZmVyTWFwR3JheVsweGZmXSA9PT0gMCkge1xuICAgICAgICBbd2hpdGUsIGJsYWNrXSA9IFtibGFjaywgd2hpdGVdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBpIDwgZnVsbENodW5rcyA/IEZVTExfQ0hVTktfSEVJR0hUIDogcGFydGlhbENodW5rSGVpZ2h0O1xuICAgICAgZGVzdFBvcyA9IDA7XG5cbiAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzQ2h1bmtIZWlnaHQ7IGorKykge1xuICAgICAgICBjb25zdCBzcmNEaWZmID0gc3JjTGVuZ3RoIC0gc3JjUG9zO1xuICAgICAgICBsZXQgayA9IDA7XG4gICAgICAgIGNvbnN0IGtFbmQgPSBzcmNEaWZmID4gZnVsbFNyY0RpZmYgPyB3aWR0aCA6IHNyY0RpZmYgKiA4IC0gNztcbiAgICAgICAgY29uc3Qga0VuZFVucm9sbGVkID0ga0VuZCAmIH43O1xuICAgICAgICBsZXQgbWFzayA9IDA7XG4gICAgICAgIGxldCBzcmNCeXRlID0gMDtcblxuICAgICAgICBmb3IgKDsgayA8IGtFbmRVbnJvbGxlZDsgayArPSA4KSB7XG4gICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTI4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA2NCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMzIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDE2ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAyID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoOyBrIDwga0VuZDsgaysrKSB7XG4gICAgICAgICAgaWYgKG1hc2sgPT09IDApIHtcbiAgICAgICAgICAgIHNyY0J5dGUgPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgICAgbWFzayA9IDEyODtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiBtYXNrID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBtYXNrID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChkZXN0UG9zIDwgZGVzdDMyRGF0YUxlbmd0aCkge1xuICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpbWdEYXRhLmtpbmQgPT09IF91dGlsLkltYWdlS2luZC5SR0JBXzMyQlBQKSB7XG4gICAgY29uc3QgaGFzVHJhbnNmZXJNYXBzID0gISEodHJhbnNmZXJNYXBSZWQgfHwgdHJhbnNmZXJNYXBHcmVlbiB8fCB0cmFuc2Zlck1hcEJsdWUpO1xuICAgIGogPSAwO1xuICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIEZVTExfQ0hVTktfSEVJR0hUICogNDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2h1bmtzOyBpKyspIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcbiAgICAgIHNyY1BvcyArPSBlbGVtc0luVGhpc0NodW5rO1xuXG4gICAgICBpZiAoaGFzVHJhbnNmZXJNYXBzKSB7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZWxlbXNJblRoaXNDaHVuazsgayArPSA0KSB7XG4gICAgICAgICAgaWYgKHRyYW5zZmVyTWFwUmVkKSB7XG4gICAgICAgICAgICBkZXN0W2sgKyAwXSA9IHRyYW5zZmVyTWFwUmVkW2Rlc3RbayArIDBdXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHJhbnNmZXJNYXBHcmVlbikge1xuICAgICAgICAgICAgZGVzdFtrICsgMV0gPSB0cmFuc2Zlck1hcEdyZWVuW2Rlc3RbayArIDFdXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHJhbnNmZXJNYXBCbHVlKSB7XG4gICAgICAgICAgICBkZXN0W2sgKyAyXSA9IHRyYW5zZmVyTWFwQmx1ZVtkZXN0W2sgKyAyXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICAgIGogKz0gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgfVxuXG4gICAgaWYgKGkgPCB0b3RhbENodW5rcykge1xuICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogcGFydGlhbENodW5rSGVpZ2h0ICogNDtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcblxuICAgICAgaWYgKGhhc1RyYW5zZmVyTWFwcykge1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGVsZW1zSW5UaGlzQ2h1bms7IGsgKz0gNCkge1xuICAgICAgICAgIGlmICh0cmFuc2Zlck1hcFJlZCkge1xuICAgICAgICAgICAgZGVzdFtrICsgMF0gPSB0cmFuc2Zlck1hcFJlZFtkZXN0W2sgKyAwXV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRyYW5zZmVyTWFwR3JlZW4pIHtcbiAgICAgICAgICAgIGRlc3RbayArIDFdID0gdHJhbnNmZXJNYXBHcmVlbltkZXN0W2sgKyAxXV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRyYW5zZmVyTWFwQmx1ZSkge1xuICAgICAgICAgICAgZGVzdFtrICsgMl0gPSB0cmFuc2Zlck1hcEJsdWVbZGVzdFtrICsgMl1dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGltZ0RhdGEua2luZCA9PT0gX3V0aWwuSW1hZ2VLaW5kLlJHQl8yNEJQUCkge1xuICAgIGNvbnN0IGhhc1RyYW5zZmVyTWFwcyA9ICEhKHRyYW5zZmVyTWFwUmVkIHx8IHRyYW5zZmVyTWFwR3JlZW4gfHwgdHJhbnNmZXJNYXBCbHVlKTtcbiAgICB0aGlzQ2h1bmtIZWlnaHQgPSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgaWYgKGkgPj0gZnVsbENodW5rcykge1xuICAgICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHRoaXNDaHVua0hlaWdodDtcbiAgICAgIH1cblxuICAgICAgZGVzdFBvcyA9IDA7XG5cbiAgICAgIGZvciAoaiA9IGVsZW1zSW5UaGlzQ2h1bms7IGotLTspIHtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gMjU1O1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzVHJhbnNmZXJNYXBzKSB7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgZGVzdFBvczsgayArPSA0KSB7XG4gICAgICAgICAgaWYgKHRyYW5zZmVyTWFwUmVkKSB7XG4gICAgICAgICAgICBkZXN0W2sgKyAwXSA9IHRyYW5zZmVyTWFwUmVkW2Rlc3RbayArIDBdXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHJhbnNmZXJNYXBHcmVlbikge1xuICAgICAgICAgICAgZGVzdFtrICsgMV0gPSB0cmFuc2Zlck1hcEdyZWVuW2Rlc3RbayArIDFdXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHJhbnNmZXJNYXBCbHVlKSB7XG4gICAgICAgICAgICBkZXN0W2sgKyAyXSA9IHRyYW5zZmVyTWFwQmx1ZVtkZXN0W2sgKyAyXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBpICogRlVMTF9DSFVOS19IRUlHSFQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBpbWFnZSBraW5kOiAke2ltZ0RhdGEua2luZH1gKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdXRCaW5hcnlJbWFnZU1hc2soY3R4LCBpbWdEYXRhKSB7XG4gIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1nRGF0YS5iaXRtYXAsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgICAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gIGNvbnN0IHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gIGNvbnN0IGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgbGV0IHNyY1BvcyA9IDA7XG4gIGNvbnN0IHNyYyA9IGltZ0RhdGEuZGF0YTtcbiAgY29uc3QgZGVzdCA9IGNodW5rSW1nRGF0YS5kYXRhO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgIGNvbnN0IHRoaXNDaHVua0hlaWdodCA9IGkgPCBmdWxsQ2h1bmtzID8gRlVMTF9DSFVOS19IRUlHSFQgOiBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgKHtcbiAgICAgIHNyY1Bvc1xuICAgIH0gPSAoMCwgX2ltYWdlX3V0aWxzLmFwcGx5TWFza0ltYWdlRGF0YSkoe1xuICAgICAgc3JjLFxuICAgICAgc3JjUG9zLFxuICAgICAgZGVzdCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzQ2h1bmtIZWlnaHRcbiAgICB9KSk7XG4gICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weUN0eFN0YXRlKHNvdXJjZUN0eCwgZGVzdEN0eCkge1xuICBjb25zdCBwcm9wZXJ0aWVzID0gW1wic3Ryb2tlU3R5bGVcIiwgXCJmaWxsU3R5bGVcIiwgXCJmaWxsUnVsZVwiLCBcImdsb2JhbEFscGhhXCIsIFwibGluZVdpZHRoXCIsIFwibGluZUNhcFwiLCBcImxpbmVKb2luXCIsIFwibWl0ZXJMaW1pdFwiLCBcImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblwiLCBcImZvbnRcIl07XG5cbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgY29uc3QgcHJvcGVydHkgPSBwcm9wZXJ0aWVzW2ldO1xuXG4gICAgaWYgKHNvdXJjZUN0eFtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdEN0eFtwcm9wZXJ0eV0gPSBzb3VyY2VDdHhbcHJvcGVydHldO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzb3VyY2VDdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgIGRlc3RDdHguc2V0TGluZURhc2goc291cmNlQ3R4LmdldExpbmVEYXNoKCkpO1xuICAgIGRlc3RDdHgubGluZURhc2hPZmZzZXQgPSBzb3VyY2VDdHgubGluZURhc2hPZmZzZXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDdHhUb0RlZmF1bHQoY3R4LCBmb3JlZ3JvdW5kQ29sb3IpIHtcbiAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IGZvcmVncm91bmRDb2xvciB8fCBcIiMwMDAwMDBcIjtcbiAgY3R4LmZpbGxSdWxlID0gXCJub256ZXJvXCI7XG4gIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gIGN0eC5saW5lV2lkdGggPSAxO1xuICBjdHgubGluZUNhcCA9IFwiYnV0dFwiO1xuICBjdHgubGluZUpvaW4gPSBcIm1pdGVyXCI7XG4gIGN0eC5taXRlckxpbWl0ID0gMTA7XG4gIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gIGN0eC5mb250ID0gXCIxMHB4IHNhbnMtc2VyaWZcIjtcblxuICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjdHguc2V0TGluZURhc2goW10pO1xuICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcG9zZVNNYXNrQmFja2Ryb3AoYnl0ZXMsIHIwLCBnMCwgYjApIHtcbiAgY29uc3QgbGVuZ3RoID0gYnl0ZXMubGVuZ3RoO1xuXG4gIGZvciAobGV0IGkgPSAzOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCBhbHBoYSA9IGJ5dGVzW2ldO1xuXG4gICAgaWYgKGFscGhhID09PSAwKSB7XG4gICAgICBieXRlc1tpIC0gM10gPSByMDtcbiAgICAgIGJ5dGVzW2kgLSAyXSA9IGcwO1xuICAgICAgYnl0ZXNbaSAtIDFdID0gYjA7XG4gICAgfSBlbHNlIGlmIChhbHBoYSA8IDI1NSkge1xuICAgICAgY29uc3QgYWxwaGFfID0gMjU1IC0gYWxwaGE7XG4gICAgICBieXRlc1tpIC0gM10gPSBieXRlc1tpIC0gM10gKiBhbHBoYSArIHIwICogYWxwaGFfID4+IDg7XG4gICAgICBieXRlc1tpIC0gMl0gPSBieXRlc1tpIC0gMl0gKiBhbHBoYSArIGcwICogYWxwaGFfID4+IDg7XG4gICAgICBieXRlc1tpIC0gMV0gPSBieXRlc1tpIC0gMV0gKiBhbHBoYSArIGIwICogYWxwaGFfID4+IDg7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBvc2VTTWFza0FscGhhKG1hc2tEYXRhLCBsYXllckRhdGEsIHRyYW5zZmVyTWFwKSB7XG4gIGNvbnN0IGxlbmd0aCA9IG1hc2tEYXRhLmxlbmd0aDtcbiAgY29uc3Qgc2NhbGUgPSAxIC8gMjU1O1xuXG4gIGZvciAobGV0IGkgPSAzOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCBhbHBoYSA9IHRyYW5zZmVyTWFwID8gdHJhbnNmZXJNYXBbbWFza0RhdGFbaV1dIDogbWFza0RhdGFbaV07XG4gICAgbGF5ZXJEYXRhW2ldID0gbGF5ZXJEYXRhW2ldICogYWxwaGEgKiBzY2FsZSB8IDA7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcG9zZVNNYXNrTHVtaW5vc2l0eShtYXNrRGF0YSwgbGF5ZXJEYXRhLCB0cmFuc2Zlck1hcCkge1xuICBjb25zdCBsZW5ndGggPSBtYXNrRGF0YS5sZW5ndGg7XG5cbiAgZm9yIChsZXQgaSA9IDM7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgIGNvbnN0IHkgPSBtYXNrRGF0YVtpIC0gM10gKiA3NyArIG1hc2tEYXRhW2kgLSAyXSAqIDE1MiArIG1hc2tEYXRhW2kgLSAxXSAqIDI4O1xuICAgIGxheWVyRGF0YVtpXSA9IHRyYW5zZmVyTWFwID8gbGF5ZXJEYXRhW2ldICogdHJhbnNmZXJNYXBbeSA+PiA4XSA+PiA4IDogbGF5ZXJEYXRhW2ldICogeSA+PiAxNjtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5lcmljQ29tcG9zZVNNYXNrKG1hc2tDdHgsIGxheWVyQ3R4LCB3aWR0aCwgaGVpZ2h0LCBzdWJ0eXBlLCBiYWNrZHJvcCwgdHJhbnNmZXJNYXAsIGxheWVyT2Zmc2V0WCwgbGF5ZXJPZmZzZXRZLCBtYXNrT2Zmc2V0WCwgbWFza09mZnNldFkpIHtcbiAgY29uc3QgaGFzQmFja2Ryb3AgPSAhIWJhY2tkcm9wO1xuICBjb25zdCByMCA9IGhhc0JhY2tkcm9wID8gYmFja2Ryb3BbMF0gOiAwO1xuICBjb25zdCBnMCA9IGhhc0JhY2tkcm9wID8gYmFja2Ryb3BbMV0gOiAwO1xuICBjb25zdCBiMCA9IGhhc0JhY2tkcm9wID8gYmFja2Ryb3BbMl0gOiAwO1xuICBsZXQgY29tcG9zZUZuO1xuXG4gIGlmIChzdWJ0eXBlID09PSBcIkx1bWlub3NpdHlcIikge1xuICAgIGNvbXBvc2VGbiA9IGNvbXBvc2VTTWFza0x1bWlub3NpdHk7XG4gIH0gZWxzZSB7XG4gICAgY29tcG9zZUZuID0gY29tcG9zZVNNYXNrQWxwaGE7XG4gIH1cblxuICBjb25zdCBQSVhFTFNfVE9fUFJPQ0VTUyA9IDEwNDg1NzY7XG4gIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgubWluKGhlaWdodCwgTWF0aC5jZWlsKFBJWEVMU19UT19QUk9DRVNTIC8gd2lkdGgpKTtcblxuICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBoZWlnaHQ7IHJvdyArPSBjaHVua1NpemUpIHtcbiAgICBjb25zdCBjaHVua0hlaWdodCA9IE1hdGgubWluKGNodW5rU2l6ZSwgaGVpZ2h0IC0gcm93KTtcbiAgICBjb25zdCBtYXNrRGF0YSA9IG1hc2tDdHguZ2V0SW1hZ2VEYXRhKGxheWVyT2Zmc2V0WCAtIG1hc2tPZmZzZXRYLCByb3cgKyAobGF5ZXJPZmZzZXRZIC0gbWFza09mZnNldFkpLCB3aWR0aCwgY2h1bmtIZWlnaHQpO1xuICAgIGNvbnN0IGxheWVyRGF0YSA9IGxheWVyQ3R4LmdldEltYWdlRGF0YShsYXllck9mZnNldFgsIHJvdyArIGxheWVyT2Zmc2V0WSwgd2lkdGgsIGNodW5rSGVpZ2h0KTtcblxuICAgIGlmIChoYXNCYWNrZHJvcCkge1xuICAgICAgY29tcG9zZVNNYXNrQmFja2Ryb3AobWFza0RhdGEuZGF0YSwgcjAsIGcwLCBiMCk7XG4gICAgfVxuXG4gICAgY29tcG9zZUZuKG1hc2tEYXRhLmRhdGEsIGxheWVyRGF0YS5kYXRhLCB0cmFuc2Zlck1hcCk7XG4gICAgbGF5ZXJDdHgucHV0SW1hZ2VEYXRhKGxheWVyRGF0YSwgbGF5ZXJPZmZzZXRYLCByb3cgKyBsYXllck9mZnNldFkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBvc2VTTWFzayhjdHgsIHNtYXNrLCBsYXllckN0eCwgbGF5ZXJCb3gpIHtcbiAgY29uc3QgbGF5ZXJPZmZzZXRYID0gbGF5ZXJCb3hbMF07XG4gIGNvbnN0IGxheWVyT2Zmc2V0WSA9IGxheWVyQm94WzFdO1xuICBjb25zdCBsYXllcldpZHRoID0gbGF5ZXJCb3hbMl0gLSBsYXllck9mZnNldFg7XG4gIGNvbnN0IGxheWVySGVpZ2h0ID0gbGF5ZXJCb3hbM10gLSBsYXllck9mZnNldFk7XG5cbiAgaWYgKGxheWVyV2lkdGggPT09IDAgfHwgbGF5ZXJIZWlnaHQgPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBnZW5lcmljQ29tcG9zZVNNYXNrKHNtYXNrLmNvbnRleHQsIGxheWVyQ3R4LCBsYXllcldpZHRoLCBsYXllckhlaWdodCwgc21hc2suc3VidHlwZSwgc21hc2suYmFja2Ryb3AsIHNtYXNrLnRyYW5zZmVyTWFwLCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgc21hc2sub2Zmc2V0WCwgc21hc2sub2Zmc2V0WSk7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gIGN0eC5kcmF3SW1hZ2UobGF5ZXJDdHguY2FudmFzLCAwLCAwKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKHRyYW5zZm9ybSwgaW50ZXJwb2xhdGUpIHtcbiAgY29uc3Qgc2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRyYW5zZm9ybSk7XG5cbiAgc2NhbGVbMF0gPSBNYXRoLmZyb3VuZChzY2FsZVswXSk7XG4gIHNjYWxlWzFdID0gTWF0aC5mcm91bmQoc2NhbGVbMV0pO1xuICBjb25zdCBhY3R1YWxTY2FsZSA9IE1hdGguZnJvdW5kKChnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgKiBfZGlzcGxheV91dGlscy5QaXhlbHNQZXJJbmNoLlBERl9UT19DU1NfVU5JVFMpO1xuXG4gIGlmIChpbnRlcnBvbGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGludGVycG9sYXRlO1xuICB9IGVsc2UgaWYgKHNjYWxlWzBdIDw9IGFjdHVhbFNjYWxlIHx8IHNjYWxlWzFdIDw9IGFjdHVhbFNjYWxlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmNvbnN0IExJTkVfQ0FQX1NUWUxFUyA9IFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXTtcbmNvbnN0IExJTkVfSk9JTl9TVFlMRVMgPSBbXCJtaXRlclwiLCBcInJvdW5kXCIsIFwiYmV2ZWxcIl07XG5jb25zdCBOT1JNQUxfQ0xJUCA9IHt9O1xuY29uc3QgRU9fQ0xJUCA9IHt9O1xuXG5jbGFzcyBDYW52YXNHcmFwaGljcyB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhc0N0eCwgY29tbW9uT2Jqcywgb2JqcywgY2FudmFzRmFjdG9yeSwgaW1hZ2VMYXllciwgb3B0aW9uYWxDb250ZW50Q29uZmlnLCBhbm5vdGF0aW9uQ2FudmFzTWFwLCBwYWdlQ29sb3JzKSB7XG4gICAgdGhpcy5jdHggPSBjYW52YXNDdHg7XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IENhbnZhc0V4dHJhU3RhdGUodGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLnN0YXRlU3RhY2sgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLnJlcyA9IG51bGw7XG4gICAgdGhpcy54b2JqcyA9IG51bGw7XG4gICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5pbWFnZUxheWVyID0gaW1hZ2VMYXllcjtcbiAgICB0aGlzLmdyb3VwU3RhY2sgPSBbXTtcbiAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gbnVsbDtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCA9IDA7XG4gICAgdGhpcy5zbWFza1N0YWNrID0gW107XG4gICAgdGhpcy5zbWFza0NvdW50ZXIgPSAwO1xuICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IG51bGw7XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sgPSBbXTtcbiAgICB0aGlzLm9wdGlvbmFsQ29udGVudENvbmZpZyA9IG9wdGlvbmFsQ29udGVudENvbmZpZztcbiAgICB0aGlzLmNhY2hlZENhbnZhc2VzID0gbmV3IENhY2hlZENhbnZhc2VzKHRoaXMuY2FudmFzRmFjdG9yeSk7XG4gICAgdGhpcy5jYWNoZWRQYXR0ZXJucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMudmlld3BvcnRTY2FsZSA9IDE7XG4gICAgdGhpcy5vdXRwdXRTY2FsZVggPSAxO1xuICAgIHRoaXMub3V0cHV0U2NhbGVZID0gMTtcbiAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IHBhZ2VDb2xvcnM/LmJhY2tncm91bmQgfHwgbnVsbDtcbiAgICB0aGlzLmZvcmVncm91bmRDb2xvciA9IHBhZ2VDb2xvcnM/LmZvcmVncm91bmQgfHwgbnVsbDtcbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgZ2V0T2JqZWN0KGRhdGEsIGZhbGxiYWNrID0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGRhdGEuc3RhcnRzV2l0aChcImdfXCIpID8gdGhpcy5jb21tb25PYmpzLmdldChkYXRhKSA6IHRoaXMub2Jqcy5nZXQoZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG5cbiAgYmVnaW5EcmF3aW5nKHtcbiAgICB0cmFuc2Zvcm0sXG4gICAgdmlld3BvcnQsXG4gICAgdHJhbnNwYXJlbmN5ID0gZmFsc2UsXG4gICAgYmFja2dyb3VuZCA9IG51bGxcbiAgfSkge1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jdHguY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3QgZGVmYXVsdEJhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmQgfHwgXCIjZmZmZmZmXCI7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuXG4gICAgaWYgKHRoaXMuZm9yZWdyb3VuZENvbG9yICYmIHRoaXMuYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmZvcmVncm91bmRDb2xvcjtcbiAgICAgIGNvbnN0IGZnID0gdGhpcy5mb3JlZ3JvdW5kQ29sb3IgPSB0aGlzLmN0eC5maWxsU3R5bGU7XG4gICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcbiAgICAgIGNvbnN0IGJnID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmN0eC5maWxsU3R5bGU7XG4gICAgICBsZXQgaXNWYWxpZERlZmF1bHRCZyA9IHRydWU7XG4gICAgICBsZXQgZGVmYXVsdEJnID0gZGVmYXVsdEJhY2tncm91bmRDb2xvcjtcbiAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGRlZmF1bHRCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICBkZWZhdWx0QmcgPSB0aGlzLmN0eC5maWxsU3R5bGU7XG4gICAgICBpc1ZhbGlkRGVmYXVsdEJnID0gdHlwZW9mIGRlZmF1bHRCZyA9PT0gXCJzdHJpbmdcIiAmJiAvXiNbMC05QS1GYS1mXXs2fSQvLnRlc3QoZGVmYXVsdEJnKTtcblxuICAgICAgaWYgKGZnID09PSBcIiMwMDAwMDBcIiAmJiBiZyA9PT0gXCIjZmZmZmZmXCIgfHwgZmcgPT09IGJnIHx8ICFpc1ZhbGlkRGVmYXVsdEJnKSB7XG4gICAgICAgIHRoaXMuZm9yZWdyb3VuZENvbG9yID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgW3JCLCBnQiwgYkJdID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldFJHQikoZGVmYXVsdEJnKTtcblxuICAgICAgICBjb25zdCBuZXdDb21wID0geCA9PiB7XG4gICAgICAgICAgeCAvPSAyNTU7XG4gICAgICAgICAgcmV0dXJuIHggPD0gMC4wMzkyOCA/IHggLyAxMi45MiA6ICgoeCArIDAuMDU1KSAvIDEuMDU1KSAqKiAyLjQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbHVtQiA9IE1hdGgucm91bmQoMC4yMTI2ICogbmV3Q29tcChyQikgKyAwLjcxNTIgKiBuZXdDb21wKGdCKSArIDAuMDcyMiAqIG5ld0NvbXAoYkIpKTtcblxuICAgICAgICB0aGlzLnNlbGVjdENvbG9yID0gKHIsIGcsIGIpID0+IHtcbiAgICAgICAgICBjb25zdCBsdW1DID0gMC4yMTI2ICogbmV3Q29tcChyKSArIDAuNzE1MiAqIG5ld0NvbXAoZykgKyAwLjA3MjIgKiBuZXdDb21wKGIpO1xuICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKGx1bUMpID09PSBsdW1CID8gYmcgOiBmZztcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvciB8fCBkZWZhdWx0QmFja2dyb3VuZENvbG9yO1xuICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcblxuICAgIGlmICh0cmFuc3BhcmVuY3kpIHtcbiAgICAgIGNvbnN0IHRyYW5zcGFyZW50Q2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJ0cmFuc3BhcmVudFwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY29tcG9zaXRlQ3R4ID0gdGhpcy5jdHg7XG4gICAgICB0aGlzLnRyYW5zcGFyZW50Q2FudmFzID0gdHJhbnNwYXJlbnRDYW52YXMuY2FudmFzO1xuICAgICAgdGhpcy5jdHggPSB0cmFuc3BhcmVudENhbnZhcy5jb250ZXh0O1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLigwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmNvbXBvc2l0ZUN0eCkpO1xuICAgIH1cblxuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCwgdGhpcy5mb3JlZ3JvdW5kQ29sb3IpO1xuXG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgICB0aGlzLm91dHB1dFNjYWxlWCA9IHRyYW5zZm9ybVswXTtcbiAgICAgIHRoaXMub3V0cHV0U2NhbGVZID0gdHJhbnNmb3JtWzBdO1xuICAgIH1cblxuICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi52aWV3cG9ydC50cmFuc2Zvcm0pO1xuICAgIHRoaXMudmlld3BvcnRTY2FsZSA9IHZpZXdwb3J0LnNjYWxlO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCk7XG5cbiAgICBpZiAodGhpcy5pbWFnZUxheWVyKSB7XG4gICAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoXCJUaGUgYGltYWdlTGF5ZXJgIGZ1bmN0aW9uYWxpdHkgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuXCIpO1xuICAgICAgdGhpcy5pbWFnZUxheWVyLmJlZ2luTGF5b3V0KCk7XG4gICAgfVxuICB9XG5cbiAgZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QsIGV4ZWN1dGlvblN0YXJ0SWR4LCBjb250aW51ZUNhbGxiYWNrLCBzdGVwcGVyKSB7XG4gICAgY29uc3QgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcbiAgICBjb25zdCBmbkFycmF5ID0gb3BlcmF0b3JMaXN0LmZuQXJyYXk7XG4gICAgbGV0IGkgPSBleGVjdXRpb25TdGFydElkeCB8fCAwO1xuICAgIGNvbnN0IGFyZ3NBcnJheUxlbiA9IGFyZ3NBcnJheS5sZW5ndGg7XG5cbiAgICBpZiAoYXJnc0FycmF5TGVuID09PSBpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG5cbiAgICBjb25zdCBjaHVua09wZXJhdGlvbnMgPSBhcmdzQXJyYXlMZW4gLSBpID4gRVhFQ1VUSU9OX1NURVBTICYmIHR5cGVvZiBjb250aW51ZUNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCI7XG4gICAgY29uc3QgZW5kVGltZSA9IGNodW5rT3BlcmF0aW9ucyA/IERhdGUubm93KCkgKyBFWEVDVVRJT05fVElNRSA6IDA7XG4gICAgbGV0IHN0ZXBzID0gMDtcbiAgICBjb25zdCBjb21tb25PYmpzID0gdGhpcy5jb21tb25PYmpzO1xuICAgIGNvbnN0IG9ianMgPSB0aGlzLm9ianM7XG4gICAgbGV0IGZuSWQ7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHN0ZXBwZXIgIT09IHVuZGVmaW5lZCAmJiBpID09PSBzdGVwcGVyLm5leHRCcmVha1BvaW50KSB7XG4gICAgICAgIHN0ZXBwZXIuYnJlYWtJdChpLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG5cbiAgICAgIGZuSWQgPSBmbkFycmF5W2ldO1xuXG4gICAgICBpZiAoZm5JZCAhPT0gX3V0aWwuT1BTLmRlcGVuZGVuY3kpIHtcbiAgICAgICAgdGhpc1tmbklkXS5hcHBseSh0aGlzLCBhcmdzQXJyYXlbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBkZXBPYmpJZCBvZiBhcmdzQXJyYXlbaV0pIHtcbiAgICAgICAgICBjb25zdCBvYmpzUG9vbCA9IGRlcE9iaklkLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IGNvbW1vbk9ianMgOiBvYmpzO1xuXG4gICAgICAgICAgaWYgKCFvYmpzUG9vbC5oYXMoZGVwT2JqSWQpKSB7XG4gICAgICAgICAgICBvYmpzUG9vbC5nZXQoZGVwT2JqSWQsIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGkrKztcblxuICAgICAgaWYgKGkgPT09IGFyZ3NBcnJheUxlbikge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNodW5rT3BlcmF0aW9ucyAmJiArK3N0ZXBzID4gRVhFQ1VUSU9OX1NURVBTKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpID4gZW5kVGltZSkge1xuICAgICAgICAgIGNvbnRpbnVlQ2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ZXBzID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAjcmVzdG9yZUluaXRpYWxTdGF0ZSgpIHtcbiAgICB3aGlsZSAodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCB8fCB0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG5cbiAgICBpZiAodGhpcy50cmFuc3BhcmVudENhbnZhcykge1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmNvbXBvc2l0ZUN0eDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLnRyYW5zcGFyZW50Q2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMudHJhbnNwYXJlbnRDYW52YXMgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGVuZERyYXdpbmcoKSB7XG4gICAgdGhpcy4jcmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMuY2xlYXIoKTtcbiAgICB0aGlzLmNhY2hlZFBhdHRlcm5zLmNsZWFyKCk7XG5cbiAgICBmb3IgKGNvbnN0IGNhY2hlIG9mIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgY2FudmFzIG9mIGNhY2hlLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cblxuICAgIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAuY2xlYXIoKTtcblxuICAgIGlmICh0aGlzLmltYWdlTGF5ZXIpIHtcbiAgICAgIHRoaXMuaW1hZ2VMYXllci5lbmRMYXlvdXQoKTtcbiAgICB9XG4gIH1cblxuICBfc2NhbGVJbWFnZShpbWcsIGludmVyc2VUcmFuc2Zvcm0pIHtcbiAgICBjb25zdCB3aWR0aCA9IGltZy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWcuaGVpZ2h0O1xuICAgIGxldCB3aWR0aFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzBdLCBpbnZlcnNlVHJhbnNmb3JtWzFdKSwgMSk7XG4gICAgbGV0IGhlaWdodFNjYWxlID0gTWF0aC5tYXgoTWF0aC5oeXBvdChpbnZlcnNlVHJhbnNmb3JtWzJdLCBpbnZlcnNlVHJhbnNmb3JtWzNdKSwgMSk7XG4gICAgbGV0IHBhaW50V2lkdGggPSB3aWR0aCxcbiAgICAgICAgcGFpbnRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgbGV0IHRtcENhbnZhc0lkID0gXCJwcmVzY2FsZTFcIjtcbiAgICBsZXQgdG1wQ2FudmFzLCB0bXBDdHg7XG5cbiAgICB3aGlsZSAod2lkdGhTY2FsZSA+IDIgJiYgcGFpbnRXaWR0aCA+IDEgfHwgaGVpZ2h0U2NhbGUgPiAyICYmIHBhaW50SGVpZ2h0ID4gMSkge1xuICAgICAgbGV0IG5ld1dpZHRoID0gcGFpbnRXaWR0aCxcbiAgICAgICAgICBuZXdIZWlnaHQgPSBwYWludEhlaWdodDtcblxuICAgICAgaWYgKHdpZHRoU2NhbGUgPiAyICYmIHBhaW50V2lkdGggPiAxKSB7XG4gICAgICAgIG5ld1dpZHRoID0gTWF0aC5jZWlsKHBhaW50V2lkdGggLyAyKTtcbiAgICAgICAgd2lkdGhTY2FsZSAvPSBwYWludFdpZHRoIC8gbmV3V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGlmIChoZWlnaHRTY2FsZSA+IDIgJiYgcGFpbnRIZWlnaHQgPiAxKSB7XG4gICAgICAgIG5ld0hlaWdodCA9IE1hdGguY2VpbChwYWludEhlaWdodCAvIDIpO1xuICAgICAgICBoZWlnaHRTY2FsZSAvPSBwYWludEhlaWdodCAvIG5ld0hlaWdodDtcbiAgICAgIH1cblxuICAgICAgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXModG1wQ2FudmFzSWQsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICB0bXBDdHguY2xlYXJSZWN0KDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgdG1wQ3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIHBhaW50V2lkdGgsIHBhaW50SGVpZ2h0LCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIGltZyA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgICBwYWludFdpZHRoID0gbmV3V2lkdGg7XG4gICAgICBwYWludEhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgIHRtcENhbnZhc0lkID0gdG1wQ2FudmFzSWQgPT09IFwicHJlc2NhbGUxXCIgPyBcInByZXNjYWxlMlwiIDogXCJwcmVzY2FsZTFcIjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaW1nLFxuICAgICAgcGFpbnRXaWR0aCxcbiAgICAgIHBhaW50SGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIF9jcmVhdGVNYXNrQ2FudmFzKGltZykge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGltZztcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpO1xuICAgIGxldCBjYWNoZSwgY2FjaGVLZXksIHNjYWxlZCwgbWFza0NhbnZhcztcblxuICAgIGlmICgoaW1nLmJpdG1hcCB8fCBpbWcuZGF0YSkgJiYgaW1nLmNvdW50ID4gMSkge1xuICAgICAgY29uc3QgbWFpbktleSA9IGltZy5iaXRtYXAgfHwgaW1nLmRhdGEuYnVmZmVyO1xuICAgICAgY29uc3Qgd2l0aG91dFRyYW5zbGF0aW9uID0gY3VycmVudFRyYW5zZm9ybS5zbGljZSgwLCA0KTtcbiAgICAgIGNhY2hlS2V5ID0gSlNPTi5zdHJpbmdpZnkoaXNQYXR0ZXJuRmlsbCA/IHdpdGhvdXRUcmFuc2xhdGlvbiA6IFt3aXRob3V0VHJhbnNsYXRpb24sIGZpbGxDb2xvcl0pO1xuICAgICAgY2FjaGUgPSB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLmdldChtYWluS2V5KTtcblxuICAgICAgaWYgKCFjYWNoZSkge1xuICAgICAgICBjYWNoZSA9IG5ldyBNYXAoKTtcblxuICAgICAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwLnNldChtYWluS2V5LCBjYWNoZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNhY2hlZEltYWdlID0gY2FjaGUuZ2V0KGNhY2hlS2V5KTtcblxuICAgICAgaWYgKGNhY2hlZEltYWdlICYmICFpc1BhdHRlcm5GaWxsKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLnJvdW5kKE1hdGgubWluKGN1cnJlbnRUcmFuc2Zvcm1bMF0sIGN1cnJlbnRUcmFuc2Zvcm1bMl0pICsgY3VycmVudFRyYW5zZm9ybVs0XSk7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLnJvdW5kKE1hdGgubWluKGN1cnJlbnRUcmFuc2Zvcm1bMV0sIGN1cnJlbnRUcmFuc2Zvcm1bM10pICsgY3VycmVudFRyYW5zZm9ybVs1XSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FudmFzOiBjYWNoZWRJbWFnZSxcbiAgICAgICAgICBvZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc2NhbGVkID0gY2FjaGVkSW1hZ2U7XG4gICAgfVxuXG4gICAgaWYgKCFzY2FsZWQpIHtcbiAgICAgIG1hc2tDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tDYW52YXNcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBwdXRCaW5hcnlJbWFnZU1hc2sobWFza0NhbnZhcy5jb250ZXh0LCBpbWcpO1xuICAgIH1cblxuICAgIGxldCBtYXNrVG9DYW52YXMgPSBfdXRpbC5VdGlsLnRyYW5zZm9ybShjdXJyZW50VHJhbnNmb3JtLCBbMSAvIHdpZHRoLCAwLCAwLCAtMSAvIGhlaWdodCwgMCwgMF0pO1xuXG4gICAgbWFza1RvQ2FudmFzID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0obWFza1RvQ2FudmFzLCBbMSwgMCwgMCwgMSwgMCwgLWhlaWdodF0pO1xuXG4gICAgY29uc3QgY29yZDEgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFswLCAwXSwgbWFza1RvQ2FudmFzKTtcblxuICAgIGNvbnN0IGNvcmQyID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbd2lkdGgsIGhlaWdodF0sIG1hc2tUb0NhbnZhcyk7XG5cbiAgICBjb25zdCByZWN0ID0gX3V0aWwuVXRpbC5ub3JtYWxpemVSZWN0KFtjb3JkMVswXSwgY29yZDFbMV0sIGNvcmQyWzBdLCBjb3JkMlsxXV0pO1xuXG4gICAgY29uc3QgZHJhd25XaWR0aCA9IE1hdGgucm91bmQocmVjdFsyXSAtIHJlY3RbMF0pIHx8IDE7XG4gICAgY29uc3QgZHJhd25IZWlnaHQgPSBNYXRoLnJvdW5kKHJlY3RbM10gLSByZWN0WzFdKSB8fCAxO1xuICAgIGNvbnN0IGZpbGxDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImZpbGxDYW52YXNcIiwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQpO1xuICAgIGNvbnN0IGZpbGxDdHggPSBmaWxsQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGgubWluKGNvcmQxWzBdLCBjb3JkMlswXSk7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IE1hdGgubWluKGNvcmQxWzFdLCBjb3JkMlsxXSk7XG4gICAgZmlsbEN0eC50cmFuc2xhdGUoLW9mZnNldFgsIC1vZmZzZXRZKTtcbiAgICBmaWxsQ3R4LnRyYW5zZm9ybSguLi5tYXNrVG9DYW52YXMpO1xuXG4gICAgaWYgKCFzY2FsZWQpIHtcbiAgICAgIHNjYWxlZCA9IHRoaXMuX3NjYWxlSW1hZ2UobWFza0NhbnZhcy5jYW52YXMsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoZmlsbEN0eCkpO1xuICAgICAgc2NhbGVkID0gc2NhbGVkLmltZztcblxuICAgICAgaWYgKGNhY2hlICYmIGlzUGF0dGVybkZpbGwpIHtcbiAgICAgICAgY2FjaGUuc2V0KGNhY2hlS2V5LCBzY2FsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpbGxDdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKCgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShmaWxsQ3R4KSwgaW1nLmludGVycG9sYXRlKTtcbiAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoZmlsbEN0eCwgc2NhbGVkLCAwLCAwLCBzY2FsZWQud2lkdGgsIHNjYWxlZC5oZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGZpbGxDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2UtaW5cIjtcblxuICAgIGNvbnN0IGludmVyc2UgPSBfdXRpbC5VdGlsLnRyYW5zZm9ybSgoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGZpbGxDdHgpLCBbMSwgMCwgMCwgMSwgLW9mZnNldFgsIC1vZmZzZXRZXSk7XG5cbiAgICBmaWxsQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsIGludmVyc2UsIF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5GSUxMKSA6IGZpbGxDb2xvcjtcbiAgICBmaWxsQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgaWYgKGNhY2hlICYmICFpc1BhdHRlcm5GaWxsKSB7XG4gICAgICB0aGlzLmNhY2hlZENhbnZhc2VzLmRlbGV0ZShcImZpbGxDYW52YXNcIik7XG4gICAgICBjYWNoZS5zZXQoY2FjaGVLZXksIGZpbGxDYW52YXMuY2FudmFzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzOiBmaWxsQ2FudmFzLmNhbnZhcyxcbiAgICAgIG9mZnNldFg6IE1hdGgucm91bmQob2Zmc2V0WCksXG4gICAgICBvZmZzZXRZOiBNYXRoLnJvdW5kKG9mZnNldFkpXG4gICAgfTtcbiAgfVxuXG4gIHNldExpbmVXaWR0aCh3aWR0aCkge1xuICAgIGlmICh3aWR0aCAhPT0gdGhpcy5jdXJyZW50LmxpbmVXaWR0aCkge1xuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xuICB9XG5cbiAgc2V0TGluZUNhcChzdHlsZSkge1xuICAgIHRoaXMuY3R4LmxpbmVDYXAgPSBMSU5FX0NBUF9TVFlMRVNbc3R5bGVdO1xuICB9XG5cbiAgc2V0TGluZUpvaW4oc3R5bGUpIHtcbiAgICB0aGlzLmN0eC5saW5lSm9pbiA9IExJTkVfSk9JTl9TVFlMRVNbc3R5bGVdO1xuICB9XG5cbiAgc2V0TWl0ZXJMaW1pdChsaW1pdCkge1xuICAgIHRoaXMuY3R4Lm1pdGVyTGltaXQgPSBsaW1pdDtcbiAgfVxuXG4gIHNldERhc2goZGFzaEFycmF5LCBkYXNoUGhhc2UpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcblxuICAgIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoUGhhc2U7XG4gICAgfVxuICB9XG5cbiAgc2V0UmVuZGVyaW5nSW50ZW50KGludGVudCkge31cblxuICBzZXRGbGF0bmVzcyhmbGF0bmVzcykge31cblxuICBzZXRHU3RhdGUoc3RhdGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3RhdGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzW2ldO1xuICAgICAgY29uc3Qga2V5ID0gc3RhdGVbMF07XG4gICAgICBjb25zdCB2YWx1ZSA9IHN0YXRlWzFdO1xuXG4gICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICBjYXNlIFwiTFdcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVXaWR0aCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkxDXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lQ2FwKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiTEpcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVKb2luKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiTUxcIjpcbiAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgdGhpcy5zZXREYXNoKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIlJJXCI6XG4gICAgICAgICAgdGhpcy5zZXRSZW5kZXJpbmdJbnRlbnQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJGTFwiOlxuICAgICAgICAgIHRoaXMuc2V0RmxhdG5lc3ModmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgdGhpcy5zZXRGb250KHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkNBXCI6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnN0cm9rZUFscGhhID0gc3RhdGVbMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcImNhXCI6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmZpbGxBbHBoYSA9IHN0YXRlWzFdO1xuICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gc3RhdGVbMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkJNXCI6XG4gICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIlNNYXNrXCI6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrID0gdmFsdWUgPyB0aGlzLnRlbXBTTWFzayA6IG51bGw7XG4gICAgICAgICAgdGhpcy50ZW1wU01hc2sgPSBudWxsO1xuICAgICAgICAgIHRoaXMuY2hlY2tTTWFza1N0YXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIlRSXCI6XG4gICAgICAgICAgdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBpblNNYXNrTW9kZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLnN1c3BlbmRlZEN0eDtcbiAgfVxuXG4gIGNoZWNrU01hc2tTdGF0ZSgpIHtcbiAgICBjb25zdCBpblNNYXNrTW9kZSA9IHRoaXMuaW5TTWFza01vZGU7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmICFpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5iZWdpblNNYXNrTW9kZSgpO1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuY3VycmVudC5hY3RpdmVTTWFzayAmJiBpblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICB9XG4gIH1cblxuICBiZWdpblNNYXNrTW9kZSgpIHtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmVnaW5TTWFza01vZGUgY2FsbGVkIHdoaWxlIGFscmVhZHkgaW4gc21hc2sgbW9kZVwiKTtcbiAgICB9XG5cbiAgICBjb25zdCBkcmF3bldpZHRoID0gdGhpcy5jdHguY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGRyYXduSGVpZ2h0ID0gdGhpcy5jdHguY2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBjYWNoZUlkID0gXCJzbWFza0dyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICBjb25zdCBzY3JhdGNoQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoY2FjaGVJZCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQpO1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gdGhpcy5jdHg7XG4gICAgdGhpcy5jdHggPSBzY3JhdGNoQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY3R4LnNldFRyYW5zZm9ybSguLi4oMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5zdXNwZW5kZWRDdHgpKTtcbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5zdXNwZW5kZWRDdHgsIGN0eCk7XG4gICAgbWlycm9yQ29udGV4dE9wZXJhdGlvbnMoY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgdGhpcy5zZXRHU3RhdGUoW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICB9XG5cbiAgZW5kU01hc2tNb2RlKCkge1xuICAgIGlmICghdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW5kU01hc2tNb2RlIGNhbGxlZCB3aGlsZSBub3QgaW4gc21hc2sgbW9kZVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmN0eC5fcmVtb3ZlTWlycm9yaW5nKCk7XG5cbiAgICBjb3B5Q3R4U3RhdGUodGhpcy5jdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICB0aGlzLmN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIHRoaXMuc3VzcGVuZGVkQ3R4ID0gbnVsbDtcbiAgfVxuXG4gIGNvbXBvc2UoZGlydHlCb3gpIHtcbiAgICBpZiAoIXRoaXMuY3VycmVudC5hY3RpdmVTTWFzaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghZGlydHlCb3gpIHtcbiAgICAgIGRpcnR5Qm94ID0gWzAsIDAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcnR5Qm94WzBdID0gTWF0aC5mbG9vcihkaXJ0eUJveFswXSk7XG4gICAgICBkaXJ0eUJveFsxXSA9IE1hdGguZmxvb3IoZGlydHlCb3hbMV0pO1xuICAgICAgZGlydHlCb3hbMl0gPSBNYXRoLmNlaWwoZGlydHlCb3hbMl0pO1xuICAgICAgZGlydHlCb3hbM10gPSBNYXRoLmNlaWwoZGlydHlCb3hbM10pO1xuICAgIH1cblxuICAgIGNvbnN0IHNtYXNrID0gdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrO1xuICAgIGNvbnN0IHN1c3BlbmRlZEN0eCA9IHRoaXMuc3VzcGVuZGVkQ3R4O1xuICAgIGNvbXBvc2VTTWFzayhzdXNwZW5kZWRDdHgsIHNtYXNrLCB0aGlzLmN0eCwgZGlydHlCb3gpO1xuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgc2F2ZSgpIHtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgY29weUN0eFN0YXRlKHRoaXMuY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgICB0aGlzLnN1c3BlbmRlZEN0eC5zYXZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBvbGQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgdGhpcy5zdGF0ZVN0YWNrLnB1c2gob2xkKTtcbiAgICB0aGlzLmN1cnJlbnQgPSBvbGQuY2xvbmUoKTtcbiAgfVxuXG4gIHJlc3RvcmUoKSB7XG4gICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggPT09IDAgJiYgdGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhpcy5lbmRTTWFza01vZGUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZVN0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5zdGF0ZVN0YWNrLnBvcCgpO1xuXG4gICAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgICB0aGlzLnN1c3BlbmRlZEN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGNvcHlDdHhTdGF0ZSh0aGlzLnN1c3BlbmRlZEN0eCwgdGhpcy5jdHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNoZWNrU01hc2tTdGF0ZSgpO1xuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nID0gbnVsbDtcbiAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgdGhpcy5jdHgudHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmcgPSBudWxsO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICB9XG5cbiAgY29uc3RydWN0UGF0aChvcHMsIGFyZ3MsIG1pbk1heCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgbGV0IHggPSBjdXJyZW50LngsXG4gICAgICAgIHkgPSBjdXJyZW50Lnk7XG4gICAgbGV0IHN0YXJ0WCwgc3RhcnRZO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KTtcbiAgICBjb25zdCBpc1NjYWxpbmdNYXRyaXggPSBjdXJyZW50VHJhbnNmb3JtWzBdID09PSAwICYmIGN1cnJlbnRUcmFuc2Zvcm1bM10gPT09IDAgfHwgY3VycmVudFRyYW5zZm9ybVsxXSA9PT0gMCAmJiBjdXJyZW50VHJhbnNmb3JtWzJdID09PSAwO1xuICAgIGNvbnN0IG1pbk1heEZvckJlemllciA9IGlzU2NhbGluZ01hdHJpeCA/IG1pbk1heC5zbGljZSgwKSA6IG51bGw7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDAsIGlpID0gb3BzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHN3aXRjaCAob3BzW2ldIHwgMCkge1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5yZWN0YW5nbGU6XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCB4dyA9IHggKyB3aWR0aDtcbiAgICAgICAgICBjb25zdCB5aCA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcblxuICAgICAgICAgIGlmICh3aWR0aCA9PT0gMCB8fCBoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeHcsIHloKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4dywgeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHh3LCB5aCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHloKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgICAgICAgY3VycmVudC51cGRhdGVSZWN0TWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIFt4LCB5LCB4dywgeWhdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5PUFMubW92ZVRvOlxuICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuXG4gICAgICAgICAgaWYgKCFpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQudXBkYXRlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCB4LCB5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIF91dGlsLk9QUy5saW5lVG86XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG5cbiAgICAgICAgICBpZiAoIWlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgICAgICAgY3VycmVudC51cGRhdGVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHgsIHkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmN1cnZlVG86XG4gICAgICAgICAgc3RhcnRYID0geDtcbiAgICAgICAgICBzdGFydFkgPSB5O1xuICAgICAgICAgIHggPSBhcmdzW2ogKyA0XTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgNV07XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSwgeCwgeSk7XG4gICAgICAgICAgY3VycmVudC51cGRhdGVDdXJ2ZVBhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgc3RhcnRYLCBzdGFydFksIGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCBhcmdzW2ogKyAyXSwgYXJnc1tqICsgM10sIHgsIHksIG1pbk1heEZvckJlemllcik7XG4gICAgICAgICAgaiArPSA2O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmN1cnZlVG8yOlxuICAgICAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICAgICAgc3RhcnRZID0geTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5LCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdKTtcbiAgICAgICAgICBjdXJyZW50LnVwZGF0ZUN1cnZlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBzdGFydFgsIHN0YXJ0WSwgeCwgeSwgYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvMzpcbiAgICAgICAgICBzdGFydFggPSB4O1xuICAgICAgICAgIHN0YXJ0WSA9IHk7XG4gICAgICAgICAgeCA9IGFyZ3NbaiArIDJdO1xuICAgICAgICAgIHkgPSBhcmdzW2ogKyAzXTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhhcmdzW2pdLCBhcmdzW2ogKyAxXSwgeCwgeSwgeCwgeSk7XG4gICAgICAgICAgY3VycmVudC51cGRhdGVDdXJ2ZVBhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgc3RhcnRYLCBzdGFydFksIGFyZ3Nbal0sIGFyZ3NbaiArIDFdLCB4LCB5LCB4LCB5LCBtaW5NYXhGb3JCZXppZXIpO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZVBhdGg6XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgIGN1cnJlbnQudXBkYXRlU2NhbGluZ1BhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICB9XG5cbiAgICBjdXJyZW50LnNldEN1cnJlbnRQb2ludCh4LCB5KTtcbiAgfVxuXG4gIGNsb3NlUGF0aCgpIHtcbiAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgfVxuXG4gIHN0cm9rZShjb25zdW1lUGF0aCkge1xuICAgIGNvbnN1bWVQYXRoID0gdHlwZW9mIGNvbnN1bWVQYXRoICE9PSBcInVuZGVmaW5lZFwiID8gY29uc3VtZVBhdGggOiB0cnVlO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5zdHJva2VBbHBoYTtcblxuICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cm9rZUNvbG9yID09PSBcIm9iamVjdFwiICYmIHN0cm9rZUNvbG9yPy5nZXRQYXR0ZXJuKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGN0eCksIF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5TVFJPS0UpO1xuICAgICAgICB0aGlzLnJlc2NhbGVBbmRTdHJva2UoZmFsc2UpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXNjYWxlQW5kU3Ryb2tlKHRydWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb25zdW1lUGF0aCkge1xuICAgICAgdGhpcy5jb25zdW1lUGF0aCh0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpKTtcbiAgICB9XG5cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmN1cnJlbnQuZmlsbEFscGhhO1xuICB9XG5cbiAgY2xvc2VTdHJva2UoKSB7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLnN0cm9rZSgpO1xuICB9XG5cbiAgZmlsbChjb25zdW1lUGF0aCkge1xuICAgIGNvbnN1bWVQYXRoID0gdHlwZW9mIGNvbnN1bWVQYXRoICE9PSBcInVuZGVmaW5lZFwiID8gY29uc3VtZVBhdGggOiB0cnVlO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3QgaXNQYXR0ZXJuRmlsbCA9IHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBsZXQgbmVlZFJlc3RvcmUgPSBmYWxzZTtcblxuICAgIGlmIChpc1BhdHRlcm5GaWxsKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxDb2xvci5nZXRQYXR0ZXJuKGN0eCwgdGhpcywgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShjdHgpLCBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuRklMTCk7XG4gICAgICBuZWVkUmVzdG9yZSA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3QgaW50ZXJzZWN0ID0gdGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKTtcblxuICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlICYmIGludGVyc2VjdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucGVuZGluZ0VPRmlsbCkge1xuICAgICAgICBjdHguZmlsbChcImV2ZW5vZGRcIik7XG4gICAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVlZFJlc3RvcmUpIHtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnN1bWVQYXRoKSB7XG4gICAgICB0aGlzLmNvbnN1bWVQYXRoKGludGVyc2VjdCk7XG4gICAgfVxuICB9XG5cbiAgZW9GaWxsKCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsKCk7XG4gIH1cblxuICBmaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMuZmlsbChmYWxzZSk7XG4gICAgdGhpcy5zdHJva2UoZmFsc2UpO1xuICAgIHRoaXMuY29uc3VtZVBhdGgoKTtcbiAgfVxuXG4gIGVvRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG5cbiAgY2xvc2VGaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gIH1cblxuICBjbG9zZUVPRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSB0cnVlO1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gIH1cblxuICBlbmRQYXRoKCkge1xuICAgIHRoaXMuY29uc3VtZVBhdGgoKTtcbiAgfVxuXG4gIGNsaXAoKSB7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IE5PUk1BTF9DTElQO1xuICB9XG5cbiAgZW9DbGlwKCkge1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBFT19DTElQO1xuICB9XG5cbiAgYmVnaW5UZXh0KCkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSAxO1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYID0gMDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSA9IDA7XG4gIH1cblxuICBlbmRUZXh0KCkge1xuICAgIGNvbnN0IHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuXG4gICAgaWYgKHBhdGhzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcblxuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5wYXRoLnRyYW5zZm9ybSk7XG4gICAgICBjdHgudHJhbnNsYXRlKHBhdGgueCwgcGF0aC55KTtcbiAgICAgIHBhdGguYWRkVG9QYXRoKGN0eCwgcGF0aC5mb250U2l6ZSk7XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBjdHguY2xpcCgpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nVGV4dFBhdGhzO1xuICB9XG5cbiAgc2V0Q2hhclNwYWNpbmcoc3BhY2luZykge1xuICAgIHRoaXMuY3VycmVudC5jaGFyU3BhY2luZyA9IHNwYWNpbmc7XG4gIH1cblxuICBzZXRXb3JkU3BhY2luZyhzcGFjaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LndvcmRTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuXG4gIHNldEhTY2FsZShzY2FsZSkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0SFNjYWxlID0gc2NhbGUgLyAxMDA7XG4gIH1cblxuICBzZXRMZWFkaW5nKGxlYWRpbmcpIHtcbiAgICB0aGlzLmN1cnJlbnQubGVhZGluZyA9IC1sZWFkaW5nO1xuICB9XG5cbiAgc2V0Rm9udChmb250UmVmTmFtZSwgc2l6ZSkge1xuICAgIGNvbnN0IGZvbnRPYmogPSB0aGlzLmNvbW1vbk9ianMuZ2V0KGZvbnRSZWZOYW1lKTtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuXG4gICAgaWYgKCFmb250T2JqKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGZpbmQgZm9udCBmb3IgJHtmb250UmVmTmFtZX1gKTtcbiAgICB9XG5cbiAgICBjdXJyZW50LmZvbnRNYXRyaXggPSBmb250T2JqLmZvbnRNYXRyaXggfHwgX3V0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG5cbiAgICBpZiAoY3VycmVudC5mb250TWF0cml4WzBdID09PSAwIHx8IGN1cnJlbnQuZm9udE1hdHJpeFszXSA9PT0gMCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwiSW52YWxpZCBmb250IG1hdHJpeCBmb3IgZm9udCBcIiArIGZvbnRSZWZOYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoc2l6ZSA8IDApIHtcbiAgICAgIHNpemUgPSAtc2l6ZTtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAxO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudC5mb250ID0gZm9udE9iajtcbiAgICB0aGlzLmN1cnJlbnQuZm9udFNpemUgPSBzaXplO1xuXG4gICAgaWYgKGZvbnRPYmouaXNUeXBlM0ZvbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBuYW1lID0gZm9udE9iai5sb2FkZWROYW1lIHx8IFwic2Fucy1zZXJpZlwiO1xuICAgIGxldCBib2xkID0gXCJub3JtYWxcIjtcblxuICAgIGlmIChmb250T2JqLmJsYWNrKSB7XG4gICAgICBib2xkID0gXCI5MDBcIjtcbiAgICB9IGVsc2UgaWYgKGZvbnRPYmouYm9sZCkge1xuICAgICAgYm9sZCA9IFwiYm9sZFwiO1xuICAgIH1cblxuICAgIGNvbnN0IGl0YWxpYyA9IGZvbnRPYmouaXRhbGljID8gXCJpdGFsaWNcIiA6IFwibm9ybWFsXCI7XG4gICAgY29uc3QgdHlwZWZhY2UgPSBgXCIke25hbWV9XCIsICR7Zm9udE9iai5mYWxsYmFja05hbWV9YDtcbiAgICBsZXQgYnJvd3NlckZvbnRTaXplID0gc2l6ZTtcblxuICAgIGlmIChzaXplIDwgTUlOX0ZPTlRfU0laRSkge1xuICAgICAgYnJvd3NlckZvbnRTaXplID0gTUlOX0ZPTlRfU0laRTtcbiAgICB9IGVsc2UgaWYgKHNpemUgPiBNQVhfRk9OVF9TSVpFKSB7XG4gICAgICBicm93c2VyRm9udFNpemUgPSBNQVhfRk9OVF9TSVpFO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudC5mb250U2l6ZVNjYWxlID0gc2l6ZSAvIGJyb3dzZXJGb250U2l6ZTtcbiAgICB0aGlzLmN0eC5mb250ID0gYCR7aXRhbGljfSAke2JvbGR9ICR7YnJvd3NlckZvbnRTaXplfXB4ICR7dHlwZWZhY2V9YDtcbiAgfVxuXG4gIHNldFRleHRSZW5kZXJpbmdNb2RlKG1vZGUpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPSBtb2RlO1xuICB9XG5cbiAgc2V0VGV4dFJpc2UocmlzZSkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0UmlzZSA9IHJpc2U7XG4gIH1cblxuICBtb3ZlVGV4dCh4LCB5KSB7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggKz0geDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSArPSB5O1xuICB9XG5cbiAgc2V0TGVhZGluZ01vdmVUZXh0KHgsIHkpIHtcbiAgICB0aGlzLnNldExlYWRpbmcoLXkpO1xuICAgIHRoaXMubW92ZVRleHQoeCwgeSk7XG4gIH1cblxuICBzZXRUZXh0TWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeCA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgICB0aGlzLmN1cnJlbnQueCA9IHRoaXMuY3VycmVudC5saW5lWCA9IDA7XG4gICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgPSAwO1xuICB9XG5cbiAgbmV4dExpbmUoKSB7XG4gICAgdGhpcy5tb3ZlVGV4dCgwLCB0aGlzLmN1cnJlbnQubGVhZGluZyk7XG4gIH1cblxuICBwYWludENoYXIoY2hhcmFjdGVyLCB4LCB5LCBwYXR0ZXJuVHJhbnNmb3JtKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGNvbnN0IHRleHRSZW5kZXJpbmdNb2RlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZTtcbiAgICBjb25zdCBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemUgLyBjdXJyZW50LmZvbnRTaXplU2NhbGU7XG4gICAgY29uc3QgZmlsbFN0cm9rZU1vZGUgPSB0ZXh0UmVuZGVyaW5nTW9kZSAmIF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFX01BU0s7XG4gICAgY29uc3QgaXNBZGRUb1BhdGhTZXQgPSAhISh0ZXh0UmVuZGVyaW5nTW9kZSAmIF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIX0ZMQUcpO1xuICAgIGNvbnN0IHBhdHRlcm5GaWxsID0gY3VycmVudC5wYXR0ZXJuRmlsbCAmJiAhZm9udC5taXNzaW5nRmlsZTtcbiAgICBsZXQgYWRkVG9QYXRoO1xuXG4gICAgaWYgKGZvbnQuZGlzYWJsZUZvbnRGYWNlIHx8IGlzQWRkVG9QYXRoU2V0IHx8IHBhdHRlcm5GaWxsKSB7XG4gICAgICBhZGRUb1BhdGggPSBmb250LmdldFBhdGhHZW5lcmF0b3IodGhpcy5jb21tb25PYmpzLCBjaGFyYWN0ZXIpO1xuICAgIH1cblxuICAgIGlmIChmb250LmRpc2FibGVGb250RmFjZSB8fCBwYXR0ZXJuRmlsbCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRUb1BhdGgoY3R4LCBmb250U2l6ZSk7XG5cbiAgICAgIGlmIChwYXR0ZXJuVHJhbnNmb3JtKSB7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4ucGF0dGVyblRyYW5zZm9ybSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBjdHguZmlsbFRleHQoY2hhcmFjdGVyLCB4LCB5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5zdHJva2VUZXh0KGNoYXJhY3RlciwgeCwgeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQWRkVG9QYXRoU2V0KSB7XG4gICAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocyB8fCAodGhpcy5wZW5kaW5nVGV4dFBhdGhzID0gW10pO1xuICAgICAgcGF0aHMucHVzaCh7XG4gICAgICAgIHRyYW5zZm9ybTogKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCksXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgICAgIGZvbnRTaXplLFxuICAgICAgICBhZGRUb1BhdGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldCBpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0OiBjdHhcbiAgICB9ID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCAxMCwgMTApO1xuICAgIGN0eC5zY2FsZSgxLjUsIDEpO1xuICAgIGN0eC5maWxsVGV4dChcIklcIiwgMCwgMTApO1xuICAgIGNvbnN0IGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEwLCAxMCkuZGF0YTtcbiAgICBsZXQgZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgZm9yIChsZXQgaSA9IDM7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICBpZiAoZGF0YVtpXSA+IDAgJiYgZGF0YVtpXSA8IDI1NSkge1xuICAgICAgICBlbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWRcIiwgZW5hYmxlZCk7XG4gIH1cblxuICBzaG93VGV4dChnbHlwaHMpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG5cbiAgICBpZiAoZm9udC5pc1R5cGUzRm9udCkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hvd1R5cGUzVGV4dChnbHlwaHMpO1xuICAgIH1cblxuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcblxuICAgIGlmIChmb250U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBmb250U2l6ZVNjYWxlID0gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgIGNvbnN0IGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICBjb25zdCB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgY29uc3QgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBnbHlwaHNMZW5ndGggPSBnbHlwaHMubGVuZ3RoO1xuICAgIGNvbnN0IHZlcnRpY2FsID0gZm9udC52ZXJ0aWNhbDtcbiAgICBjb25zdCBzcGFjaW5nRGlyID0gdmVydGljYWwgPyAxIDogLTE7XG4gICAgY29uc3QgZGVmYXVsdFZNZXRyaWNzID0gZm9udC5kZWZhdWx0Vk1ldHJpY3M7XG4gICAgY29uc3Qgd2lkdGhBZHZhbmNlU2NhbGUgPSBmb250U2l6ZSAqIGN1cnJlbnQuZm9udE1hdHJpeFswXTtcbiAgICBjb25zdCBzaW1wbGVGaWxsVGV4dCA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEwgJiYgIWZvbnQuZGlzYWJsZUZvbnRGYWNlICYmICFjdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zZm9ybSguLi5jdXJyZW50LnRleHRNYXRyaXgpO1xuICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkgKyBjdXJyZW50LnRleHRSaXNlKTtcblxuICAgIGlmIChmb250RGlyZWN0aW9uID4gMCkge1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIC0xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIDEpO1xuICAgIH1cblxuICAgIGxldCBwYXR0ZXJuVHJhbnNmb3JtO1xuXG4gICAgaWYgKGN1cnJlbnQucGF0dGVybkZpbGwpIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gY3VycmVudC5maWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KSwgX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLkZJTEwpO1xuICAgICAgcGF0dGVyblRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBwYXR0ZXJuO1xuICAgIH1cblxuICAgIGxldCBsaW5lV2lkdGggPSBjdXJyZW50LmxpbmVXaWR0aDtcbiAgICBjb25zdCBzY2FsZSA9IGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlO1xuXG4gICAgaWYgKHNjYWxlID09PSAwIHx8IGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgY29uc3QgZmlsbFN0cm9rZU1vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcblxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGxpbmVXaWR0aCA9IHRoaXMuZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lV2lkdGggLz0gc2NhbGU7XG4gICAgfVxuXG4gICAgaWYgKGZvbnRTaXplU2NhbGUgIT09IDEuMCkge1xuICAgICAgY3R4LnNjYWxlKGZvbnRTaXplU2NhbGUsIGZvbnRTaXplU2NhbGUpO1xuICAgICAgbGluZVdpZHRoIC89IGZvbnRTaXplU2NhbGU7XG4gICAgfVxuXG4gICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICBsZXQgeCA9IDAsXG4gICAgICAgIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IGdseXBoID0gZ2x5cGhzW2ldO1xuXG4gICAgICBpZiAodHlwZW9mIGdseXBoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHggKz0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGV0IHJlc3RvcmVOZWVkZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgIGNvbnN0IGNoYXJhY3RlciA9IGdseXBoLmZvbnRDaGFyO1xuICAgICAgY29uc3QgYWNjZW50ID0gZ2x5cGguYWNjZW50O1xuICAgICAgbGV0IHNjYWxlZFgsIHNjYWxlZFk7XG4gICAgICBsZXQgd2lkdGggPSBnbHlwaC53aWR0aDtcblxuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIGNvbnN0IHZtZXRyaWMgPSBnbHlwaC52bWV0cmljIHx8IGRlZmF1bHRWTWV0cmljcztcbiAgICAgICAgY29uc3QgdnggPSAtKGdseXBoLnZtZXRyaWMgPyB2bWV0cmljWzFdIDogd2lkdGggKiAwLjUpICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIGNvbnN0IHZ5ID0gdm1ldHJpY1syXSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICB3aWR0aCA9IHZtZXRyaWMgPyAtdm1ldHJpY1swXSA6IHdpZHRoO1xuICAgICAgICBzY2FsZWRYID0gdnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gKHggKyB2eSkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVkWCA9IHggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gMDtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvbnQucmVtZWFzdXJlICYmIHdpZHRoID4gMCkge1xuICAgICAgICBjb25zdCBtZWFzdXJlZFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGNoYXJhY3Rlcikud2lkdGggKiAxMDAwIC8gZm9udFNpemUgKiBmb250U2l6ZVNjYWxlO1xuXG4gICAgICAgIGlmICh3aWR0aCA8IG1lYXN1cmVkV2lkdGggJiYgdGhpcy5pc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCkge1xuICAgICAgICAgIGNvbnN0IGNoYXJhY3RlclNjYWxlWCA9IHdpZHRoIC8gbWVhc3VyZWRXaWR0aDtcbiAgICAgICAgICByZXN0b3JlTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIGN0eC5zY2FsZShjaGFyYWN0ZXJTY2FsZVgsIDEpO1xuICAgICAgICAgIHNjYWxlZFggLz0gY2hhcmFjdGVyU2NhbGVYO1xuICAgICAgICB9IGVsc2UgaWYgKHdpZHRoICE9PSBtZWFzdXJlZFdpZHRoKSB7XG4gICAgICAgICAgc2NhbGVkWCArPSAod2lkdGggLSBtZWFzdXJlZFdpZHRoKSAvIDIwMDAgKiBmb250U2l6ZSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29udGVudFZpc2libGUgJiYgKGdseXBoLmlzSW5Gb250IHx8IGZvbnQubWlzc2luZ0ZpbGUpKSB7XG4gICAgICAgIGlmIChzaW1wbGVGaWxsVGV4dCAmJiAhYWNjZW50KSB7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3Rlciwgc2NhbGVkWCwgc2NhbGVkWSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5wYWludENoYXIoY2hhcmFjdGVyLCBzY2FsZWRYLCBzY2FsZWRZLCBwYXR0ZXJuVHJhbnNmb3JtKTtcblxuICAgICAgICAgIGlmIChhY2NlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZEFjY2VudFggPSBzY2FsZWRYICsgZm9udFNpemUgKiBhY2NlbnQub2Zmc2V0LnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkQWNjZW50WSA9IHNjYWxlZFkgLSBmb250U2l6ZSAqIGFjY2VudC5vZmZzZXQueSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICB0aGlzLnBhaW50Q2hhcihhY2NlbnQuZm9udENoYXIsIHNjYWxlZEFjY2VudFgsIHNjYWxlZEFjY2VudFksIHBhdHRlcm5UcmFuc2Zvcm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsZXQgY2hhcldpZHRoO1xuXG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgY2hhcldpZHRoID0gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSAtIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhcldpZHRoID0gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSArIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uO1xuICAgICAgfVxuXG4gICAgICB4ICs9IGNoYXJXaWR0aDtcblxuICAgICAgaWYgKHJlc3RvcmVOZWVkZWQpIHtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIGN1cnJlbnQueSAtPSB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnggKz0geCAqIHRleHRIU2NhbGU7XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgc2hvd1R5cGUzVGV4dChnbHlwaHMpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IGZvbnQudmVydGljYWwgPyAxIDogLTE7XG4gICAgY29uc3QgY2hhclNwYWNpbmcgPSBjdXJyZW50LmNoYXJTcGFjaW5nO1xuICAgIGNvbnN0IHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCBmb250TWF0cml4ID0gY3VycmVudC5mb250TWF0cml4IHx8IF91dGlsLkZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgIGNvbnN0IGdseXBoc0xlbmd0aCA9IGdseXBocy5sZW5ndGg7XG4gICAgY29uc3QgaXNUZXh0SW52aXNpYmxlID0gY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuSU5WSVNJQkxFO1xuICAgIGxldCBpLCBnbHlwaCwgd2lkdGgsIHNwYWNpbmdMZW5ndGg7XG5cbiAgICBpZiAoaXNUZXh0SW52aXNpYmxlIHx8IGZvbnRTaXplID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZyA9IG51bGw7XG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNmb3JtKC4uLmN1cnJlbnQudGV4dE1hdHJpeCk7XG4gICAgY3R4LnRyYW5zbGF0ZShjdXJyZW50LngsIGN1cnJlbnQueSk7XG4gICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIGZvbnREaXJlY3Rpb24pO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGdseXBoc0xlbmd0aDsgKytpKSB7XG4gICAgICBnbHlwaCA9IGdseXBoc1tpXTtcblxuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzcGFjaW5nTGVuZ3RoID0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUoc3BhY2luZ0xlbmd0aCwgMCk7XG4gICAgICAgIGN1cnJlbnQueCArPSBzcGFjaW5nTGVuZ3RoICogdGV4dEhTY2FsZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgIGNvbnN0IG9wZXJhdG9yTGlzdCA9IGZvbnQuY2hhclByb2NPcGVyYXRvckxpc3RbZ2x5cGgub3BlcmF0b3JMaXN0SWRdO1xuXG4gICAgICBpZiAoIW9wZXJhdG9yTGlzdCkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoYFR5cGUzIGNoYXJhY3RlciBcIiR7Z2x5cGgub3BlcmF0b3JMaXN0SWR9XCIgaXMgbm90IGF2YWlsYWJsZS5gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gZ2x5cGg7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICBjdHguc2NhbGUoZm9udFNpemUsIGZvbnRTaXplKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi5mb250TWF0cml4KTtcbiAgICAgICAgdGhpcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW2dseXBoLndpZHRoLCAwXSwgZm9udE1hdHJpeCk7XG5cbiAgICAgIHdpZHRoID0gdHJhbnNmb3JtZWRbMF0gKiBmb250U2l6ZSArIHNwYWNpbmc7XG4gICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLCAwKTtcbiAgICAgIGN1cnJlbnQueCArPSB3aWR0aCAqIHRleHRIU2NhbGU7XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IG51bGw7XG4gIH1cblxuICBzZXRDaGFyV2lkdGgoeFdpZHRoLCB5V2lkdGgpIHt9XG5cbiAgc2V0Q2hhcldpZHRoQW5kQm91bmRzKHhXaWR0aCwgeVdpZHRoLCBsbHgsIGxseSwgdXJ4LCB1cnkpIHtcbiAgICB0aGlzLmN0eC5yZWN0KGxseCwgbGx5LCB1cnggLSBsbHgsIHVyeSAtIGxseSk7XG4gICAgdGhpcy5jdHguY2xpcCgpO1xuICAgIHRoaXMuZW5kUGF0aCgpO1xuICB9XG5cbiAgZ2V0Q29sb3JOX1BhdHRlcm4oSVIpIHtcbiAgICBsZXQgcGF0dGVybjtcblxuICAgIGlmIChJUlswXSA9PT0gXCJUaWxpbmdQYXR0ZXJuXCIpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gSVJbMV07XG4gICAgICBjb25zdCBiYXNlVHJhbnNmb3JtID0gdGhpcy5iYXNlVHJhbnNmb3JtIHx8ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCk7XG4gICAgICBjb25zdCBjYW52YXNHcmFwaGljc0ZhY3RvcnkgPSB7XG4gICAgICAgIGNyZWF0ZUNhbnZhc0dyYXBoaWNzOiBjdHggPT4ge1xuICAgICAgICAgIHJldHVybiBuZXcgQ2FudmFzR3JhcGhpY3MoY3R4LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHBhdHRlcm4gPSBuZXcgX3BhdHRlcm5faGVscGVyLlRpbGluZ1BhdHRlcm4oSVIsIGNvbG9yLCB0aGlzLmN0eCwgY2FudmFzR3JhcGhpY3NGYWN0b3J5LCBiYXNlVHJhbnNmb3JtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0dGVybiA9IHRoaXMuX2dldFBhdHRlcm4oSVJbMV0sIElSWzJdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuXG4gIHNldFN0cm9rZUNvbG9yTigpIHtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKGFyZ3VtZW50cyk7XG4gIH1cblxuICBzZXRGaWxsQ29sb3JOKCkge1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSB0aGlzLmdldENvbG9yTl9QYXR0ZXJuKGFyZ3VtZW50cyk7XG4gICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gdHJ1ZTtcbiAgfVxuXG4gIHNldFN0cm9rZVJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuc2VsZWN0Q29sb3I/LihyLCBnLCBiKSB8fCBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcblxuICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gY29sb3I7XG4gIH1cblxuICBzZXRGaWxsUkdCQ29sb3IociwgZywgYikge1xuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5zZWxlY3RDb2xvcj8uKHIsIGcsIGIpIHx8IF91dGlsLlV0aWwubWFrZUhleENvbG9yKHIsIGcsIGIpO1xuXG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbCA9IGZhbHNlO1xuICB9XG5cbiAgX2dldFBhdHRlcm4ob2JqSWQsIG1hdHJpeCA9IG51bGwpIHtcbiAgICBsZXQgcGF0dGVybjtcblxuICAgIGlmICh0aGlzLmNhY2hlZFBhdHRlcm5zLmhhcyhvYmpJZCkpIHtcbiAgICAgIHBhdHRlcm4gPSB0aGlzLmNhY2hlZFBhdHRlcm5zLmdldChvYmpJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm4gPSAoMCwgX3BhdHRlcm5faGVscGVyLmdldFNoYWRpbmdQYXR0ZXJuKSh0aGlzLm9ianMuZ2V0KG9iaklkKSk7XG4gICAgICB0aGlzLmNhY2hlZFBhdHRlcm5zLnNldChvYmpJZCwgcGF0dGVybik7XG4gICAgfVxuXG4gICAgaWYgKG1hdHJpeCkge1xuICAgICAgcGF0dGVybi5tYXRyaXggPSBtYXRyaXg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cblxuICBzaGFkaW5nRmlsbChvYmpJZCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIHRoaXMuc2F2ZSgpO1xuXG4gICAgY29uc3QgcGF0dGVybiA9IHRoaXMuX2dldFBhdHRlcm4ob2JqSWQpO1xuXG4gICAgY3R4LmZpbGxTdHlsZSA9IHBhdHRlcm4uZ2V0UGF0dGVybihjdHgsIHRoaXMsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KSwgX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLlNIQURJTkcpO1xuICAgIGNvbnN0IGludiA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KTtcblxuICAgIGlmIChpbnYpIHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gICAgICBjb25zdCB3aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG5cbiAgICAgIGNvbnN0IGJsID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbMCwgMF0sIGludik7XG5cbiAgICAgIGNvbnN0IGJyID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbMCwgaGVpZ2h0XSwgaW52KTtcblxuICAgICAgY29uc3QgdWwgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt3aWR0aCwgMF0sIGludik7XG5cbiAgICAgIGNvbnN0IHVyID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbd2lkdGgsIGhlaWdodF0sIGludik7XG5cbiAgICAgIGNvbnN0IHgwID0gTWF0aC5taW4oYmxbMF0sIGJyWzBdLCB1bFswXSwgdXJbMF0pO1xuICAgICAgY29uc3QgeTAgPSBNYXRoLm1pbihibFsxXSwgYnJbMV0sIHVsWzFdLCB1clsxXSk7XG4gICAgICBjb25zdCB4MSA9IE1hdGgubWF4KGJsWzBdLCBiclswXSwgdWxbMF0sIHVyWzBdKTtcbiAgICAgIGNvbnN0IHkxID0gTWF0aC5tYXgoYmxbMV0sIGJyWzFdLCB1bFsxXSwgdXJbMV0pO1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoeDAsIHkwLCB4MSAtIHgwLCB5MSAtIHkwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoLTFlMTAsIC0xZTEwLCAyZTEwLCAyZTEwKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbXBvc2UodGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cblxuICBiZWdpbklubGluZUltYWdlKCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJTaG91bGQgbm90IGNhbGwgYmVnaW5JbmxpbmVJbWFnZVwiKTtcbiAgfVxuXG4gIGJlZ2luSW1hZ2VEYXRhKCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJTaG91bGQgbm90IGNhbGwgYmVnaW5JbWFnZURhdGFcIik7XG4gIH1cblxuICBwYWludEZvcm1YT2JqZWN0QmVnaW4obWF0cml4LCBiYm94KSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zYXZlKCk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtU3RhY2sucHVzaCh0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0cml4KSAmJiBtYXRyaXgubGVuZ3RoID09PSA2KSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybSguLi5tYXRyaXgpO1xuICAgIH1cblxuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCk7XG5cbiAgICBpZiAoYmJveCkge1xuICAgICAgY29uc3Qgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgICAgIGNvbnN0IGhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuICAgICAgdGhpcy5jdHgucmVjdChiYm94WzBdLCBiYm94WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMuY3VycmVudC51cGRhdGVSZWN0TWluTWF4KCgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCksIGJib3gpO1xuICAgICAgdGhpcy5jbGlwKCk7XG4gICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICB9XG4gIH1cblxuICBwYWludEZvcm1YT2JqZWN0RW5kKCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybVN0YWNrLnBvcCgpO1xuICB9XG5cbiAgYmVnaW5Hcm91cChncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuc2F2ZSgpO1xuXG4gICAgaWYgKHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMuZW5kU01hc2tNb2RlKCk7XG4gICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRDdHggPSB0aGlzLmN0eDtcblxuICAgIGlmICghZ3JvdXAuaXNvbGF0ZWQpIHtcbiAgICAgICgwLCBfdXRpbC5pbmZvKShcIlRPRE86IFN1cHBvcnQgbm9uLWlzb2xhdGVkIGdyb3Vwcy5cIik7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLmtub2Nrb3V0KSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJLbm9ja291dCBncm91cHMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdXJyZW50Q3R4KTtcblxuICAgIGlmIChncm91cC5tYXRyaXgpIHtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNmb3JtKC4uLmdyb3VwLm1hdHJpeCk7XG4gICAgfVxuXG4gICAgaWYgKCFncm91cC5iYm94KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3VuZGluZyBib3ggaXMgcmVxdWlyZWQuXCIpO1xuICAgIH1cblxuICAgIGxldCBib3VuZHMgPSBfdXRpbC5VdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KGdyb3VwLmJib3gsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdXJyZW50Q3R4KSk7XG5cbiAgICBjb25zdCBjYW52YXNCb3VuZHMgPSBbMCwgMCwgY3VycmVudEN0eC5jYW52YXMud2lkdGgsIGN1cnJlbnRDdHguY2FudmFzLmhlaWdodF07XG4gICAgYm91bmRzID0gX3V0aWwuVXRpbC5pbnRlcnNlY3QoYm91bmRzLCBjYW52YXNCb3VuZHMpIHx8IFswLCAwLCAwLCAwXTtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5mbG9vcihib3VuZHNbMF0pO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmZsb29yKGJvdW5kc1sxXSk7XG4gICAgbGV0IGRyYXduV2lkdGggPSBNYXRoLm1heChNYXRoLmNlaWwoYm91bmRzWzJdKSAtIG9mZnNldFgsIDEpO1xuICAgIGxldCBkcmF3bkhlaWdodCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbM10pIC0gb2Zmc2V0WSwgMSk7XG4gICAgbGV0IHNjYWxlWCA9IDEsXG4gICAgICAgIHNjYWxlWSA9IDE7XG5cbiAgICBpZiAoZHJhd25XaWR0aCA+IE1BWF9HUk9VUF9TSVpFKSB7XG4gICAgICBzY2FsZVggPSBkcmF3bldpZHRoIC8gTUFYX0dST1VQX1NJWkU7XG4gICAgICBkcmF3bldpZHRoID0gTUFYX0dST1VQX1NJWkU7XG4gICAgfVxuXG4gICAgaWYgKGRyYXduSGVpZ2h0ID4gTUFYX0dST1VQX1NJWkUpIHtcbiAgICAgIHNjYWxlWSA9IGRyYXduSGVpZ2h0IC8gTUFYX0dST1VQX1NJWkU7XG4gICAgICBkcmF3bkhlaWdodCA9IE1BWF9HUk9VUF9TSVpFO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudC5zdGFydE5ld1BhdGhBbmRDbGlwQm94KFswLCAwLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodF0pO1xuICAgIGxldCBjYWNoZUlkID0gXCJncm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG5cbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIGNhY2hlSWQgKz0gXCJfc21hc2tfXCIgKyB0aGlzLnNtYXNrQ291bnRlcisrICUgMjtcbiAgICB9XG5cbiAgICBjb25zdCBzY3JhdGNoQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoY2FjaGVJZCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQpO1xuICAgIGNvbnN0IGdyb3VwQ3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgIGdyb3VwQ3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgIGdyb3VwQ3R4LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICAgIGdyb3VwQ3R4LnRyYW5zZm9ybSguLi5jdXJyZW50VHJhbnNmb3JtKTtcblxuICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgdGhpcy5zbWFza1N0YWNrLnB1c2goe1xuICAgICAgICBjYW52YXM6IHNjcmF0Y2hDYW52YXMuY2FudmFzLFxuICAgICAgICBjb250ZXh0OiBncm91cEN0eCxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICAgICAgc2NhbGVYLFxuICAgICAgICBzY2FsZVksXG4gICAgICAgIHN1YnR5cGU6IGdyb3VwLnNtYXNrLnN1YnR5cGUsXG4gICAgICAgIGJhY2tkcm9wOiBncm91cC5zbWFzay5iYWNrZHJvcCxcbiAgICAgICAgdHJhbnNmZXJNYXA6IGdyb3VwLnNtYXNrLnRyYW5zZmVyTWFwIHx8IG51bGwsXG4gICAgICAgIHN0YXJ0VHJhbnNmb3JtSW52ZXJzZTogbnVsbFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgY3VycmVudEN0eC50cmFuc2xhdGUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICBjdXJyZW50Q3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgIGN1cnJlbnRDdHguc2F2ZSgpO1xuICAgIH1cblxuICAgIGNvcHlDdHhTdGF0ZShjdXJyZW50Q3R4LCBncm91cEN0eCk7XG4gICAgdGhpcy5jdHggPSBncm91cEN0eDtcbiAgICB0aGlzLnNldEdTdGF0ZShbW1wiQk1cIiwgXCJzb3VyY2Utb3ZlclwiXSwgW1wiY2FcIiwgMV0sIFtcIkNBXCIsIDFdXSk7XG4gICAgdGhpcy5ncm91cFN0YWNrLnB1c2goY3VycmVudEN0eCk7XG4gICAgdGhpcy5ncm91cExldmVsKys7XG4gIH1cblxuICBlbmRHcm91cChncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZ3JvdXBMZXZlbC0tO1xuICAgIGNvbnN0IGdyb3VwQ3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5ncm91cFN0YWNrLnBvcCgpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICB0aGlzLnRlbXBTTWFzayA9IHRoaXMuc21hc2tTdGFjay5wb3AoKTtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICBjb25zdCBjdXJyZW50TXR4ID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KTtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKC4uLmN1cnJlbnRNdHgpO1xuXG4gICAgICBjb25zdCBkaXJ0eUJveCA9IF91dGlsLlV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIGdyb3VwQ3R4LmNhbnZhcy53aWR0aCwgZ3JvdXBDdHguY2FudmFzLmhlaWdodF0sIGN1cnJlbnRNdHgpO1xuXG4gICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoZ3JvdXBDdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuY29tcG9zZShkaXJ0eUJveCk7XG4gICAgfVxuICB9XG5cbiAgYmVnaW5Bbm5vdGF0aW9uKGlkLCByZWN0LCB0cmFuc2Zvcm0sIG1hdHJpeCwgaGFzT3duQ2FudmFzKSB7XG4gICAgdGhpcy4jcmVzdG9yZUluaXRpYWxTdGF0ZSgpO1xuICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4LCB0aGlzLmZvcmVncm91bmRDb2xvcik7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHRoaXMuc2F2ZSgpO1xuXG4gICAgaWYgKHRoaXMuYmFzZVRyYW5zZm9ybSkge1xuICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKC4uLnRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVjdCkgJiYgcmVjdC5sZW5ndGggPT09IDQpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gcmVjdFsyXSAtIHJlY3RbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSByZWN0WzNdIC0gcmVjdFsxXTtcblxuICAgICAgaWYgKGhhc093bkNhbnZhcyAmJiB0aGlzLmFubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtLnNsaWNlKCk7XG4gICAgICAgIHRyYW5zZm9ybVs0XSAtPSByZWN0WzBdO1xuICAgICAgICB0cmFuc2Zvcm1bNV0gLT0gcmVjdFsxXTtcbiAgICAgICAgcmVjdCA9IHJlY3Quc2xpY2UoKTtcbiAgICAgICAgcmVjdFswXSA9IHJlY3RbMV0gPSAwO1xuICAgICAgICByZWN0WzJdID0gd2lkdGg7XG4gICAgICAgIHJlY3RbM10gPSBoZWlnaHQ7XG5cbiAgICAgICAgY29uc3QgW3NjYWxlWCwgc2NhbGVZXSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUoKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KSk7XG5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHZpZXdwb3J0U2NhbGVcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogdGhpcy5vdXRwdXRTY2FsZVggKiB2aWV3cG9ydFNjYWxlKTtcbiAgICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIHRoaXMub3V0cHV0U2NhbGVZICogdmlld3BvcnRTY2FsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhcyA9IHRoaXMuY2FudmFzRmFjdG9yeS5jcmVhdGUoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9ID0gdGhpcy5hbm5vdGF0aW9uQ2FudmFzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAuc2V0KGlkLCBjYW52YXMpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHggPSB0aGlzLmN0eDtcbiAgICAgICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oc2NhbGVYLCAwLCAwLCAtc2NhbGVZLCAwLCBoZWlnaHQgKiBzY2FsZVkpO1xuICAgICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCwgdGhpcy5mb3JlZ3JvdW5kQ29sb3IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgsIHRoaXMuZm9yZWdyb3VuZENvbG9yKTtcbiAgICAgICAgdGhpcy5jdHgucmVjdChyZWN0WzBdLCByZWN0WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jdHguY2xpcCgpO1xuICAgICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSh0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMudHJhbnNmb3JtKC4uLnRyYW5zZm9ybSk7XG4gICAgdGhpcy50cmFuc2Zvcm0oLi4ubWF0cml4KTtcbiAgfVxuXG4gIGVuZEFubm90YXRpb24oKSB7XG4gICAgaWYgKHRoaXMuYW5ub3RhdGlvbkNhbnZhcykge1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHg7XG4gICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uQ2FudmFzLnNhdmVkQ3R4O1xuICAgICAgZGVsZXRlIHRoaXMuYW5ub3RhdGlvbkNhbnZhcztcbiAgICB9XG4gIH1cblxuICBwYWludEltYWdlTWFza1hPYmplY3QoaW1nKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY291bnQgPSBpbWcuY291bnQ7XG4gICAgaW1nID0gdGhpcy5nZXRPYmplY3QoaW1nLmRhdGEsIGltZyk7XG4gICAgaW1nLmNvdW50ID0gY291bnQ7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZ2x5cGggPSB0aGlzLnByb2Nlc3NpbmdUeXBlMztcblxuICAgIGlmIChnbHlwaCkge1xuICAgICAgaWYgKGdseXBoLmNvbXBpbGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2x5cGguY29tcGlsZWQgPSBjb21waWxlVHlwZTNHbHlwaChpbWcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2x5cGguY29tcGlsZWQpIHtcbiAgICAgICAgZ2x5cGguY29tcGlsZWQoY3R4KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG1hc2sgPSB0aGlzLl9jcmVhdGVNYXNrQ2FudmFzKGltZyk7XG5cbiAgICBjb25zdCBtYXNrQ2FudmFzID0gbWFzay5jYW52YXM7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGN0eC5kcmF3SW1hZ2UobWFza0NhbnZhcywgbWFzay5vZmZzZXRYLCBtYXNrLm9mZnNldFkpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cblxuICBwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQoaW1nLCBzY2FsZVgsIHNrZXdYID0gMCwgc2tld1kgPSAwLCBzY2FsZVksIHBvc2l0aW9ucykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGltZyA9IHRoaXMuZ2V0T2JqZWN0KGltZy5kYXRhLCBpbWcpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpO1xuICAgIGN0eC50cmFuc2Zvcm0oc2NhbGVYLCBza2V3WCwgc2tld1ksIHNjYWxlWSwgMCwgMCk7XG5cbiAgICBjb25zdCBtYXNrID0gdGhpcy5fY3JlYXRlTWFza0NhbnZhcyhpbWcpO1xuXG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBjb25zdCB0cmFucyA9IF91dGlsLlV0aWwudHJhbnNmb3JtKGN1cnJlbnRUcmFuc2Zvcm0sIFtzY2FsZVgsIHNrZXdYLCBza2V3WSwgc2NhbGVZLCBwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tpICsgMV1dKTtcblxuICAgICAgY29uc3QgW3gsIHldID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbMCwgMF0sIHRyYW5zKTtcblxuICAgICAgY3R4LmRyYXdJbWFnZShtYXNrLmNhbnZhcywgeCwgeSk7XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuXG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwKGltYWdlcykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3QgaXNQYXR0ZXJuRmlsbCA9IHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbDtcblxuICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgaW1hZ2VzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHRyYW5zZm9ybVxuICAgICAgfSA9IGltYWdlO1xuICAgICAgY29uc3QgbWFza0NhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0NhbnZhc1wiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IG1hc2tDdHggPSBtYXNrQ2FudmFzLmNvbnRleHQ7XG4gICAgICBtYXNrQ3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IGltZyA9IHRoaXMuZ2V0T2JqZWN0KGRhdGEsIGltYWdlKTtcbiAgICAgIHB1dEJpbmFyeUltYWdlTWFzayhtYXNrQ3R4LCBpbWcpO1xuICAgICAgbWFza0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgICAgbWFza0N0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4obWFza0N0eCwgdGhpcywgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShjdHgpLCBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuRklMTCkgOiBmaWxsQ29sb3I7XG4gICAgICBtYXNrQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgbWFza0N0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIG1hc2tDYW52YXMuY2FudmFzLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCAwLCAtMSwgMSwgMSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG5cbiAgcGFpbnRJbWFnZVhPYmplY3Qob2JqSWQpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob2JqSWQpO1xuXG4gICAgaWYgKCFpbWdEYXRhKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJEZXBlbmRlbnQgaW1hZ2UgaXNuJ3QgcmVhZHkgeWV0XCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSk7XG4gIH1cblxuICBwYWludEltYWdlWE9iamVjdFJlcGVhdChvYmpJZCwgc2NhbGVYLCBzY2FsZVksIHBvc2l0aW9ucykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvYmpJZCk7XG5cbiAgICBpZiAoIWltZ0RhdGEpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcIkRlcGVuZGVudCBpbWFnZSBpc24ndCByZWFkeSB5ZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgIGNvbnN0IG1hcCA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGlpOyBpICs9IDIpIHtcbiAgICAgIG1hcC5wdXNoKHtcbiAgICAgICAgdHJhbnNmb3JtOiBbc2NhbGVYLCAwLCAwLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0sXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHc6IHdpZHRoLFxuICAgICAgICBoOiBoZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cChpbWdEYXRhLCBtYXApO1xuICB9XG5cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLnNhdmUoKTtcbiAgICBjdHguc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgbGV0IGltZ1RvUGFpbnQ7XG5cbiAgICBpZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSBcImZ1bmN0aW9uXCIgJiYgaW1nRGF0YSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IHx8ICFpbWdEYXRhLmRhdGEpIHtcbiAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhLCB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzKTtcbiAgICAgIGltZ1RvUGFpbnQgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgIH1cblxuICAgIGNvbnN0IHNjYWxlZCA9IHRoaXMuX3NjYWxlSW1hZ2UoaW1nVG9QYWludCwgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShjdHgpKTtcblxuICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCksIGltZ0RhdGEuaW50ZXJwb2xhdGUpO1xuICAgIGNvbnN0IFtyV2lkdGgsIHJIZWlnaHRdID0gZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgc2NhbGVkLmltZywgMCwgMCwgc2NhbGVkLnBhaW50V2lkdGgsIHNjYWxlZC5wYWludEhlaWdodCwgMCwgLWhlaWdodCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBpZiAodGhpcy5pbWFnZUxheWVyKSB7XG4gICAgICBjb25zdCBbbGVmdCwgdG9wXSA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oWzAsIC1oZWlnaHRdLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpKTtcblxuICAgICAgdGhpcy5pbWFnZUxheWVyLmFwcGVuZEltYWdlKHtcbiAgICAgICAgaW1nRGF0YSxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgdG9wLFxuICAgICAgICB3aWR0aDogcldpZHRoLFxuICAgICAgICBoZWlnaHQ6IHJIZWlnaHRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY29tcG9zZSgpO1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG5cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cChpbWdEYXRhLCBtYXApIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBjb25zdCB3ID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3LCBoKTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhLCB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzKTtcblxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgbWFwKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi5lbnRyeS50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIHRtcENhbnZhcy5jYW52YXMsIGVudHJ5LngsIGVudHJ5LnksIGVudHJ5LncsIGVudHJ5LmgsIDAsIC0xLCAxLCAxKTtcblxuICAgICAgaWYgKHRoaXMuaW1hZ2VMYXllcikge1xuICAgICAgICBjb25zdCBbbGVmdCwgdG9wXSA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW2VudHJ5LngsIGVudHJ5LnldLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpKTtcblxuICAgICAgICB0aGlzLmltYWdlTGF5ZXIuYXBwZW5kSW1hZ2Uoe1xuICAgICAgICAgIGltZ0RhdGEsXG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgaGVpZ2h0OiBoXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG5cbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrKCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgIHRoaXMuY29tcG9zZSgpO1xuICB9XG5cbiAgbWFya1BvaW50KHRhZykge31cblxuICBtYXJrUG9pbnRQcm9wcyh0YWcsIHByb3BlcnRpZXMpIHt9XG5cbiAgYmVnaW5NYXJrZWRDb250ZW50KHRhZykge1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgYmVnaW5NYXJrZWRDb250ZW50UHJvcHModGFnLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKHRhZyA9PT0gXCJPQ1wiKSB7XG4gICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgICAgdmlzaWJsZTogdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcuaXNWaXNpYmxlKHByb3BlcnRpZXMpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucHVzaCh7XG4gICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0aGlzLmlzQ29udGVudFZpc2libGUoKTtcbiAgfVxuXG4gIGVuZE1hcmtlZENvbnRlbnQoKSB7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucG9wKCk7XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRoaXMuaXNDb250ZW50VmlzaWJsZSgpO1xuICB9XG5cbiAgYmVnaW5Db21wYXQoKSB7fVxuXG4gIGVuZENvbXBhdCgpIHt9XG5cbiAgY29uc3VtZVBhdGgoY2xpcEJveCkge1xuICAgIGNvbnN0IGlzRW1wdHkgPSB0aGlzLmN1cnJlbnQuaXNFbXB0eUNsaXAoKTtcblxuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICB0aGlzLmN1cnJlbnQudXBkYXRlQ2xpcEZyb21QYXRoKCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICB0aGlzLmNvbXBvc2UoY2xpcEJveCk7XG4gICAgfVxuXG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG5cbiAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwID09PSBFT19DTElQKSB7XG4gICAgICAgICAgY3R4LmNsaXAoXCJldmVub2RkXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0eC5jbGlwKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJyZW50LnN0YXJ0TmV3UGF0aEFuZENsaXBCb3godGhpcy5jdXJyZW50LmNsaXBCb3gpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgfVxuXG4gIGdldFNpbmdsZVBpeGVsV2lkdGgoKSB7XG4gICAgaWYgKCF0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoKSB7XG4gICAgICBjb25zdCBtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KTtcblxuICAgICAgaWYgKG1bMV0gPT09IDAgJiYgbVsyXSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gMSAvIE1hdGgubWluKE1hdGguYWJzKG1bMF0pLCBNYXRoLmFicyhtWzNdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYnNEZXQgPSBNYXRoLmFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKTtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmh5cG90KG1bMF0sIG1bMl0pO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguaHlwb3QobVsxXSwgbVszXSk7XG4gICAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBNYXRoLm1heChub3JtWCwgbm9ybVkpIC8gYWJzRGV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoO1xuICB9XG5cbiAgZ2V0U2NhbGVGb3JTdHJva2luZygpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmcpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGluZVdpZHRoXG4gICAgICB9ID0gdGhpcy5jdXJyZW50O1xuICAgICAgY29uc3QgbSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCk7XG4gICAgICBsZXQgc2NhbGVYLCBzY2FsZVk7XG5cbiAgICAgIGlmIChtWzFdID09PSAwICYmIG1bMl0gPT09IDApIHtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmFicyhtWzBdKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmFicyhtWzNdKTtcblxuICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgc2NhbGVYID0gMSAvIG5vcm1YO1xuICAgICAgICAgIHNjYWxlWSA9IDEgLyBub3JtWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBzY2FsZWRYTGluZVdpZHRoID0gbm9ybVggKiBsaW5lV2lkdGg7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkWUxpbmVXaWR0aCA9IG5vcm1ZICogbGluZVdpZHRoO1xuICAgICAgICAgIHNjYWxlWCA9IHNjYWxlZFhMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFhMaW5lV2lkdGggOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IHNjYWxlZFlMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZFlMaW5lV2lkdGggOiAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYnNEZXQgPSBNYXRoLmFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKTtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmh5cG90KG1bMF0sIG1bMV0pO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguaHlwb3QobVsyXSwgbVszXSk7XG5cbiAgICAgICAgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIHNjYWxlWCA9IG5vcm1ZIC8gYWJzRGV0O1xuICAgICAgICAgIHNjYWxlWSA9IG5vcm1YIC8gYWJzRGV0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGJhc2VBcmVhID0gbGluZVdpZHRoICogYWJzRGV0O1xuICAgICAgICAgIHNjYWxlWCA9IG5vcm1ZID4gYmFzZUFyZWEgPyBub3JtWSAvIGJhc2VBcmVhIDogMTtcbiAgICAgICAgICBzY2FsZVkgPSBub3JtWCA+IGJhc2VBcmVhID8gbm9ybVggLyBiYXNlQXJlYSA6IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZyA9IFtzY2FsZVgsIHNjYWxlWV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmc7XG4gIH1cblxuICByZXNjYWxlQW5kU3Ryb2tlKHNhdmVSZXN0b3JlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3R4XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qge1xuICAgICAgbGluZVdpZHRoXG4gICAgfSA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBbc2NhbGVYLCBzY2FsZVldID0gdGhpcy5nZXRTY2FsZUZvclN0cm9raW5nKCk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aCB8fCAxO1xuXG4gICAgaWYgKHNjYWxlWCA9PT0gMSAmJiBzY2FsZVkgPT09IDEpIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgc2F2ZWRNYXRyaXgsIHNhdmVkRGFzaGVzLCBzYXZlZERhc2hPZmZzZXQ7XG5cbiAgICBpZiAoc2F2ZVJlc3RvcmUpIHtcbiAgICAgIHNhdmVkTWF0cml4ID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCk7XG4gICAgICBzYXZlZERhc2hlcyA9IGN0eC5nZXRMaW5lRGFzaCgpLnNsaWNlKCk7XG4gICAgICBzYXZlZERhc2hPZmZzZXQgPSBjdHgubGluZURhc2hPZmZzZXQ7XG4gICAgfVxuXG4gICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICBjb25zdCBzY2FsZSA9IE1hdGgubWF4KHNjYWxlWCwgc2NhbGVZKTtcbiAgICBjdHguc2V0TGluZURhc2goY3R4LmdldExpbmVEYXNoKCkubWFwKHggPT4geCAvIHNjYWxlKSk7XG4gICAgY3R4LmxpbmVEYXNoT2Zmc2V0IC89IHNjYWxlO1xuICAgIGN0eC5zdHJva2UoKTtcblxuICAgIGlmIChzYXZlUmVzdG9yZSkge1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5zYXZlZE1hdHJpeCk7XG4gICAgICBjdHguc2V0TGluZURhc2goc2F2ZWREYXNoZXMpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gc2F2ZWREYXNoT2Zmc2V0O1xuICAgIH1cbiAgfVxuXG4gIGlzQ29udGVudFZpc2libGUoKSB7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMubWFya2VkQ29udGVudFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoIXRoaXMubWFya2VkQ29udGVudFN0YWNrW2ldLnZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn1cblxuZXhwb3J0cy5DYW52YXNHcmFwaGljcyA9IENhbnZhc0dyYXBoaWNzO1xuXG5mb3IgKGNvbnN0IG9wIGluIF91dGlsLk9QUykge1xuICBpZiAoQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW29wXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW191dGlsLk9QU1tvcF1dID0gQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW29wXTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlRpbGluZ1BhdHRlcm4gPSBleHBvcnRzLlBhdGhUeXBlID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRTaGFkaW5nUGF0dGVybiA9IGdldFNoYWRpbmdQYXR0ZXJuO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgpO1xuXG52YXIgX2lzX25vZGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMpO1xuXG5jb25zdCBQYXRoVHlwZSA9IHtcbiAgRklMTDogXCJGaWxsXCIsXG4gIFNUUk9LRTogXCJTdHJva2VcIixcbiAgU0hBRElORzogXCJTaGFkaW5nXCJcbn07XG5leHBvcnRzLlBhdGhUeXBlID0gUGF0aFR5cGU7XG5cbmZ1bmN0aW9uIGFwcGx5Qm91bmRpbmdCb3goY3R4LCBiYm94KSB7XG4gIGlmICghYmJveCB8fCBfaXNfbm9kZS5pc05vZGVKUykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNvbnN0IHdpZHRoID0gYmJveFsyXSAtIGJib3hbMF07XG4gIGNvbnN0IGhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuICBjb25zdCByZWdpb24gPSBuZXcgUGF0aDJEKCk7XG4gIHJlZ2lvbi5yZWN0KGJib3hbMF0sIGJib3hbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICBjdHguY2xpcChyZWdpb24pO1xufVxuXG5jbGFzcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZVNoYWRpbmdQYXR0ZXJuKSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZVNoYWRpbmdQYXR0ZXJuLlwiKTtcbiAgICB9XG4gIH1cblxuICBnZXRQYXR0ZXJuKCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYGdldFBhdHRlcm5gIGNhbGxlZC5cIik7XG4gIH1cblxufVxuXG5jbGFzcyBSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoSVIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3R5cGUgPSBJUlsxXTtcbiAgICB0aGlzLl9iYm94ID0gSVJbMl07XG4gICAgdGhpcy5fY29sb3JTdG9wcyA9IElSWzNdO1xuICAgIHRoaXMuX3AwID0gSVJbNF07XG4gICAgdGhpcy5fcDEgPSBJUls1XTtcbiAgICB0aGlzLl9yMCA9IElSWzZdO1xuICAgIHRoaXMuX3IxID0gSVJbN107XG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUdyYWRpZW50KGN0eCkge1xuICAgIGxldCBncmFkO1xuXG4gICAgaWYgKHRoaXMuX3R5cGUgPT09IFwiYXhpYWxcIikge1xuICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh0aGlzLl9wMFswXSwgdGhpcy5fcDBbMV0sIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl90eXBlID09PSBcInJhZGlhbFwiKSB7XG4gICAgICBncmFkID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHRoaXMuX3AwWzBdLCB0aGlzLl9wMFsxXSwgdGhpcy5fcjAsIHRoaXMuX3AxWzBdLCB0aGlzLl9wMVsxXSwgdGhpcy5fcjEpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgY29sb3JTdG9wIG9mIHRoaXMuX2NvbG9yU3RvcHMpIHtcbiAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcFswXSwgY29sb3JTdG9wWzFdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JhZDtcbiAgfVxuXG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBsZXQgcGF0dGVybjtcblxuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU1RST0tFIHx8IHBhdGhUeXBlID09PSBQYXRoVHlwZS5GSUxMKSB7XG4gICAgICBjb25zdCBvd25lckJCb3ggPSBvd25lci5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpKSB8fCBbMCwgMCwgMCwgMF07XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChvd25lckJCb3hbMl0gLSBvd25lckJCb3hbMF0pIHx8IDE7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwob3duZXJCQm94WzNdIC0gb3duZXJCQm94WzFdKSB8fCAxO1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gb3duZXIuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwicGF0dGVyblwiLCB3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCB0bXBDdHguY2FudmFzLndpZHRoLCB0bXBDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICB0bXBDdHguYmVnaW5QYXRoKCk7XG4gICAgICB0bXBDdHgucmVjdCgwLCAwLCB0bXBDdHguY2FudmFzLndpZHRoLCB0bXBDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICB0bXBDdHgudHJhbnNsYXRlKC1vd25lckJCb3hbMF0sIC1vd25lckJCb3hbMV0pO1xuICAgICAgaW52ZXJzZSA9IF91dGlsLlV0aWwudHJhbnNmb3JtKGludmVyc2UsIFsxLCAwLCAwLCAxLCBvd25lckJCb3hbMF0sIG93bmVyQkJveFsxXV0pO1xuICAgICAgdG1wQ3R4LnRyYW5zZm9ybSguLi5vd25lci5iYXNlVHJhbnNmb3JtKTtcblxuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIHRtcEN0eC50cmFuc2Zvcm0oLi4udGhpcy5tYXRyaXgpO1xuICAgICAgfVxuXG4gICAgICBhcHBseUJvdW5kaW5nQm94KHRtcEN0eCwgdGhpcy5fYmJveCk7XG4gICAgICB0bXBDdHguZmlsbFN0eWxlID0gdGhpcy5fY3JlYXRlR3JhZGllbnQodG1wQ3R4KTtcbiAgICAgIHRtcEN0eC5maWxsKCk7XG4gICAgICBwYXR0ZXJuID0gY3R4LmNyZWF0ZVBhdHRlcm4odG1wQ2FudmFzLmNhbnZhcywgXCJuby1yZXBlYXRcIik7XG4gICAgICBjb25zdCBkb21NYXRyaXggPSBuZXcgRE9NTWF0cml4KGludmVyc2UpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybShkb21NYXRyaXgpO1xuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKGBSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuLmdldFBhdHRlcm46IFwiJHtleD8ubWVzc2FnZX1cIi5gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIHRoaXMuX2Jib3gpO1xuICAgICAgcGF0dGVybiA9IHRoaXMuX2NyZWF0ZUdyYWRpZW50KGN0eCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cblxufVxuXG5mdW5jdGlvbiBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcDEsIHAyLCBwMywgYzEsIGMyLCBjMykge1xuICBjb25zdCBjb29yZHMgPSBjb250ZXh0LmNvb3JkcyxcbiAgICAgICAgY29sb3JzID0gY29udGV4dC5jb2xvcnM7XG4gIGNvbnN0IGJ5dGVzID0gZGF0YS5kYXRhLFxuICAgICAgICByb3dTaXplID0gZGF0YS53aWR0aCAqIDQ7XG4gIGxldCB0bXA7XG5cbiAgaWYgKGNvb3Jkc1twMSArIDFdID4gY29vcmRzW3AyICsgMV0pIHtcbiAgICB0bXAgPSBwMTtcbiAgICBwMSA9IHAyO1xuICAgIHAyID0gdG1wO1xuICAgIHRtcCA9IGMxO1xuICAgIGMxID0gYzI7XG4gICAgYzIgPSB0bXA7XG4gIH1cblxuICBpZiAoY29vcmRzW3AyICsgMV0gPiBjb29yZHNbcDMgKyAxXSkge1xuICAgIHRtcCA9IHAyO1xuICAgIHAyID0gcDM7XG4gICAgcDMgPSB0bXA7XG4gICAgdG1wID0gYzI7XG4gICAgYzIgPSBjMztcbiAgICBjMyA9IHRtcDtcbiAgfVxuXG4gIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgdG1wID0gcDE7XG4gICAgcDEgPSBwMjtcbiAgICBwMiA9IHRtcDtcbiAgICB0bXAgPSBjMTtcbiAgICBjMSA9IGMyO1xuICAgIGMyID0gdG1wO1xuICB9XG5cbiAgY29uc3QgeDEgPSAoY29vcmRzW3AxXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTEgPSAoY29vcmRzW3AxICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGNvbnN0IHgyID0gKGNvb3Jkc1twMl0gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkyID0gKGNvb3Jkc1twMiArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBjb25zdCB4MyA9IChjb29yZHNbcDNdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MyA9IChjb29yZHNbcDMgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcblxuICBpZiAoeTEgPj0geTMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBjMXIgPSBjb2xvcnNbYzFdLFxuICAgICAgICBjMWcgPSBjb2xvcnNbYzEgKyAxXSxcbiAgICAgICAgYzFiID0gY29sb3JzW2MxICsgMl07XG4gIGNvbnN0IGMyciA9IGNvbG9yc1tjMl0sXG4gICAgICAgIGMyZyA9IGNvbG9yc1tjMiArIDFdLFxuICAgICAgICBjMmIgPSBjb2xvcnNbYzIgKyAyXTtcbiAgY29uc3QgYzNyID0gY29sb3JzW2MzXSxcbiAgICAgICAgYzNnID0gY29sb3JzW2MzICsgMV0sXG4gICAgICAgIGMzYiA9IGNvbG9yc1tjMyArIDJdO1xuICBjb25zdCBtaW5ZID0gTWF0aC5yb3VuZCh5MSksXG4gICAgICAgIG1heFkgPSBNYXRoLnJvdW5kKHkzKTtcbiAgbGV0IHhhLCBjYXIsIGNhZywgY2FiO1xuICBsZXQgeGIsIGNiciwgY2JnLCBjYmI7XG5cbiAgZm9yIChsZXQgeSA9IG1pblk7IHkgPD0gbWF4WTsgeSsrKSB7XG4gICAgaWYgKHkgPCB5Mikge1xuICAgICAgbGV0IGs7XG5cbiAgICAgIGlmICh5IDwgeTEpIHtcbiAgICAgICAgayA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBrID0gKHkxIC0geSkgLyAoeTEgLSB5Mik7XG4gICAgICB9XG5cbiAgICAgIHhhID0geDEgLSAoeDEgLSB4MikgKiBrO1xuICAgICAgY2FyID0gYzFyIC0gKGMxciAtIGMycikgKiBrO1xuICAgICAgY2FnID0gYzFnIC0gKGMxZyAtIGMyZykgKiBrO1xuICAgICAgY2FiID0gYzFiIC0gKGMxYiAtIGMyYikgKiBrO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaztcblxuICAgICAgaWYgKHkgPiB5Mykge1xuICAgICAgICBrID0gMTtcbiAgICAgIH0gZWxzZSBpZiAoeTIgPT09IHkzKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayA9ICh5MiAtIHkpIC8gKHkyIC0geTMpO1xuICAgICAgfVxuXG4gICAgICB4YSA9IHgyIC0gKHgyIC0geDMpICogaztcbiAgICAgIGNhciA9IGMyciAtIChjMnIgLSBjM3IpICogaztcbiAgICAgIGNhZyA9IGMyZyAtIChjMmcgLSBjM2cpICogaztcbiAgICAgIGNhYiA9IGMyYiAtIChjMmIgLSBjM2IpICogaztcbiAgICB9XG5cbiAgICBsZXQgaztcblxuICAgIGlmICh5IDwgeTEpIHtcbiAgICAgIGsgPSAwO1xuICAgIH0gZWxzZSBpZiAoeSA+IHkzKSB7XG4gICAgICBrID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgayA9ICh5MSAtIHkpIC8gKHkxIC0geTMpO1xuICAgIH1cblxuICAgIHhiID0geDEgLSAoeDEgLSB4MykgKiBrO1xuICAgIGNiciA9IGMxciAtIChjMXIgLSBjM3IpICogaztcbiAgICBjYmcgPSBjMWcgLSAoYzFnIC0gYzNnKSAqIGs7XG4gICAgY2JiID0gYzFiIC0gKGMxYiAtIGMzYikgKiBrO1xuICAgIGNvbnN0IHgxXyA9IE1hdGgucm91bmQoTWF0aC5taW4oeGEsIHhiKSk7XG4gICAgY29uc3QgeDJfID0gTWF0aC5yb3VuZChNYXRoLm1heCh4YSwgeGIpKTtcbiAgICBsZXQgaiA9IHJvd1NpemUgKiB5ICsgeDFfICogNDtcblxuICAgIGZvciAobGV0IHggPSB4MV87IHggPD0geDJfOyB4KyspIHtcbiAgICAgIGsgPSAoeGEgLSB4KSAvICh4YSAtIHhiKTtcblxuICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgIGsgPSAwO1xuICAgICAgfSBlbHNlIGlmIChrID4gMSkge1xuICAgICAgICBrID0gMTtcbiAgICAgIH1cblxuICAgICAgYnl0ZXNbaisrXSA9IGNhciAtIChjYXIgLSBjYnIpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gY2FnIC0gKGNhZyAtIGNiZykgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSBjYWIgLSAoY2FiIC0gY2JiKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IDI1NTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZHJhd0ZpZ3VyZShkYXRhLCBmaWd1cmUsIGNvbnRleHQpIHtcbiAgY29uc3QgcHMgPSBmaWd1cmUuY29vcmRzO1xuICBjb25zdCBjcyA9IGZpZ3VyZS5jb2xvcnM7XG4gIGxldCBpLCBpaTtcblxuICBzd2l0Y2ggKGZpZ3VyZS50eXBlKSB7XG4gICAgY2FzZSBcImxhdHRpY2VcIjpcbiAgICAgIGNvbnN0IHZlcnRpY2VzUGVyUm93ID0gZmlndXJlLnZlcnRpY2VzUGVyUm93O1xuICAgICAgY29uc3Qgcm93cyA9IE1hdGguZmxvb3IocHMubGVuZ3RoIC8gdmVydGljZXNQZXJSb3cpIC0gMTtcbiAgICAgIGNvbnN0IGNvbHMgPSB2ZXJ0aWNlc1BlclJvdyAtIDE7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgbGV0IHEgPSBpICogdmVydGljZXNQZXJSb3c7XG5cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyBqKyssIHErKykge1xuICAgICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1txXSwgcHNbcSArIDFdLCBwc1txICsgdmVydGljZXNQZXJSb3ddLCBjc1txXSwgY3NbcSArIDFdLCBjc1txICsgdmVydGljZXNQZXJSb3ddKTtcbiAgICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbcSArIHZlcnRpY2VzUGVyUm93ICsgMV0sIHBzW3EgKyAxXSwgcHNbcSArIHZlcnRpY2VzUGVyUm93XSwgY3NbcSArIHZlcnRpY2VzUGVyUm93ICsgMV0sIGNzW3EgKyAxXSwgY3NbcSArIHZlcnRpY2VzUGVyUm93XSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFwidHJpYW5nbGVzXCI6XG4gICAgICBmb3IgKGkgPSAwLCBpaSA9IHBzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDMpIHtcbiAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW2ldLCBwc1tpICsgMV0sIHBzW2kgKyAyXSwgY3NbaV0sIGNzW2kgKyAxXSwgY3NbaSArIDJdKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBmaWd1cmVcIik7XG4gIH1cbn1cblxuY2xhc3MgTWVzaFNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoSVIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX2Nvb3JkcyA9IElSWzJdO1xuICAgIHRoaXMuX2NvbG9ycyA9IElSWzNdO1xuICAgIHRoaXMuX2ZpZ3VyZXMgPSBJUls0XTtcbiAgICB0aGlzLl9ib3VuZHMgPSBJUls1XTtcbiAgICB0aGlzLl9iYm94ID0gSVJbN107XG4gICAgdGhpcy5fYmFja2dyb3VuZCA9IElSWzhdO1xuICAgIHRoaXMubWF0cml4ID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVNZXNoQ2FudmFzKGNvbWJpbmVkU2NhbGUsIGJhY2tncm91bmRDb2xvciwgY2FjaGVkQ2FudmFzZXMpIHtcbiAgICBjb25zdCBFWFBFQ1RFRF9TQ0FMRSA9IDEuMTtcbiAgICBjb25zdCBNQVhfUEFUVEVSTl9TSVpFID0gMzAwMDtcbiAgICBjb25zdCBCT1JERVJfU0laRSA9IDI7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGguZmxvb3IodGhpcy5fYm91bmRzWzBdKTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5mbG9vcih0aGlzLl9ib3VuZHNbMV0pO1xuICAgIGNvbnN0IGJvdW5kc1dpZHRoID0gTWF0aC5jZWlsKHRoaXMuX2JvdW5kc1syXSkgLSBvZmZzZXRYO1xuICAgIGNvbnN0IGJvdW5kc0hlaWdodCA9IE1hdGguY2VpbCh0aGlzLl9ib3VuZHNbM10pIC0gb2Zmc2V0WTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKE1hdGguY2VpbChNYXRoLmFicyhib3VuZHNXaWR0aCAqIGNvbWJpbmVkU2NhbGVbMF0gKiBFWFBFQ1RFRF9TQ0FMRSkpLCBNQVhfUEFUVEVSTl9TSVpFKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzSGVpZ2h0ICogY29tYmluZWRTY2FsZVsxXSAqIEVYUEVDVEVEX1NDQUxFKSksIE1BWF9QQVRURVJOX1NJWkUpO1xuICAgIGNvbnN0IHNjYWxlWCA9IGJvdW5kc1dpZHRoIC8gd2lkdGg7XG4gICAgY29uc3Qgc2NhbGVZID0gYm91bmRzSGVpZ2h0IC8gaGVpZ2h0O1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBjb29yZHM6IHRoaXMuX2Nvb3JkcyxcbiAgICAgIGNvbG9yczogdGhpcy5fY29sb3JzLFxuICAgICAgb2Zmc2V0WDogLW9mZnNldFgsXG4gICAgICBvZmZzZXRZOiAtb2Zmc2V0WSxcbiAgICAgIHNjYWxlWDogMSAvIHNjYWxlWCxcbiAgICAgIHNjYWxlWTogMSAvIHNjYWxlWVxuICAgIH07XG4gICAgY29uc3QgcGFkZGVkV2lkdGggPSB3aWR0aCArIEJPUkRFUl9TSVpFICogMjtcbiAgICBjb25zdCBwYWRkZWRIZWlnaHQgPSBoZWlnaHQgKyBCT1JERVJfU0laRSAqIDI7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWVzaFwiLCBwYWRkZWRXaWR0aCwgcGFkZGVkSGVpZ2h0LCBmYWxzZSk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3QgZGF0YSA9IHRtcEN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG5cbiAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGRhdGEuZGF0YTtcblxuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gYnl0ZXMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgICBieXRlc1tpXSA9IGJhY2tncm91bmRDb2xvclswXTtcbiAgICAgICAgYnl0ZXNbaSArIDFdID0gYmFja2dyb3VuZENvbG9yWzFdO1xuICAgICAgICBieXRlc1tpICsgMl0gPSBiYWNrZ3JvdW5kQ29sb3JbMl07XG4gICAgICAgIGJ5dGVzW2kgKyAzXSA9IDI1NTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGZpZ3VyZSBvZiB0aGlzLl9maWd1cmVzKSB7XG4gICAgICBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZSwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgdG1wQ3R4LnB1dEltYWdlRGF0YShkYXRhLCBCT1JERVJfU0laRSwgQk9SREVSX1NJWkUpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhcyxcbiAgICAgIG9mZnNldFg6IG9mZnNldFggLSBCT1JERVJfU0laRSAqIHNjYWxlWCxcbiAgICAgIG9mZnNldFk6IG9mZnNldFkgLSBCT1JERVJfU0laRSAqIHNjYWxlWSxcbiAgICAgIHNjYWxlWCxcbiAgICAgIHNjYWxlWVxuICAgIH07XG4gIH1cblxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIHRoaXMuX2Jib3gpO1xuICAgIGxldCBzY2FsZTtcblxuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgc2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKCgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuXG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgY29uc3QgbWF0cml4U2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMubWF0cml4KTtcblxuICAgICAgICBzY2FsZSA9IFtzY2FsZVswXSAqIG1hdHJpeFNjYWxlWzBdLCBzY2FsZVsxXSAqIG1hdHJpeFNjYWxlWzFdXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzID0gdGhpcy5fY3JlYXRlTWVzaENhbnZhcyhzY2FsZSwgcGF0aFR5cGUgPT09IFBhdGhUeXBlLlNIQURJTkcgPyBudWxsIDogdGhpcy5fYmFja2dyb3VuZCwgb3duZXIuY2FjaGVkQ2FudmFzZXMpO1xuXG4gICAgaWYgKHBhdGhUeXBlICE9PSBQYXRoVHlwZS5TSEFESU5HKSB7XG4gICAgICBjdHguc2V0VHJhbnNmb3JtKC4uLm93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuXG4gICAgICBpZiAodGhpcy5tYXRyaXgpIHtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi50aGlzLm1hdHJpeCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LnRyYW5zbGF0ZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WSk7XG4gICAgY3R4LnNjYWxlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWSk7XG4gICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuY2FudmFzLCBcIm5vLXJlcGVhdFwiKTtcbiAgfVxuXG59XG5cbmNsYXNzIER1bW15U2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBnZXRQYXR0ZXJuKCkge1xuICAgIHJldHVybiBcImhvdHBpbmtcIjtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGdldFNoYWRpbmdQYXR0ZXJuKElSKSB7XG4gIHN3aXRjaCAoSVJbMF0pIHtcbiAgICBjYXNlIFwiUmFkaWFsQXhpYWxcIjpcbiAgICAgIHJldHVybiBuZXcgUmFkaWFsQXhpYWxTaGFkaW5nUGF0dGVybihJUik7XG5cbiAgICBjYXNlIFwiTWVzaFwiOlxuICAgICAgcmV0dXJuIG5ldyBNZXNoU2hhZGluZ1BhdHRlcm4oSVIpO1xuXG4gICAgY2FzZSBcIkR1bW15XCI6XG4gICAgICByZXR1cm4gbmV3IER1bW15U2hhZGluZ1BhdHRlcm4oKTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBJUiB0eXBlOiAke0lSWzBdfWApO1xufVxuXG5jb25zdCBQYWludFR5cGUgPSB7XG4gIENPTE9SRUQ6IDEsXG4gIFVOQ09MT1JFRDogMlxufTtcblxuY2xhc3MgVGlsaW5nUGF0dGVybiB7XG4gIHN0YXRpYyBnZXQgTUFYX1BBVFRFUk5fU0laRSgpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJNQVhfUEFUVEVSTl9TSVpFXCIsIDMwMDApO1xuICB9XG5cbiAgY29uc3RydWN0b3IoSVIsIGNvbG9yLCBjdHgsIGNhbnZhc0dyYXBoaWNzRmFjdG9yeSwgYmFzZVRyYW5zZm9ybSkge1xuICAgIHRoaXMub3BlcmF0b3JMaXN0ID0gSVJbMl07XG4gICAgdGhpcy5tYXRyaXggPSBJUlszXSB8fCBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgdGhpcy5iYm94ID0gSVJbNF07XG4gICAgdGhpcy54c3RlcCA9IElSWzVdO1xuICAgIHRoaXMueXN0ZXAgPSBJUls2XTtcbiAgICB0aGlzLnBhaW50VHlwZSA9IElSWzddO1xuICAgIHRoaXMudGlsaW5nVHlwZSA9IElSWzhdO1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IGNhbnZhc0dyYXBoaWNzRmFjdG9yeTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBiYXNlVHJhbnNmb3JtO1xuICB9XG5cbiAgY3JlYXRlUGF0dGVybkNhbnZhcyhvd25lcikge1xuICAgIGNvbnN0IG9wZXJhdG9yTGlzdCA9IHRoaXMub3BlcmF0b3JMaXN0O1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLmJib3g7XG4gICAgY29uc3QgeHN0ZXAgPSB0aGlzLnhzdGVwO1xuICAgIGNvbnN0IHlzdGVwID0gdGhpcy55c3RlcDtcbiAgICBjb25zdCBwYWludFR5cGUgPSB0aGlzLnBhaW50VHlwZTtcbiAgICBjb25zdCB0aWxpbmdUeXBlID0gdGhpcy50aWxpbmdUeXBlO1xuICAgIGNvbnN0IGNvbG9yID0gdGhpcy5jb2xvcjtcbiAgICBjb25zdCBjYW52YXNHcmFwaGljc0ZhY3RvcnkgPSB0aGlzLmNhbnZhc0dyYXBoaWNzRmFjdG9yeTtcbiAgICAoMCwgX3V0aWwuaW5mbykoXCJUaWxpbmdUeXBlOiBcIiArIHRpbGluZ1R5cGUpO1xuICAgIGNvbnN0IHgwID0gYmJveFswXSxcbiAgICAgICAgICB5MCA9IGJib3hbMV0sXG4gICAgICAgICAgeDEgPSBiYm94WzJdLFxuICAgICAgICAgIHkxID0gYmJveFszXTtcblxuICAgIGNvbnN0IG1hdHJpeFNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0aGlzLm1hdHJpeCk7XG5cbiAgICBjb25zdCBjdXJNYXRyaXhTY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5iYXNlVHJhbnNmb3JtKTtcblxuICAgIGNvbnN0IGNvbWJpbmVkU2NhbGUgPSBbbWF0cml4U2NhbGVbMF0gKiBjdXJNYXRyaXhTY2FsZVswXSwgbWF0cml4U2NhbGVbMV0gKiBjdXJNYXRyaXhTY2FsZVsxXV07XG4gICAgY29uc3QgZGlteCA9IHRoaXMuZ2V0U2l6ZUFuZFNjYWxlKHhzdGVwLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIGNvbWJpbmVkU2NhbGVbMF0pO1xuICAgIGNvbnN0IGRpbXkgPSB0aGlzLmdldFNpemVBbmRTY2FsZSh5c3RlcCwgdGhpcy5jdHguY2FudmFzLmhlaWdodCwgY29tYmluZWRTY2FsZVsxXSk7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gb3duZXIuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwicGF0dGVyblwiLCBkaW14LnNpemUsIGRpbXkuc2l6ZSwgdHJ1ZSk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3QgZ3JhcGhpY3MgPSBjYW52YXNHcmFwaGljc0ZhY3RvcnkuY3JlYXRlQ2FudmFzR3JhcGhpY3ModG1wQ3R4KTtcbiAgICBncmFwaGljcy5ncm91cExldmVsID0gb3duZXIuZ3JvdXBMZXZlbDtcbiAgICB0aGlzLnNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dChncmFwaGljcywgcGFpbnRUeXBlLCBjb2xvcik7XG4gICAgbGV0IGFkanVzdGVkWDAgPSB4MDtcbiAgICBsZXQgYWRqdXN0ZWRZMCA9IHkwO1xuICAgIGxldCBhZGp1c3RlZFgxID0geDE7XG4gICAgbGV0IGFkanVzdGVkWTEgPSB5MTtcblxuICAgIGlmICh4MCA8IDApIHtcbiAgICAgIGFkanVzdGVkWDAgPSAwO1xuICAgICAgYWRqdXN0ZWRYMSArPSBNYXRoLmFicyh4MCk7XG4gICAgfVxuXG4gICAgaWYgKHkwIDwgMCkge1xuICAgICAgYWRqdXN0ZWRZMCA9IDA7XG4gICAgICBhZGp1c3RlZFkxICs9IE1hdGguYWJzKHkwKTtcbiAgICB9XG5cbiAgICB0bXBDdHgudHJhbnNsYXRlKC0oZGlteC5zY2FsZSAqIGFkanVzdGVkWDApLCAtKGRpbXkuc2NhbGUgKiBhZGp1c3RlZFkwKSk7XG4gICAgZ3JhcGhpY3MudHJhbnNmb3JtKGRpbXguc2NhbGUsIDAsIDAsIGRpbXkuc2NhbGUsIDAsIDApO1xuICAgIHRtcEN0eC5zYXZlKCk7XG4gICAgdGhpcy5jbGlwQmJveChncmFwaGljcywgYWRqdXN0ZWRYMCwgYWRqdXN0ZWRZMCwgYWRqdXN0ZWRYMSwgYWRqdXN0ZWRZMSk7XG4gICAgZ3JhcGhpY3MuYmFzZVRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShncmFwaGljcy5jdHgpO1xuICAgIGdyYXBoaWNzLmV4ZWN1dGVPcGVyYXRvckxpc3Qob3BlcmF0b3JMaXN0KTtcbiAgICBncmFwaGljcy5lbmREcmF3aW5nKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNhbnZhczogdG1wQ2FudmFzLmNhbnZhcyxcbiAgICAgIHNjYWxlWDogZGlteC5zY2FsZSxcbiAgICAgIHNjYWxlWTogZGlteS5zY2FsZSxcbiAgICAgIG9mZnNldFg6IGFkanVzdGVkWDAsXG4gICAgICBvZmZzZXRZOiBhZGp1c3RlZFkwXG4gICAgfTtcbiAgfVxuXG4gIGdldFNpemVBbmRTY2FsZShzdGVwLCByZWFsT3V0cHV0U2l6ZSwgc2NhbGUpIHtcbiAgICBzdGVwID0gTWF0aC5hYnMoc3RlcCk7XG4gICAgY29uc3QgbWF4U2l6ZSA9IE1hdGgubWF4KFRpbGluZ1BhdHRlcm4uTUFYX1BBVFRFUk5fU0laRSwgcmVhbE91dHB1dFNpemUpO1xuICAgIGxldCBzaXplID0gTWF0aC5jZWlsKHN0ZXAgKiBzY2FsZSk7XG5cbiAgICBpZiAoc2l6ZSA+PSBtYXhTaXplKSB7XG4gICAgICBzaXplID0gbWF4U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBzaXplIC8gc3RlcDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGUsXG4gICAgICBzaXplXG4gICAgfTtcbiAgfVxuXG4gIGNsaXBCYm94KGdyYXBoaWNzLCB4MCwgeTAsIHgxLCB5MSkge1xuICAgIGNvbnN0IGJib3hXaWR0aCA9IHgxIC0geDA7XG4gICAgY29uc3QgYmJveEhlaWdodCA9IHkxIC0geTA7XG4gICAgZ3JhcGhpY3MuY3R4LnJlY3QoeDAsIHkwLCBiYm94V2lkdGgsIGJib3hIZWlnaHQpO1xuICAgIGdyYXBoaWNzLmN1cnJlbnQudXBkYXRlUmVjdE1pbk1heCgoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoZ3JhcGhpY3MuY3R4KSwgW3gwLCB5MCwgeDEsIHkxXSk7XG4gICAgZ3JhcGhpY3MuY2xpcCgpO1xuICAgIGdyYXBoaWNzLmVuZFBhdGgoKTtcbiAgfVxuXG4gIHNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dChncmFwaGljcywgcGFpbnRUeXBlLCBjb2xvcikge1xuICAgIGNvbnN0IGNvbnRleHQgPSBncmFwaGljcy5jdHgsXG4gICAgICAgICAgY3VycmVudCA9IGdyYXBoaWNzLmN1cnJlbnQ7XG5cbiAgICBzd2l0Y2ggKHBhaW50VHlwZSkge1xuICAgICAgY2FzZSBQYWludFR5cGUuQ09MT1JFRDpcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgICAgY3VycmVudC5maWxsQ29sb3IgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgICBjdXJyZW50LnN0cm9rZUNvbG9yID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBQYWludFR5cGUuVU5DT0xPUkVEOlxuICAgICAgICBjb25zdCBjc3NDb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0pO1xuXG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY3NzQ29sb3I7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjc3NDb2xvcjtcbiAgICAgICAgY3VycmVudC5maWxsQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgICAgY3VycmVudC5zdHJva2VDb2xvciA9IGNzc0NvbG9yO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IF91dGlsLkZvcm1hdEVycm9yKGBVbnN1cHBvcnRlZCBwYWludCB0eXBlOiAke3BhaW50VHlwZX1gKTtcbiAgICB9XG4gIH1cblxuICBnZXRQYXR0ZXJuKGN0eCwgb3duZXIsIGludmVyc2UsIHBhdGhUeXBlKSB7XG4gICAgbGV0IG1hdHJpeCA9IGludmVyc2U7XG5cbiAgICBpZiAocGF0aFR5cGUgIT09IFBhdGhUeXBlLlNIQURJTkcpIHtcbiAgICAgIG1hdHJpeCA9IF91dGlsLlV0aWwudHJhbnNmb3JtKG1hdHJpeCwgb3duZXIuYmFzZVRyYW5zZm9ybSk7XG5cbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBtYXRyaXggPSBfdXRpbC5VdGlsLnRyYW5zZm9ybShtYXRyaXgsIHRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzID0gdGhpcy5jcmVhdGVQYXR0ZXJuQ2FudmFzKG93bmVyKTtcbiAgICBsZXQgZG9tTWF0cml4ID0gbmV3IERPTU1hdHJpeChtYXRyaXgpO1xuICAgIGRvbU1hdHJpeCA9IGRvbU1hdHJpeC50cmFuc2xhdGUodGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFkpO1xuICAgIGRvbU1hdHJpeCA9IGRvbU1hdHJpeC5zY2FsZSgxIC8gdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVgsIDEgLyB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWSk7XG4gICAgY29uc3QgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuY2FudmFzLCBcInJlcGVhdFwiKTtcblxuICAgIHRyeSB7XG4gICAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybShkb21NYXRyaXgpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYFRpbGluZ1BhdHRlcm4uZ2V0UGF0dGVybjogXCIke2V4Py5tZXNzYWdlfVwiLmApO1xuICAgIH1cblxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9XG5cbn1cblxuZXhwb3J0cy5UaWxpbmdQYXR0ZXJuID0gVGlsaW5nUGF0dGVybjtcblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5hcHBseU1hc2tJbWFnZURhdGEgPSBhcHBseU1hc2tJbWFnZURhdGE7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5cbmZ1bmN0aW9uIGFwcGx5TWFza0ltYWdlRGF0YSh7XG4gIHNyYyxcbiAgc3JjUG9zID0gMCxcbiAgZGVzdCxcbiAgZGVzdFBvcyA9IDAsXG4gIHdpZHRoLFxuICBoZWlnaHQsXG4gIGludmVyc2VEZWNvZGUgPSBmYWxzZVxufSkge1xuICBjb25zdCBvcGFxdWUgPSBfdXRpbC5GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbiA/IDB4ZmYwMDAwMDAgOiAweDAwMDAwMGZmO1xuICBjb25zdCBbemVyb01hcHBpbmcsIG9uZU1hcHBpbmddID0gIWludmVyc2VEZWNvZGUgPyBbb3BhcXVlLCAwXSA6IFswLCBvcGFxdWVdO1xuICBjb25zdCB3aWR0aEluU291cmNlID0gd2lkdGggPj4gMztcbiAgY29uc3Qgd2lkdGhSZW1haW5kZXIgPSB3aWR0aCAmIDc7XG4gIGNvbnN0IHNyY0xlbmd0aCA9IHNyYy5sZW5ndGg7XG4gIGRlc3QgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICBmb3IgKGNvbnN0IG1heCA9IHNyY1BvcyArIHdpZHRoSW5Tb3VyY2U7IHNyY1BvcyA8IG1heDsgc3JjUG9zKyspIHtcbiAgICAgIGNvbnN0IGVsZW0gPSBzcmNQb3MgPCBzcmNMZW5ndGggPyBzcmNbc3JjUG9zXSA6IDI1NTtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMTAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwID8gb25lTWFwcGluZyA6IHplcm9NYXBwaW5nO1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDBiMSA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICB9XG5cbiAgICBpZiAod2lkdGhSZW1haW5kZXIgPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGVsZW0gPSBzcmNQb3MgPCBzcmNMZW5ndGggPyBzcmNbc3JjUG9zKytdIDogMjU1O1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aWR0aFJlbWFpbmRlcjsgaisrKSB7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMSA8PCA3IC0gaiA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHNyY1BvcyxcbiAgICBkZXN0UG9zXG4gIH07XG59XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuR2xvYmFsV29ya2VyT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IEdsb2JhbFdvcmtlck9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZXhwb3J0cy5HbG9iYWxXb3JrZXJPcHRpb25zID0gR2xvYmFsV29ya2VyT3B0aW9ucztcbkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydCA9IEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydDtcbkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjID0gR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmMgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYztcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5NZXNzYWdlSGFuZGxlciA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcblxuY29uc3QgQ2FsbGJhY2tLaW5kID0ge1xuICBVTktOT1dOOiAwLFxuICBEQVRBOiAxLFxuICBFUlJPUjogMlxufTtcbmNvbnN0IFN0cmVhbUtpbmQgPSB7XG4gIFVOS05PV046IDAsXG4gIENBTkNFTDogMSxcbiAgQ0FOQ0VMX0NPTVBMRVRFOiAyLFxuICBDTE9TRTogMyxcbiAgRU5RVUVVRTogNCxcbiAgRVJST1I6IDUsXG4gIFBVTEw6IDYsXG4gIFBVTExfQ09NUExFVEU6IDcsXG4gIFNUQVJUX0NPTVBMRVRFOiA4XG59O1xuXG5mdW5jdGlvbiB3cmFwUmVhc29uKHJlYXNvbikge1xuICBpZiAoIShyZWFzb24gaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgcmVhc29uID09PSBcIm9iamVjdFwiICYmIHJlYXNvbiAhPT0gbnVsbCkpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKCd3cmFwUmVhc29uOiBFeHBlY3RlZCBcInJlYXNvblwiIHRvIGJlIGEgKHBvc3NpYmx5IGNsb25lZCkgRXJyb3IuJyk7XG4gIH1cblxuICBzd2l0Y2ggKHJlYXNvbi5uYW1lKSB7XG4gICAgY2FzZSBcIkFib3J0RXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKTtcblxuICAgIGNhc2UgXCJNaXNzaW5nUERGRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UpO1xuXG4gICAgY2FzZSBcIlBhc3N3b3JkRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsLlBhc3N3b3JkRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uY29kZSk7XG5cbiAgICBjYXNlIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSwgcmVhc29uLnN0YXR1cyk7XG5cbiAgICBjYXNlIFwiVW5rbm93bkVycm9yRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsLlVua25vd25FcnJvckV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSwgcmVhc29uLmRldGFpbHMpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuVW5rbm93bkVycm9yRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24udG9TdHJpbmcoKSk7XG4gIH1cbn1cblxuY2xhc3MgTWVzc2FnZUhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2VOYW1lLCB0YXJnZXROYW1lLCBjb21PYmopIHtcbiAgICB0aGlzLnNvdXJjZU5hbWUgPSBzb3VyY2VOYW1lO1xuICAgIHRoaXMudGFyZ2V0TmFtZSA9IHRhcmdldE5hbWU7XG4gICAgdGhpcy5jb21PYmogPSBjb21PYmo7XG4gICAgdGhpcy5jYWxsYmFja0lkID0gMTtcbiAgICB0aGlzLnN0cmVhbUlkID0gMTtcbiAgICB0aGlzLnN0cmVhbVNpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmFjdGlvbkhhbmRsZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgdGhpcy5fb25Db21PYmpPbk1lc3NhZ2UgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gZXZlbnQuZGF0YTtcblxuICAgICAgaWYgKGRhdGEudGFyZ2V0TmFtZSAhPT0gdGhpcy5zb3VyY2VOYW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuc3RyZWFtKSB7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NTdHJlYW1NZXNzYWdlKGRhdGEpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tJZCA9IGRhdGEuY2FsbGJhY2tJZDtcbiAgICAgICAgY29uc3QgY2FwYWJpbGl0eSA9IHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG5cbiAgICAgICAgaWYgKCFjYXBhYmlsaXR5KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgcmVzb2x2ZSBjYWxsYmFjayAke2NhbGxiYWNrSWR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXTtcblxuICAgICAgICBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkRBVEEpIHtcbiAgICAgICAgICBjYXBhYmlsaXR5LnJlc29sdmUoZGF0YS5kYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmNhbGxiYWNrID09PSBDYWxsYmFja0tpbmQuRVJST1IpIHtcbiAgICAgICAgICBjYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjYWxsYmFjayBjYXNlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFjdGlvbkhhbmRsZXJbZGF0YS5hY3Rpb25dO1xuXG4gICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYWN0aW9uIGZyb20gd29ya2VyOiAke2RhdGEuYWN0aW9ufWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5jYWxsYmFja0lkKSB7XG4gICAgICAgIGNvbnN0IGNiU291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZTtcbiAgICAgICAgY29uc3QgY2JUYXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lO1xuICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoYWN0aW9uKGRhdGEuZGF0YSkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZTogY2JTb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZTogY2JUYXJnZXROYW1lLFxuICAgICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5EQVRBLFxuICAgICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgICAgZGF0YTogcmVzdWx0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZTogY2JTb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZTogY2JUYXJnZXROYW1lLFxuICAgICAgICAgICAgY2FsbGJhY2s6IENhbGxiYWNrS2luZC5FUlJPUixcbiAgICAgICAgICAgIGNhbGxiYWNrSWQ6IGRhdGEuY2FsbGJhY2tJZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLnN0cmVhbUlkKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhY3Rpb24oZGF0YS5kYXRhKTtcbiAgICB9O1xuXG4gICAgY29tT2JqLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uQ29tT2JqT25NZXNzYWdlKTtcbiAgfVxuXG4gIG9uKGFjdGlvbk5hbWUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBhaCA9IHRoaXMuYWN0aW9uSGFuZGxlcjtcblxuICAgIGlmIChhaFthY3Rpb25OYW1lXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBhbHJlYWR5IGFuIGFjdGlvbk5hbWUgY2FsbGVkIFwiJHthY3Rpb25OYW1lfVwiYCk7XG4gICAgfVxuXG4gICAgYWhbYWN0aW9uTmFtZV0gPSBoYW5kbGVyO1xuICB9XG5cbiAgc2VuZChhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICBkYXRhXG4gICAgfSwgdHJhbnNmZXJzKTtcbiAgfVxuXG4gIHNlbmRXaXRoUHJvbWlzZShhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICBjb25zdCBjYWxsYmFja0lkID0gdGhpcy5jYWxsYmFja0lkKys7XG4gICAgY29uc3QgY2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdID0gY2FwYWJpbGl0eTtcblxuICAgIHRyeSB7XG4gICAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWU6IHRoaXMuc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZTogdGhpcy50YXJnZXROYW1lLFxuICAgICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICAgIGNhbGxiYWNrSWQsXG4gICAgICAgIGRhdGFcbiAgICAgIH0sIHRyYW5zZmVycyk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGNhcGFiaWxpdHkucmVqZWN0KGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG5cbiAgc2VuZFdpdGhTdHJlYW0oYWN0aW9uTmFtZSwgZGF0YSwgcXVldWVpbmdTdHJhdGVneSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSB0aGlzLnN0cmVhbUlkKyssXG4gICAgICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lID0gdGhpcy50YXJnZXROYW1lLFxuICAgICAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBjb25zdCBzdGFydENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdID0ge1xuICAgICAgICAgIGNvbnRyb2xsZXIsXG4gICAgICAgICAgc3RhcnRDYWxsOiBzdGFydENhcGFiaWxpdHksXG4gICAgICAgICAgcHVsbENhbGw6IG51bGwsXG4gICAgICAgICAgY2FuY2VsQ2FsbDogbnVsbCxcbiAgICAgICAgICBpc0Nsb3NlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgZGVzaXJlZFNpemU6IGNvbnRyb2xsZXIuZGVzaXJlZFNpemVcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIHB1bGw6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBjb25zdCBwdWxsQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0ucHVsbENhbGwgPSBwdWxsQ2FwYWJpbGl0eTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTEwsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgZGVzaXJlZFNpemU6IGNvbnRyb2xsZXIuZGVzaXJlZFNpemVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwdWxsQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgfSxcbiAgICAgIGNhbmNlbDogcmVhc29uID0+IHtcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkocmVhc29uIGluc3RhbmNlb2YgRXJyb3IsIFwiY2FuY2VsIG11c3QgaGF2ZSBhIHZhbGlkIHJlYXNvblwiKTtcbiAgICAgICAgY29uc3QgY2FuY2VsQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uY2FuY2VsQ2FsbCA9IGNhbmNlbENhcGFiaWxpdHk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNBTkNFTCxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhbmNlbENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH1cbiAgICB9LCBxdWV1ZWluZ1N0cmF0ZWd5KTtcbiAgfVxuXG4gIF9jcmVhdGVTdHJlYW1TaW5rKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IGRhdGEuc3RyZWFtSWQsXG4gICAgICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLFxuICAgICAgICAgIGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG4gICAgY29uc3Qgc3RyZWFtU2luayA9IHtcbiAgICAgIGVucXVldWUoY2h1bmssIHNpemUgPSAxLCB0cmFuc2ZlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsYXN0RGVzaXJlZFNpemUgPSB0aGlzLmRlc2lyZWRTaXplO1xuICAgICAgICB0aGlzLmRlc2lyZWRTaXplIC09IHNpemU7XG5cbiAgICAgICAgaWYgKGxhc3REZXNpcmVkU2l6ZSA+IDAgJiYgdGhpcy5kZXNpcmVkU2l6ZSA8PSAwKSB7XG4gICAgICAgICAgdGhpcy5zaW5rQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgICAgICB0aGlzLnJlYWR5ID0gdGhpcy5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVOUVVFVUUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgY2h1bmtcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgIH0sXG5cbiAgICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0xPU0UsXG4gICAgICAgICAgc3RyZWFtSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGRlbGV0ZSBzZWxmLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICAgIH0sXG5cbiAgICAgIGVycm9yKHJlYXNvbikge1xuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJlcnJvciBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb25cIik7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVSUk9SLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgfSxcblxuICAgICAgc2lua0NhcGFiaWxpdHk6ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKSxcbiAgICAgIG9uUHVsbDogbnVsbCxcbiAgICAgIG9uQ2FuY2VsOiBudWxsLFxuICAgICAgaXNDYW5jZWxsZWQ6IGZhbHNlLFxuICAgICAgZGVzaXJlZFNpemU6IGRhdGEuZGVzaXJlZFNpemUsXG4gICAgICByZWFkeTogbnVsbFxuICAgIH07XG4gICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgc3RyZWFtU2luay5yZWFkeSA9IHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXSA9IHN0cmVhbVNpbms7XG4gICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIHJlc29sdmUoYWN0aW9uKGRhdGEuZGF0YSwgc3RyZWFtU2luaykpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX3Byb2Nlc3NTdHJlYW1NZXNzYWdlKGRhdGEpIHtcbiAgICBjb25zdCBzdHJlYW1JZCA9IGRhdGEuc3RyZWFtSWQsXG4gICAgICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIGNvbnN0IHN0cmVhbUNvbnRyb2xsZXIgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSxcbiAgICAgICAgICBzdHJlYW1TaW5rID0gdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG5cbiAgICBzd2l0Y2ggKGRhdGEuc3RyZWFtKSB7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbC5yZXNvbHZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIucHVsbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTDpcbiAgICAgICAgaWYgKCFzdHJlYW1TaW5rKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdHJlYW1TaW5rLmRlc2lyZWRTaXplIDw9IDAgJiYgZGF0YS5kZXNpcmVkU2l6ZSA+IDApIHtcbiAgICAgICAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmVhbVNpbmsuZGVzaXJlZFNpemUgPSBkYXRhLmRlc2lyZWRTaXplO1xuICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoc3RyZWFtU2luay5vblB1bGwgJiYgc3RyZWFtU2luay5vblB1bGwoKSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFN0cmVhbUtpbmQuRU5RVUVVRTpcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkoc3RyZWFtQ29udHJvbGxlciwgXCJlbnF1ZXVlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuXG4gICAgICAgIGlmIChzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhLmNodW5rKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DTE9TRTpcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkoc3RyZWFtQ29udHJvbGxlciwgXCJjbG9zZSBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcblxuICAgICAgICBpZiAoc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5jbG9zZSgpO1xuXG4gICAgICAgIHRoaXMuX2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpO1xuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFN0cmVhbUtpbmQuRVJST1I6XG4gICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHN0cmVhbUNvbnRyb2xsZXIsIFwiZXJyb3Igc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY29udHJvbGxlci5lcnJvcih3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG5cbiAgICAgICAgdGhpcy5fZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGwucmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU3RyZWFtS2luZC5DQU5DRUw6XG4gICAgICAgIGlmICghc3RyZWFtU2luaykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKHN0cmVhbVNpbmsub25DYW5jZWwgJiYgc3RyZWFtU2luay5vbkNhbmNlbCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICBzdHJlYW1TaW5rLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgZGVsZXRlIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBzdHJlYW0gY2FzZVwiKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBfZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChbc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGwgJiYgc3RyZWFtQ29udHJvbGxlci5zdGFydENhbGwucHJvbWlzZSwgc3RyZWFtQ29udHJvbGxlci5wdWxsQ2FsbCAmJiBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsLnByb21pc2UsIHN0cmVhbUNvbnRyb2xsZXIuY2FuY2VsQ2FsbCAmJiBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGwucHJvbWlzZV0pO1xuICAgIGRlbGV0ZSB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb21PYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25Db21PYmpPbk1lc3NhZ2UpO1xuICB9XG5cbn1cblxuZXhwb3J0cy5NZXNzYWdlSGFuZGxlciA9IE1lc3NhZ2VIYW5kbGVyO1xuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLk1ldGFkYXRhID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG5jbGFzcyBNZXRhZGF0YSB7XG4gICNtZXRhZGF0YU1hcDtcbiAgI2RhdGE7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhcnNlZERhdGEsXG4gICAgcmF3RGF0YVxuICB9KSB7XG4gICAgdGhpcy4jbWV0YWRhdGFNYXAgPSBwYXJzZWREYXRhO1xuICAgIHRoaXMuI2RhdGEgPSByYXdEYXRhO1xuICB9XG5cbiAgZ2V0UmF3KCkge1xuICAgIHJldHVybiB0aGlzLiNkYXRhO1xuICB9XG5cbiAgZ2V0KG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy4jbWV0YWRhdGFNYXAuZ2V0KG5hbWUpID8/IG51bGw7XG4gIH1cblxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5vYmplY3RGcm9tTWFwKSh0aGlzLiNtZXRhZGF0YU1hcCk7XG4gIH1cblxuICBoYXMobmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNtZXRhZGF0YU1hcC5oYXMobmFtZSk7XG4gIH1cblxufVxuXG5leHBvcnRzLk1ldGFkYXRhID0gTWV0YWRhdGE7XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuT3B0aW9uYWxDb250ZW50Q29uZmlnID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG5jb25zdCBJTlRFUk5BTCA9IFN5bWJvbChcIklOVEVSTkFMXCIpO1xuXG5jbGFzcyBPcHRpb25hbENvbnRlbnRHcm91cCB7XG4gICN2aXNpYmxlID0gdHJ1ZTtcblxuICBjb25zdHJ1Y3RvcihuYW1lLCBpbnRlbnQpIHtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMuaW50ZW50ID0gaW50ZW50O1xuICB9XG5cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Zpc2libGU7XG4gIH1cblxuICBfc2V0VmlzaWJsZShpbnRlcm5hbCwgdmlzaWJsZSkge1xuICAgIGlmIChpbnRlcm5hbCAhPT0gSU5URVJOQUwpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJJbnRlcm5hbCBtZXRob2QgYF9zZXRWaXNpYmxlYCBjYWxsZWQuXCIpO1xuICAgIH1cblxuICAgIHRoaXMuI3Zpc2libGUgPSB2aXNpYmxlO1xuICB9XG5cbn1cblxuY2xhc3MgT3B0aW9uYWxDb250ZW50Q29uZmlnIHtcbiAgI2NhY2hlZEhhc0luaXRpYWxWaXNpYmlsaXR5ID0gdHJ1ZTtcbiAgI2dyb3VwcyA9IG5ldyBNYXAoKTtcbiAgI2luaXRpYWxWaXNpYmlsaXR5ID0gbnVsbDtcbiAgI29yZGVyID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICB0aGlzLmNyZWF0b3IgPSBudWxsO1xuXG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgdGhpcy5jcmVhdG9yID0gZGF0YS5jcmVhdG9yO1xuICAgIHRoaXMuI29yZGVyID0gZGF0YS5vcmRlcjtcblxuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgZGF0YS5ncm91cHMpIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5zZXQoZ3JvdXAuaWQsIG5ldyBPcHRpb25hbENvbnRlbnRHcm91cChncm91cC5uYW1lLCBncm91cC5pbnRlbnQpKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5iYXNlU3RhdGUgPT09IFwiT0ZGXCIpIHtcbiAgICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgdGhpcy4jZ3JvdXBzLnZhbHVlcygpKSB7XG4gICAgICAgIGdyb3VwLl9zZXRWaXNpYmxlKElOVEVSTkFMLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBvbiBvZiBkYXRhLm9uKSB7XG4gICAgICB0aGlzLiNncm91cHMuZ2V0KG9uKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBvZmYgb2YgZGF0YS5vZmYpIHtcbiAgICAgIHRoaXMuI2dyb3Vwcy5nZXQob2ZmKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgZmFsc2UpO1xuICAgIH1cblxuICAgIHRoaXMuI2luaXRpYWxWaXNpYmlsaXR5ID0gbmV3IE1hcCgpO1xuXG4gICAgZm9yIChjb25zdCBbaWQsIGdyb3VwXSBvZiB0aGlzLiNncm91cHMpIHtcbiAgICAgIHRoaXMuI2luaXRpYWxWaXNpYmlsaXR5LnNldChpZCwgZ3JvdXAudmlzaWJsZSk7XG4gICAgfVxuICB9XG5cbiAgI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oYXJyYXkpIHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICBpZiAobGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY29uc3Qgb3BlcmF0b3IgPSBhcnJheVswXTtcblxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICAgIGxldCBzdGF0ZTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLiNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLiNncm91cHMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy4jZ3JvdXBzLmdldChlbGVtZW50KS52aXNpYmxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtlbGVtZW50fWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChvcGVyYXRvcikge1xuICAgICAgICBjYXNlIFwiQW5kXCI6XG4gICAgICAgICAgaWYgKCFzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJPclwiOlxuICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIk5vdFwiOlxuICAgICAgICAgIHJldHVybiAhc3RhdGU7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3BlcmF0b3IgPT09IFwiQW5kXCI7XG4gIH1cblxuICBpc1Zpc2libGUoZ3JvdXApIHtcbiAgICBpZiAodGhpcy4jZ3JvdXBzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcIk9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGRlZmluZWQuXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGdyb3VwLnR5cGUgPT09IFwiT0NHXCIpIHtcbiAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhncm91cC5pZCkpIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtncm91cC5pZH1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLiNncm91cHMuZ2V0KGdyb3VwLmlkKS52aXNpYmxlO1xuICAgIH0gZWxzZSBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ01EXCIpIHtcbiAgICAgIGlmIChncm91cC5leHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGdyb3VwLmV4cHJlc3Npb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWdyb3VwLnBvbGljeSB8fCBncm91cC5wb2xpY3kgPT09IFwiQW55T25cIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQWxsT25cIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFueU9mZlwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQWxsT2ZmXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgKDAsIF91dGlsLndhcm4pKGBVbmtub3duIG9wdGlvbmFsIGNvbnRlbnQgcG9saWN5ICR7Z3JvdXAucG9saWN5fS5gKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgICgwLCBfdXRpbC53YXJuKShgVW5rbm93biBncm91cCB0eXBlICR7Z3JvdXAudHlwZX0uYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzZXRWaXNpYmlsaXR5KGlkLCB2aXNpYmxlID0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy4jZ3JvdXBzLmdldChpZCkuX3NldFZpc2libGUoSU5URVJOQUwsICEhdmlzaWJsZSk7XG5cbiAgICB0aGlzLiNjYWNoZWRIYXNJbml0aWFsVmlzaWJpbGl0eSA9IG51bGw7XG4gIH1cblxuICBnZXQgaGFzSW5pdGlhbFZpc2liaWxpdHkoKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZEhhc0luaXRpYWxWaXNpYmlsaXR5ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy4jY2FjaGVkSGFzSW5pdGlhbFZpc2liaWxpdHk7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbaWQsIGdyb3VwXSBvZiB0aGlzLiNncm91cHMpIHtcbiAgICAgIGNvbnN0IHZpc2libGUgPSB0aGlzLiNpbml0aWFsVmlzaWJpbGl0eS5nZXQoaWQpO1xuXG4gICAgICBpZiAoZ3JvdXAudmlzaWJsZSAhPT0gdmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY2FjaGVkSGFzSW5pdGlhbFZpc2liaWxpdHkgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy4jY2FjaGVkSGFzSW5pdGlhbFZpc2liaWxpdHkgPSB0cnVlO1xuICB9XG5cbiAgZ2V0T3JkZXIoKSB7XG4gICAgaWYgKCF0aGlzLiNncm91cHMuc2l6ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuI29yZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy4jb3JkZXIuc2xpY2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gWy4uLnRoaXMuI2dyb3Vwcy5rZXlzKCldO1xuICB9XG5cbiAgZ2V0R3JvdXBzKCkge1xuICAgIHJldHVybiB0aGlzLiNncm91cHMuc2l6ZSA+IDAgPyAoMCwgX3V0aWwub2JqZWN0RnJvbU1hcCkodGhpcy4jZ3JvdXBzKSA6IG51bGw7XG4gIH1cblxuICBnZXRHcm91cChpZCkge1xuICAgIHJldHVybiB0aGlzLiNncm91cHMuZ2V0KGlkKSB8fCBudWxsO1xuICB9XG5cbn1cblxuZXhwb3J0cy5PcHRpb25hbENvbnRlbnRDb25maWcgPSBPcHRpb25hbENvbnRlbnRDb25maWc7XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuUERGRGF0YVRyYW5zcG9ydFN0cmVhbSA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcblxudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg4KTtcblxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtcywgcGRmRGF0YVJhbmdlVHJhbnNwb3J0KSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkocGRmRGF0YVJhbmdlVHJhbnNwb3J0LCAnUERGRGF0YVRyYW5zcG9ydFN0cmVhbSAtIG1pc3NpbmcgcmVxdWlyZWQgXCJwZGZEYXRhUmFuZ2VUcmFuc3BvcnRcIiBhcmd1bWVudC4nKTtcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSBwYXJhbXMucHJvZ3Jlc3NpdmVEb25lIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gcGFyYW1zLmNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lIHx8IG51bGw7XG4gICAgY29uc3QgaW5pdGlhbERhdGEgPSBwYXJhbXMuaW5pdGlhbERhdGE7XG5cbiAgICBpZiAoaW5pdGlhbERhdGE/Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGluaXRpYWxEYXRhKS5idWZmZXI7XG5cbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGJ1ZmZlcik7XG4gICAgfVxuXG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0ID0gcGRmRGF0YVJhbmdlVHJhbnNwb3J0O1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXBhcmFtcy5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhcGFyYW1zLmRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gcGFyYW1zLmxlbmd0aDtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZWFkZXJzID0gW107XG5cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUmFuZ2VMaXN0ZW5lcigoYmVnaW4sIGNodW5rKSA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgYmVnaW4sXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc0xpc3RlbmVyKChsb2FkZWQsIHRvdGFsKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzKHtcbiAgICAgICAgbG9hZGVkLFxuICAgICAgICB0b3RhbFxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXIoY2h1bmsgPT4ge1xuICAgICAgdGhpcy5fb25SZWNlaXZlRGF0YSh7XG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzaXZlRG9uZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnRyYW5zcG9ydFJlYWR5KCk7XG4gIH1cblxuICBfb25SZWNlaXZlRGF0YShhcmdzKSB7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYXJncy5jaHVuaykuYnVmZmVyO1xuXG4gICAgaWYgKGFyZ3MuYmVnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLl9lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmb3VuZCA9IHRoaXMuX3JhbmdlUmVhZGVycy5zb21lKGZ1bmN0aW9uIChyYW5nZVJlYWRlcikge1xuICAgICAgICBpZiAocmFuZ2VSZWFkZXIuX2JlZ2luICE9PSBhcmdzLmJlZ2luKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmFuZ2VSZWFkZXIuX2VucXVldWUoYnVmZmVyKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KShmb3VuZCwgXCJfb25SZWNlaXZlRGF0YSAtIG5vIGBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXJgIGluc3RhbmNlIGZvdW5kLlwiKTtcbiAgICB9XG4gIH1cblxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuXG4gIF9vblByb2dyZXNzKGV2dCkge1xuICAgIGlmIChldnQudG90YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZmlyc3RSZWFkZXIgPSB0aGlzLl9yYW5nZVJlYWRlcnNbMF07XG5cbiAgICAgIGlmIChmaXJzdFJlYWRlcj8ub25Qcm9ncmVzcykge1xuICAgICAgICBmaXJzdFJlYWRlci5vblByb2dyZXNzKHtcbiAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZ1bGxSZWFkZXIgPSB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcblxuICAgICAgaWYgKGZ1bGxSZWFkZXI/Lm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgZnVsbFJlYWRlci5vblByb2dyZXNzKHtcbiAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfb25Qcm9ncmVzc2l2ZURvbmUoKSB7XG4gICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5wcm9ncmVzc2l2ZURvbmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSB0cnVlO1xuICB9XG5cbiAgX3JlbW92ZVJhbmdlUmVhZGVyKHJlYWRlcikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9yYW5nZVJlYWRlcnMuaW5kZXhPZihyZWFkZXIpO1xuXG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cblxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgICgwLCBfdXRpbC5hc3NlcnQpKCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIGNvbnN0IHF1ZXVlZENodW5rcyA9IHRoaXMuX3F1ZXVlZENodW5rcztcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBudWxsO1xuICAgIHJldHVybiBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlcih0aGlzLCBxdWV1ZWRDaHVua3MsIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSwgdGhpcy5fY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUpO1xuICB9XG5cbiAgZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIGJlZ2luLCBlbmQpO1xuXG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCk7XG5cbiAgICB0aGlzLl9yYW5nZVJlYWRlcnMucHVzaChyZWFkZXIpO1xuXG4gICAgcmV0dXJuIHJlYWRlcjtcbiAgfVxuXG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIGlmICh0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcikge1xuICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuXG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFib3J0KCk7XG4gIH1cblxufVxuXG5leHBvcnRzLlBERkRhdGFUcmFuc3BvcnRTdHJlYW0gPSBQREZEYXRhVHJhbnNwb3J0U3RyZWFtO1xuXG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBxdWV1ZWRDaHVua3MsIHByb2dyZXNzaXZlRG9uZSA9IGZhbHNlLCBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IG51bGwpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fZG9uZSA9IHByb2dyZXNzaXZlRG9uZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9maWxlbmFtZSA9ICgwLCBfZGlzcGxheV91dGlscy5pc1BkZkZpbGUpKGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lKSA/IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lIDogbnVsbDtcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBxdWV1ZWRDaHVua3MgfHwgW107XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcblxuICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdGhpcy5fcXVldWVkQ2h1bmtzKSB7XG4gICAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2hlYWRlcnNSZWFkeSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHN0cmVhbS5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cblxuICBfZW5xdWV1ZShjaHVuaykge1xuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcblxuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmJ5dGVMZW5ndGg7XG4gIH1cblxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzUmVhZHk7XG4gIH1cblxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG5cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuXG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuXG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2NvbnRlbnRMZW5ndGg7XG4gIH1cblxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVua3Muc2hpZnQoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcblxuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuXG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cblxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG5cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIHByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICB9XG5cbn1cblxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX2JlZ2luID0gYmVnaW47XG4gICAgdGhpcy5fZW5kID0gZW5kO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG5cbiAgX2VucXVldWUoY2h1bmspIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RzQ2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG5cbiAgICAgIHJlcXVlc3RzQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG5cbiAgICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIH1cblxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuXG4gICAgdGhpcy5fc3RyZWFtLl9yZW1vdmVSYW5nZVJlYWRlcih0aGlzKTtcbiAgfVxuXG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVuaykge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVuaztcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG5cbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcblxuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG5cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuXG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG5cbiAgICB0aGlzLl9zdHJlYW0uX3JlbW92ZVJhbmdlUmVhZGVyKHRoaXMpO1xuICB9XG5cbn1cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5YZmFUZXh0ID0gdm9pZCAwO1xuXG5jbGFzcyBYZmFUZXh0IHtcbiAgc3RhdGljIHRleHRDb250ZW50KHhmYSkge1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgaXRlbXMsXG4gICAgICBzdHlsZXM6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gd2Fsayhub2RlKSB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgc3RyID0gbnVsbDtcbiAgICAgIGNvbnN0IG5hbWUgPSBub2RlLm5hbWU7XG5cbiAgICAgIGlmIChuYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgc3RyID0gbm9kZS52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIVhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobm9kZT8uYXR0cmlidXRlcz8udGV4dENvbnRlbnQpIHtcbiAgICAgICAgc3RyID0gbm9kZS5hdHRyaWJ1dGVzLnRleHRDb250ZW50O1xuICAgICAgfSBlbHNlIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICAgIHN0ciA9IG5vZGUudmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHIgIT09IG51bGwpIHtcbiAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgc3RyXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgd2FsayhjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2Fsayh4ZmEpO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBzdGF0aWMgc2hvdWxkQnVpbGRUZXh0KG5hbWUpIHtcbiAgICByZXR1cm4gIShuYW1lID09PSBcInRleHRhcmVhXCIgfHwgbmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwib3B0aW9uXCIgfHwgbmFtZSA9PT0gXCJzZWxlY3RcIik7XG4gIH1cblxufVxuXG5leHBvcnRzLlhmYVRleHQgPSBYZmFUZXh0O1xuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLk5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IGV4cG9ydHMuTm9kZUNhbnZhc0ZhY3RvcnkgPSBleHBvcnRzLk5vZGVDTWFwUmVhZGVyRmFjdG9yeSA9IHZvaWQgMDtcblxudmFyIF9iYXNlX2ZhY3RvcnkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkpO1xuXG47XG5cbmNvbnN0IGZldGNoRGF0YSA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcblxuICAgIGZzLnJlYWRGaWxlKHVybCwgKGVycm9yLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyb3IgfHwgIWRhdGEpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJvcikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUobmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbmNsYXNzIE5vZGVDYW52YXNGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlQ2FudmFzRmFjdG9yeSB7XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IENhbnZhcyA9IHJlcXVpcmUoXCJjYW52YXNcIik7XG5cbiAgICByZXR1cm4gQ2FudmFzLmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuTm9kZUNhbnZhc0ZhY3RvcnkgPSBOb2RlQ2FudmFzRmFjdG9yeTtcblxuY2xhc3MgTm9kZUNNYXBSZWFkZXJGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBfZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKSB7XG4gICAgcmV0dXJuIGZldGNoRGF0YSh1cmwpLnRoZW4oZGF0YSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjTWFwRGF0YTogZGF0YSxcbiAgICAgICAgY29tcHJlc3Npb25UeXBlXG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbn1cblxuZXhwb3J0cy5Ob2RlQ01hcFJlYWRlckZhY3RvcnkgPSBOb2RlQ01hcFJlYWRlckZhY3Rvcnk7XG5cbmNsYXNzIE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnkuQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IHtcbiAgX2ZldGNoRGF0YSh1cmwpIHtcbiAgICByZXR1cm4gZmV0Y2hEYXRhKHVybCk7XG4gIH1cblxufVxuXG5leHBvcnRzLk5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IE5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yTGF5ZXIgPSB2b2lkIDA7XG5cbnZhciBfdG9vbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcpO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2ZyZWV0ZXh0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMyk7XG5cbnZhciBfaW5rID0gX193X3BkZmpzX3JlcXVpcmVfXygyNCk7XG5cbmNsYXNzIEFubm90YXRpb25FZGl0b3JMYXllciB7XG4gICNhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgI2FsbG93Q2xpY2sgPSBmYWxzZTtcbiAgI2JvdW5kUG9pbnRlcnVwID0gdGhpcy5wb2ludGVydXAuYmluZCh0aGlzKTtcbiAgI2JvdW5kUG9pbnRlcmRvd24gPSB0aGlzLnBvaW50ZXJkb3duLmJpbmQodGhpcyk7XG4gICNlZGl0b3JzID0gbmV3IE1hcCgpO1xuICAjaGFkUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgI2lzQ2xlYW5pbmdVcCA9IGZhbHNlO1xuICAjdWlNYW5hZ2VyO1xuICBzdGF0aWMgX2luaXRpYWxpemVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGlmICghQW5ub3RhdGlvbkVkaXRvckxheWVyLl9pbml0aWFsaXplZCkge1xuICAgICAgQW5ub3RhdGlvbkVkaXRvckxheWVyLl9pbml0aWFsaXplZCA9IHRydWU7XG5cbiAgICAgIF9mcmVldGV4dC5GcmVlVGV4dEVkaXRvci5pbml0aWFsaXplKG9wdGlvbnMubDEwbik7XG5cbiAgICAgIF9pbmsuSW5rRWRpdG9yLmluaXRpYWxpemUob3B0aW9ucy5sMTBuKTtcblxuICAgICAgb3B0aW9ucy51aU1hbmFnZXIucmVnaXN0ZXJFZGl0b3JUeXBlcyhbX2ZyZWV0ZXh0LkZyZWVUZXh0RWRpdG9yLCBfaW5rLklua0VkaXRvcl0pO1xuICAgIH1cblxuICAgIHRoaXMuI3VpTWFuYWdlciA9IG9wdGlvbnMudWlNYW5hZ2VyO1xuICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UgPSBvcHRpb25zLmFubm90YXRpb25TdG9yYWdlO1xuICAgIHRoaXMucGFnZUluZGV4ID0gb3B0aW9ucy5wYWdlSW5kZXg7XG4gICAgdGhpcy5kaXYgPSBvcHRpb25zLmRpdjtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IG9wdGlvbnMuYWNjZXNzaWJpbGl0eU1hbmFnZXI7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZExheWVyKHRoaXMpO1xuICB9XG5cbiAgdXBkYXRlVG9vbGJhcihtb2RlKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZVRvb2xiYXIobW9kZSk7XG4gIH1cblxuICB1cGRhdGVNb2RlKG1vZGUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpKSB7XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuXG4gICAgaWYgKG1vZGUgPT09IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSykge1xuICAgICAgdGhpcy5hZGRJbmtFZGl0b3JJZk5lZWRlZChmYWxzZSk7XG4gICAgICB0aGlzLmRpc2FibGVDbGljaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVuYWJsZUNsaWNrKCk7XG4gICAgfVxuXG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVuc2VsZWN0QWxsKCk7XG4gIH1cblxuICBhZGRJbmtFZGl0b3JJZk5lZWRlZChpc0NvbW1pdHRpbmcpIHtcbiAgICBpZiAoIWlzQ29tbWl0dGluZyAmJiB0aGlzLiN1aU1hbmFnZXIuZ2V0TW9kZSgpICE9PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkspIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWlzQ29tbWl0dGluZykge1xuICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoZWRpdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICAgIGVkaXRvci5zZXRJbkJhY2tncm91bmQoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVBbmRBZGROZXdFZGl0b3Ioe1xuICAgICAgb2Zmc2V0WDogMCxcbiAgICAgIG9mZnNldFk6IDBcbiAgICB9KTtcbiAgICBlZGl0b3Iuc2V0SW5CYWNrZ3JvdW5kKCk7XG4gIH1cblxuICBzZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpO1xuICB9XG5cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZENvbW1hbmRzKHBhcmFtcyk7XG4gIH1cblxuICBlbmFibGUoKSB7XG4gICAgdGhpcy5kaXYuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwiYXV0b1wiO1xuXG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZWRpdG9ycy52YWx1ZXMoKSkge1xuICAgICAgZWRpdG9yLmVuYWJsZUVkaXRpbmcoKTtcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuZGl2LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcblxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGVkaXRvci5kaXNhYmxlRWRpdGluZygpO1xuICAgIH1cbiAgfVxuXG4gIHNldEFjdGl2ZUVkaXRvcihlZGl0b3IpIHtcbiAgICBjb25zdCBjdXJyZW50QWN0aXZlID0gdGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpO1xuXG4gICAgaWYgKGN1cnJlbnRBY3RpdmUgPT09IGVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuI3VpTWFuYWdlci5zZXRBY3RpdmVFZGl0b3IoZWRpdG9yKTtcbiAgfVxuXG4gIGVuYWJsZUNsaWNrKCkge1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNib3VuZFBvaW50ZXJkb3duKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHRoaXMuI2JvdW5kUG9pbnRlcnVwKTtcbiAgfVxuXG4gIGRpc2FibGVDbGljaygpIHtcbiAgICB0aGlzLmRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jYm91bmRQb2ludGVyZG93bik7XG4gICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLiNib3VuZFBvaW50ZXJ1cCk7XG4gIH1cblxuICBhdHRhY2goZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9ycy5zZXQoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICB9XG5cbiAgZGV0YWNoKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnMuZGVsZXRlKGVkaXRvci5pZCk7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/LnJlbW92ZVBvaW50ZXJJblRleHRMYXllcihlZGl0b3IuY29udGVudERpdik7XG4gIH1cblxuICByZW1vdmUoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUVkaXRvcihlZGl0b3IpO1xuICAgIHRoaXMuZGV0YWNoKGVkaXRvcik7XG4gICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5yZW1vdmUoZWRpdG9yLmlkKTtcbiAgICBlZGl0b3IuZGl2LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGVkaXRvci5kaXYuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuXG4gICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aGlzLiN1aU1hbmFnZXIuZm9jdXNNYWluQ29udGFpbmVyKCk7XG4gICAgICB9XG4gICAgfSwgMCk7XG5cbiAgICBpZiAoIXRoaXMuI2lzQ2xlYW5pbmdVcCkge1xuICAgICAgdGhpcy5hZGRJbmtFZGl0b3JJZk5lZWRlZChmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgI2NoYW5nZVBhcmVudChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYXR0YWNoKGVkaXRvcik7XG4gICAgZWRpdG9yLnBhZ2VJbmRleCA9IHRoaXMucGFnZUluZGV4O1xuICAgIGVkaXRvci5wYXJlbnQ/LmRldGFjaChlZGl0b3IpO1xuICAgIGVkaXRvci5wYXJlbnQgPSB0aGlzO1xuXG4gICAgaWYgKGVkaXRvci5kaXYgJiYgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChlZGl0b3IuZGl2KTtcbiAgICB9XG4gIH1cblxuICBhZGQoZWRpdG9yKSB7XG4gICAgdGhpcy4jY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZEVkaXRvcihlZGl0b3IpO1xuICAgIHRoaXMuYXR0YWNoKGVkaXRvcik7XG5cbiAgICBpZiAoIWVkaXRvci5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIGNvbnN0IGRpdiA9IGVkaXRvci5yZW5kZXIoKTtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChkaXYpO1xuICAgICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5tb3ZlRWRpdG9ySW5ET00oZWRpdG9yKTtcbiAgICBlZGl0b3Iub25jZUFkZGVkKCk7XG4gICAgdGhpcy5hZGRUb0Fubm90YXRpb25TdG9yYWdlKGVkaXRvcik7XG4gIH1cblxuICBtb3ZlRWRpdG9ySW5ET00oZWRpdG9yKSB7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/Lm1vdmVFbGVtZW50SW5ET00odGhpcy5kaXYsIGVkaXRvci5kaXYsIGVkaXRvci5jb250ZW50RGl2LCB0cnVlKTtcbiAgfVxuXG4gIGFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNFbXB0eSgpICYmICF0aGlzLmFubm90YXRpb25TdG9yYWdlLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgICB9XG4gIH1cblxuICBhZGRPclJlYnVpbGQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5uZWVkc1RvQmVSZWJ1aWx0KCkpIHtcbiAgICAgIGVkaXRvci5yZWJ1aWxkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICB9XG5cbiAgYWRkQU5ld0VkaXRvcihlZGl0b3IpIHtcbiAgICBjb25zdCBjbWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmFkZE9yUmVidWlsZChlZGl0b3IpO1xuICAgIH07XG5cbiAgICBjb25zdCB1bmRvID0gKCkgPT4ge1xuICAgICAgZWRpdG9yLnJlbW92ZSgpO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgYWRkVW5kb2FibGVFZGl0b3IoZWRpdG9yKSB7XG4gICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgdGhpcy5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICB9O1xuXG4gICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxuICBnZXROZXh0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VpTWFuYWdlci5nZXRJZCgpO1xuICB9XG5cbiAgI2NyZWF0ZU5ld0VkaXRvcihwYXJhbXMpIHtcbiAgICBzd2l0Y2ggKHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgX2ZyZWV0ZXh0LkZyZWVUZXh0RWRpdG9yKHBhcmFtcyk7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LOlxuICAgICAgICByZXR1cm4gbmV3IF9pbmsuSW5rRWRpdG9yKHBhcmFtcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXNlcmlhbGl6ZShkYXRhKSB7XG4gICAgc3dpdGNoIChkYXRhLmFubm90YXRpb25UeXBlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUOlxuICAgICAgICByZXR1cm4gX2ZyZWV0ZXh0LkZyZWVUZXh0RWRpdG9yLmRlc2VyaWFsaXplKGRhdGEsIHRoaXMpO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSzpcbiAgICAgICAgcmV0dXJuIF9pbmsuSW5rRWRpdG9yLmRlc2VyaWFsaXplKGRhdGEsIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgI2NyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROZXh0SWQoKTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVOZXdFZGl0b3Ioe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWQsXG4gICAgICB4OiBldmVudC5vZmZzZXRYLFxuICAgICAgeTogZXZlbnQub2Zmc2V0WVxuICAgIH0pO1xuXG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG5cbiAgc2V0U2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnNldFNlbGVjdGVkKGVkaXRvcik7XG4gIH1cblxuICB0b2dnbGVTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuXG4gIGlzU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuI3VpTWFuYWdlci5pc1NlbGVjdGVkKGVkaXRvcik7XG4gIH1cblxuICB1bnNlbGVjdChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3QoZWRpdG9yKTtcbiAgfVxuXG4gIHBvaW50ZXJ1cChldmVudCkge1xuICAgIGNvbnN0IGlzTWFjID0gX3Rvb2xzLktleWJvYXJkTWFuYWdlci5wbGF0Zm9ybS5pc01hYztcblxuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLiNoYWRQb2ludGVyRG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMuI2FsbG93Q2xpY2spIHtcbiAgICAgIHRoaXMuI2FsbG93Q2xpY2sgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuI2NyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCk7XG4gIH1cblxuICBwb2ludGVyZG93bihldmVudCkge1xuICAgIGNvbnN0IGlzTWFjID0gX3Rvb2xzLktleWJvYXJkTWFuYWdlci5wbGF0Zm9ybS5pc01hYztcblxuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC50YXJnZXQgIT09IHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy4jaGFkUG9pbnRlckRvd24gPSB0cnVlO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI3VpTWFuYWdlci5nZXRBY3RpdmUoKTtcbiAgICB0aGlzLiNhbGxvd0NsaWNrID0gIWVkaXRvciB8fCBlZGl0b3IuaXNFbXB0eSgpO1xuICB9XG5cbiAgZHJvcChldmVudCkge1xuICAgIGNvbnN0IGlkID0gZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpO1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuI3VpTWFuYWdlci5nZXRFZGl0b3IoaWQpO1xuXG4gICAgaWYgKCFlZGl0b3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gXCJtb3ZlXCI7XG4gICAgdGhpcy4jY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGVuZFggPSBldmVudC5jbGllbnRYIC0gcmVjdC54O1xuICAgIGNvbnN0IGVuZFkgPSBldmVudC5jbGllbnRZIC0gcmVjdC55O1xuICAgIGVkaXRvci50cmFuc2xhdGUoZW5kWCAtIGVkaXRvci5zdGFydFgsIGVuZFkgLSBlZGl0b3Iuc3RhcnRZKTtcbiAgICB0aGlzLm1vdmVFZGl0b3JJbkRPTShlZGl0b3IpO1xuICAgIGVkaXRvci5kaXYuZm9jdXMoKTtcbiAgfVxuXG4gIGRyYWdvdmVyKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5nZXRBY3RpdmUoKT8ucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5yZW1vdmVQb2ludGVySW5UZXh0TGF5ZXIoZWRpdG9yLmNvbnRlbnREaXYpO1xuICAgICAgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICAgICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICAgIGVkaXRvci5wYXJlbnQgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLiNlZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnJlbW92ZUxheWVyKHRoaXMpO1xuICB9XG5cbiAgI2NsZWFudXAoKSB7XG4gICAgdGhpcy4jaXNDbGVhbmluZ1VwID0gdHJ1ZTtcblxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLiNpc0NsZWFuaW5nVXAgPSBmYWxzZTtcbiAgfVxuXG4gIHJlbmRlcihwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy52aWV3cG9ydCA9IHBhcmFtZXRlcnMudmlld3BvcnQ7XG4gICAgKDAsIF90b29scy5iaW5kRXZlbnRzKSh0aGlzLCB0aGlzLmRpdiwgW1wiZHJhZ292ZXJcIiwgXCJkcm9wXCJdKTtcbiAgICB0aGlzLnNldERpbWVuc2lvbnMoKTtcblxuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3VpTWFuYWdlci5nZXRFZGl0b3JzKHRoaXMucGFnZUluZGV4KSkge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZU1vZGUoKTtcbiAgfVxuXG4gIHVwZGF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgdGhpcy52aWV3cG9ydCA9IHBhcmFtZXRlcnMudmlld3BvcnQ7XG4gICAgdGhpcy5zZXREaW1lbnNpb25zKCk7XG4gICAgdGhpcy51cGRhdGVNb2RlKCk7XG4gIH1cblxuICBnZXQgc2NhbGVGYWN0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlld3BvcnQuc2NhbGU7XG4gIH1cblxuICBnZXQgcGFnZURpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgW3BhZ2VMTHgsIHBhZ2VMTHksIHBhZ2VVUngsIHBhZ2VVUnldID0gdGhpcy52aWV3cG9ydC52aWV3Qm94O1xuICAgIGNvbnN0IHdpZHRoID0gcGFnZVVSeCAtIHBhZ2VMTHg7XG4gICAgY29uc3QgaGVpZ2h0ID0gcGFnZVVSeSAtIHBhZ2VMTHk7XG4gICAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0XTtcbiAgfVxuXG4gIGdldCB2aWV3cG9ydEJhc2VEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gdGhpcy52aWV3cG9ydDtcbiAgICByZXR1cm4gcm90YXRpb24gJSAxODAgPT09IDAgPyBbd2lkdGgsIGhlaWdodF0gOiBbaGVpZ2h0LCB3aWR0aF07XG4gIH1cblxuICBzZXREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcm90YXRpb25cbiAgICB9ID0gdGhpcy52aWV3cG9ydDtcbiAgICBjb25zdCBmbGlwT3JpZW50YXRpb24gPSByb3RhdGlvbiAlIDE4MCAhPT0gMCxcbiAgICAgICAgICB3aWR0aFN0ciA9IE1hdGguZmxvb3Iod2lkdGgpICsgXCJweFwiLFxuICAgICAgICAgIGhlaWdodFN0ciA9IE1hdGguZmxvb3IoaGVpZ2h0KSArIFwicHhcIjtcbiAgICB0aGlzLmRpdi5zdHlsZS53aWR0aCA9IGZsaXBPcmllbnRhdGlvbiA/IGhlaWdodFN0ciA6IHdpZHRoU3RyO1xuICAgIHRoaXMuZGl2LnN0eWxlLmhlaWdodCA9IGZsaXBPcmllbnRhdGlvbiA/IHdpZHRoU3RyIDogaGVpZ2h0U3RyO1xuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCByb3RhdGlvbik7XG4gIH1cblxufVxuXG5leHBvcnRzLkFubm90YXRpb25FZGl0b3JMYXllciA9IEFubm90YXRpb25FZGl0b3JMYXllcjtcblxuLyoqKi8gfSksXG4vKiAyMyAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5GcmVlVGV4dEVkaXRvciA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcblxudmFyIF90b29scyA9IF9fd19wZGZqc19yZXF1aXJlX18oNyk7XG5cbnZhciBfZWRpdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcblxuY2xhc3MgRnJlZVRleHRFZGl0b3IgZXh0ZW5kcyBfZWRpdG9yLkFubm90YXRpb25FZGl0b3Ige1xuICAjYm91bmRFZGl0b3JEaXZCbHVyID0gdGhpcy5lZGl0b3JEaXZCbHVyLmJpbmQodGhpcyk7XG4gICNib3VuZEVkaXRvckRpdkZvY3VzID0gdGhpcy5lZGl0b3JEaXZGb2N1cy5iaW5kKHRoaXMpO1xuICAjYm91bmRFZGl0b3JEaXZLZXlkb3duID0gdGhpcy5lZGl0b3JEaXZLZXlkb3duLmJpbmQodGhpcyk7XG4gICNjb2xvcjtcbiAgI2NvbnRlbnQgPSBcIlwiO1xuICAjaGFzQWxyZWFkeUJlZW5Db21taXR0ZWQgPSBmYWxzZTtcbiAgI2ZvbnRTaXplO1xuICBzdGF0aWMgX2ZyZWVUZXh0RGVmYXVsdENvbnRlbnQgPSBcIlwiO1xuICBzdGF0aWMgX2wxMG5Qcm9taXNlO1xuICBzdGF0aWMgX2ludGVybmFsUGFkZGluZyA9IDA7XG4gIHN0YXRpYyBfZGVmYXVsdENvbG9yID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0Rm9udFNpemUgPSAxMDtcbiAgc3RhdGljIF9rZXlib2FyZE1hbmFnZXIgPSBuZXcgX3Rvb2xzLktleWJvYXJkTWFuYWdlcihbW1tcImN0cmwrRW50ZXJcIiwgXCJtYWMrbWV0YStFbnRlclwiLCBcIkVzY2FwZVwiLCBcIm1hYytFc2NhcGVcIl0sIEZyZWVUZXh0RWRpdG9yLnByb3RvdHlwZS5jb21taXRPclJlbW92ZV1dKTtcbiAgc3RhdGljIF90eXBlID0gXCJmcmVldGV4dFwiO1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHsgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJmcmVlVGV4dEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy4jY29sb3IgPSBwYXJhbXMuY29sb3IgfHwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3I7XG4gICAgdGhpcy4jZm9udFNpemUgPSBwYXJhbXMuZm9udFNpemUgfHwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZTtcbiAgfVxuXG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4pIHtcbiAgICB0aGlzLl9sMTBuUHJvbWlzZSA9IG5ldyBNYXAoW1wiZnJlZV90ZXh0X2RlZmF1bHRfY29udGVudFwiLCBcImVkaXRvcl9mcmVlX3RleHRfYXJpYV9sYWJlbFwiXS5tYXAoc3RyID0+IFtzdHIsIGwxMG4uZ2V0KHN0cildKSk7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgdGhpcy5faW50ZXJuYWxQYWRkaW5nID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1mcmVldGV4dC1wYWRkaW5nXCIpKTtcbiAgfVxuXG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemUgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I6XG4gICAgICAgIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUZvbnRTaXplKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1I6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUNvbG9yKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0UHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Rm9udFNpemVdLCBbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfQ09MT1IsIEZyZWVUZXh0RWRpdG9yLl9kZWZhdWx0Q29sb3IgfHwgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yXV07XG4gIH1cblxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsIHRoaXMuI2ZvbnRTaXplXSwgW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLCB0aGlzLiNjb2xvcl1dO1xuICB9XG5cbiAgI3VwZGF0ZUZvbnRTaXplKGZvbnRTaXplKSB7XG4gICAgY29uc3Qgc2V0Rm9udHNpemUgPSBzaXplID0+IHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LnN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHtzaXplfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSlgO1xuICAgICAgdGhpcy50cmFuc2xhdGUoMCwgLShzaXplIC0gdGhpcy4jZm9udFNpemUpICogdGhpcy5wYXJlbnQuc2NhbGVGYWN0b3IpO1xuICAgICAgdGhpcy4jZm9udFNpemUgPSBzaXplO1xuICAgICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICAgIH07XG5cbiAgICBjb25zdCBzYXZlZEZvbnRzaXplID0gdGhpcy4jZm9udFNpemU7XG4gICAgdGhpcy5wYXJlbnQuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHNldEZvbnRzaXplKGZvbnRTaXplKTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHNldEZvbnRzaXplKHNhdmVkRm9udHNpemUpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgI3VwZGF0ZUNvbG9yKGNvbG9yKSB7XG4gICAgY29uc3Qgc2F2ZWRDb2xvciA9IHRoaXMuI2NvbG9yO1xuICAgIHRoaXMucGFyZW50LmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICB0aGlzLiNjb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLmVkaXRvckRpdi5zdHlsZS5jb2xvciA9IGNvbG9yO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgdGhpcy4jY29sb3IgPSBzYXZlZENvbG9yO1xuICAgICAgICB0aGlzLmVkaXRvckRpdi5zdHlsZS5jb2xvciA9IHNhdmVkQ29sb3I7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUixcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbLUZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiB0aGlzLnBhcmVudC5zY2FsZUZhY3RvciwgLShGcmVlVGV4dEVkaXRvci5faW50ZXJuYWxQYWRkaW5nICsgdGhpcy4jZm9udFNpemUpICogdGhpcy5wYXJlbnQuc2NhbGVGYWN0b3JdO1xuICB9XG5cbiAgcmVidWlsZCgpIHtcbiAgICBzdXBlci5yZWJ1aWxkKCk7XG5cbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICB0aGlzLnBhcmVudC5hZGQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnBhcmVudC5zZXRFZGl0aW5nU3RhdGUoZmFsc2UpO1xuICAgIHRoaXMucGFyZW50LnVwZGF0ZVRvb2xiYXIoX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQpO1xuICAgIHN1cGVyLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5lbmFibGVFZGl0aW5nKCk7XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgdGhpcy5kaXYuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZLZXlkb3duKTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZGb2N1cyk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZCbHVyKTtcbiAgfVxuXG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNJbkVkaXRNb2RlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnBhcmVudC5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gICAgc3VwZXIuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5kaXNhYmxlRWRpdGluZygpO1xuICAgIHRoaXMub3ZlcmxheURpdi5jbGFzc0xpc3QuYWRkKFwiZW5hYmxlZFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRpdi5kcmFnZ2FibGUgPSB0cnVlO1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2S2V5ZG93bik7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2Rm9jdXMpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2Qmx1cik7XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgZm9jdXNpbihldmVudCkge1xuICAgIHN1cGVyLmZvY3VzaW4oZXZlbnQpO1xuXG4gICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gdGhpcy5lZGl0b3JEaXYpIHtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgb25jZUFkZGVkKCkge1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gIH1cblxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiAhdGhpcy5lZGl0b3JEaXYgfHwgdGhpcy5lZGl0b3JEaXYuaW5uZXJUZXh0LnRyaW0oKSA9PT0gXCJcIjtcbiAgfVxuXG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgIHRoaXMucGFyZW50LnNldEVkaXRpbmdTdGF0ZSh0cnVlKTtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuXG4gICNleHRyYWN0VGV4dCgpIHtcbiAgICBjb25zdCBkaXZzID0gdGhpcy5lZGl0b3JEaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXZcIik7XG5cbiAgICBpZiAoZGl2cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmVkaXRvckRpdi5pbm5lclRleHQ7XG4gICAgfVxuXG4gICAgY29uc3QgYnVmZmVyID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBkaXZzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IGRpdiA9IGRpdnNbaV07XG4gICAgICBjb25zdCBmaXJzdCA9IGRpdi5maXJzdENoaWxkO1xuXG4gICAgICBpZiAoZmlyc3Q/Lm5vZGVOYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgYnVmZmVyLnB1c2goZmlyc3QuZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXIucHVzaChcIlwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcXG5cIik7XG4gIH1cblxuICAjc2V0RWRpdG9yRGltZW5zaW9ucygpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudC52aWV3cG9ydEJhc2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0aGlzLndpZHRoID0gcmVjdC53aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLyBwYXJlbnRIZWlnaHQ7XG4gIH1cblxuICBjb21taXQoKSB7XG4gICAgc3VwZXIuY29tbWl0KCk7XG5cbiAgICBpZiAoIXRoaXMuI2hhc0FscmVhZHlCZWVuQ29tbWl0dGVkKSB7XG4gICAgICB0aGlzLiNoYXNBbHJlYWR5QmVlbkNvbW1pdHRlZCA9IHRydWU7XG4gICAgICB0aGlzLnBhcmVudC5hZGRVbmRvYWJsZUVkaXRvcih0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuI2NvbnRlbnQgPSB0aGlzLiNleHRyYWN0VGV4dCgpLnRyaW1FbmQoKTtcbiAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gIH1cblxuICBzaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5pc0luRWRpdE1vZGUoKTtcbiAgfVxuXG4gIGRibGNsaWNrKGV2ZW50KSB7XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gIH1cblxuICBrZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5kaXYgJiYgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgZWRpdG9yRGl2S2V5ZG93bihldmVudCkge1xuICAgIEZyZWVUZXh0RWRpdG9yLl9rZXlib2FyZE1hbmFnZXIuZXhlYyh0aGlzLCBldmVudCk7XG4gIH1cblxuICBlZGl0b3JEaXZGb2N1cyhldmVudCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTtcbiAgfVxuXG4gIGVkaXRvckRpdkJsdXIoZXZlbnQpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgZGlzYWJsZUVkaXRpbmcoKSB7XG4gICAgdGhpcy5lZGl0b3JEaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImNvbW1lbnRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1tdWx0aWxpbmVcIik7XG4gIH1cblxuICBlbmFibGVFZGl0aW5nKCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0ZXh0Ym94XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbXVsdGlsaW5lXCIsIHRydWUpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmRpdikge1xuICAgICAgcmV0dXJuIHRoaXMuZGl2O1xuICAgIH1cblxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG5cbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG5cbiAgICBzdXBlci5yZW5kZXIoKTtcbiAgICB0aGlzLmVkaXRvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuY2xhc3NOYW1lID0gXCJpbnRlcm5hbFwiO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImlkXCIsIGAke3RoaXMuaWR9LWVkaXRvcmApO1xuICAgIHRoaXMuZW5hYmxlRWRpdGluZygpO1xuXG4gICAgRnJlZVRleHRFZGl0b3IuX2wxMG5Qcm9taXNlLmdldChcImVkaXRvcl9mcmVlX3RleHRfYXJpYV9sYWJlbFwiKS50aGVuKG1zZyA9PiB0aGlzLmVkaXRvckRpdj8uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBtc2cpKTtcblxuICAgIEZyZWVUZXh0RWRpdG9yLl9sMTBuUHJvbWlzZS5nZXQoXCJmcmVlX3RleHRfZGVmYXVsdF9jb250ZW50XCIpLnRoZW4obXNnID0+IHRoaXMuZWRpdG9yRGl2Py5zZXRBdHRyaWJ1dGUoXCJkZWZhdWx0LWNvbnRlbnRcIiwgbXNnKSk7XG5cbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZWRpdG9yRGl2O1xuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHt0aGlzLiNmb250U2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IHRoaXMuI2NvbG9yO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLmVkaXRvckRpdik7XG4gICAgdGhpcy5vdmVybGF5RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LmFkZChcIm92ZXJsYXlcIiwgXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLm92ZXJsYXlEaXYpO1xuICAgICgwLCBfdG9vbHMuYmluZEV2ZW50cykodGhpcywgdGhpcy5kaXYsIFtcImRibGNsaWNrXCIsIFwia2V5ZG93blwiXSk7XG5cbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnQudmlld3BvcnRCYXNlRGltZW5zaW9ucztcbiAgICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuXG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy4jY29udGVudC5zcGxpdChcIlxcblwiKSkge1xuICAgICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBkaXYuYXBwZW5kKGxpbmUgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICAgIHRoaXMuZWRpdG9yRGl2LmFwcGVuZChkaXYpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpdi5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGl2LmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cblxuICBnZXQgY29udGVudERpdigpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3JEaXY7XG4gIH1cblxuICBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50KSB7XG4gICAgY29uc3QgZWRpdG9yID0gc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50KTtcbiAgICBlZGl0b3IuI2ZvbnRTaXplID0gZGF0YS5mb250U2l6ZTtcbiAgICBlZGl0b3IuI2NvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4uZGF0YS5jb2xvcik7XG4gICAgZWRpdG9yLiNjb250ZW50ID0gZGF0YS52YWx1ZTtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG5cbiAgc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcGFkZGluZyA9IEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiB0aGlzLnBhcmVudC5zY2FsZUZhY3RvcjtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5nZXRSZWN0KHBhZGRpbmcsIHBhZGRpbmcpO1xuXG4gICAgY29uc3QgY29sb3IgPSBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KGdldENvbXB1dGVkU3R5bGUodGhpcy5lZGl0b3JEaXYpLmNvbG9yKTtcblxuICAgIHJldHVybiB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQsXG4gICAgICBjb2xvcixcbiAgICAgIGZvbnRTaXplOiB0aGlzLiNmb250U2l6ZSxcbiAgICAgIHZhbHVlOiB0aGlzLiNjb250ZW50LFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhcmVudC5wYWdlSW5kZXgsXG4gICAgICByZWN0LFxuICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb25cbiAgICB9O1xuICB9XG5cbn1cblxuZXhwb3J0cy5GcmVlVGV4dEVkaXRvciA9IEZyZWVUZXh0RWRpdG9yO1xuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLklua0VkaXRvciA9IHZvaWQgMDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZpdEN1cnZlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfcGRmanNGaXRDdXJ2ZS5maXRDdXJ2ZTtcbiAgfVxufSkpO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2VkaXRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG5cbnZhciBfcGRmanNGaXRDdXJ2ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjUpO1xuXG52YXIgX3Rvb2xzID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcblxuY29uc3QgUkVTSVpFUl9TSVpFID0gMTY7XG5cbmNsYXNzIElua0VkaXRvciBleHRlbmRzIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvciB7XG4gICNhc3BlY3RSYXRpbyA9IDA7XG4gICNiYXNlSGVpZ2h0ID0gMDtcbiAgI2Jhc2VXaWR0aCA9IDA7XG4gICNib3VuZENhbnZhc1BvaW50ZXJtb3ZlID0gdGhpcy5jYW52YXNQb2ludGVybW92ZS5iaW5kKHRoaXMpO1xuICAjYm91bmRDYW52YXNQb2ludGVybGVhdmUgPSB0aGlzLmNhbnZhc1BvaW50ZXJsZWF2ZS5iaW5kKHRoaXMpO1xuICAjYm91bmRDYW52YXNQb2ludGVydXAgPSB0aGlzLmNhbnZhc1BvaW50ZXJ1cC5iaW5kKHRoaXMpO1xuICAjYm91bmRDYW52YXNQb2ludGVyZG93biA9IHRoaXMuY2FudmFzUG9pbnRlcmRvd24uYmluZCh0aGlzKTtcbiAgI2Rpc2FibGVFZGl0aW5nID0gZmFsc2U7XG4gICNpc0NhbnZhc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICNsYXN0UG9pbnQgPSBudWxsO1xuICAjb2JzZXJ2ZXIgPSBudWxsO1xuICAjcmVhbFdpZHRoID0gMDtcbiAgI3JlYWxIZWlnaHQgPSAwO1xuICAjcmVxdWVzdEZyYW1lQ2FsbGJhY2sgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRDb2xvciA9IG51bGw7XG4gIHN0YXRpYyBfZGVmYXVsdE9wYWNpdHkgPSAxO1xuICBzdGF0aWMgX2RlZmF1bHRUaGlja25lc3MgPSAxO1xuICBzdGF0aWMgX2wxMG5Qcm9taXNlO1xuICBzdGF0aWMgX3R5cGUgPSBcImlua1wiO1xuXG4gIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgIHN1cGVyKHsgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJpbmtFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuY29sb3IgPSBwYXJhbXMuY29sb3IgfHwgbnVsbDtcbiAgICB0aGlzLnRoaWNrbmVzcyA9IHBhcmFtcy50aGlja25lc3MgfHwgbnVsbDtcbiAgICB0aGlzLm9wYWNpdHkgPSBwYXJhbXMub3BhY2l0eSB8fCBudWxsO1xuICAgIHRoaXMucGF0aHMgPSBbXTtcbiAgICB0aGlzLmJlemllclBhdGgyRCA9IFtdO1xuICAgIHRoaXMuY3VycmVudFBhdGggPSBbXTtcbiAgICB0aGlzLnNjYWxlRmFjdG9yID0gMTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWCA9IHRoaXMudHJhbnNsYXRpb25ZID0gMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gIH1cblxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuKSB7XG4gICAgdGhpcy5fbDEwblByb21pc2UgPSBuZXcgTWFwKFtcImVkaXRvcl9pbmtfY2FudmFzX2FyaWFfbGFiZWxcIiwgXCJlZGl0b3JfaW5rX2FyaWFfbGFiZWxcIl0ubWFwKHN0ciA9PiBbc3RyLCBsMTBuLmdldChzdHIpXSkpO1xuICB9XG5cbiAgc3RhdGljIHVwZGF0ZURlZmF1bHRQYXJhbXModHlwZSwgdmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUzpcbiAgICAgICAgSW5rRWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUjpcbiAgICAgICAgSW5rRWRpdG9yLl9kZWZhdWx0Q29sb3IgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFk6XG4gICAgICAgIElua0VkaXRvci5fZGVmYXVsdE9wYWNpdHkgPSB2YWx1ZSAvIDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1M6XG4gICAgICAgIHRoaXMuI3VwZGF0ZVRoaWNrbmVzcyh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUjpcbiAgICAgICAgdGhpcy4jdXBkYXRlQ29sb3IodmFsdWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWTpcbiAgICAgICAgdGhpcy4jdXBkYXRlT3BhY2l0eSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTLCBJbmtFZGl0b3IuX2RlZmF1bHRUaGlja25lc3NdLCBbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SLCBJbmtFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3JdLCBbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFksIE1hdGgucm91bmQoSW5rRWRpdG9yLl9kZWZhdWx0T3BhY2l0eSAqIDEwMCldXTtcbiAgfVxuXG4gIGdldCBwcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUywgdGhpcy50aGlja25lc3MgfHwgSW5rRWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzXSwgW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUiwgdGhpcy5jb2xvciB8fCBJbmtFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3JdLCBbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFksIE1hdGgucm91bmQoMTAwICogKHRoaXMub3BhY2l0eSA/PyBJbmtFZGl0b3IuX2RlZmF1bHRPcGFjaXR5KSldXTtcbiAgfVxuXG4gICN1cGRhdGVUaGlja25lc3ModGhpY2tuZXNzKSB7XG4gICAgY29uc3Qgc2F2ZWRUaGlja25lc3MgPSB0aGlzLnRoaWNrbmVzcztcbiAgICB0aGlzLnBhcmVudC5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy50aGlja25lc3MgPSB0aGlja25lc3M7XG4gICAgICAgIHRoaXMuI2ZpdFRvQ29udGVudCgpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgdGhpcy50aGlja25lc3MgPSBzYXZlZFRoaWNrbmVzcztcbiAgICAgICAgdGhpcy4jZml0VG9Db250ZW50KCk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICAjdXBkYXRlQ29sb3IoY29sb3IpIHtcbiAgICBjb25zdCBzYXZlZENvbG9yID0gdGhpcy5jb2xvcjtcbiAgICB0aGlzLnBhcmVudC5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuY29sb3IgPSBzYXZlZENvbG9yO1xuICAgICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUixcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgI3VwZGF0ZU9wYWNpdHkob3BhY2l0eSkge1xuICAgIG9wYWNpdHkgLz0gMTAwO1xuICAgIGNvbnN0IHNhdmVkT3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICB0aGlzLnBhcmVudC5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSBzYXZlZE9wYWNpdHk7XG4gICAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFksXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHJlYnVpbGQoKSB7XG4gICAgc3VwZXIucmVidWlsZCgpO1xuXG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmNhbnZhcykge1xuICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgICB0aGlzLiNjcmVhdGVPYnNlcnZlcigpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICAgIHRoaXMuI3NldENhbnZhc0RpbXMoKTtcbiAgICB9XG5cbiAgICB0aGlzLiNmaXRUb0NvbnRlbnQoKTtcbiAgfVxuXG4gIHJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5jYW52YXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgIH1cblxuICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmNhbnZhcy5yZW1vdmUoKTtcbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgdGhpcy4jb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuI29ic2VydmVyID0gbnVsbDtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuXG4gIGVuYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICh0aGlzLiNkaXNhYmxlRWRpdGluZyB8fCB0aGlzLmNhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1cGVyLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5kaXYuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcmRvd24pO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVydXApO1xuICB9XG5cbiAgZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICghdGhpcy5pc0luRWRpdE1vZGUoKSB8fCB0aGlzLmNhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN1cGVyLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuZGl2LmRyYWdnYWJsZSA9ICF0aGlzLmlzRW1wdHkoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiZWRpdGluZ1wiKTtcbiAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVyZG93bik7XG4gICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJ1cCk7XG4gIH1cblxuICBvbmNlQWRkZWQoKSB7XG4gICAgdGhpcy5kaXYuZHJhZ2dhYmxlID0gIXRoaXMuaXNFbXB0eSgpO1xuICB9XG5cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXRocy5sZW5ndGggPT09IDAgfHwgdGhpcy5wYXRocy5sZW5ndGggPT09IDEgJiYgdGhpcy5wYXRoc1swXS5sZW5ndGggPT09IDA7XG4gIH1cblxuICAjZ2V0SW5pdGlhbEJCb3goKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICByb3RhdGlvblxuICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydDtcblxuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMCwgd2lkdGgsIHdpZHRoLCBoZWlnaHRdO1xuXG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt3aWR0aCwgaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0XTtcblxuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbaGVpZ2h0LCAwLCB3aWR0aCwgaGVpZ2h0XTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFswLCAwLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9XG4gIH1cblxuICAjc2V0U3Ryb2tlKCkge1xuICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHRoaXMudGhpY2tuZXNzICogdGhpcy5wYXJlbnQuc2NhbGVGYWN0b3IgLyB0aGlzLnNjYWxlRmFjdG9yO1xuICAgIHRoaXMuY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7XG4gICAgdGhpcy5jdHgubGluZUpvaW4gPSBcInJvdW5kXCI7XG4gICAgdGhpcy5jdHgubWl0ZXJMaW1pdCA9IDEwO1xuICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gYCR7dGhpcy5jb2xvcn0keygwLCBfdG9vbHMub3BhY2l0eVRvSGV4KSh0aGlzLm9wYWNpdHkpfWA7XG4gIH1cblxuICAjc3RhcnREcmF3aW5nKHgsIHkpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG5cbiAgICBpZiAoIXRoaXMuI2lzQ2FudmFzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRoaXMuI2lzQ2FudmFzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgICAgdGhpcy50aGlja25lc3MgfHw9IElua0VkaXRvci5fZGVmYXVsdFRoaWNrbmVzcztcbiAgICAgIHRoaXMuY29sb3IgfHw9IElua0VkaXRvci5fZGVmYXVsdENvbG9yIHx8IF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcjtcbiAgICAgIHRoaXMub3BhY2l0eSA/Pz0gSW5rRWRpdG9yLl9kZWZhdWx0T3BhY2l0eTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRQYXRoLnB1c2goW3gsIHldKTtcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBudWxsO1xuICAgIHRoaXMuI3NldFN0cm9rZSgpO1xuICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuY3R4Lm1vdmVUbyh4LCB5KTtcblxuICAgIHRoaXMuI3JlcXVlc3RGcmFtZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLiNyZXF1ZXN0RnJhbWVDYWxsYmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLiNsYXN0UG9pbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY3R4LmxpbmVUbyguLi50aGlzLiNsYXN0UG9pbnQpO1xuICAgICAgICB0aGlzLiNsYXN0UG9pbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgIH1cblxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLiNyZXF1ZXN0RnJhbWVDYWxsYmFjayk7XG4gICAgfTtcblxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy4jcmVxdWVzdEZyYW1lQ2FsbGJhY2spO1xuICB9XG5cbiAgI2RyYXcoeCwgeSkge1xuICAgIGNvbnN0IFtsYXN0WCwgbGFzdFldID0gdGhpcy5jdXJyZW50UGF0aC5hdCgtMSk7XG5cbiAgICBpZiAoeCA9PT0gbGFzdFggJiYgeSA9PT0gbGFzdFkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRQYXRoLnB1c2goW3gsIHldKTtcbiAgICB0aGlzLiNsYXN0UG9pbnQgPSBbeCwgeV07XG4gIH1cblxuICAjc3RvcERyYXdpbmcoeCwgeSkge1xuICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuI3JlcXVlc3RGcmFtZUNhbGxiYWNrID0gbnVsbDtcbiAgICB4ID0gTWF0aC5taW4oTWF0aC5tYXgoeCwgMCksIHRoaXMuY2FudmFzLndpZHRoKTtcbiAgICB5ID0gTWF0aC5taW4oTWF0aC5tYXgoeSwgMCksIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgY29uc3QgW2xhc3RYLCBsYXN0WV0gPSB0aGlzLmN1cnJlbnRQYXRoLmF0KC0xKTtcblxuICAgIGlmICh4ICE9PSBsYXN0WCB8fCB5ICE9PSBsYXN0WSkge1xuICAgICAgdGhpcy5jdXJyZW50UGF0aC5wdXNoKFt4LCB5XSk7XG4gICAgfVxuXG4gICAgbGV0IGJlemllcjtcblxuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLmxlbmd0aCAhPT0gMSkge1xuICAgICAgYmV6aWVyID0gKDAsIF9wZGZqc0ZpdEN1cnZlLmZpdEN1cnZlKSh0aGlzLmN1cnJlbnRQYXRoLCAzMCwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHh5ID0gW3gsIHldO1xuICAgICAgYmV6aWVyID0gW1t4eSwgeHkuc2xpY2UoKSwgeHkuc2xpY2UoKSwgeHldXTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXRoMkQgPSBJbmtFZGl0b3IuI2J1aWxkUGF0aDJEKGJlemllcik7XG4gICAgdGhpcy5jdXJyZW50UGF0aC5sZW5ndGggPSAwO1xuXG4gICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgdGhpcy5wYXRocy5wdXNoKGJlemllcik7XG4gICAgICB0aGlzLmJlemllclBhdGgyRC5wdXNoKHBhdGgyRCk7XG4gICAgICB0aGlzLnJlYnVpbGQoKTtcbiAgICB9O1xuXG4gICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgIHRoaXMucGF0aHMucG9wKCk7XG4gICAgICB0aGlzLmJlemllclBhdGgyRC5wb3AoKTtcblxuICAgICAgaWYgKHRoaXMucGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgICAgICAgdGhpcy4jY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuI2ZpdFRvQ29udGVudCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnBhcmVudC5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gICNyZWRyYXcoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLiN1cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLiNzZXRTdHJva2UoKTtcbiAgICBjb25zdCB7XG4gICAgICBjYW52YXMsXG4gICAgICBjdHhcbiAgICB9ID0gdGhpcztcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLiN1cGRhdGVUcmFuc2Zvcm0oKTtcblxuICAgIGZvciAoY29uc3QgcGF0aCBvZiB0aGlzLmJlemllclBhdGgyRCkge1xuICAgICAgY3R4LnN0cm9rZShwYXRoKTtcbiAgICB9XG4gIH1cblxuICBjb21taXQoKSB7XG4gICAgaWYgKHRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3VwZXIuY29tbWl0KCk7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIHRoaXMuc2V0SW5Gb3JlZ3JvdW5kKCk7XG4gICAgdGhpcy4jZGlzYWJsZUVkaXRpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKTtcbiAgICB0aGlzLiNmaXRUb0NvbnRlbnQodHJ1ZSk7XG4gICAgdGhpcy5wYXJlbnQuYWRkSW5rRWRpdG9ySWZOZWVkZWQodHJ1ZSk7XG4gICAgdGhpcy5wYXJlbnQubW92ZUVkaXRvckluRE9NKHRoaXMpO1xuICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gIH1cblxuICBmb2N1c2luKGV2ZW50KSB7XG4gICAgc3VwZXIuZm9jdXNpbihldmVudCk7XG4gICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICB9XG5cbiAgY2FudmFzUG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8ICF0aGlzLmlzSW5FZGl0TW9kZSgpIHx8IHRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zZXRJbkZvcmVncm91bmQoKTtcblxuICAgIGlmIChldmVudC50eXBlICE9PSBcIm1vdXNlXCIpIHtcbiAgICAgIHRoaXMuZGl2LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJsZWF2ZSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcm1vdmUpO1xuICAgIHRoaXMuI3N0YXJ0RHJhd2luZyhldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgfVxuXG4gIGNhbnZhc1BvaW50ZXJtb3ZlKGV2ZW50KSB7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgdGhpcy4jZHJhdyhldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgfVxuXG4gIGNhbnZhc1BvaW50ZXJ1cChldmVudCkge1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0luRWRpdE1vZGUoKSAmJiB0aGlzLmN1cnJlbnRQYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLiNlbmREcmF3aW5nKGV2ZW50KTtcbiAgICAgIHRoaXMuc2V0SW5CYWNrZ3JvdW5kKCk7XG4gICAgfVxuICB9XG5cbiAgY2FudmFzUG9pbnRlcmxlYXZlKGV2ZW50KSB7XG4gICAgdGhpcy4jZW5kRHJhd2luZyhldmVudCk7XG4gICAgdGhpcy5zZXRJbkJhY2tncm91bmQoKTtcbiAgfVxuXG4gICNlbmREcmF3aW5nKGV2ZW50KSB7XG4gICAgdGhpcy4jc3RvcERyYXdpbmcoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJsZWF2ZSk7XG4gICAgdGhpcy5jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcm1vdmUpO1xuICAgIHRoaXMucGFyZW50LmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UodGhpcyk7XG4gIH1cblxuICAjY3JlYXRlQ2FudmFzKCkge1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuY2FudmFzLmhlaWdodCA9IDA7XG4gICAgdGhpcy5jYW52YXMuY2xhc3NOYW1lID0gXCJpbmtFZGl0b3JDYW52YXNcIjtcblxuICAgIElua0VkaXRvci5fbDEwblByb21pc2UuZ2V0KFwiZWRpdG9yX2lua19jYW52YXNfYXJpYV9sYWJlbFwiKS50aGVuKG1zZyA9PiB0aGlzLmNhbnZhcz8uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBtc2cpKTtcblxuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLmNhbnZhcyk7XG4gICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIH1cblxuICAjY3JlYXRlT2JzZXJ2ZXIoKSB7XG4gICAgdGhpcy4jb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZW50cmllcyA9PiB7XG4gICAgICBjb25zdCByZWN0ID0gZW50cmllc1swXS5jb250ZW50UmVjdDtcblxuICAgICAgaWYgKHJlY3Qud2lkdGggJiYgcmVjdC5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5zZXREaW1lbnNpb25zKHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLiNvYnNlcnZlci5vYnNlcnZlKHRoaXMuZGl2KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG5cbiAgICBsZXQgYmFzZVgsIGJhc2VZO1xuXG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuXG4gICAgc3VwZXIucmVuZGVyKCk7XG5cbiAgICBJbmtFZGl0b3IuX2wxMG5Qcm9taXNlLmdldChcImVkaXRvcl9pbmtfYXJpYV9sYWJlbFwiKS50aGVuKG1zZyA9PiB0aGlzLmRpdj8uc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBtc2cpKTtcblxuICAgIGNvbnN0IFt4LCB5LCB3LCBoXSA9IHRoaXMuI2dldEluaXRpYWxCQm94KCk7XG4gICAgdGhpcy5zZXRBdCh4LCB5LCAwLCAwKTtcbiAgICB0aGlzLnNldERpbXModywgaCk7XG4gICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG5cbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnQudmlld3BvcnRCYXNlRGltZW5zaW9ucztcbiAgICAgIHRoaXMuc2V0QXQoYmFzZVggKiBwYXJlbnRXaWR0aCwgYmFzZVkgKiBwYXJlbnRIZWlnaHQsIHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgICAgdGhpcy4jaXNDYW52YXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLiNzZXRDYW52YXNEaW1zKCk7XG4gICAgICB0aGlzLnNldERpbXModGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIHRoaXMuI3NldE1pbkRpbXMoKTtcbiAgICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5hZGQoXCJkaXNhYmxlZFwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LmFkZChcImVkaXRpbmdcIik7XG4gICAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgfVxuXG4gICAgdGhpcy4jY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cblxuICAjc2V0Q2FudmFzRGltcygpIHtcbiAgICBpZiAoIXRoaXMuI2lzQ2FudmFzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudC52aWV3cG9ydEJhc2VEaW1lbnNpb25zO1xuICAgIHRoaXMuY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCk7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICB0aGlzLiN1cGRhdGVUcmFuc2Zvcm0oKTtcbiAgfVxuXG4gIHNldERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHJvdW5kZWRXaWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgIGNvbnN0IHJvdW5kZWRIZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG5cbiAgICBpZiAodGhpcy4jcmVhbFdpZHRoID09PSByb3VuZGVkV2lkdGggJiYgdGhpcy4jcmVhbEhlaWdodCA9PT0gcm91bmRlZEhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuI3JlYWxXaWR0aCA9IHJvdW5kZWRXaWR0aDtcbiAgICB0aGlzLiNyZWFsSGVpZ2h0ID0gcm91bmRlZEhlaWdodDtcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcblxuICAgIGlmICh0aGlzLiNhc3BlY3RSYXRpbyAmJiBNYXRoLmFicyh0aGlzLiNhc3BlY3RSYXRpbyAtIHdpZHRoIC8gaGVpZ2h0KSA+IDFlLTIpIHtcbiAgICAgIGhlaWdodCA9IE1hdGguY2VpbCh3aWR0aCAvIHRoaXMuI2FzcGVjdFJhdGlvKTtcbiAgICAgIHRoaXMuc2V0RGltcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudC52aWV3cG9ydEJhc2VEaW1lbnNpb25zO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFyZW50SGVpZ2h0O1xuXG4gICAgaWYgKHRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICB0aGlzLiNzZXRTY2FsZUZhY3Rvcih3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG5cbiAgICB0aGlzLiNzZXRDYW52YXNEaW1zKCk7XG4gICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgdGhpcy5jYW52YXMuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICB9XG5cbiAgI3NldFNjYWxlRmFjdG9yKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy4jZ2V0UGFkZGluZygpO1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yVyA9ICh3aWR0aCAtIHBhZGRpbmcpIC8gdGhpcy4jYmFzZVdpZHRoO1xuICAgIGNvbnN0IHNjYWxlRmFjdG9ySCA9IChoZWlnaHQgLSBwYWRkaW5nKSAvIHRoaXMuI2Jhc2VIZWlnaHQ7XG4gICAgdGhpcy5zY2FsZUZhY3RvciA9IE1hdGgubWluKHNjYWxlRmFjdG9yVywgc2NhbGVGYWN0b3JIKTtcbiAgfVxuXG4gICN1cGRhdGVUcmFuc2Zvcm0oKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMuI2dldFBhZGRpbmcoKSAvIDI7XG4gICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKHRoaXMuc2NhbGVGYWN0b3IsIDAsIDAsIHRoaXMuc2NhbGVGYWN0b3IsIHRoaXMudHJhbnNsYXRpb25YICogdGhpcy5zY2FsZUZhY3RvciArIHBhZGRpbmcsIHRoaXMudHJhbnNsYXRpb25ZICogdGhpcy5zY2FsZUZhY3RvciArIHBhZGRpbmcpO1xuICB9XG5cbiAgc3RhdGljICNidWlsZFBhdGgyRChiZXppZXIpIHtcbiAgICBjb25zdCBwYXRoMkQgPSBuZXcgUGF0aDJEKCk7XG5cbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBiZXppZXIubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgW2ZpcnN0LCBjb250cm9sMSwgY29udHJvbDIsIHNlY29uZF0gPSBiZXppZXJbaV07XG5cbiAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgIHBhdGgyRC5tb3ZlVG8oLi4uZmlyc3QpO1xuICAgICAgfVxuXG4gICAgICBwYXRoMkQuYmV6aWVyQ3VydmVUbyhjb250cm9sMVswXSwgY29udHJvbDFbMV0sIGNvbnRyb2wyWzBdLCBjb250cm9sMlsxXSwgc2Vjb25kWzBdLCBzZWNvbmRbMV0pO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoMkQ7XG4gIH1cblxuICAjc2VyaWFsaXplUGF0aHMocywgdHgsIHR5LCBoKSB7XG4gICAgY29uc3QgTlVNQkVSX09GX1BPSU5UU19PTl9CRVpJRVJfQ1VSVkUgPSA0O1xuICAgIGNvbnN0IHBhdGhzID0gW107XG4gICAgY29uc3QgcGFkZGluZyA9IHRoaXMudGhpY2tuZXNzIC8gMjtcbiAgICBsZXQgYnVmZmVyLCBwb2ludHM7XG5cbiAgICBmb3IgKGNvbnN0IGJlemllciBvZiB0aGlzLnBhdGhzKSB7XG4gICAgICBidWZmZXIgPSBbXTtcbiAgICAgIHBvaW50cyA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBiZXppZXIubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBjb25zdCBbZmlyc3QsIGNvbnRyb2wxLCBjb250cm9sMiwgc2Vjb25kXSA9IGJlemllcltpXTtcbiAgICAgICAgY29uc3QgcDEwID0gcyAqIChmaXJzdFswXSArIHR4KSArIHBhZGRpbmc7XG4gICAgICAgIGNvbnN0IHAxMSA9IGggLSBzICogKGZpcnN0WzFdICsgdHkpIC0gcGFkZGluZztcbiAgICAgICAgY29uc3QgcDIwID0gcyAqIChjb250cm9sMVswXSArIHR4KSArIHBhZGRpbmc7XG4gICAgICAgIGNvbnN0IHAyMSA9IGggLSBzICogKGNvbnRyb2wxWzFdICsgdHkpIC0gcGFkZGluZztcbiAgICAgICAgY29uc3QgcDMwID0gcyAqIChjb250cm9sMlswXSArIHR4KSArIHBhZGRpbmc7XG4gICAgICAgIGNvbnN0IHAzMSA9IGggLSBzICogKGNvbnRyb2wyWzFdICsgdHkpIC0gcGFkZGluZztcbiAgICAgICAgY29uc3QgcDQwID0gcyAqIChzZWNvbmRbMF0gKyB0eCkgKyBwYWRkaW5nO1xuICAgICAgICBjb25zdCBwNDEgPSBoIC0gcyAqIChzZWNvbmRbMV0gKyB0eSkgLSBwYWRkaW5nO1xuXG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgYnVmZmVyLnB1c2gocDEwLCBwMTEpO1xuICAgICAgICAgIHBvaW50cy5wdXNoKHAxMCwgcDExKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ1ZmZlci5wdXNoKHAyMCwgcDIxLCBwMzAsIHAzMSwgcDQwLCBwNDEpO1xuICAgICAgICB0aGlzLiNleHRyYWN0UG9pbnRzT25CZXppZXIocDEwLCBwMTEsIHAyMCwgcDIxLCBwMzAsIHAzMSwgcDQwLCBwNDEsIE5VTUJFUl9PRl9QT0lOVFNfT05fQkVaSUVSX0NVUlZFLCBwb2ludHMpO1xuICAgICAgfVxuXG4gICAgICBwYXRocy5wdXNoKHtcbiAgICAgICAgYmV6aWVyOiBidWZmZXIsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhzO1xuICB9XG5cbiAgI2V4dHJhY3RQb2ludHNPbkJlemllcihwMTAsIHAxMSwgcDIwLCBwMjEsIHAzMCwgcDMxLCBwNDAsIHA0MSwgbiwgcG9pbnRzKSB7XG4gICAgaWYgKHRoaXMuI2lzQWxtb3N0RmxhdChwMTAsIHAxMSwgcDIwLCBwMjEsIHAzMCwgcDMxLCBwNDAsIHA0MSkpIHtcbiAgICAgIHBvaW50cy5wdXNoKHA0MCwgcDQxKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICAgIGNvbnN0IHQgPSBpIC8gbjtcbiAgICAgIGNvbnN0IG10ID0gMSAtIHQ7XG4gICAgICBsZXQgcTEwID0gdCAqIHAxMCArIG10ICogcDIwO1xuICAgICAgbGV0IHExMSA9IHQgKiBwMTEgKyBtdCAqIHAyMTtcbiAgICAgIGxldCBxMjAgPSB0ICogcDIwICsgbXQgKiBwMzA7XG4gICAgICBsZXQgcTIxID0gdCAqIHAyMSArIG10ICogcDMxO1xuICAgICAgY29uc3QgcTMwID0gdCAqIHAzMCArIG10ICogcDQwO1xuICAgICAgY29uc3QgcTMxID0gdCAqIHAzMSArIG10ICogcDQxO1xuICAgICAgcTEwID0gdCAqIHExMCArIG10ICogcTIwO1xuICAgICAgcTExID0gdCAqIHExMSArIG10ICogcTIxO1xuICAgICAgcTIwID0gdCAqIHEyMCArIG10ICogcTMwO1xuICAgICAgcTIxID0gdCAqIHEyMSArIG10ICogcTMxO1xuICAgICAgcTEwID0gdCAqIHExMCArIG10ICogcTIwO1xuICAgICAgcTExID0gdCAqIHExMSArIG10ICogcTIxO1xuICAgICAgcG9pbnRzLnB1c2gocTEwLCBxMTEpO1xuICAgIH1cblxuICAgIHBvaW50cy5wdXNoKHA0MCwgcDQxKTtcbiAgfVxuXG4gICNpc0FsbW9zdEZsYXQocDEwLCBwMTEsIHAyMCwgcDIxLCBwMzAsIHAzMSwgcDQwLCBwNDEpIHtcbiAgICBjb25zdCB0b2wgPSAxMDtcbiAgICBjb25zdCBheCA9ICgzICogcDIwIC0gMiAqIHAxMCAtIHA0MCkgKiogMjtcbiAgICBjb25zdCBheSA9ICgzICogcDIxIC0gMiAqIHAxMSAtIHA0MSkgKiogMjtcbiAgICBjb25zdCBieCA9ICgzICogcDMwIC0gcDEwIC0gMiAqIHA0MCkgKiogMjtcbiAgICBjb25zdCBieSA9ICgzICogcDMxIC0gcDExIC0gMiAqIHA0MSkgKiogMjtcbiAgICByZXR1cm4gTWF0aC5tYXgoYXgsIGJ4KSArIE1hdGgubWF4KGF5LCBieSkgPD0gdG9sO1xuICB9XG5cbiAgI2dldEJib3goKSB7XG4gICAgbGV0IHhNaW4gPSBJbmZpbml0eTtcbiAgICBsZXQgeE1heCA9IC1JbmZpbml0eTtcbiAgICBsZXQgeU1pbiA9IEluZmluaXR5O1xuICAgIGxldCB5TWF4ID0gLUluZmluaXR5O1xuXG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHRoaXMucGF0aHMpIHtcbiAgICAgIGZvciAoY29uc3QgW2ZpcnN0LCBjb250cm9sMSwgY29udHJvbDIsIHNlY29uZF0gb2YgcGF0aCkge1xuICAgICAgICBjb25zdCBiYm94ID0gX3V0aWwuVXRpbC5iZXppZXJCb3VuZGluZ0JveCguLi5maXJzdCwgLi4uY29udHJvbDEsIC4uLmNvbnRyb2wyLCAuLi5zZWNvbmQpO1xuXG4gICAgICAgIHhNaW4gPSBNYXRoLm1pbih4TWluLCBiYm94WzBdKTtcbiAgICAgICAgeU1pbiA9IE1hdGgubWluKHlNaW4sIGJib3hbMV0pO1xuICAgICAgICB4TWF4ID0gTWF0aC5tYXgoeE1heCwgYmJveFsyXSk7XG4gICAgICAgIHlNYXggPSBNYXRoLm1heCh5TWF4LCBiYm94WzNdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW3hNaW4sIHlNaW4sIHhNYXgsIHlNYXhdO1xuICB9XG5cbiAgI2dldFBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Rpc2FibGVFZGl0aW5nID8gTWF0aC5jZWlsKHRoaXMudGhpY2tuZXNzICogdGhpcy5wYXJlbnQuc2NhbGVGYWN0b3IpIDogMDtcbiAgfVxuXG4gICNmaXRUb0NvbnRlbnQoZmlyc3RUaW1lID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBiYm94ID0gdGhpcy4jZ2V0QmJveCgpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLiNnZXRQYWRkaW5nKCk7XG4gICAgdGhpcy4jYmFzZVdpZHRoID0gTWF0aC5tYXgoUkVTSVpFUl9TSVpFLCBiYm94WzJdIC0gYmJveFswXSk7XG4gICAgdGhpcy4jYmFzZUhlaWdodCA9IE1hdGgubWF4KFJFU0laRVJfU0laRSwgYmJveFszXSAtIGJib3hbMV0pO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKHBhZGRpbmcgKyB0aGlzLiNiYXNlV2lkdGggKiB0aGlzLnNjYWxlRmFjdG9yKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwocGFkZGluZyArIHRoaXMuI2Jhc2VIZWlnaHQgKiB0aGlzLnNjYWxlRmFjdG9yKTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudC52aWV3cG9ydEJhc2VEaW1lbnNpb25zO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFyZW50SGVpZ2h0O1xuICAgIHRoaXMuI2FzcGVjdFJhdGlvID0gd2lkdGggLyBoZWlnaHQ7XG4gICAgdGhpcy4jc2V0TWluRGltcygpO1xuICAgIGNvbnN0IHByZXZUcmFuc2xhdGlvblggPSB0aGlzLnRyYW5zbGF0aW9uWDtcbiAgICBjb25zdCBwcmV2VHJhbnNsYXRpb25ZID0gdGhpcy50cmFuc2xhdGlvblk7XG4gICAgdGhpcy50cmFuc2xhdGlvblggPSAtYmJveFswXTtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWSA9IC1iYm94WzFdO1xuICAgIHRoaXMuI3NldENhbnZhc0RpbXMoKTtcbiAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICB0aGlzLiNyZWFsV2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLiNyZWFsSGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuc2V0RGltcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB1bnNjYWxlZFBhZGRpbmcgPSBmaXJzdFRpbWUgPyBwYWRkaW5nIC8gdGhpcy5zY2FsZUZhY3RvciAvIDIgOiAwO1xuICAgIHRoaXMudHJhbnNsYXRlKHByZXZUcmFuc2xhdGlvblggLSB0aGlzLnRyYW5zbGF0aW9uWCAtIHVuc2NhbGVkUGFkZGluZywgcHJldlRyYW5zbGF0aW9uWSAtIHRoaXMudHJhbnNsYXRpb25ZIC0gdW5zY2FsZWRQYWRkaW5nKTtcbiAgfVxuXG4gICNzZXRNaW5EaW1zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZGl2O1xuXG4gICAgaWYgKHRoaXMuI2FzcGVjdFJhdGlvID49IDEpIHtcbiAgICAgIHN0eWxlLm1pbkhlaWdodCA9IGAke1JFU0laRVJfU0laRX1weGA7XG4gICAgICBzdHlsZS5taW5XaWR0aCA9IGAke01hdGgucm91bmQodGhpcy4jYXNwZWN0UmF0aW8gKiBSRVNJWkVSX1NJWkUpfXB4YDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUubWluV2lkdGggPSBgJHtSRVNJWkVSX1NJWkV9cHhgO1xuICAgICAgc3R5bGUubWluSGVpZ2h0ID0gYCR7TWF0aC5yb3VuZChSRVNJWkVSX1NJWkUgLyB0aGlzLiNhc3BlY3RSYXRpbyl9cHhgO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQpIHtcbiAgICBjb25zdCBlZGl0b3IgPSBzdXBlci5kZXNlcmlhbGl6ZShkYXRhLCBwYXJlbnQpO1xuICAgIGVkaXRvci50aGlja25lc3MgPSBkYXRhLnRoaWNrbmVzcztcbiAgICBlZGl0b3IuY29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi5kYXRhLmNvbG9yKTtcbiAgICBlZGl0b3Iub3BhY2l0eSA9IGRhdGEub3BhY2l0eTtcbiAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHBhcmVudC5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCB3aWR0aCA9IGVkaXRvci53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBlZGl0b3IuaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICBjb25zdCBzY2FsZUZhY3RvciA9IHBhcmVudC5zY2FsZUZhY3RvcjtcbiAgICBjb25zdCBwYWRkaW5nID0gZGF0YS50aGlja25lc3MgLyAyO1xuICAgIGVkaXRvci4jYXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcbiAgICBlZGl0b3IuI2Rpc2FibGVFZGl0aW5nID0gdHJ1ZTtcbiAgICBlZGl0b3IuI3JlYWxXaWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgIGVkaXRvci4jcmVhbEhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KTtcblxuICAgIGZvciAoY29uc3Qge1xuICAgICAgYmV6aWVyXG4gICAgfSBvZiBkYXRhLnBhdGhzKSB7XG4gICAgICBjb25zdCBwYXRoID0gW107XG4gICAgICBlZGl0b3IucGF0aHMucHVzaChwYXRoKTtcbiAgICAgIGxldCBwMCA9IHNjYWxlRmFjdG9yICogKGJlemllclswXSAtIHBhZGRpbmcpO1xuICAgICAgbGV0IHAxID0gc2NhbGVGYWN0b3IgKiAoaGVpZ2h0IC0gYmV6aWVyWzFdIC0gcGFkZGluZyk7XG5cbiAgICAgIGZvciAobGV0IGkgPSAyLCBpaSA9IGJlemllci5sZW5ndGg7IGkgPCBpaTsgaSArPSA2KSB7XG4gICAgICAgIGNvbnN0IHAxMCA9IHNjYWxlRmFjdG9yICogKGJlemllcltpXSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMTEgPSBzY2FsZUZhY3RvciAqIChoZWlnaHQgLSBiZXppZXJbaSArIDFdIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAyMCA9IHNjYWxlRmFjdG9yICogKGJlemllcltpICsgMl0gLSBwYWRkaW5nKTtcbiAgICAgICAgY29uc3QgcDIxID0gc2NhbGVGYWN0b3IgKiAoaGVpZ2h0IC0gYmV6aWVyW2kgKyAzXSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMzAgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaSArIDRdIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAzMSA9IHNjYWxlRmFjdG9yICogKGhlaWdodCAtIGJlemllcltpICsgNV0gLSBwYWRkaW5nKTtcbiAgICAgICAgcGF0aC5wdXNoKFtbcDAsIHAxXSwgW3AxMCwgcDExXSwgW3AyMCwgcDIxXSwgW3AzMCwgcDMxXV0pO1xuICAgICAgICBwMCA9IHAzMDtcbiAgICAgICAgcDEgPSBwMzE7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHBhdGgyRCA9IHRoaXMuI2J1aWxkUGF0aDJEKHBhdGgpO1xuICAgICAgZWRpdG9yLmJlemllclBhdGgyRC5wdXNoKHBhdGgyRCk7XG4gICAgfVxuXG4gICAgY29uc3QgYmJveCA9IGVkaXRvci4jZ2V0QmJveCgpO1xuICAgIGVkaXRvci4jYmFzZVdpZHRoID0gTWF0aC5tYXgoUkVTSVpFUl9TSVpFLCBiYm94WzJdIC0gYmJveFswXSk7XG4gICAgZWRpdG9yLiNiYXNlSGVpZ2h0ID0gTWF0aC5tYXgoUkVTSVpFUl9TSVpFLCBiYm94WzNdIC0gYmJveFsxXSk7XG4gICAgZWRpdG9yLiNzZXRTY2FsZUZhY3Rvcih3aWR0aCwgaGVpZ2h0KTtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG5cbiAgc2VyaWFsaXplKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcmVjdCA9IHRoaXMuZ2V0UmVjdCgwLCAwKTtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnJvdGF0aW9uICUgMTgwID09PSAwID8gcmVjdFszXSAtIHJlY3RbMV0gOiByZWN0WzJdIC0gcmVjdFswXTtcblxuICAgIGNvbnN0IGNvbG9yID0gX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9jb2xvck1hbmFnZXIuY29udmVydCh0aGlzLmN0eC5zdHJva2VTdHlsZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSyxcbiAgICAgIGNvbG9yLFxuICAgICAgdGhpY2tuZXNzOiB0aGlzLnRoaWNrbmVzcyxcbiAgICAgIG9wYWNpdHk6IHRoaXMub3BhY2l0eSxcbiAgICAgIHBhdGhzOiB0aGlzLiNzZXJpYWxpemVQYXRocyh0aGlzLnNjYWxlRmFjdG9yIC8gdGhpcy5wYXJlbnQuc2NhbGVGYWN0b3IsIHRoaXMudHJhbnNsYXRpb25YLCB0aGlzLnRyYW5zbGF0aW9uWSwgaGVpZ2h0KSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYXJlbnQucGFnZUluZGV4LFxuICAgICAgcmVjdCxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uXG4gICAgfTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuSW5rRWRpdG9yID0gSW5rRWRpdG9yO1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLmZpdEN1cnZlID0gdm9pZCAwO1xuXG5jb25zdCBmaXRDdXJ2ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjYpO1xuXG5leHBvcnRzLmZpdEN1cnZlID0gZml0Q3VydmU7XG5cbi8qKiovIH0pLFxuLyogMjYgKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxuXG5mdW5jdGlvbiBmaXRDdXJ2ZShwb2ludHMsIG1heEVycm9yLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhbiBhcnJheVwiKTtcbiAgfVxuXG4gIHBvaW50cy5mb3JFYWNoKHBvaW50ID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocG9pbnQpIHx8IHBvaW50LnNvbWUoaXRlbSA9PiB0eXBlb2YgaXRlbSAhPT0gJ251bWJlcicpIHx8IHBvaW50Lmxlbmd0aCAhPT0gcG9pbnRzWzBdLmxlbmd0aCkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJFYWNoIHBvaW50IHNob3VsZCBiZSBhbiBhcnJheSBvZiBudW1iZXJzLiBFYWNoIHBvaW50IHNob3VsZCBoYXZlIHRoZSBzYW1lIGFtb3VudCBvZiBudW1iZXJzLlwiKTtcbiAgICB9XG4gIH0pO1xuICBwb2ludHMgPSBwb2ludHMuZmlsdGVyKChwb2ludCwgaSkgPT4gaSA9PT0gMCB8fCAhcG9pbnQuZXZlcnkoKHZhbCwgaikgPT4gdmFsID09PSBwb2ludHNbaSAtIDFdW2pdKSk7XG5cbiAgaWYgKHBvaW50cy5sZW5ndGggPCAyKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgY29uc3QgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgY29uc3QgbGVmdFRhbmdlbnQgPSBjcmVhdGVUYW5nZW50KHBvaW50c1sxXSwgcG9pbnRzWzBdKTtcbiAgY29uc3QgcmlnaHRUYW5nZW50ID0gY3JlYXRlVGFuZ2VudChwb2ludHNbbGVuIC0gMl0sIHBvaW50c1tsZW4gLSAxXSk7XG4gIHJldHVybiBmaXRDdWJpYyhwb2ludHMsIGxlZnRUYW5nZW50LCByaWdodFRhbmdlbnQsIG1heEVycm9yLCBwcm9ncmVzc0NhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZml0Q3ViaWMocG9pbnRzLCBsZWZ0VGFuZ2VudCwgcmlnaHRUYW5nZW50LCBlcnJvciwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICBjb25zdCBNYXhJdGVyYXRpb25zID0gMjA7XG4gIHZhciBiZXpDdXJ2ZSwgdSwgdVByaW1lLCBtYXhFcnJvciwgcHJldkVyciwgc3BsaXRQb2ludCwgcHJldlNwbGl0LCBjZW50ZXJWZWN0b3IsIHRvQ2VudGVyVGFuZ2VudCwgZnJvbUNlbnRlclRhbmdlbnQsIGJlemllcnMsIGRpc3QsIGk7XG5cbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBkaXN0ID0gbWF0aHMudmVjdG9yTGVuKG1hdGhzLnN1YnRyYWN0KHBvaW50c1swXSwgcG9pbnRzWzFdKSkgLyAzLjA7XG4gICAgYmV6Q3VydmUgPSBbcG9pbnRzWzBdLCBtYXRocy5hZGRBcnJheXMocG9pbnRzWzBdLCBtYXRocy5tdWxJdGVtcyhsZWZ0VGFuZ2VudCwgZGlzdCkpLCBtYXRocy5hZGRBcnJheXMocG9pbnRzWzFdLCBtYXRocy5tdWxJdGVtcyhyaWdodFRhbmdlbnQsIGRpc3QpKSwgcG9pbnRzWzFdXTtcbiAgICByZXR1cm4gW2JlekN1cnZlXTtcbiAgfVxuXG4gIHUgPSBjaG9yZExlbmd0aFBhcmFtZXRlcml6ZShwb2ludHMpO1xuICBbYmV6Q3VydmUsIG1heEVycm9yLCBzcGxpdFBvaW50XSA9IGdlbmVyYXRlQW5kUmVwb3J0KHBvaW50cywgdSwgdSwgbGVmdFRhbmdlbnQsIHJpZ2h0VGFuZ2VudCwgcHJvZ3Jlc3NDYWxsYmFjayk7XG5cbiAgaWYgKG1heEVycm9yID09PSAwIHx8IG1heEVycm9yIDwgZXJyb3IpIHtcbiAgICByZXR1cm4gW2JlekN1cnZlXTtcbiAgfVxuXG4gIGlmIChtYXhFcnJvciA8IGVycm9yICogZXJyb3IpIHtcbiAgICB1UHJpbWUgPSB1O1xuICAgIHByZXZFcnIgPSBtYXhFcnJvcjtcbiAgICBwcmV2U3BsaXQgPSBzcGxpdFBvaW50O1xuXG4gICAgZm9yIChpID0gMDsgaSA8IE1heEl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgdVByaW1lID0gcmVwYXJhbWV0ZXJpemUoYmV6Q3VydmUsIHBvaW50cywgdVByaW1lKTtcbiAgICAgIFtiZXpDdXJ2ZSwgbWF4RXJyb3IsIHNwbGl0UG9pbnRdID0gZ2VuZXJhdGVBbmRSZXBvcnQocG9pbnRzLCB1LCB1UHJpbWUsIGxlZnRUYW5nZW50LCByaWdodFRhbmdlbnQsIHByb2dyZXNzQ2FsbGJhY2spO1xuXG4gICAgICBpZiAobWF4RXJyb3IgPCBlcnJvcikge1xuICAgICAgICByZXR1cm4gW2JlekN1cnZlXTtcbiAgICAgIH0gZWxzZSBpZiAoc3BsaXRQb2ludCA9PT0gcHJldlNwbGl0KSB7XG4gICAgICAgIGxldCBlcnJDaGFuZ2UgPSBtYXhFcnJvciAvIHByZXZFcnI7XG5cbiAgICAgICAgaWYgKGVyckNoYW5nZSA+IC45OTk5ICYmIGVyckNoYW5nZSA8IDEuMDAwMSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByZXZFcnIgPSBtYXhFcnJvcjtcbiAgICAgIHByZXZTcGxpdCA9IHNwbGl0UG9pbnQ7XG4gICAgfVxuICB9XG5cbiAgYmV6aWVycyA9IFtdO1xuICBjZW50ZXJWZWN0b3IgPSBtYXRocy5zdWJ0cmFjdChwb2ludHNbc3BsaXRQb2ludCAtIDFdLCBwb2ludHNbc3BsaXRQb2ludCArIDFdKTtcblxuICBpZiAoY2VudGVyVmVjdG9yLmV2ZXJ5KHZhbCA9PiB2YWwgPT09IDApKSB7XG4gICAgY2VudGVyVmVjdG9yID0gbWF0aHMuc3VidHJhY3QocG9pbnRzW3NwbGl0UG9pbnQgLSAxXSwgcG9pbnRzW3NwbGl0UG9pbnRdKTtcbiAgICBbY2VudGVyVmVjdG9yWzBdLCBjZW50ZXJWZWN0b3JbMV1dID0gWy1jZW50ZXJWZWN0b3JbMV0sIGNlbnRlclZlY3RvclswXV07XG4gIH1cblxuICB0b0NlbnRlclRhbmdlbnQgPSBtYXRocy5ub3JtYWxpemUoY2VudGVyVmVjdG9yKTtcbiAgZnJvbUNlbnRlclRhbmdlbnQgPSBtYXRocy5tdWxJdGVtcyh0b0NlbnRlclRhbmdlbnQsIC0xKTtcbiAgYmV6aWVycyA9IGJlemllcnMuY29uY2F0KGZpdEN1YmljKHBvaW50cy5zbGljZSgwLCBzcGxpdFBvaW50ICsgMSksIGxlZnRUYW5nZW50LCB0b0NlbnRlclRhbmdlbnQsIGVycm9yLCBwcm9ncmVzc0NhbGxiYWNrKSk7XG4gIGJlemllcnMgPSBiZXppZXJzLmNvbmNhdChmaXRDdWJpYyhwb2ludHMuc2xpY2Uoc3BsaXRQb2ludCksIGZyb21DZW50ZXJUYW5nZW50LCByaWdodFRhbmdlbnQsIGVycm9yLCBwcm9ncmVzc0NhbGxiYWNrKSk7XG4gIHJldHVybiBiZXppZXJzO1xufVxuXG47XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQW5kUmVwb3J0KHBvaW50cywgcGFyYW1zT3JpZywgcGFyYW1zUHJpbWUsIGxlZnRUYW5nZW50LCByaWdodFRhbmdlbnQsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgdmFyIGJlekN1cnZlLCBtYXhFcnJvciwgc3BsaXRQb2ludDtcbiAgYmV6Q3VydmUgPSBnZW5lcmF0ZUJlemllcihwb2ludHMsIHBhcmFtc1ByaW1lLCBsZWZ0VGFuZ2VudCwgcmlnaHRUYW5nZW50LCBwcm9ncmVzc0NhbGxiYWNrKTtcbiAgW21heEVycm9yLCBzcGxpdFBvaW50XSA9IGNvbXB1dGVNYXhFcnJvcihwb2ludHMsIGJlekN1cnZlLCBwYXJhbXNPcmlnKTtcblxuICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgIHByb2dyZXNzQ2FsbGJhY2soe1xuICAgICAgYmV6OiBiZXpDdXJ2ZSxcbiAgICAgIHBvaW50czogcG9pbnRzLFxuICAgICAgcGFyYW1zOiBwYXJhbXNPcmlnLFxuICAgICAgbWF4RXJyOiBtYXhFcnJvcixcbiAgICAgIG1heFBvaW50OiBzcGxpdFBvaW50XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gW2JlekN1cnZlLCBtYXhFcnJvciwgc3BsaXRQb2ludF07XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlQmV6aWVyKHBvaW50cywgcGFyYW1ldGVycywgbGVmdFRhbmdlbnQsIHJpZ2h0VGFuZ2VudCkge1xuICB2YXIgYmV6Q3VydmUsXG4gICAgICBBLFxuICAgICAgYSxcbiAgICAgIEMsXG4gICAgICBYLFxuICAgICAgZGV0X0MwX0MxLFxuICAgICAgZGV0X0MwX1gsXG4gICAgICBkZXRfWF9DMSxcbiAgICAgIGFscGhhX2wsXG4gICAgICBhbHBoYV9yLFxuICAgICAgZXBzaWxvbixcbiAgICAgIHNlZ0xlbmd0aCxcbiAgICAgIGksXG4gICAgICBsZW4sXG4gICAgICB0bXAsXG4gICAgICB1LFxuICAgICAgdXgsXG4gICAgICBmaXJzdFBvaW50ID0gcG9pbnRzWzBdLFxuICAgICAgbGFzdFBvaW50ID0gcG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXTtcbiAgYmV6Q3VydmUgPSBbZmlyc3RQb2ludCwgbnVsbCwgbnVsbCwgbGFzdFBvaW50XTtcbiAgQSA9IG1hdGhzLnplcm9zX1h4MngyKHBhcmFtZXRlcnMubGVuZ3RoKTtcblxuICBmb3IgKGkgPSAwLCBsZW4gPSBwYXJhbWV0ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdSA9IHBhcmFtZXRlcnNbaV07XG4gICAgdXggPSAxIC0gdTtcbiAgICBhID0gQVtpXTtcbiAgICBhWzBdID0gbWF0aHMubXVsSXRlbXMobGVmdFRhbmdlbnQsIDMgKiB1ICogKHV4ICogdXgpKTtcbiAgICBhWzFdID0gbWF0aHMubXVsSXRlbXMocmlnaHRUYW5nZW50LCAzICogdXggKiAodSAqIHUpKTtcbiAgfVxuXG4gIEMgPSBbWzAsIDBdLCBbMCwgMF1dO1xuICBYID0gWzAsIDBdO1xuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHUgPSBwYXJhbWV0ZXJzW2ldO1xuICAgIGEgPSBBW2ldO1xuICAgIENbMF1bMF0gKz0gbWF0aHMuZG90KGFbMF0sIGFbMF0pO1xuICAgIENbMF1bMV0gKz0gbWF0aHMuZG90KGFbMF0sIGFbMV0pO1xuICAgIENbMV1bMF0gKz0gbWF0aHMuZG90KGFbMF0sIGFbMV0pO1xuICAgIENbMV1bMV0gKz0gbWF0aHMuZG90KGFbMV0sIGFbMV0pO1xuICAgIHRtcCA9IG1hdGhzLnN1YnRyYWN0KHBvaW50c1tpXSwgYmV6aWVyLnEoW2ZpcnN0UG9pbnQsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCwgbGFzdFBvaW50XSwgdSkpO1xuICAgIFhbMF0gKz0gbWF0aHMuZG90KGFbMF0sIHRtcCk7XG4gICAgWFsxXSArPSBtYXRocy5kb3QoYVsxXSwgdG1wKTtcbiAgfVxuXG4gIGRldF9DMF9DMSA9IENbMF1bMF0gKiBDWzFdWzFdIC0gQ1sxXVswXSAqIENbMF1bMV07XG4gIGRldF9DMF9YID0gQ1swXVswXSAqIFhbMV0gLSBDWzFdWzBdICogWFswXTtcbiAgZGV0X1hfQzEgPSBYWzBdICogQ1sxXVsxXSAtIFhbMV0gKiBDWzBdWzFdO1xuICBhbHBoYV9sID0gZGV0X0MwX0MxID09PSAwID8gMCA6IGRldF9YX0MxIC8gZGV0X0MwX0MxO1xuICBhbHBoYV9yID0gZGV0X0MwX0MxID09PSAwID8gMCA6IGRldF9DMF9YIC8gZGV0X0MwX0MxO1xuICBzZWdMZW5ndGggPSBtYXRocy52ZWN0b3JMZW4obWF0aHMuc3VidHJhY3QoZmlyc3RQb2ludCwgbGFzdFBvaW50KSk7XG4gIGVwc2lsb24gPSAxLjBlLTYgKiBzZWdMZW5ndGg7XG5cbiAgaWYgKGFscGhhX2wgPCBlcHNpbG9uIHx8IGFscGhhX3IgPCBlcHNpbG9uKSB7XG4gICAgYmV6Q3VydmVbMV0gPSBtYXRocy5hZGRBcnJheXMoZmlyc3RQb2ludCwgbWF0aHMubXVsSXRlbXMobGVmdFRhbmdlbnQsIHNlZ0xlbmd0aCAvIDMuMCkpO1xuICAgIGJlekN1cnZlWzJdID0gbWF0aHMuYWRkQXJyYXlzKGxhc3RQb2ludCwgbWF0aHMubXVsSXRlbXMocmlnaHRUYW5nZW50LCBzZWdMZW5ndGggLyAzLjApKTtcbiAgfSBlbHNlIHtcbiAgICBiZXpDdXJ2ZVsxXSA9IG1hdGhzLmFkZEFycmF5cyhmaXJzdFBvaW50LCBtYXRocy5tdWxJdGVtcyhsZWZ0VGFuZ2VudCwgYWxwaGFfbCkpO1xuICAgIGJlekN1cnZlWzJdID0gbWF0aHMuYWRkQXJyYXlzKGxhc3RQb2ludCwgbWF0aHMubXVsSXRlbXMocmlnaHRUYW5nZW50LCBhbHBoYV9yKSk7XG4gIH1cblxuICByZXR1cm4gYmV6Q3VydmU7XG59XG5cbjtcblxuZnVuY3Rpb24gcmVwYXJhbWV0ZXJpemUoYmV6aWVyLCBwb2ludHMsIHBhcmFtZXRlcnMpIHtcbiAgcmV0dXJuIHBhcmFtZXRlcnMubWFwKChwLCBpKSA9PiBuZXd0b25SYXBoc29uUm9vdEZpbmQoYmV6aWVyLCBwb2ludHNbaV0sIHApKTtcbn1cblxuO1xuXG5mdW5jdGlvbiBuZXd0b25SYXBoc29uUm9vdEZpbmQoYmV6LCBwb2ludCwgdSkge1xuICB2YXIgZCA9IG1hdGhzLnN1YnRyYWN0KGJlemllci5xKGJleiwgdSksIHBvaW50KSxcbiAgICAgIHFwcmltZSA9IGJlemllci5xcHJpbWUoYmV6LCB1KSxcbiAgICAgIG51bWVyYXRvciA9IG1hdGhzLm11bE1hdHJpeChkLCBxcHJpbWUpLFxuICAgICAgZGVub21pbmF0b3IgPSBtYXRocy5zdW0obWF0aHMuc3F1YXJlSXRlbXMocXByaW1lKSkgKyAyICogbWF0aHMubXVsTWF0cml4KGQsIGJlemllci5xcHJpbWVwcmltZShiZXosIHUpKTtcblxuICBpZiAoZGVub21pbmF0b3IgPT09IDApIHtcbiAgICByZXR1cm4gdTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdSAtIG51bWVyYXRvciAvIGRlbm9taW5hdG9yO1xuICB9XG59XG5cbjtcblxuZnVuY3Rpb24gY2hvcmRMZW5ndGhQYXJhbWV0ZXJpemUocG9pbnRzKSB7XG4gIHZhciB1ID0gW10sXG4gICAgICBjdXJyVSxcbiAgICAgIHByZXZVLFxuICAgICAgcHJldlA7XG4gIHBvaW50cy5mb3JFYWNoKChwLCBpKSA9PiB7XG4gICAgY3VyclUgPSBpID8gcHJldlUgKyBtYXRocy52ZWN0b3JMZW4obWF0aHMuc3VidHJhY3QocCwgcHJldlApKSA6IDA7XG4gICAgdS5wdXNoKGN1cnJVKTtcbiAgICBwcmV2VSA9IGN1cnJVO1xuICAgIHByZXZQID0gcDtcbiAgfSk7XG4gIHUgPSB1Lm1hcCh4ID0+IHggLyBwcmV2VSk7XG4gIHJldHVybiB1O1xufVxuXG47XG5cbmZ1bmN0aW9uIGNvbXB1dGVNYXhFcnJvcihwb2ludHMsIGJleiwgcGFyYW1ldGVycykge1xuICB2YXIgZGlzdCwgbWF4RGlzdCwgc3BsaXRQb2ludCwgdiwgaSwgY291bnQsIHBvaW50LCB0O1xuICBtYXhEaXN0ID0gMDtcbiAgc3BsaXRQb2ludCA9IE1hdGguZmxvb3IocG9pbnRzLmxlbmd0aCAvIDIpO1xuICBjb25zdCB0X2Rpc3RNYXAgPSBtYXBUdG9SZWxhdGl2ZURpc3RhbmNlcyhiZXosIDEwKTtcblxuICBmb3IgKGkgPSAwLCBjb3VudCA9IHBvaW50cy5sZW5ndGg7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgdCA9IGZpbmRfdChiZXosIHBhcmFtZXRlcnNbaV0sIHRfZGlzdE1hcCwgMTApO1xuICAgIHYgPSBtYXRocy5zdWJ0cmFjdChiZXppZXIucShiZXosIHQpLCBwb2ludCk7XG4gICAgZGlzdCA9IHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV07XG5cbiAgICBpZiAoZGlzdCA+IG1heERpc3QpIHtcbiAgICAgIG1heERpc3QgPSBkaXN0O1xuICAgICAgc3BsaXRQb2ludCA9IGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFttYXhEaXN0LCBzcGxpdFBvaW50XTtcbn1cblxuO1xuXG52YXIgbWFwVHRvUmVsYXRpdmVEaXN0YW5jZXMgPSBmdW5jdGlvbiAoYmV6LCBCX3BhcnRzKSB7XG4gIHZhciBCX3RfY3VycjtcbiAgdmFyIEJfdF9kaXN0ID0gWzBdO1xuICB2YXIgQl90X3ByZXYgPSBiZXpbMF07XG4gIHZhciBzdW1MZW4gPSAwO1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IEJfcGFydHM7IGkrKykge1xuICAgIEJfdF9jdXJyID0gYmV6aWVyLnEoYmV6LCBpIC8gQl9wYXJ0cyk7XG4gICAgc3VtTGVuICs9IG1hdGhzLnZlY3RvckxlbihtYXRocy5zdWJ0cmFjdChCX3RfY3VyciwgQl90X3ByZXYpKTtcbiAgICBCX3RfZGlzdC5wdXNoKHN1bUxlbik7XG4gICAgQl90X3ByZXYgPSBCX3RfY3VycjtcbiAgfVxuXG4gIEJfdF9kaXN0ID0gQl90X2Rpc3QubWFwKHggPT4geCAvIHN1bUxlbik7XG4gIHJldHVybiBCX3RfZGlzdDtcbn07XG5cbmZ1bmN0aW9uIGZpbmRfdChiZXosIHBhcmFtLCB0X2Rpc3RNYXAsIEJfcGFydHMpIHtcbiAgaWYgKHBhcmFtIDwgMCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKHBhcmFtID4gMSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGxlbk1heCwgbGVuTWluLCB0TWF4LCB0TWluLCB0O1xuXG4gIGZvciAodmFyIGkgPSAxOyBpIDw9IEJfcGFydHM7IGkrKykge1xuICAgIGlmIChwYXJhbSA8PSB0X2Rpc3RNYXBbaV0pIHtcbiAgICAgIHRNaW4gPSAoaSAtIDEpIC8gQl9wYXJ0cztcbiAgICAgIHRNYXggPSBpIC8gQl9wYXJ0cztcbiAgICAgIGxlbk1pbiA9IHRfZGlzdE1hcFtpIC0gMV07XG4gICAgICBsZW5NYXggPSB0X2Rpc3RNYXBbaV07XG4gICAgICB0ID0gKHBhcmFtIC0gbGVuTWluKSAvIChsZW5NYXggLSBsZW5NaW4pICogKHRNYXggLSB0TWluKSArIHRNaW47XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGFuZ2VudChwb2ludEEsIHBvaW50Qikge1xuICByZXR1cm4gbWF0aHMubm9ybWFsaXplKG1hdGhzLnN1YnRyYWN0KHBvaW50QSwgcG9pbnRCKSk7XG59XG5cbmNsYXNzIG1hdGhzIHtcbiAgc3RhdGljIHplcm9zX1h4MngyKHgpIHtcbiAgICB2YXIgenMgPSBbXTtcblxuICAgIHdoaWxlICh4LS0pIHtcbiAgICAgIHpzLnB1c2goWzAsIDBdKTtcbiAgICB9XG5cbiAgICByZXR1cm4genM7XG4gIH1cblxuICBzdGF0aWMgbXVsSXRlbXMoaXRlbXMsIG11bHRpcGxpZXIpIHtcbiAgICByZXR1cm4gaXRlbXMubWFwKHggPT4geCAqIG11bHRpcGxpZXIpO1xuICB9XG5cbiAgc3RhdGljIG11bE1hdHJpeChtMSwgbTIpIHtcbiAgICByZXR1cm4gbTEucmVkdWNlKChzdW0sIHgxLCBpKSA9PiBzdW0gKyB4MSAqIG0yW2ldLCAwKTtcbiAgfVxuXG4gIHN0YXRpYyBzdWJ0cmFjdChhcnIxLCBhcnIyKSB7XG4gICAgcmV0dXJuIGFycjEubWFwKCh4MSwgaSkgPT4geDEgLSBhcnIyW2ldKTtcbiAgfVxuXG4gIHN0YXRpYyBhZGRBcnJheXMoYXJyMSwgYXJyMikge1xuICAgIHJldHVybiBhcnIxLm1hcCgoeDEsIGkpID0+IHgxICsgYXJyMltpXSk7XG4gIH1cblxuICBzdGF0aWMgYWRkSXRlbXMoaXRlbXMsIGFkZGl0aW9uKSB7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcCh4ID0+IHggKyBhZGRpdGlvbik7XG4gIH1cblxuICBzdGF0aWMgc3VtKGl0ZW1zKSB7XG4gICAgcmV0dXJuIGl0ZW1zLnJlZHVjZSgoc3VtLCB4KSA9PiBzdW0gKyB4KTtcbiAgfVxuXG4gIHN0YXRpYyBkb3QobTEsIG0yKSB7XG4gICAgcmV0dXJuIG1hdGhzLm11bE1hdHJpeChtMSwgbTIpO1xuICB9XG5cbiAgc3RhdGljIHZlY3Rvckxlbih2KSB7XG4gICAgcmV0dXJuIE1hdGguaHlwb3QoLi4udik7XG4gIH1cblxuICBzdGF0aWMgZGl2SXRlbXMoaXRlbXMsIGRpdmlzb3IpIHtcbiAgICByZXR1cm4gaXRlbXMubWFwKHggPT4geCAvIGRpdmlzb3IpO1xuICB9XG5cbiAgc3RhdGljIHNxdWFyZUl0ZW1zKGl0ZW1zKSB7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcCh4ID0+IHggKiB4KTtcbiAgfVxuXG4gIHN0YXRpYyBub3JtYWxpemUodikge1xuICAgIHJldHVybiB0aGlzLmRpdkl0ZW1zKHYsIHRoaXMudmVjdG9yTGVuKHYpKTtcbiAgfVxuXG59XG5cbmNsYXNzIGJlemllciB7XG4gIHN0YXRpYyBxKGN0cmxQb2x5LCB0KSB7XG4gICAgdmFyIHR4ID0gMS4wIC0gdDtcbiAgICB2YXIgcEEgPSBtYXRocy5tdWxJdGVtcyhjdHJsUG9seVswXSwgdHggKiB0eCAqIHR4KSxcbiAgICAgICAgcEIgPSBtYXRocy5tdWxJdGVtcyhjdHJsUG9seVsxXSwgMyAqIHR4ICogdHggKiB0KSxcbiAgICAgICAgcEMgPSBtYXRocy5tdWxJdGVtcyhjdHJsUG9seVsyXSwgMyAqIHR4ICogdCAqIHQpLFxuICAgICAgICBwRCA9IG1hdGhzLm11bEl0ZW1zKGN0cmxQb2x5WzNdLCB0ICogdCAqIHQpO1xuICAgIHJldHVybiBtYXRocy5hZGRBcnJheXMobWF0aHMuYWRkQXJyYXlzKHBBLCBwQiksIG1hdGhzLmFkZEFycmF5cyhwQywgcEQpKTtcbiAgfVxuXG4gIHN0YXRpYyBxcHJpbWUoY3RybFBvbHksIHQpIHtcbiAgICB2YXIgdHggPSAxLjAgLSB0O1xuICAgIHZhciBwQSA9IG1hdGhzLm11bEl0ZW1zKG1hdGhzLnN1YnRyYWN0KGN0cmxQb2x5WzFdLCBjdHJsUG9seVswXSksIDMgKiB0eCAqIHR4KSxcbiAgICAgICAgcEIgPSBtYXRocy5tdWxJdGVtcyhtYXRocy5zdWJ0cmFjdChjdHJsUG9seVsyXSwgY3RybFBvbHlbMV0pLCA2ICogdHggKiB0KSxcbiAgICAgICAgcEMgPSBtYXRocy5tdWxJdGVtcyhtYXRocy5zdWJ0cmFjdChjdHJsUG9seVszXSwgY3RybFBvbHlbMl0pLCAzICogdCAqIHQpO1xuICAgIHJldHVybiBtYXRocy5hZGRBcnJheXMobWF0aHMuYWRkQXJyYXlzKHBBLCBwQiksIHBDKTtcbiAgfVxuXG4gIHN0YXRpYyBxcHJpbWVwcmltZShjdHJsUG9seSwgdCkge1xuICAgIHJldHVybiBtYXRocy5hZGRBcnJheXMobWF0aHMubXVsSXRlbXMobWF0aHMuYWRkQXJyYXlzKG1hdGhzLnN1YnRyYWN0KGN0cmxQb2x5WzJdLCBtYXRocy5tdWxJdGVtcyhjdHJsUG9seVsxXSwgMikpLCBjdHJsUG9seVswXSksIDYgKiAoMS4wIC0gdCkpLCBtYXRocy5tdWxJdGVtcyhtYXRocy5hZGRBcnJheXMobWF0aHMuc3VidHJhY3QoY3RybFBvbHlbM10sIG1hdGhzLm11bEl0ZW1zKGN0cmxQb2x5WzJdLCAyKSksIGN0cmxQb2x5WzFdKSwgNiAqIHQpKTtcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZml0Q3VydmU7XG5tb2R1bGUuZXhwb3J0cy5maXRDdWJpYyA9IGZpdEN1YmljO1xubW9kdWxlLmV4cG9ydHMuY3JlYXRlVGFuZ2VudCA9IGNyZWF0ZVRhbmdlbnQ7XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuQW5ub3RhdGlvbkxheWVyID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgpO1xuXG52YXIgX2Fubm90YXRpb25fc3RvcmFnZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNSk7XG5cbnZhciBfc2NyaXB0aW5nX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygyOCk7XG5cbnZhciBfeGZhX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygyOSk7XG5cbmNvbnN0IERFRkFVTFRfVEFCX0lOREVYID0gMTAwMDtcbmNvbnN0IERFRkFVTFRfRk9OVF9TSVpFID0gOTtcbmNvbnN0IEdldEVsZW1lbnRzQnlOYW1lU2V0ID0gbmV3IFdlYWtTZXQoKTtcblxuZnVuY3Rpb24gZ2V0UmVjdERpbXMocmVjdCkge1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiByZWN0WzJdIC0gcmVjdFswXSxcbiAgICBoZWlnaHQ6IHJlY3RbM10gLSByZWN0WzFdXG4gIH07XG59XG5cbmNsYXNzIEFubm90YXRpb25FbGVtZW50RmFjdG9yeSB7XG4gIHN0YXRpYyBjcmVhdGUocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHN1YnR5cGUgPSBwYXJhbWV0ZXJzLmRhdGEuYW5ub3RhdGlvblR5cGU7XG5cbiAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuTElOSzpcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuVEVYVDpcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuV0lER0VUOlxuICAgICAgICBjb25zdCBmaWVsZFR5cGUgPSBwYXJhbWV0ZXJzLmRhdGEuZmllbGRUeXBlO1xuXG4gICAgICAgIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgICAgICAgY2FzZSBcIlR4XCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgICAgIGNhc2UgXCJCdG5cIjpcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmRhdGEucmFkaW9CdXR0b24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbWV0ZXJzLmRhdGEuY2hlY2tCb3gpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgICAgIGNhc2UgXCJDaFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuZXcgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuUE9QVVA6XG4gICAgICAgIHJldHVybiBuZXcgUG9wdXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5GUkVFVEVYVDpcbiAgICAgICAgcmV0dXJuIG5ldyBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgTGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlNRVUFSRTpcbiAgICAgICAgcmV0dXJuIG5ldyBTcXVhcmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5DSVJDTEU6XG4gICAgICAgIHJldHVybiBuZXcgQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuUE9MWUxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5DQVJFVDpcbiAgICAgICAgcmV0dXJuIG5ldyBDYXJldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLklOSzpcbiAgICAgICAgcmV0dXJuIG5ldyBJbmtBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5QT0xZR09OOlxuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5ISUdITElHSFQ6XG4gICAgICAgIHJldHVybiBuZXcgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuVU5ERVJMSU5FOlxuICAgICAgICByZXR1cm4gbmV3IFVuZGVybGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlNRVUlHR0xZOlxuICAgICAgICByZXR1cm4gbmV3IFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuU1RSSUtFT1VUOlxuICAgICAgICByZXR1cm4gbmV3IFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlNUQU1QOlxuICAgICAgICByZXR1cm4gbmV3IFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuRklMRUFUVEFDSE1FTlQ6XG4gICAgICAgIHJldHVybiBuZXcgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5ldyBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIHtcbiAgICBpc1JlbmRlcmFibGUgPSBmYWxzZSxcbiAgICBpZ25vcmVCb3JkZXIgPSBmYWxzZSxcbiAgICBjcmVhdGVRdWFkcmlsYXRlcmFscyA9IGZhbHNlXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuaXNSZW5kZXJhYmxlID0gaXNSZW5kZXJhYmxlO1xuICAgIHRoaXMuZGF0YSA9IHBhcmFtZXRlcnMuZGF0YTtcbiAgICB0aGlzLmxheWVyID0gcGFyYW1ldGVycy5sYXllcjtcbiAgICB0aGlzLnBhZ2UgPSBwYXJhbWV0ZXJzLnBhZ2U7XG4gICAgdGhpcy52aWV3cG9ydCA9IHBhcmFtZXRlcnMudmlld3BvcnQ7XG4gICAgdGhpcy5saW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXIgPSBwYXJhbWV0ZXJzLmRvd25sb2FkTWFuYWdlcjtcbiAgICB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCA9IHBhcmFtZXRlcnMuaW1hZ2VSZXNvdXJjZXNQYXRoO1xuICAgIHRoaXMucmVuZGVyRm9ybXMgPSBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zO1xuICAgIHRoaXMuc3ZnRmFjdG9yeSA9IHBhcmFtZXRlcnMuc3ZnRmFjdG9yeTtcbiAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICB0aGlzLmVuYWJsZVNjcmlwdGluZyA9IHBhcmFtZXRlcnMuZW5hYmxlU2NyaXB0aW5nO1xuICAgIHRoaXMuaGFzSlNBY3Rpb25zID0gcGFyYW1ldGVycy5oYXNKU0FjdGlvbnM7XG4gICAgdGhpcy5fZmllbGRPYmplY3RzID0gcGFyYW1ldGVycy5maWVsZE9iamVjdHM7XG4gICAgdGhpcy5fbW91c2VTdGF0ZSA9IHBhcmFtZXRlcnMubW91c2VTdGF0ZTtcblxuICAgIGlmIChpc1JlbmRlcmFibGUpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5fY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlcik7XG4gICAgfVxuXG4gICAgaWYgKGNyZWF0ZVF1YWRyaWxhdGVyYWxzKSB7XG4gICAgICB0aGlzLnF1YWRyaWxhdGVyYWxzID0gdGhpcy5fY3JlYXRlUXVhZHJpbGF0ZXJhbHMoaWdub3JlQm9yZGVyKTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlciA9IGZhbHNlKSB7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICBwYWdlID0gdGhpcy5wYWdlLFxuICAgICAgICAgIHZpZXdwb3J0ID0gdGhpcy52aWV3cG9ydDtcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiKTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IFtwYWdlTEx4LCBwYWdlTEx5LCBwYWdlVVJ4LCBwYWdlVVJ5XSA9IHZpZXdwb3J0LnZpZXdCb3g7XG4gICAgY29uc3QgcGFnZVdpZHRoID0gcGFnZVVSeCAtIHBhZ2VMTHg7XG4gICAgY29uc3QgcGFnZUhlaWdodCA9IHBhZ2VVUnkgLSBwYWdlTEx5O1xuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLWFubm90YXRpb24taWRcIiwgZGF0YS5pZCk7XG5cbiAgICBjb25zdCByZWN0ID0gX3V0aWwuVXRpbC5ub3JtYWxpemVSZWN0KFtkYXRhLnJlY3RbMF0sIHBhZ2Uudmlld1szXSAtIGRhdGEucmVjdFsxXSArIHBhZ2Uudmlld1sxXSwgZGF0YS5yZWN0WzJdLCBwYWdlLnZpZXdbM10gLSBkYXRhLnJlY3RbM10gKyBwYWdlLnZpZXdbMV1dKTtcblxuICAgIGlmICghaWdub3JlQm9yZGVyICYmIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggPiAwKSB7XG4gICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyV2lkdGggPSBgJHtkYXRhLmJvcmRlclN0eWxlLndpZHRofXB4YDtcbiAgICAgIGNvbnN0IGhvcml6b250YWxSYWRpdXMgPSBkYXRhLmJvcmRlclN0eWxlLmhvcml6b250YWxDb3JuZXJSYWRpdXM7XG4gICAgICBjb25zdCB2ZXJ0aWNhbFJhZGl1cyA9IGRhdGEuYm9yZGVyU3R5bGUudmVydGljYWxDb3JuZXJSYWRpdXM7XG5cbiAgICAgIGlmIChob3Jpem9udGFsUmFkaXVzID4gMCB8fCB2ZXJ0aWNhbFJhZGl1cyA+IDApIHtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gYGNhbGMoJHtob3Jpem9udGFsUmFkaXVzfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSkgLyBjYWxjKCR7dmVydGljYWxSYWRpdXN9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGBjYWxjKCR7d2lkdGh9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKSAvIGNhbGMoJHtoZWlnaHR9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoZGF0YS5ib3JkZXJTdHlsZS5zdHlsZSkge1xuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuU09MSUQ6XG4gICAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlclN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5EQVNIRUQ6XG4gICAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlclN0eWxlID0gXCJkYXNoZWRcIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuQkVWRUxFRDpcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJVbmltcGxlbWVudGVkIGJvcmRlciBzdHlsZTogYmV2ZWxlZFwiKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuSU5TRVQ6XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiVW5pbXBsZW1lbnRlZCBib3JkZXIgc3R5bGU6IGluc2V0XCIpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5VTkRFUkxJTkU6XG4gICAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlckJvdHRvbVN0eWxlID0gXCJzb2xpZFwiO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJvcmRlckNvbG9yID0gZGF0YS5ib3JkZXJDb2xvciB8fCBudWxsO1xuXG4gICAgICBpZiAoYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlckNvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoYm9yZGVyQ29sb3JbMF0gfCAwLCBib3JkZXJDb2xvclsxXSB8IDAsIGJvcmRlckNvbG9yWzJdIHwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gYCR7MTAwICogKHJlY3RbMF0gLSBwYWdlTEx4KSAvIHBhZ2VXaWR0aH0lYDtcbiAgICBjb250YWluZXIuc3R5bGUudG9wID0gYCR7MTAwICogKHJlY3RbMV0gLSBwYWdlTEx5KSAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRpb25cbiAgICB9ID0gZGF0YTtcblxuICAgIGlmIChkYXRhLmhhc093bkNhbnZhcyB8fCByb3RhdGlvbiA9PT0gMCkge1xuICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGggLyBwYWdlV2lkdGh9JWA7XG4gICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogaGVpZ2h0IC8gcGFnZUhlaWdodH0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbiwgY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG5cbiAgc2V0Um90YXRpb24oYW5nbGUsIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyKSB7XG4gICAgY29uc3QgW3BhZ2VMTHgsIHBhZ2VMTHksIHBhZ2VVUngsIHBhZ2VVUnldID0gdGhpcy52aWV3cG9ydC52aWV3Qm94O1xuICAgIGNvbnN0IHBhZ2VXaWR0aCA9IHBhZ2VVUnggLSBwYWdlTEx4O1xuICAgIGNvbnN0IHBhZ2VIZWlnaHQgPSBwYWdlVVJ5IC0gcGFnZUxMeTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyh0aGlzLmRhdGEucmVjdCk7XG4gICAgbGV0IGVsZW1lbnRXaWR0aCwgZWxlbWVudEhlaWdodDtcblxuICAgIGlmIChhbmdsZSAlIDE4MCA9PT0gMCkge1xuICAgICAgZWxlbWVudFdpZHRoID0gMTAwICogd2lkdGggLyBwYWdlV2lkdGg7XG4gICAgICBlbGVtZW50SGVpZ2h0ID0gMTAwICogaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudFdpZHRoID0gMTAwICogaGVpZ2h0IC8gcGFnZVdpZHRoO1xuICAgICAgZWxlbWVudEhlaWdodCA9IDEwMCAqIHdpZHRoIC8gcGFnZUhlaWdodDtcbiAgICB9XG5cbiAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBgJHtlbGVtZW50V2lkdGh9JWA7XG4gICAgY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGAke2VsZW1lbnRIZWlnaHR9JWA7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCAoMzYwIC0gYW5nbGUpICUgMzYwKTtcbiAgfVxuXG4gIGdldCBfY29tbW9uQWN0aW9ucygpIHtcbiAgICBjb25zdCBzZXRDb2xvciA9IChqc05hbWUsIHN0eWxlTmFtZSwgZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IGNvbG9yID0gZXZlbnQuZGV0YWlsW2pzTmFtZV07XG4gICAgICBldmVudC50YXJnZXQuc3R5bGVbc3R5bGVOYW1lXSA9IF9zY3JpcHRpbmdfdXRpbHMuQ29sb3JDb252ZXJ0ZXJzW2Ake2NvbG9yWzBdfV9IVE1MYF0oY29sb3Iuc2xpY2UoMSkpO1xuICAgIH07XG5cbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfY29tbW9uQWN0aW9uc1wiLCB7XG4gICAgICBkaXNwbGF5OiBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGhpZGRlbiA9IGV2ZW50LmRldGFpbC5kaXNwbGF5ICUgMiA9PT0gMTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IGhpZGRlbiA/IFwiaGlkZGVuXCIgOiBcInZpc2libGVcIjtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXRWYWx1ZSh0aGlzLmRhdGEuaWQsIHtcbiAgICAgICAgICBoaWRkZW4sXG4gICAgICAgICAgcHJpbnQ6IGV2ZW50LmRldGFpbC5kaXNwbGF5ID09PSAwIHx8IGV2ZW50LmRldGFpbC5kaXNwbGF5ID09PSAzXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHByaW50OiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgcHJpbnQ6IGV2ZW50LmRldGFpbC5wcmludFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBoaWRkZW46IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IGV2ZW50LmRldGFpbC5oaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgaGlkZGVuOiBldmVudC5kZXRhaWwuaGlkZGVuXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGZvY3VzOiBldmVudCA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gZXZlbnQudGFyZ2V0LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiBmYWxzZVxuICAgICAgICB9KSwgMCk7XG4gICAgICB9LFxuICAgICAgdXNlck5hbWU6IGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQudGFyZ2V0LnRpdGxlID0gZXZlbnQuZGV0YWlsLnVzZXJOYW1lO1xuICAgICAgfSxcbiAgICAgIHJlYWRvbmx5OiBldmVudCA9PiB7XG4gICAgICAgIGlmIChldmVudC5kZXRhaWwucmVhZG9ubHkpIHtcbiAgICAgICAgICBldmVudC50YXJnZXQuc2V0QXR0cmlidXRlKFwicmVhZG9ubHlcIiwgXCJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXZlbnQudGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcInJlYWRvbmx5XCIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZXZlbnQudGFyZ2V0LCBldmVudC5kZXRhaWwucmVxdWlyZWQpO1xuICAgICAgfSxcbiAgICAgIGJnQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJiZ0NvbG9yXCIsIFwiYmFja2dyb3VuZENvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBmaWxsQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJmaWxsQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZnQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJmZ0NvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHRleHRDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcInRleHRDb2xvclwiLCBcImNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBib3JkZXJDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJvcmRlckNvbG9yXCIsIFwiYm9yZGVyQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHN0cm9rZUNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwic3Ryb2tlQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgcm90YXRpb246IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBldmVudC5kZXRhaWwucm90YXRpb247XG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24oYW5nbGUpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIHJvdGF0aW9uOiBhbmdsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIF9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCkge1xuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuXG4gICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGpzRXZlbnQuZGV0YWlsKSkge1xuICAgICAgY29uc3QgYWN0aW9uID0gYWN0aW9uc1tuYW1lXSB8fCBjb21tb25BY3Rpb25zW25hbWVdO1xuXG4gICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIGFjdGlvbihqc0V2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVTY3JpcHRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdG9yZWREYXRhID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5nZXRSYXdWYWx1ZSh0aGlzLmRhdGEuaWQpO1xuXG4gICAgaWYgKCFzdG9yZWREYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgY29tbW9uQWN0aW9ucyA9IHRoaXMuX2NvbW1vbkFjdGlvbnM7XG5cbiAgICBmb3IgKGNvbnN0IFthY3Rpb25OYW1lLCBkZXRhaWxdIG9mIE9iamVjdC5lbnRyaWVzKHN0b3JlZERhdGEpKSB7XG4gICAgICBjb25zdCBhY3Rpb24gPSBjb21tb25BY3Rpb25zW2FjdGlvbk5hbWVdO1xuXG4gICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50UHJveHkgPSB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBbYWN0aW9uTmFtZV06IGRldGFpbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGFyZ2V0OiBlbGVtZW50XG4gICAgICAgIH07XG4gICAgICAgIGFjdGlvbihldmVudFByb3h5KTtcbiAgICAgICAgZGVsZXRlIHN0b3JlZERhdGFbYWN0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZVF1YWRyaWxhdGVyYWxzKGlnbm9yZUJvcmRlciA9IGZhbHNlKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucXVhZFBvaW50cykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcXVhZHJpbGF0ZXJhbHMgPSBbXTtcbiAgICBjb25zdCBzYXZlZFJlY3QgPSB0aGlzLmRhdGEucmVjdDtcblxuICAgIGZvciAoY29uc3QgcXVhZFBvaW50IG9mIHRoaXMuZGF0YS5xdWFkUG9pbnRzKSB7XG4gICAgICB0aGlzLmRhdGEucmVjdCA9IFtxdWFkUG9pbnRbMl0ueCwgcXVhZFBvaW50WzJdLnksIHF1YWRQb2ludFsxXS54LCBxdWFkUG9pbnRbMV0ueV07XG4gICAgICBxdWFkcmlsYXRlcmFscy5wdXNoKHRoaXMuX2NyZWF0ZUNvbnRhaW5lcihpZ25vcmVCb3JkZXIpKTtcbiAgICB9XG5cbiAgICB0aGlzLmRhdGEucmVjdCA9IHNhdmVkUmVjdDtcbiAgICByZXR1cm4gcXVhZHJpbGF0ZXJhbHM7XG4gIH1cblxuICBfY3JlYXRlUG9wdXAodHJpZ2dlciwgZGF0YSkge1xuICAgIGxldCBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcblxuICAgIGlmICh0aGlzLnF1YWRyaWxhdGVyYWxzKSB7XG4gICAgICB0cmlnZ2VyID0gdHJpZ2dlciB8fCB0aGlzLnF1YWRyaWxhdGVyYWxzO1xuICAgICAgY29udGFpbmVyID0gdGhpcy5xdWFkcmlsYXRlcmFsc1swXTtcbiAgICB9XG5cbiAgICBpZiAoIXRyaWdnZXIpIHtcbiAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdHJpZ2dlci5jbGFzc05hbWUgPSBcInBvcHVwVHJpZ2dlckFyZWFcIjtcbiAgICAgIGNvbnRhaW5lci5hcHBlbmQodHJpZ2dlcik7XG4gICAgfVxuXG4gICAgY29uc3QgcG9wdXBFbGVtZW50ID0gbmV3IFBvcHVwRWxlbWVudCh7XG4gICAgICBjb250YWluZXIsXG4gICAgICB0cmlnZ2VyLFxuICAgICAgY29sb3I6IGRhdGEuY29sb3IsXG4gICAgICB0aXRsZU9iajogZGF0YS50aXRsZU9iaixcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IGRhdGEubW9kaWZpY2F0aW9uRGF0ZSxcbiAgICAgIGNvbnRlbnRzT2JqOiBkYXRhLmNvbnRlbnRzT2JqLFxuICAgICAgcmljaFRleHQ6IGRhdGEucmljaFRleHQsXG4gICAgICBoaWRlV3JhcHBlcjogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHBvcHVwID0gcG9wdXBFbGVtZW50LnJlbmRlcigpO1xuICAgIHBvcHVwLnN0eWxlLmxlZnQgPSBcIjEwMCVcIjtcbiAgICBjb250YWluZXIuYXBwZW5kKHBvcHVwKTtcbiAgfVxuXG4gIF9yZW5kZXJRdWFkcmlsYXRlcmFscyhjbGFzc05hbWUpIHtcbiAgICBmb3IgKGNvbnN0IHF1YWRyaWxhdGVyYWwgb2YgdGhpcy5xdWFkcmlsYXRlcmFscykge1xuICAgICAgcXVhZHJpbGF0ZXJhbC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucXVhZHJpbGF0ZXJhbHM7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgQW5ub3RhdGlvbkVsZW1lbnQucmVuZGVyYCBjYWxsZWRcIik7XG4gIH1cblxuICBfZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgc2tpcElkID0gbnVsbCkge1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuX2ZpZWxkT2JqZWN0cykge1xuICAgICAgY29uc3QgZmllbGRPYmogPSB0aGlzLl9maWVsZE9iamVjdHNbbmFtZV07XG5cbiAgICAgIGlmIChmaWVsZE9iaikge1xuICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICBwYWdlLFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGV4cG9ydFZhbHVlc1xuICAgICAgICB9IG9mIGZpZWxkT2JqKSB7XG4gICAgICAgICAgaWYgKHBhZ2UgPT09IC0xKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaWQgPT09IHNraXBJZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgZXhwb3J0VmFsdWUgPSB0eXBlb2YgZXhwb3J0VmFsdWVzID09PSBcInN0cmluZ1wiID8gZXhwb3J0VmFsdWVzIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtZWxlbWVudC1pZD1cIiR7aWR9XCJdYCk7XG5cbiAgICAgICAgICBpZiAoZG9tRWxlbWVudCAmJiAhR2V0RWxlbWVudHNCeU5hbWVTZXQuaGFzKGRvbUVsZW1lbnQpKSB7XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoYF9nZXRFbGVtZW50c0J5TmFtZSAtIGVsZW1lbnQgbm90IGFsbG93ZWQ6ICR7aWR9YCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGV4cG9ydFZhbHVlLFxuICAgICAgICAgICAgZG9tRWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaWVsZHM7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBkb21FbGVtZW50IG9mIGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKG5hbWUpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlkLFxuICAgICAgICBleHBvcnRWYWx1ZVxuICAgICAgfSA9IGRvbUVsZW1lbnQ7XG5cbiAgICAgIGlmIChpZCA9PT0gc2tpcElkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIUdldEVsZW1lbnRzQnlOYW1lU2V0Lmhhcyhkb21FbGVtZW50KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgZmllbGRzLnB1c2goe1xuICAgICAgICBpZCxcbiAgICAgICAgZXhwb3J0VmFsdWUsXG4gICAgICAgIGRvbUVsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBmaWVsZHM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHBsYXRmb3JtKCkge1xuICAgIGNvbnN0IHBsYXRmb3JtID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiA/IG5hdmlnYXRvci5wbGF0Zm9ybSA6IFwiXCI7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwicGxhdGZvcm1cIiwge1xuICAgICAgaXNXaW46IHBsYXRmb3JtLmluY2x1ZGVzKFwiV2luXCIpLFxuICAgICAgaXNNYWM6IHBsYXRmb3JtLmluY2x1ZGVzKFwiTWFjXCIpXG4gICAgfSk7XG4gIH1cblxufVxuXG5jbGFzcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMsIG9wdGlvbnMgPSBudWxsKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiAhIW9wdGlvbnM/Lmlnbm9yZUJvcmRlcixcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc1Rvb2x0aXBPbmx5ID0gcGFyYW1ldGVycy5kYXRhLmlzVG9vbHRpcE9ubHk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZGF0YSxcbiAgICAgIGxpbmtTZXJ2aWNlXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKFwiZGF0YS1lbGVtZW50LWlkXCIsIGRhdGEuaWQpO1xuICAgIGxldCBpc0JvdW5kID0gZmFsc2U7XG5cbiAgICBpZiAoZGF0YS51cmwpIHtcbiAgICAgIGxpbmtTZXJ2aWNlLmFkZExpbmtBdHRyaWJ1dGVzKGxpbmssIGRhdGEudXJsLCBkYXRhLm5ld1dpbmRvdyk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuYWN0aW9uKSB7XG4gICAgICB0aGlzLl9iaW5kTmFtZWRBY3Rpb24obGluaywgZGF0YS5hY3Rpb24pO1xuXG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuZGVzdCkge1xuICAgICAgdGhpcy5fYmluZExpbmsobGluaywgZGF0YS5kZXN0KTtcblxuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkYXRhLmFjdGlvbnMgJiYgKGRhdGEuYWN0aW9ucy5BY3Rpb24gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgVXBcIl0gfHwgZGF0YS5hY3Rpb25zW1wiTW91c2UgRG93blwiXSkgJiYgdGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fYmluZEpTQWN0aW9uKGxpbmssIGRhdGEpO1xuXG4gICAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YS5yZXNldEZvcm0pIHtcbiAgICAgICAgdGhpcy5fYmluZFJlc2V0Rm9ybUFjdGlvbihsaW5rLCBkYXRhLnJlc2V0Rm9ybSk7XG5cbiAgICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUb29sdGlwT25seSAmJiAhaXNCb3VuZCkge1xuICAgICAgICB0aGlzLl9iaW5kTGluayhsaW5rLCBcIlwiKTtcblxuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5xdWFkcmlsYXRlcmFscykge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclF1YWRyaWxhdGVyYWxzKFwibGlua0Fubm90YXRpb25cIikubWFwKChxdWFkcmlsYXRlcmFsLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsaW5rRWxlbWVudCA9IGluZGV4ID09PSAwID8gbGluayA6IGxpbmsuY2xvbmVOb2RlKCk7XG4gICAgICAgIHF1YWRyaWxhdGVyYWwuYXBwZW5kKGxpbmtFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIHF1YWRyaWxhdGVyYWw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImxpbmtBbm5vdGF0aW9uXCI7XG5cbiAgICBpZiAoaXNCb3VuZCkge1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKGxpbmspO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG4gIF9iaW5kTGluayhsaW5rLCBkZXN0aW5hdGlvbikge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0RGVzdGluYXRpb25IYXNoKGRlc3RpbmF0aW9uKTtcblxuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIGlmIChkZXN0aW5hdGlvbikge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmdvVG9EZXN0aW5hdGlvbihkZXN0aW5hdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgaWYgKGRlc3RpbmF0aW9uIHx8IGRlc3RpbmF0aW9uID09PSBcIlwiKSB7XG4gICAgICBsaW5rLmNsYXNzTmFtZSA9IFwiaW50ZXJuYWxMaW5rXCI7XG4gICAgfVxuICB9XG5cbiAgX2JpbmROYW1lZEFjdGlvbihsaW5rLCBhY3Rpb24pIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcblxuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIHRoaXMubGlua1NlcnZpY2UuZXhlY3V0ZU5hbWVkQWN0aW9uKGFjdGlvbik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIGxpbmsuY2xhc3NOYW1lID0gXCJpbnRlcm5hbExpbmtcIjtcbiAgfVxuXG4gIF9iaW5kSlNBY3Rpb24obGluaywgZGF0YSkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoW1tcIkFjdGlvblwiLCBcIm9uY2xpY2tcIl0sIFtcIk1vdXNlIFVwXCIsIFwib25tb3VzZXVwXCJdLCBbXCJNb3VzZSBEb3duXCIsIFwib25tb3VzZWRvd25cIl1dKTtcblxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhkYXRhLmFjdGlvbnMpKSB7XG4gICAgICBjb25zdCBqc05hbWUgPSBtYXAuZ2V0KG5hbWUpO1xuXG4gICAgICBpZiAoIWpzTmFtZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbGlua1tqc05hbWVdID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCFsaW5rLm9uY2xpY2spIHtcbiAgICAgIGxpbmsub25jbGljayA9ICgpID0+IGZhbHNlO1xuICAgIH1cblxuICAgIGxpbmsuY2xhc3NOYW1lID0gXCJpbnRlcm5hbExpbmtcIjtcbiAgfVxuXG4gIF9iaW5kUmVzZXRGb3JtQWN0aW9uKGxpbmssIHJlc2V0Rm9ybSkge1xuICAgIGNvbnN0IG90aGVyQ2xpY2tBY3Rpb24gPSBsaW5rLm9uY2xpY2s7XG5cbiAgICBpZiAoIW90aGVyQ2xpY2tBY3Rpb24pIHtcbiAgICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIH1cblxuICAgIGxpbmsuY2xhc3NOYW1lID0gXCJpbnRlcm5hbExpbmtcIjtcblxuICAgIGlmICghdGhpcy5fZmllbGRPYmplY3RzKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYF9iaW5kUmVzZXRGb3JtQWN0aW9uIC0gXCJyZXNldEZvcm1cIiBhY3Rpb24gbm90IHN1cHBvcnRlZCwgYCArIFwiZW5zdXJlIHRoYXQgdGhlIGBmaWVsZE9iamVjdHNgIHBhcmFtZXRlciBpcyBwcm92aWRlZC5cIik7XG5cbiAgICAgIGlmICghb3RoZXJDbGlja0FjdGlvbikge1xuICAgICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxpbmsub25jbGljayA9ICgpID0+IHtcbiAgICAgIGlmIChvdGhlckNsaWNrQWN0aW9uKSB7XG4gICAgICAgIG90aGVyQ2xpY2tBY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qge1xuICAgICAgICBmaWVsZHM6IHJlc2V0Rm9ybUZpZWxkcyxcbiAgICAgICAgcmVmczogcmVzZXRGb3JtUmVmcyxcbiAgICAgICAgaW5jbHVkZVxuICAgICAgfSA9IHJlc2V0Rm9ybTtcbiAgICAgIGNvbnN0IGFsbEZpZWxkcyA9IFtdO1xuXG4gICAgICBpZiAocmVzZXRGb3JtRmllbGRzLmxlbmd0aCAhPT0gMCB8fCByZXNldEZvcm1SZWZzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBjb25zdCBmaWVsZElkcyA9IG5ldyBTZXQocmVzZXRGb3JtUmVmcyk7XG5cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgcmVzZXRGb3JtRmllbGRzKSB7XG4gICAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRPYmplY3RzW2ZpZWxkTmFtZV0gfHwgW107XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgfSBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGZpZWxkSWRzLmFkZChpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9maWVsZE9iamVjdHMpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZElkcy5oYXMoZmllbGQuaWQpID09PSBpbmNsdWRlKSB7XG4gICAgICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGRzIG9mIE9iamVjdC52YWx1ZXModGhpcy5fZmllbGRPYmplY3RzKSkge1xuICAgICAgICAgIGFsbEZpZWxkcy5wdXNoKC4uLmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgICBjb25zdCBhbGxJZHMgPSBbXTtcblxuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBhbGxGaWVsZHMpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGlkXG4gICAgICAgIH0gPSBmaWVsZDtcbiAgICAgICAgYWxsSWRzLnB1c2goaWQpO1xuXG4gICAgICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgICBjYXNlIFwicmFkaW9idXR0b25cIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgPT09IGZpZWxkLmV4cG9ydFZhbHVlcztcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgXCJjb21ib2JveFwiOlxuICAgICAgICAgIGNhc2UgXCJsaXN0Ym94XCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQuZGVmYXVsdFZhbHVlIHx8IFwiXCI7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtZWxlbWVudC1pZD1cIiR7aWR9XCJdYCk7XG5cbiAgICAgICAgaWYgKCFkb21FbGVtZW50KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIUdldEVsZW1lbnRzQnlOYW1lU2V0Lmhhcyhkb21FbGVtZW50KSkge1xuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgX2JpbmRSZXNldEZvcm1BY3Rpb24gLSBlbGVtZW50IG5vdCBhbGxvd2VkOiAke2lkfWApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9tRWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcInJlc2V0Zm9ybVwiKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZykge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiBcImFwcFwiLFxuICAgICAgICAgICAgaWRzOiBhbGxJZHMsXG4gICAgICAgICAgICBuYW1lOiBcIlJlc2V0Rm9ybVwiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gIH1cblxufVxuXG5jbGFzcyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlT2JqPy5zdHIgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzT2JqPy5zdHIgfHwgcGFyYW1ldGVycy5kYXRhLnJpY2hUZXh0Py5zdHIpO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZVxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwidGV4dEFubm90YXRpb25cIjtcbiAgICBjb25zdCBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgaW1hZ2Uuc3JjID0gdGhpcy5pbWFnZVJlc291cmNlc1BhdGggKyBcImFubm90YXRpb24tXCIgKyB0aGlzLmRhdGEubmFtZS50b0xvd2VyQ2FzZSgpICsgXCIuc3ZnXCI7XG4gICAgaW1hZ2UuYWx0ID0gXCJbe3t0eXBlfX0gQW5ub3RhdGlvbl1cIjtcbiAgICBpbWFnZS5kYXRhc2V0LmwxMG5JZCA9IFwidGV4dF9hbm5vdGF0aW9uX3R5cGVcIjtcbiAgICBpbWFnZS5kYXRhc2V0LmwxMG5BcmdzID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdHlwZTogdGhpcy5kYXRhLm5hbWVcbiAgICB9KTtcblxuICAgIGlmICghdGhpcy5kYXRhLmhhc1BvcHVwKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cChpbWFnZSwgdGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoaW1hZ2UpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG59XG5cbmNsYXNzIFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGF0YS5hbHRlcm5hdGl2ZVRleHQpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLnRpdGxlID0gdGhpcy5kYXRhLmFsdGVybmF0aXZlVGV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxuICBfZ2V0S2V5TW9kaWZpZXIoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1dpbixcbiAgICAgIGlzTWFjXG4gICAgfSA9IEFubm90YXRpb25FbGVtZW50LnBsYXRmb3JtO1xuICAgIHJldHVybiBpc1dpbiAmJiBldmVudC5jdHJsS2V5IHx8IGlzTWFjICYmIGV2ZW50Lm1ldGFLZXk7XG4gIH1cblxuICBfc2V0RXZlbnRMaXN0ZW5lcihlbGVtZW50LCBiYXNlTmFtZSwgZXZlbnROYW1lLCB2YWx1ZUdldHRlcikge1xuICAgIGlmIChiYXNlTmFtZS5pbmNsdWRlcyhcIm1vdXNlXCIpKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZU5hbWUsIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5kYXRhLmlkLFxuICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlR2V0dGVyKGV2ZW50KSxcbiAgICAgICAgICAgIHNoaWZ0OiBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgIG1vZGlmaWVyOiB0aGlzLl9nZXRLZXlNb2RpZmllcihldmVudClcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihiYXNlTmFtZSwgZXZlbnQgPT4ge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVHZXR0ZXIoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIF9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBuYW1lcywgZ2V0dGVyKSB7XG4gICAgZm9yIChjb25zdCBbYmFzZU5hbWUsIGV2ZW50TmFtZV0gb2YgbmFtZXMpIHtcbiAgICAgIGlmIChldmVudE5hbWUgPT09IFwiQWN0aW9uXCIgfHwgdGhpcy5kYXRhLmFjdGlvbnM/LltldmVudE5hbWVdKSB7XG4gICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgYmFzZU5hbWUsIGV2ZW50TmFtZSwgZ2V0dGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpIHtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuZGF0YS5iYWNrZ3JvdW5kQ29sb3IgfHwgbnVsbDtcbiAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yID09PSBudWxsID8gXCJ0cmFuc3BhcmVudFwiIDogX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSk7XG4gIH1cblxuICBfc2V0VGV4dFN0eWxlKGVsZW1lbnQpIHtcbiAgICBjb25zdCBURVhUX0FMSUdOTUVOVCA9IFtcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiXTtcbiAgICBjb25zdCB7XG4gICAgICBmb250Q29sb3JcbiAgICB9ID0gdGhpcy5kYXRhLmRlZmF1bHRBcHBlYXJhbmNlRGF0YTtcbiAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGEuZm9udFNpemUgfHwgREVGQVVMVF9GT05UX1NJWkU7XG4gICAgY29uc3Qgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgIGxldCBjb21wdXRlZEZvbnRTaXplO1xuXG4gICAgaWYgKHRoaXMuZGF0YS5tdWx0aUxpbmUpIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV0pO1xuICAgICAgY29uc3QgbnVtYmVyT2ZMaW5lcyA9IE1hdGgucm91bmQoaGVpZ2h0IC8gKF91dGlsLkxJTkVfRkFDVE9SICogZm9udFNpemUpKSB8fCAxO1xuICAgICAgY29uc3QgbGluZUhlaWdodCA9IGhlaWdodCAvIG51bWJlck9mTGluZXM7XG4gICAgICBjb21wdXRlZEZvbnRTaXplID0gTWF0aC5taW4oZm9udFNpemUsIE1hdGgucm91bmQobGluZUhlaWdodCAvIF91dGlsLkxJTkVfRkFDVE9SKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IE1hdGguYWJzKHRoaXMuZGF0YS5yZWN0WzNdIC0gdGhpcy5kYXRhLnJlY3RbMV0pO1xuICAgICAgY29tcHV0ZWRGb250U2l6ZSA9IE1hdGgubWluKGZvbnRTaXplLCBNYXRoLnJvdW5kKGhlaWdodCAvIF91dGlsLkxJTkVfRkFDVE9SKSk7XG4gICAgfVxuXG4gICAgc3R5bGUuZm9udFNpemUgPSBgY2FsYygke2NvbXB1dGVkRm9udFNpemV9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgc3R5bGUuY29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihmb250Q29sb3JbMF0sIGZvbnRDb2xvclsxXSwgZm9udENvbG9yWzJdKTtcblxuICAgIGlmICh0aGlzLmRhdGEudGV4dEFsaWdubWVudCAhPT0gbnVsbCkge1xuICAgICAgc3R5bGUudGV4dEFsaWduID0gVEVYVF9BTElHTk1FTlRbdGhpcy5kYXRhLnRleHRBbGlnbm1lbnRdO1xuICAgIH1cbiAgfVxuXG4gIF9zZXRSZXF1aXJlZChlbGVtZW50LCBpc1JlcXVpcmVkKSB7XG4gICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwicmVxdWlyZWRcIiwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwicmVxdWlyZWRcIik7XG4gICAgfVxuXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJhcmlhLXJlcXVpcmVkXCIsIGlzUmVxdWlyZWQpO1xuICB9XG5cbn1cblxuY2xhc3MgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgaXNSZW5kZXJhYmxlID0gcGFyYW1ldGVycy5yZW5kZXJGb3JtcyB8fCAhcGFyYW1ldGVycy5kYXRhLmhhc0FwcGVhcmFuY2UgJiYgISFwYXJhbWV0ZXJzLmRhdGEuZmllbGRWYWx1ZTtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGVcbiAgICB9KTtcbiAgfVxuXG4gIHNldFByb3BlcnR5T25TaWJsaW5ncyhiYXNlLCBrZXksIHZhbHVlLCBrZXlJblN0b3JhZ2UpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcblxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShiYXNlLm5hbWUsIGJhc2UuaWQpKSB7XG4gICAgICBpZiAoZWxlbWVudC5kb21FbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuZG9tRWxlbWVudFtrZXldID0gdmFsdWU7XG4gICAgICB9XG5cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoZWxlbWVudC5pZCwge1xuICAgICAgICBba2V5SW5TdG9yYWdlXTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZGF0YS5pZDtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcInRleHRXaWRnZXRBbm5vdGF0aW9uXCI7XG4gICAgbGV0IGVsZW1lbnQgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMucmVuZGVyRm9ybXMpIHtcbiAgICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiB0aGlzLmRhdGEuZmllbGRWYWx1ZVxuICAgICAgfSk7XG4gICAgICBsZXQgdGV4dENvbnRlbnQgPSBzdG9yZWREYXRhLmZvcm1hdHRlZFZhbHVlIHx8IHN0b3JlZERhdGEudmFsdWUgfHwgXCJcIjtcbiAgICAgIGNvbnN0IG1heExlbiA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgICAgY2hhckxpbWl0OiB0aGlzLmRhdGEubWF4TGVuXG4gICAgICB9KS5jaGFyTGltaXQ7XG5cbiAgICAgIGlmIChtYXhMZW4gJiYgdGV4dENvbnRlbnQubGVuZ3RoID4gbWF4TGVuKSB7XG4gICAgICAgIHRleHRDb250ZW50ID0gdGV4dENvbnRlbnQuc2xpY2UoMCwgbWF4TGVuKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZWxlbWVudERhdGEgPSB7XG4gICAgICAgIHVzZXJWYWx1ZTogdGV4dENvbnRlbnQsXG4gICAgICAgIGZvcm1hdHRlZFZhbHVlOiBudWxsLFxuICAgICAgICB2YWx1ZU9uRm9jdXM6IFwiXCJcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudDtcblxuICAgICAgICBpZiAodGhpcy5kYXRhLmRvTm90U2Nyb2xsKSB7XG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSBcImhpZGRlblwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgICBlbGVtZW50LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCB0ZXh0Q29udGVudCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5kb05vdFNjcm9sbCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3dYID0gXCJoaWRkZW5cIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgICBlbGVtZW50LmRpc2FibGVkID0gdGhpcy5kYXRhLnJlYWRPbmx5O1xuICAgICAgZWxlbWVudC5uYW1lID0gdGhpcy5kYXRhLmZpZWxkTmFtZTtcbiAgICAgIGVsZW1lbnQudGFiSW5kZXggPSBERUZBVUxUX1RBQl9JTkRFWDtcblxuICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcblxuICAgICAgaWYgKG1heExlbikge1xuICAgICAgICBlbGVtZW50Lm1heExlbmd0aCA9IG1heExlbjtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0eU9uU2libGluZ3MoZWxlbWVudCwgXCJ2YWx1ZVwiLCBldmVudC50YXJnZXQudmFsdWUsIFwidmFsdWVcIik7XG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSA/PyBcIlwiO1xuICAgICAgICBlbGVtZW50LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICB9KTtcblxuICAgICAgbGV0IGJsdXJMaXN0ZW5lciA9IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgIH0gPSBlbGVtZW50RGF0YTtcblxuICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQudGFyZ2V0LnNjcm9sbExlZnQgPSAwO1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEudXNlclZhbHVlKSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWxlbWVudERhdGEudmFsdWVPbkZvY3VzID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZSA/PyBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGVsZW1lbnREYXRhLnVzZXJWYWx1ZS50b1N0cmluZygpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZShldmVudCkge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWVcbiAgICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgICAgZWxlbWVudERhdGEuZm9ybWF0dGVkVmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoZm9ybWF0dGVkVmFsdWUgIT09IG51bGwgJiYgZm9ybWF0dGVkVmFsdWUgIT09IHVuZGVmaW5lZCAmJiBldmVudC50YXJnZXQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBmb3JtYXR0ZWRWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNlbFJhbmdlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGV2ZW50LnRhcmdldC5zZXRTZWxlY3Rpb25SYW5nZSguLi5ldmVudC5kZXRhaWwuc2VsUmFuZ2UpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY2hhckxpbWl0OiBldmVudCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBjaGFyTGltaXRcbiAgICAgICAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgICB9ID0gZXZlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKGNoYXJMaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGFyZ2V0LnNldEF0dHJpYnV0ZShcIm1heExlbmd0aFwiLCBjaGFyTGltaXQpO1xuICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG5cbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS5sZW5ndGggPD0gY2hhckxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBjaGFyTGltaXQpO1xuICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiB0YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICBzZWxFbmQ6IHRhcmdldC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBsZXQgY29tbWl0S2V5ID0gLTE7XG5cbiAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBcIkVzY2FwZVwiKSB7XG4gICAgICAgICAgICBjb21taXRLZXkgPSAwO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICAgIGNvbW1pdEtleSA9IDI7XG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudC5rZXkgPT09IFwiVGFiXCIpIHtcbiAgICAgICAgICAgIGNvbW1pdEtleSA9IDM7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbW1pdEtleSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG5cbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEudmFsdWVPbkZvY3VzID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICBjb21taXRLZXksXG4gICAgICAgICAgICAgIHNlbFN0YXJ0OiBldmVudC50YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbEVuZDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX2JsdXJMaXN0ZW5lciA9IGJsdXJMaXN0ZW5lcjtcbiAgICAgICAgYmx1ckxpc3RlbmVyID0gbnVsbDtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBldmVudCA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IHZhbHVlO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX21vdXNlU3RhdGUuaXNEb3duICYmIGVsZW1lbnREYXRhLnZhbHVlT25Gb2N1cyAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICB3aWxsQ29tbWl0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgICAgICAgICBzZWxTdGFydDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgIHNlbEVuZDogZXZlbnQudGFyZ2V0LnNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfYmx1ckxpc3RlbmVyKGV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5hY3Rpb25zPy5LZXlzdHJva2UpIHtcbiAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgIHRhcmdldFxuICAgICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgIHNlbGVjdGlvbkVuZFxuICAgICAgICAgICAgfSA9IHRhcmdldDtcbiAgICAgICAgICAgIGxldCBzZWxTdGFydCA9IHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgIHNlbEVuZCA9IHNlbGVjdGlvbkVuZDtcblxuICAgICAgICAgICAgc3dpdGNoIChldmVudC5pbnB1dFR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVdvcmRCYWNrd2FyZFwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KS5tYXRjaCgvXFx3KlteXFx3XSokLyk7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxTdGFydCAtPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlV29yZEZvcndhcmRcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb25TdGFydCkubWF0Y2goL15bXlxcd10qXFx3Ki8pO1xuXG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVDb250ZW50QmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgc2VsU3RhcnQgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlQ29udGVudEZvcndhcmRcIjpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgc2VsRW5kICs9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgY2hhbmdlOiBkYXRhIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgd2lsbENvbW1pdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgc2VsU3RhcnQsXG4gICAgICAgICAgICAgICAgc2VsRW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgW1tcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQudmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYmx1ckxpc3RlbmVyKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYmx1ckxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuZGF0YS5jb21iKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkV2lkdGggPSB0aGlzLmRhdGEucmVjdFsyXSAtIHRoaXMuZGF0YS5yZWN0WzBdO1xuICAgICAgICBjb25zdCBjb21iV2lkdGggPSBmaWVsZFdpZHRoIC8gbWF4TGVuO1xuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb21iXCIpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmxldHRlclNwYWNpbmcgPSBgY2FsYygke2NvbWJXaWR0aH1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikgLSAxY2gpYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgICBlbGVtZW50LnN0eWxlLnZlcnRpY2FsQWxpZ24gPSBcIm1pZGRsZVwiO1xuICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJ0YWJsZS1jZWxsXCI7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0VGV4dFN0eWxlKGVsZW1lbnQpO1xuXG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuXG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG5cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG5cbn1cblxuY2xhc3MgQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmV4cG9ydFZhbHVlID09PSBkYXRhLmZpZWxkVmFsdWVcbiAgICB9KS52YWx1ZTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgIT09IFwiT2ZmXCI7XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImJ1dHRvbldpZGdldEFubm90YXRpb24gY2hlY2tCb3hcIjtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgZWxlbWVudC5kaXNhYmxlZCA9IGRhdGEucmVhZE9ubHk7XG5cbiAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuXG4gICAgZWxlbWVudC50eXBlID0gXCJjaGVja2JveFwiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJleHBvcnRWYWx1ZVwiLCBkYXRhLmV4cG9ydFZhbHVlKTtcbiAgICBlbGVtZW50LnRhYkluZGV4ID0gREVGQVVMVF9UQUJfSU5ERVg7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY2hlY2tlZFxuICAgICAgfSA9IGV2ZW50LnRhcmdldDtcblxuICAgICAgZm9yIChjb25zdCBjaGVja2JveCBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShuYW1lLCBpZCkpIHtcbiAgICAgICAgY29uc3QgY3VyQ2hlY2tlZCA9IGNoZWNrZWQgJiYgY2hlY2tib3guZXhwb3J0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG5cbiAgICAgICAgaWYgKGNoZWNrYm94LmRvbUVsZW1lbnQpIHtcbiAgICAgICAgICBjaGVja2JveC5kb21FbGVtZW50LmNoZWNrZWQgPSBjdXJDaGVja2VkO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShjaGVja2JveC5pZCwge1xuICAgICAgICAgIHZhbHVlOiBjdXJDaGVja2VkXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSB8fCBcIk9mZlwiO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgPT09IGRhdGEuZXhwb3J0VmFsdWU7XG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGV2ZW50LmRldGFpbC52YWx1ZSAhPT0gXCJPZmZcIjtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC5jaGVja2VkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgW1tcImNoYW5nZVwiLCBcIlZhbGlkYXRlXCJdLCBbXCJjaGFuZ2VcIiwgXCJBY3Rpb25cIl0sIFtcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpO1xuXG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoZWxlbWVudCk7XG5cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG5cbn1cblxuY2xhc3MgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvbiByYWRpb0J1dHRvblwiO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3QgaWQgPSBkYXRhLmlkO1xuICAgIGxldCB2YWx1ZSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBkYXRhLmZpZWxkVmFsdWUgPT09IGRhdGEuYnV0dG9uVmFsdWVcbiAgICB9KS52YWx1ZTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgIT09IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgZWxlbWVudC5kaXNhYmxlZCA9IGRhdGEucmVhZE9ubHk7XG5cbiAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuXG4gICAgZWxlbWVudC50eXBlID0gXCJyYWRpb1wiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuXG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgZWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNoZWNrZWRcbiAgICAgIH0gPSBldmVudC50YXJnZXQ7XG5cbiAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgaWQpKSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWU6IGNoZWNrZWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBkYXRhLmRlZmF1bHRGaWVsZFZhbHVlO1xuICAgICAgZXZlbnQudGFyZ2V0LmNoZWNrZWQgPSBkZWZhdWx0VmFsdWUgIT09IG51bGwgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgZGVmYXVsdFZhbHVlID09PSBkYXRhLmJ1dHRvblZhbHVlO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zKSB7XG4gICAgICBjb25zdCBwZGZCdXR0b25WYWx1ZSA9IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICB2YWx1ZTogZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IHBkZkJ1dHRvblZhbHVlID09PSBldmVudC5kZXRhaWwudmFsdWU7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoZXZlbnQudGFyZ2V0Lm5hbWUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1ckNoZWNrZWQgPSBjaGVja2VkICYmIHJhZGlvLmlkID09PSBpZDtcblxuICAgICAgICAgICAgICBpZiAocmFkaW8uZG9tRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJhZGlvLmRvbUVsZW1lbnQuY2hlY2tlZCA9IGN1ckNoZWNrZWQ7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKHJhZGlvLmlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGN1ckNoZWNrZWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBbW1wiY2hhbmdlXCIsIFwiVmFsaWRhdGVcIl0sIFtcImNoYW5nZVwiLCBcIkFjdGlvblwiXSwgW1wiZm9jdXNcIiwgXCJGb2N1c1wiXSwgW1wiYmx1clwiLCBcIkJsdXJcIl0sIFtcIm1vdXNlZG93blwiLCBcIk1vdXNlIERvd25cIl0sIFtcIm1vdXNlZW50ZXJcIiwgXCJNb3VzZSBFbnRlclwiXSwgW1wibW91c2VsZWF2ZVwiLCBcIk1vdXNlIEV4aXRcIl0sIFtcIm1vdXNldXBcIiwgXCJNb3VzZSBVcFwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3IoZWxlbWVudCk7XG5cbiAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhlbGVtZW50KTtcblxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChlbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaWdub3JlQm9yZGVyOiBwYXJhbWV0ZXJzLmRhdGEuaGFzQXBwZWFyYW5jZVxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHN1cGVyLnJlbmRlcigpO1xuICAgIGNvbnRhaW5lci5jbGFzc05hbWUgPSBcImJ1dHRvbldpZGdldEFubm90YXRpb24gcHVzaEJ1dHRvblwiO1xuXG4gICAgaWYgKHRoaXMuZGF0YS5hbHRlcm5hdGl2ZVRleHQpIHtcbiAgICAgIGNvbnRhaW5lci50aXRsZSA9IHRoaXMuZGF0YS5hbHRlcm5hdGl2ZVRleHQ7XG4gICAgfVxuXG4gICAgY29uc3QgbGlua0VsZW1lbnQgPSBjb250YWluZXIubGFzdENoaWxkO1xuXG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zICYmIGxpbmtFbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhsaW5rRWxlbWVudCk7XG5cbiAgICAgIGxpbmtFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KHt9LCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogcGFyYW1ldGVycy5yZW5kZXJGb3Jtc1xuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiY2hvaWNlV2lkZ2V0QW5ub3RhdGlvblwiO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGlkID0gdGhpcy5kYXRhLmlkO1xuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICB2YWx1ZTogdGhpcy5kYXRhLmZpZWxkVmFsdWVcbiAgICB9KTtcbiAgICBjb25zdCBzZWxlY3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoc2VsZWN0RWxlbWVudCk7XG4gICAgc2VsZWN0RWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIHNlbGVjdEVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG5cbiAgICB0aGlzLl9zZXRSZXF1aXJlZChzZWxlY3RFbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuXG4gICAgc2VsZWN0RWxlbWVudC5uYW1lID0gdGhpcy5kYXRhLmZpZWxkTmFtZTtcbiAgICBzZWxlY3RFbGVtZW50LnRhYkluZGV4ID0gREVGQVVMVF9UQUJfSU5ERVg7XG4gICAgbGV0IGFkZEFuRW1wdHlFbnRyeSA9IHRoaXMuZGF0YS5jb21ibyAmJiB0aGlzLmRhdGEub3B0aW9ucy5sZW5ndGggPiAwO1xuXG4gICAgaWYgKCF0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuc2l6ZSA9IHRoaXMuZGF0YS5vcHRpb25zLmxlbmd0aDtcblxuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aVNlbGVjdCkge1xuICAgICAgICBzZWxlY3RFbGVtZW50Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gdGhpcy5kYXRhLmRlZmF1bHRGaWVsZFZhbHVlO1xuXG4gICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBzZWxlY3RFbGVtZW50Lm9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gb3B0aW9uLnZhbHVlID09PSBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiB0aGlzLmRhdGEub3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gb3B0aW9uLmRpc3BsYXlWYWx1ZTtcbiAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBvcHRpb24uZXhwb3J0VmFsdWU7XG5cbiAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlLmluY2x1ZGVzKG9wdGlvbi5leHBvcnRWYWx1ZSkpIHtcbiAgICAgICAgb3B0aW9uRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiLCB0cnVlKTtcbiAgICAgICAgYWRkQW5FbXB0eUVudHJ5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgIH1cblxuICAgIGxldCByZW1vdmVFbXB0eUVudHJ5ID0gbnVsbDtcblxuICAgIGlmIChhZGRBbkVtcHR5RW50cnkpIHtcbiAgICAgIGNvbnN0IG5vbmVPcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgIG5vbmVPcHRpb25FbGVtZW50LnZhbHVlID0gXCIgXCI7XG4gICAgICBub25lT3B0aW9uRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJoaWRkZW5cIiwgdHJ1ZSk7XG4gICAgICBub25lT3B0aW9uRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJzZWxlY3RlZFwiLCB0cnVlKTtcbiAgICAgIHNlbGVjdEVsZW1lbnQucHJlcGVuZChub25lT3B0aW9uRWxlbWVudCk7XG5cbiAgICAgIHJlbW92ZUVtcHR5RW50cnkgPSAoKSA9PiB7XG4gICAgICAgIG5vbmVPcHRpb25FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9IG51bGw7XG4gICAgICB9O1xuXG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICB9XG5cbiAgICBjb25zdCBnZXRWYWx1ZSA9IChldmVudCwgaXNFeHBvcnQpID0+IHtcbiAgICAgIGNvbnN0IG5hbWUgPSBpc0V4cG9ydCA/IFwidmFsdWVcIiA6IFwidGV4dENvbnRlbnRcIjtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC50YXJnZXQub3B0aW9ucztcblxuICAgICAgaWYgKCFldmVudC50YXJnZXQubXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBudWxsIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdW25hbWVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKG9wdGlvbnMsIG9wdGlvbiA9PiBvcHRpb24uc2VsZWN0ZWQpLm1hcChvcHRpb24gPT4gb3B0aW9uW25hbWVdKTtcbiAgICB9O1xuXG4gICAgY29uc3QgZ2V0SXRlbXMgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG9wdGlvbnMsIG9wdGlvbiA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlzcGxheVZhbHVlOiBvcHRpb24udGV4dENvbnRlbnQsXG4gICAgICAgICAgZXhwb3J0VmFsdWU6IG9wdGlvbi52YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGlvbnMgPSB7XG4gICAgICAgICAgdmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgIHJlbW92ZUVtcHR5RW50cnk/LigpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBldmVudC5kZXRhaWwudmFsdWU7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygc2VsZWN0RWxlbWVudC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlcy5oYXMob3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUoZXZlbnQsIHRydWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgbXVsdGlwbGVTZWxlY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICByZW1vdmUoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBzZWxlY3RFbGVtZW50Lm9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGV2ZW50LmRldGFpbC5yZW1vdmU7XG4gICAgICAgICAgICBvcHRpb25zW2luZGV4XS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmUoaW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGkgPSBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4LmNhbGwob3B0aW9ucywgb3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZCk7XG5cbiAgICAgICAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUoZXZlbnQsIHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgY2xlYXIoZXZlbnQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW5zZXJ0KGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICBkaXNwbGF5VmFsdWUsXG4gICAgICAgICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsLmluc2VydDtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdENoaWxkID0gc2VsZWN0RWxlbWVudC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudGV4dENvbnRlbnQgPSBkaXNwbGF5VmFsdWU7XG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gZXhwb3J0VmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RDaGlsZCkge1xuICAgICAgICAgICAgICBzZWxlY3RDaGlsZC5iZWZvcmUob3B0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LmFwcGVuZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUoZXZlbnQsIHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaXRlbXMoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgaXRlbXNcbiAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG5cbiAgICAgICAgICAgIHdoaWxlIChzZWxlY3RFbGVtZW50Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBzZWxlY3RFbGVtZW50LnJlbW92ZSgwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWUsXG4gICAgICAgICAgICAgICAgZXhwb3J0VmFsdWVcbiAgICAgICAgICAgICAgfSA9IGl0ZW07XG4gICAgICAgICAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gZXhwb3J0VmFsdWU7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0RWxlbWVudC5vcHRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5vcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUoZXZlbnQsIHRydWUpLFxuICAgICAgICAgICAgICBpdGVtczogZ2V0SXRlbXMoZXZlbnQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW5kaWNlcyhldmVudCkge1xuICAgICAgICAgICAgY29uc3QgaW5kaWNlcyA9IG5ldyBTZXQoZXZlbnQuZGV0YWlsLmluZGljZXMpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBldmVudC50YXJnZXQub3B0aW9ucykge1xuICAgICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBpbmRpY2VzLmhhcyhvcHRpb24uaW5kZXgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZShldmVudCwgdHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG5cbiAgICAgICAgICBlZGl0YWJsZShldmVudCkge1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmRpc2FibGVkID0gIWV2ZW50LmRldGFpbC5lZGl0YWJsZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50RnJvbVNhbmRib3goYWN0aW9ucywganNFdmVudCk7XG4gICAgICB9KTtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgZXhwb3J0VmFsdWUgPSBnZXRWYWx1ZShldmVudCwgdHJ1ZSk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0VmFsdWUoZXZlbnQsIGZhbHNlKTtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBleHBvcnRWYWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG5hbWU6IFwiS2V5c3Ryb2tlXCIsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGNoYW5nZUV4OiBleHBvcnRWYWx1ZSxcbiAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgICAgICBrZXlEb3duOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoc2VsZWN0RWxlbWVudCwgW1tcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl0sIFtcImlucHV0XCIsIFwiQWN0aW9uXCJdXSwgZXZlbnQgPT4gZXZlbnQudGFyZ2V0LmNoZWNrZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZShldmVudCwgdHJ1ZSlcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kYXRhLmNvbWJvKSB7XG4gICAgICB0aGlzLl9zZXRUZXh0U3R5bGUoc2VsZWN0RWxlbWVudCk7XG4gICAgfSBlbHNlIHt9XG5cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3Ioc2VsZWN0RWxlbWVudCk7XG5cbiAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhzZWxlY3RFbGVtZW50KTtcblxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzZWxlY3RFbGVtZW50KTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBQb3B1cEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLnRpdGxlT2JqPy5zdHIgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzT2JqPy5zdHIgfHwgcGFyYW1ldGVycy5kYXRhLnJpY2hUZXh0Py5zdHIpO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZVxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IElHTk9SRV9UWVBFUyA9IFtcIkxpbmVcIiwgXCJTcXVhcmVcIiwgXCJDaXJjbGVcIiwgXCJQb2x5TGluZVwiLCBcIlBvbHlnb25cIiwgXCJJbmtcIl07XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJwb3B1cEFubm90YXRpb25cIjtcblxuICAgIGlmIChJR05PUkVfVFlQRVMuaW5jbHVkZXModGhpcy5kYXRhLnBhcmVudFR5cGUpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZWN0b3IgPSBgW2RhdGEtYW5ub3RhdGlvbi1pZD1cIiR7dGhpcy5kYXRhLnBhcmVudElkfVwiXWA7XG4gICAgY29uc3QgcGFyZW50RWxlbWVudHMgPSB0aGlzLmxheWVyLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXG4gICAgaWYgKHBhcmVudEVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cblxuICAgIGNvbnN0IHBvcHVwID0gbmV3IFBvcHVwRWxlbWVudCh7XG4gICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxuICAgICAgdHJpZ2dlcjogQXJyYXkuZnJvbShwYXJlbnRFbGVtZW50cyksXG4gICAgICBjb2xvcjogdGhpcy5kYXRhLmNvbG9yLFxuICAgICAgdGl0bGVPYmo6IHRoaXMuZGF0YS50aXRsZU9iaixcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGU6IHRoaXMuZGF0YS5tb2RpZmljYXRpb25EYXRlLFxuICAgICAgY29udGVudHNPYmo6IHRoaXMuZGF0YS5jb250ZW50c09iaixcbiAgICAgIHJpY2hUZXh0OiB0aGlzLmRhdGEucmljaFRleHRcbiAgICB9KTtcbiAgICBjb25zdCBwYWdlID0gdGhpcy5wYWdlO1xuXG4gICAgY29uc3QgcmVjdCA9IF91dGlsLlV0aWwubm9ybWFsaXplUmVjdChbdGhpcy5kYXRhLnBhcmVudFJlY3RbMF0sIHBhZ2Uudmlld1szXSAtIHRoaXMuZGF0YS5wYXJlbnRSZWN0WzFdICsgcGFnZS52aWV3WzFdLCB0aGlzLmRhdGEucGFyZW50UmVjdFsyXSwgcGFnZS52aWV3WzNdIC0gdGhpcy5kYXRhLnBhcmVudFJlY3RbM10gKyBwYWdlLnZpZXdbMV1dKTtcblxuICAgIGNvbnN0IHBvcHVwTGVmdCA9IHJlY3RbMF0gKyB0aGlzLmRhdGEucGFyZW50UmVjdFsyXSAtIHRoaXMuZGF0YS5wYXJlbnRSZWN0WzBdO1xuICAgIGNvbnN0IHBvcHVwVG9wID0gcmVjdFsxXTtcbiAgICBjb25zdCBbcGFnZUxMeCwgcGFnZUxMeSwgcGFnZVVSeCwgcGFnZVVSeV0gPSB0aGlzLnZpZXdwb3J0LnZpZXdCb3g7XG4gICAgY29uc3QgcGFnZVdpZHRoID0gcGFnZVVSeCAtIHBhZ2VMTHg7XG4gICAgY29uc3QgcGFnZUhlaWdodCA9IHBhZ2VVUnkgLSBwYWdlTEx5O1xuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmxlZnQgPSBgJHsxMDAgKiAocG9wdXBMZWZ0IC0gcGFnZUxMeCkgLyBwYWdlV2lkdGh9JWA7XG4gICAgdGhpcy5jb250YWluZXIuc3R5bGUudG9wID0gYCR7MTAwICogKHBvcHVwVG9wIC0gcGFnZUxMeSkgLyBwYWdlSGVpZ2h0fSVgO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChwb3B1cC5yZW5kZXIoKSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG5cbn1cblxuY2xhc3MgUG9wdXBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHRoaXMuY29udGFpbmVyID0gcGFyYW1ldGVycy5jb250YWluZXI7XG4gICAgdGhpcy50cmlnZ2VyID0gcGFyYW1ldGVycy50cmlnZ2VyO1xuICAgIHRoaXMuY29sb3IgPSBwYXJhbWV0ZXJzLmNvbG9yO1xuICAgIHRoaXMudGl0bGVPYmogPSBwYXJhbWV0ZXJzLnRpdGxlT2JqO1xuICAgIHRoaXMubW9kaWZpY2F0aW9uRGF0ZSA9IHBhcmFtZXRlcnMubW9kaWZpY2F0aW9uRGF0ZTtcbiAgICB0aGlzLmNvbnRlbnRzT2JqID0gcGFyYW1ldGVycy5jb250ZW50c09iajtcbiAgICB0aGlzLnJpY2hUZXh0ID0gcGFyYW1ldGVycy5yaWNoVGV4dDtcbiAgICB0aGlzLmhpZGVXcmFwcGVyID0gcGFyYW1ldGVycy5oaWRlV3JhcHBlciB8fCBmYWxzZTtcbiAgICB0aGlzLnBpbm5lZCA9IGZhbHNlO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IEJBQ0tHUk9VTkRfRU5MSUdIVCA9IDAuNztcbiAgICBjb25zdCB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB3cmFwcGVyLmNsYXNzTmFtZSA9IFwicG9wdXBXcmFwcGVyXCI7XG4gICAgdGhpcy5oaWRlRWxlbWVudCA9IHRoaXMuaGlkZVdyYXBwZXIgPyB3cmFwcGVyIDogdGhpcy5jb250YWluZXI7XG4gICAgdGhpcy5oaWRlRWxlbWVudC5oaWRkZW4gPSB0cnVlO1xuICAgIGNvbnN0IHBvcHVwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBwb3B1cC5jbGFzc05hbWUgPSBcInBvcHVwXCI7XG4gICAgY29uc3QgY29sb3IgPSB0aGlzLmNvbG9yO1xuXG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICBjb25zdCByID0gQkFDS0dST1VORF9FTkxJR0hUICogKDI1NSAtIGNvbG9yWzBdKSArIGNvbG9yWzBdO1xuICAgICAgY29uc3QgZyA9IEJBQ0tHUk9VTkRfRU5MSUdIVCAqICgyNTUgLSBjb2xvclsxXSkgKyBjb2xvclsxXTtcbiAgICAgIGNvbnN0IGIgPSBCQUNLR1JPVU5EX0VOTElHSFQgKiAoMjU1IC0gY29sb3JbMl0pICsgY29sb3JbMl07XG4gICAgICBwb3B1cC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihyIHwgMCwgZyB8IDAsIGIgfCAwKTtcbiAgICB9XG5cbiAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoMVwiKTtcbiAgICB0aXRsZS5kaXIgPSB0aGlzLnRpdGxlT2JqLmRpcjtcbiAgICB0aXRsZS50ZXh0Q29udGVudCA9IHRoaXMudGl0bGVPYmouc3RyO1xuICAgIHBvcHVwLmFwcGVuZCh0aXRsZSk7XG5cbiAgICBjb25zdCBkYXRlT2JqZWN0ID0gX2Rpc3BsYXlfdXRpbHMuUERGRGF0ZVN0cmluZy50b0RhdGVPYmplY3QodGhpcy5tb2RpZmljYXRpb25EYXRlKTtcblxuICAgIGlmIChkYXRlT2JqZWN0KSB7XG4gICAgICBjb25zdCBtb2RpZmljYXRpb25EYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLmNsYXNzTmFtZSA9IFwicG9wdXBEYXRlXCI7XG4gICAgICBtb2RpZmljYXRpb25EYXRlLnRleHRDb250ZW50ID0gXCJ7e2RhdGV9fSwge3t0aW1lfX1cIjtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuZGF0YXNldC5sMTBuSWQgPSBcImFubm90YXRpb25fZGF0ZV9zdHJpbmdcIjtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuZGF0YXNldC5sMTBuQXJncyA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgZGF0ZTogZGF0ZU9iamVjdC50b0xvY2FsZURhdGVTdHJpbmcoKSxcbiAgICAgICAgdGltZTogZGF0ZU9iamVjdC50b0xvY2FsZVRpbWVTdHJpbmcoKVxuICAgICAgfSk7XG4gICAgICBwb3B1cC5hcHBlbmQobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmljaFRleHQ/LnN0ciAmJiAoIXRoaXMuY29udGVudHNPYmo/LnN0ciB8fCB0aGlzLmNvbnRlbnRzT2JqLnN0ciA9PT0gdGhpcy5yaWNoVGV4dC5zdHIpKSB7XG4gICAgICBfeGZhX2xheWVyLlhmYUxheWVyLnJlbmRlcih7XG4gICAgICAgIHhmYUh0bWw6IHRoaXMucmljaFRleHQuaHRtbCxcbiAgICAgICAgaW50ZW50OiBcInJpY2hUZXh0XCIsXG4gICAgICAgIGRpdjogcG9wdXBcbiAgICAgIH0pO1xuXG4gICAgICBwb3B1cC5sYXN0Q2hpbGQuY2xhc3NOYW1lID0gXCJyaWNoVGV4dCBwb3B1cENvbnRlbnRcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29udGVudHMgPSB0aGlzLl9mb3JtYXRDb250ZW50cyh0aGlzLmNvbnRlbnRzT2JqKTtcblxuICAgICAgcG9wdXAuYXBwZW5kKGNvbnRlbnRzKTtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy50cmlnZ2VyKSkge1xuICAgICAgdGhpcy50cmlnZ2VyID0gW3RoaXMudHJpZ2dlcl07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMudHJpZ2dlcikge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5fdG9nZ2xlLmJpbmQodGhpcykpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdmVyXCIsIHRoaXMuX3Nob3cuYmluZCh0aGlzLCBmYWxzZSkpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5faGlkZS5iaW5kKHRoaXMsIGZhbHNlKSk7XG4gICAgfVxuXG4gICAgcG9wdXAuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuX2hpZGUuYmluZCh0aGlzLCB0cnVlKSk7XG4gICAgd3JhcHBlci5hcHBlbmQocG9wdXApO1xuICAgIHJldHVybiB3cmFwcGVyO1xuICB9XG5cbiAgX2Zvcm1hdENvbnRlbnRzKHtcbiAgICBzdHIsXG4gICAgZGlyXG4gIH0pIHtcbiAgICBjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgcC5jbGFzc05hbWUgPSBcInBvcHVwQ29udGVudFwiO1xuICAgIHAuZGlyID0gZGlyO1xuICAgIGNvbnN0IGxpbmVzID0gc3RyLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvKTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGxpbmVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgIHAuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpKTtcblxuICAgICAgaWYgKGkgPCBpaSAtIDEpIHtcbiAgICAgICAgcC5hcHBlbmQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcDtcbiAgfVxuXG4gIF90b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMucGlubmVkKSB7XG4gICAgICB0aGlzLl9oaWRlKHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zaG93KHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93KHBpbiA9IGZhbHNlKSB7XG4gICAgaWYgKHBpbikge1xuICAgICAgdGhpcy5waW5uZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhpZGVFbGVtZW50LmhpZGRlbikge1xuICAgICAgdGhpcy5oaWRlRWxlbWVudC5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHBhcnNlSW50KHRoaXMuY29udGFpbmVyLnN0eWxlLnpJbmRleCkgKyAxMDAwO1xuICAgIH1cbiAgfVxuXG4gIF9oaWRlKHVucGluID0gdHJ1ZSkge1xuICAgIGlmICh1bnBpbikge1xuICAgICAgdGhpcy5waW5uZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaGlkZUVsZW1lbnQuaGlkZGVuICYmICF0aGlzLnBpbm5lZCkge1xuICAgICAgdGhpcy5oaWRlRWxlbWVudC5oaWRkZW4gPSB0cnVlO1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuekluZGV4ID0gcGFyc2VJbnQodGhpcy5jb250YWluZXIuc3R5bGUuekluZGV4KSAtIDEwMDA7XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGVPYmo/LnN0ciB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHNPYmo/LnN0ciB8fCBwYXJhbWV0ZXJzLmRhdGEucmljaFRleHQ/LnN0cik7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHBhcmFtZXRlcnMuZGF0YS50ZXh0Q29udGVudDtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImZyZWVUZXh0QW5ub3RhdGlvblwiO1xuXG4gICAgaWYgKHRoaXMudGV4dENvbnRlbnQpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY29udGVudC5jbGFzc05hbWUgPSBcImFubm90YXRpb25UZXh0Q29udGVudFwiO1xuICAgICAgY29udGVudC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiY29tbWVudFwiKTtcblxuICAgICAgZm9yIChjb25zdCBsaW5lIG9mIHRoaXMudGV4dENvbnRlbnQpIHtcbiAgICAgICAgY29uc3QgbGluZVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgbGluZVNwYW4udGV4dENvbnRlbnQgPSBsaW5lO1xuICAgICAgICBjb250ZW50LmFwcGVuZChsaW5lU3Bhbik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChjb250ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZGF0YS5oYXNQb3B1cCkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAobnVsbCwgdGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBMaW5lQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlT2JqPy5zdHIgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzT2JqPy5zdHIgfHwgcGFyYW1ldGVycy5kYXRhLnJpY2hUZXh0Py5zdHIpO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwibGluZUFubm90YXRpb25cIjtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6bGluZVwiKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcIngxXCIsIGRhdGEucmVjdFsyXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzBdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInkxXCIsIGRhdGEucmVjdFszXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzFdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcIngyXCIsIGRhdGEucmVjdFsyXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzJdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInkyXCIsIGRhdGEucmVjdFszXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzNdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBkYXRhLmJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChsaW5lKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcblxuICAgIHRoaXMuX2NyZWF0ZVBvcHVwKGxpbmUsIGRhdGEpO1xuXG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG5cbn1cblxuY2xhc3MgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlT2JqPy5zdHIgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzT2JqPy5zdHIgfHwgcGFyYW1ldGVycy5kYXRhLnJpY2hUZXh0Py5zdHIpO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwic3F1YXJlQW5ub3RhdGlvblwiO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICBjb25zdCBzcXVhcmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ4XCIsIGJvcmRlcldpZHRoIC8gMik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInlcIiwgYm9yZGVyV2lkdGggLyAyKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgd2lkdGggLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQgLSBib3JkZXJXaWR0aCk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKHNxdWFyZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG5cbiAgICB0aGlzLl9jcmVhdGVQb3B1cChzcXVhcmUsIGRhdGEpO1xuXG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG5cbn1cblxuY2xhc3MgQ2lyY2xlQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlT2JqPy5zdHIgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzT2JqPy5zdHIgfHwgcGFyYW1ldGVycy5kYXRhLnJpY2hUZXh0Py5zdHIpO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiY2lyY2xlQW5ub3RhdGlvblwiO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGJvcmRlcldpZHRoID0gZGF0YS5ib3JkZXJTdHlsZS53aWR0aDtcbiAgICBjb25zdCBjaXJjbGUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzplbGxpcHNlXCIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeFwiLCB3aWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBoZWlnaHQgLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicnhcIiwgd2lkdGggLyAyIC0gYm9yZGVyV2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwicnlcIiwgaGVpZ2h0IC8gMiAtIGJvcmRlcldpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKGNpcmNsZSk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG5cbiAgICB0aGlzLl9jcmVhdGVQb3B1cChjaXJjbGUsIGRhdGEpO1xuXG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG5cbn1cblxuY2xhc3MgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGVPYmo/LnN0ciB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHNPYmo/LnN0ciB8fCBwYXJhbWV0ZXJzLmRhdGEucmljaFRleHQ/LnN0cik7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlsaW5lQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5bGluZVwiO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGxldCBwb2ludHMgPSBbXTtcblxuICAgIGZvciAoY29uc3QgY29vcmRpbmF0ZSBvZiBkYXRhLnZlcnRpY2VzKSB7XG4gICAgICBjb25zdCB4ID0gY29vcmRpbmF0ZS54IC0gZGF0YS5yZWN0WzBdO1xuICAgICAgY29uc3QgeSA9IGRhdGEucmVjdFszXSAtIGNvb3JkaW5hdGUueTtcbiAgICAgIHBvaW50cy5wdXNoKHggKyBcIixcIiArIHkpO1xuICAgIH1cblxuICAgIHBvaW50cyA9IHBvaW50cy5qb2luKFwiIFwiKTtcbiAgICBjb25zdCBwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHMpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBkYXRhLmJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKHBvbHlsaW5lKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcblxuICAgIHRoaXMuX2NyZWF0ZVBvcHVwKHBvbHlsaW5lLCBkYXRhKTtcblxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG59XG5cbmNsYXNzIFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycyk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlnb25Bbm5vdGF0aW9uXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlnb25cIjtcbiAgfVxuXG59XG5cbmNsYXNzIENhcmV0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlT2JqPy5zdHIgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzT2JqPy5zdHIgfHwgcGFyYW1ldGVycy5kYXRhLnJpY2hUZXh0Py5zdHIpO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiY2FyZXRBbm5vdGF0aW9uXCI7XG5cbiAgICBpZiAoIXRoaXMuZGF0YS5oYXNQb3B1cCkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAobnVsbCwgdGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBJbmtBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGVPYmo/LnN0ciB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHNPYmo/LnN0ciB8fCBwYXJhbWV0ZXJzLmRhdGEucmljaFRleHQ/LnN0cik7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcImlua0Fubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWxpbmVcIjtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLmNvbnRhaW5lckNsYXNzTmFtZTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcblxuICAgIGZvciAoY29uc3QgaW5rTGlzdCBvZiBkYXRhLmlua0xpc3RzKSB7XG4gICAgICBsZXQgcG9pbnRzID0gW107XG5cbiAgICAgIGZvciAoY29uc3QgY29vcmRpbmF0ZSBvZiBpbmtMaXN0KSB7XG4gICAgICAgIGNvbnN0IHggPSBjb29yZGluYXRlLnggLSBkYXRhLnJlY3RbMF07XG4gICAgICAgIGNvbnN0IHkgPSBkYXRhLnJlY3RbM10gLSBjb29yZGluYXRlLnk7XG4gICAgICAgIHBvaW50cy5wdXNoKGAke3h9LCR7eX1gKTtcbiAgICAgIH1cblxuICAgICAgcG9pbnRzID0gcG9pbnRzLmpvaW4oXCIgXCIpO1xuICAgICAgY29uc3QgcG9seWxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudCh0aGlzLnN2Z0VsZW1lbnROYW1lKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHMpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcblxuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAocG9seWxpbmUsIGRhdGEpO1xuXG4gICAgICBzdmcuYXBwZW5kKHBvbHlsaW5lKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGVPYmo/LnN0ciB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHNPYmo/LnN0ciB8fCBwYXJhbWV0ZXJzLmRhdGEucmljaFRleHQ/LnN0cik7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5oYXNQb3B1cCkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAobnVsbCwgdGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5xdWFkcmlsYXRlcmFscykge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclF1YWRyaWxhdGVyYWxzKFwiaGlnaGxpZ2h0QW5ub3RhdGlvblwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImhpZ2hsaWdodEFubm90YXRpb25cIjtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGVPYmo/LnN0ciB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHNPYmo/LnN0ciB8fCBwYXJhbWV0ZXJzLmRhdGEucmljaFRleHQ/LnN0cik7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5oYXNQb3B1cCkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAobnVsbCwgdGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5xdWFkcmlsYXRlcmFscykge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclF1YWRyaWxhdGVyYWxzKFwidW5kZXJsaW5lQW5ub3RhdGlvblwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcInVuZGVybGluZUFubm90YXRpb25cIjtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLmhhc1BvcHVwIHx8IHBhcmFtZXRlcnMuZGF0YS50aXRsZU9iaj8uc3RyIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50c09iaj8uc3RyIHx8IHBhcmFtZXRlcnMuZGF0YS5yaWNoVGV4dD8uc3RyKTtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5kYXRhLmhhc1BvcHVwKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cChudWxsLCB0aGlzLmRhdGEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnF1YWRyaWxhdGVyYWxzKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyUXVhZHJpbGF0ZXJhbHMoXCJzcXVpZ2dseUFubm90YXRpb25cIik7XG4gICAgfVxuXG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJzcXVpZ2dseUFubm90YXRpb25cIjtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGVPYmo/LnN0ciB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHNPYmo/LnN0ciB8fCBwYXJhbWV0ZXJzLmRhdGEucmljaFRleHQ/LnN0cik7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5oYXNQb3B1cCkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAobnVsbCwgdGhpcy5kYXRhKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5xdWFkcmlsYXRlcmFscykge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlclF1YWRyaWxhdGVyYWxzKFwic3RyaWtlb3V0QW5ub3RhdGlvblwiKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcInN0cmlrZW91dEFubm90YXRpb25cIjtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cblxufVxuXG5jbGFzcyBTdGFtcEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLmhhc1BvcHVwIHx8IHBhcmFtZXRlcnMuZGF0YS50aXRsZU9iaj8uc3RyIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50c09iaj8uc3RyIHx8IHBhcmFtZXRlcnMuZGF0YS5yaWNoVGV4dD8uc3RyKTtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcInN0YW1wQW5ub3RhdGlvblwiO1xuXG4gICAgaWYgKCF0aGlzLmRhdGEuaGFzUG9wdXApIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKG51bGwsIHRoaXMuZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG5cbn1cblxuY2xhc3MgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbGVuYW1lLFxuICAgICAgY29udGVudFxuICAgIH0gPSB0aGlzLmRhdGEuZmlsZTtcbiAgICB0aGlzLmZpbGVuYW1lID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEZpbGVuYW1lRnJvbVVybCkoZmlsZW5hbWUpO1xuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJmaWxlYXR0YWNobWVudGFubm90YXRpb25cIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZmlsZW5hbWUsXG4gICAgICBjb250ZW50XG4gICAgfSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJmaWxlQXR0YWNobWVudEFubm90YXRpb25cIjtcbiAgICBjb25zdCB0cmlnZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0cmlnZ2VyLmNsYXNzTmFtZSA9IFwicG9wdXBUcmlnZ2VyQXJlYVwiO1xuICAgIHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsIHRoaXMuX2Rvd25sb2FkLmJpbmQodGhpcykpO1xuXG4gICAgaWYgKCF0aGlzLmRhdGEuaGFzUG9wdXAgJiYgKHRoaXMuZGF0YS50aXRsZU9iaj8uc3RyIHx8IHRoaXMuZGF0YS5jb250ZW50c09iaj8uc3RyIHx8IHRoaXMuZGF0YS5yaWNoVGV4dCkpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKHRyaWdnZXIsIHRoaXMuZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHRyaWdnZXIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuXG4gIF9kb3dubG9hZCgpIHtcbiAgICB0aGlzLmRvd25sb2FkTWFuYWdlcj8ub3Blbk9yRG93bmxvYWREYXRhKHRoaXMuY29udGFpbmVyLCB0aGlzLmNvbnRlbnQsIHRoaXMuZmlsZW5hbWUpO1xuICB9XG5cbn1cblxuY2xhc3MgQW5ub3RhdGlvbkxheWVyIHtcbiAgc3RhdGljICNhcHBlbmRFbGVtZW50KGVsZW1lbnQsIGlkLCBkaXYsIGFjY2Vzc2liaWxpdHlNYW5hZ2VyKSB7XG4gICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBlbGVtZW50LmZpcnN0Q2hpbGQgfHwgZWxlbWVudDtcbiAgICBjb250ZW50RWxlbWVudC5pZCA9IGAke19kaXNwbGF5X3V0aWxzLkFubm90YXRpb25QcmVmaXh9JHtpZH1gO1xuICAgIGRpdi5hcHBlbmQoZWxlbWVudCk7XG4gICAgYWNjZXNzaWJpbGl0eU1hbmFnZXI/Lm1vdmVFbGVtZW50SW5ET00oZGl2LCBlbGVtZW50LCBjb250ZW50RWxlbWVudCwgZmFsc2UpO1xuICB9XG5cbiAgc3RhdGljIHJlbmRlcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICBkaXYsXG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGFjY2Vzc2liaWxpdHlNYW5hZ2VyXG4gICAgfSA9IHBhcmFtZXRlcnM7XG4gICAgdGhpcy4jc2V0RGltZW5zaW9ucyhkaXYsIHZpZXdwb3J0KTtcbiAgICBsZXQgekluZGV4ID0gMDtcblxuICAgIGZvciAoY29uc3QgZGF0YSBvZiBhbm5vdGF0aW9ucykge1xuICAgICAgaWYgKGRhdGEuYW5ub3RhdGlvblR5cGUgIT09IF91dGlsLkFubm90YXRpb25UeXBlLlBPUFVQKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICBoZWlnaHRcbiAgICAgICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG5cbiAgICAgICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBlbGVtZW50ID0gQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5LmNyZWF0ZSh7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIGxheWVyOiBkaXYsXG4gICAgICAgIHBhZ2U6IHBhcmFtZXRlcnMucGFnZSxcbiAgICAgICAgdmlld3BvcnQsXG4gICAgICAgIGxpbmtTZXJ2aWNlOiBwYXJhbWV0ZXJzLmxpbmtTZXJ2aWNlLFxuICAgICAgICBkb3dubG9hZE1hbmFnZXI6IHBhcmFtZXRlcnMuZG93bmxvYWRNYW5hZ2VyLFxuICAgICAgICBpbWFnZVJlc291cmNlc1BhdGg6IHBhcmFtZXRlcnMuaW1hZ2VSZXNvdXJjZXNQYXRoIHx8IFwiXCIsXG4gICAgICAgIHJlbmRlckZvcm1zOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zICE9PSBmYWxzZSxcbiAgICAgICAgc3ZnRmFjdG9yeTogbmV3IF9kaXNwbGF5X3V0aWxzLkRPTVNWR0ZhY3RvcnkoKSxcbiAgICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IHBhcmFtZXRlcnMuYW5ub3RhdGlvblN0b3JhZ2UgfHwgbmV3IF9hbm5vdGF0aW9uX3N0b3JhZ2UuQW5ub3RhdGlvblN0b3JhZ2UoKSxcbiAgICAgICAgZW5hYmxlU2NyaXB0aW5nOiBwYXJhbWV0ZXJzLmVuYWJsZVNjcmlwdGluZyxcbiAgICAgICAgaGFzSlNBY3Rpb25zOiBwYXJhbWV0ZXJzLmhhc0pTQWN0aW9ucyxcbiAgICAgICAgZmllbGRPYmplY3RzOiBwYXJhbWV0ZXJzLmZpZWxkT2JqZWN0cyxcbiAgICAgICAgbW91c2VTdGF0ZTogcGFyYW1ldGVycy5tb3VzZVN0YXRlIHx8IHtcbiAgICAgICAgICBpc0Rvd246IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZWxlbWVudC5pc1JlbmRlcmFibGUpIHtcbiAgICAgICAgY29uc3QgcmVuZGVyZWQgPSBlbGVtZW50LnJlbmRlcigpO1xuXG4gICAgICAgIGlmIChkYXRhLmhpZGRlbikge1xuICAgICAgICAgIHJlbmRlcmVkLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVuZGVyZWQpKSB7XG4gICAgICAgICAgZm9yIChjb25zdCByZW5kZXJlZEVsZW1lbnQgb2YgcmVuZGVyZWQpIHtcbiAgICAgICAgICAgIHJlbmRlcmVkRWxlbWVudC5zdHlsZS56SW5kZXggPSB6SW5kZXgrKztcbiAgICAgICAgICAgIEFubm90YXRpb25MYXllci4jYXBwZW5kRWxlbWVudChyZW5kZXJlZEVsZW1lbnQsIGRhdGEuaWQsIGRpdiwgYWNjZXNzaWJpbGl0eU1hbmFnZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW5kZXJlZC5zdHlsZS56SW5kZXggPSB6SW5kZXgrKztcblxuICAgICAgICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgICAgICAgZGl2LnByZXBlbmQocmVuZGVyZWQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBBbm5vdGF0aW9uTGF5ZXIuI2FwcGVuZEVsZW1lbnQocmVuZGVyZWQsIGRhdGEuaWQsIGRpdiwgYWNjZXNzaWJpbGl0eU1hbmFnZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuI3NldEFubm90YXRpb25DYW52YXNNYXAoZGl2LCBwYXJhbWV0ZXJzLmFubm90YXRpb25DYW52YXNNYXApO1xuICB9XG5cbiAgc3RhdGljIHVwZGF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkNhbnZhc01hcCxcbiAgICAgIGRpdixcbiAgICAgIHZpZXdwb3J0XG4gICAgfSA9IHBhcmFtZXRlcnM7XG4gICAgdGhpcy4jc2V0RGltZW5zaW9ucyhkaXYsIHZpZXdwb3J0KTtcbiAgICB0aGlzLiNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKGRpdiwgYW5ub3RhdGlvbkNhbnZhc01hcCk7XG4gICAgZGl2LmhpZGRlbiA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGljICNzZXREaW1lbnNpb25zKGRpdiwge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICByb3RhdGlvblxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gZGl2O1xuICAgIGNvbnN0IGZsaXBPcmllbnRhdGlvbiA9IHJvdGF0aW9uICUgMTgwICE9PSAwLFxuICAgICAgICAgIHdpZHRoU3RyID0gTWF0aC5mbG9vcih3aWR0aCkgKyBcInB4XCIsXG4gICAgICAgICAgaGVpZ2h0U3RyID0gTWF0aC5mbG9vcihoZWlnaHQpICsgXCJweFwiO1xuICAgIHN0eWxlLndpZHRoID0gZmxpcE9yaWVudGF0aW9uID8gaGVpZ2h0U3RyIDogd2lkdGhTdHI7XG4gICAgc3R5bGUuaGVpZ2h0ID0gZmxpcE9yaWVudGF0aW9uID8gd2lkdGhTdHIgOiBoZWlnaHRTdHI7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtbWFpbi1yb3RhdGlvblwiLCByb3RhdGlvbik7XG4gIH1cblxuICBzdGF0aWMgI3NldEFubm90YXRpb25DYW52YXNNYXAoZGl2LCBhbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgaWYgKCFhbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBbaWQsIGNhbnZhc10gb2YgYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGRpdi5xdWVyeVNlbGVjdG9yKGBbZGF0YS1hbm5vdGF0aW9uLWlkPVwiJHtpZH1cIl1gKTtcblxuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGZpcnN0Q2hpbGRcbiAgICAgIH0gPSBlbGVtZW50O1xuXG4gICAgICBpZiAoIWZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmQoY2FudmFzKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RDaGlsZC5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgICBmaXJzdENoaWxkLnJlcGxhY2VXaXRoKGNhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdENoaWxkLmJlZm9yZShjYW52YXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFubm90YXRpb25DYW52YXNNYXAuY2xlYXIoKTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuQW5ub3RhdGlvbkxheWVyID0gQW5ub3RhdGlvbkxheWVyO1xuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkNvbG9yQ29udmVydGVycyA9IHZvaWQgMDtcblxuZnVuY3Rpb24gbWFrZUNvbG9yQ29tcChuKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG4pKSAqIDI1NSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbn1cblxuY2xhc3MgQ29sb3JDb252ZXJ0ZXJzIHtcbiAgc3RhdGljIENNWUtfRyhbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW1wiR1wiLCAxIC0gTWF0aC5taW4oMSwgMC4zICogYyArIDAuNTkgKiBtICsgMC4xMSAqIHkgKyBrKV07XG4gIH1cblxuICBzdGF0aWMgR19DTVlLKFtnXSkge1xuICAgIHJldHVybiBbXCJDTVlLXCIsIDAsIDAsIDAsIDEgLSBnXTtcbiAgfVxuXG4gIHN0YXRpYyBHX1JHQihbZ10pIHtcbiAgICByZXR1cm4gW1wiUkdCXCIsIGcsIGcsIGddO1xuICB9XG5cbiAgc3RhdGljIEdfSFRNTChbZ10pIHtcbiAgICBjb25zdCBHID0gbWFrZUNvbG9yQ29tcChnKTtcbiAgICByZXR1cm4gYCMke0d9JHtHfSR7R31gO1xuICB9XG5cbiAgc3RhdGljIFJHQl9HKFtyLCBnLCBiXSkge1xuICAgIHJldHVybiBbXCJHXCIsIDAuMyAqIHIgKyAwLjU5ICogZyArIDAuMTEgKiBiXTtcbiAgfVxuXG4gIHN0YXRpYyBSR0JfSFRNTChbciwgZywgYl0pIHtcbiAgICBjb25zdCBSID0gbWFrZUNvbG9yQ29tcChyKTtcbiAgICBjb25zdCBHID0gbWFrZUNvbG9yQ29tcChnKTtcbiAgICBjb25zdCBCID0gbWFrZUNvbG9yQ29tcChiKTtcbiAgICByZXR1cm4gYCMke1J9JHtHfSR7Qn1gO1xuICB9XG5cbiAgc3RhdGljIFRfSFRNTCgpIHtcbiAgICByZXR1cm4gXCIjMDAwMDAwMDBcIjtcbiAgfVxuXG4gIHN0YXRpYyBDTVlLX1JHQihbYywgeSwgbSwga10pIHtcbiAgICByZXR1cm4gW1wiUkdCXCIsIDEgLSBNYXRoLm1pbigxLCBjICsgayksIDEgLSBNYXRoLm1pbigxLCBtICsgayksIDEgLSBNYXRoLm1pbigxLCB5ICsgayldO1xuICB9XG5cbiAgc3RhdGljIENNWUtfSFRNTChjb21wb25lbnRzKSB7XG4gICAgY29uc3QgcmdiID0gdGhpcy5DTVlLX1JHQihjb21wb25lbnRzKS5zbGljZSgxKTtcbiAgICByZXR1cm4gdGhpcy5SR0JfSFRNTChyZ2IpO1xuICB9XG5cbiAgc3RhdGljIFJHQl9DTVlLKFtyLCBnLCBiXSkge1xuICAgIGNvbnN0IGMgPSAxIC0gcjtcbiAgICBjb25zdCBtID0gMSAtIGc7XG4gICAgY29uc3QgeSA9IDEgLSBiO1xuICAgIGNvbnN0IGsgPSBNYXRoLm1pbihjLCBtLCB5KTtcbiAgICByZXR1cm4gW1wiQ01ZS1wiLCBjLCBtLCB5LCBrXTtcbiAgfVxuXG59XG5cbmV4cG9ydHMuQ29sb3JDb252ZXJ0ZXJzID0gQ29sb3JDb252ZXJ0ZXJzO1xuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlhmYUxheWVyID0gdm9pZCAwO1xuXG52YXIgX3hmYV90ZXh0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMCk7XG5cbmNsYXNzIFhmYUxheWVyIHtcbiAgc3RhdGljIHNldHVwU3RvcmFnZShodG1sLCBpZCwgZWxlbWVudCwgc3RvcmFnZSwgaW50ZW50KSB7XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiBudWxsXG4gICAgfSk7XG5cbiAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaHRtbC50ZXh0Q29udGVudCA9IHN0b3JlZERhdGEudmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgIGlmIChlbGVtZW50LmF0dHJpYnV0ZXMudHlwZSA9PT0gXCJyYWRpb1wiIHx8IGVsZW1lbnQuYXR0cmlidXRlcy50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSA9PT0gZWxlbWVudC5hdHRyaWJ1dGVzLnhmYU9uKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9yZWREYXRhLnZhbHVlID09PSBlbGVtZW50LmF0dHJpYnV0ZXMueGZhT2ZmKSB7XG4gICAgICAgICAgICBodG1sLnJlbW92ZUF0dHJpYnV0ZShcImNoZWNrZWRcIik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZXZlbnQudGFyZ2V0LmNoZWNrZWQgPyBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwieGZhT25cIikgOiBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKFwieGZhT2ZmXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaHRtbC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBzdG9yZWREYXRhLnZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC52YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGVsZW1lbnQuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChvcHRpb24uYXR0cmlidXRlcy52YWx1ZSA9PT0gc3RvcmVkRGF0YS52YWx1ZSkge1xuICAgICAgICAgICAgICBvcHRpb24uYXR0cmlidXRlcy5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBldmVudC50YXJnZXQub3B0aW9ucztcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBcIlwiIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgc2V0QXR0cmlidXRlcyh7XG4gICAgaHRtbCxcbiAgICBlbGVtZW50LFxuICAgIHN0b3JhZ2UgPSBudWxsLFxuICAgIGludGVudCxcbiAgICBsaW5rU2VydmljZVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgYXR0cmlidXRlc1xuICAgIH0gPSBlbGVtZW50O1xuICAgIGNvbnN0IGlzSFRNTEFuY2hvckVsZW1lbnQgPSBodG1sIGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQ7XG5cbiAgICBpZiAoYXR0cmlidXRlcy50eXBlID09PSBcInJhZGlvXCIpIHtcbiAgICAgIGF0dHJpYnV0ZXMubmFtZSA9IGAke2F0dHJpYnV0ZXMubmFtZX0tJHtpbnRlbnR9YDtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSkge1xuICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJjbGFzc1wiOlxuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUuam9pbihcIiBcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJkYXRhSWRcIjpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihodG1sLnN0eWxlLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcInRleHRDb250ZW50XCI6XG4gICAgICAgICAgaHRtbC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFpc0hUTUxBbmNob3JFbGVtZW50IHx8IGtleSAhPT0gXCJocmVmXCIgJiYga2V5ICE9PSBcIm5ld1dpbmRvd1wiKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MQW5jaG9yRWxlbWVudCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMoaHRtbCwgYXR0cmlidXRlcy5ocmVmLCBhdHRyaWJ1dGVzLm5ld1dpbmRvdyk7XG4gICAgfVxuXG4gICAgaWYgKHN0b3JhZ2UgJiYgYXR0cmlidXRlcy5kYXRhSWQpIHtcbiAgICAgIHRoaXMuc2V0dXBTdG9yYWdlKGh0bWwsIGF0dHJpYnV0ZXMuZGF0YUlkLCBlbGVtZW50LCBzdG9yYWdlKTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcmVuZGVyKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdG9yYWdlID0gcGFyYW1ldGVycy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICBjb25zdCBsaW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgY29uc3Qgcm9vdCA9IHBhcmFtZXRlcnMueGZhSHRtbDtcbiAgICBjb25zdCBpbnRlbnQgPSBwYXJhbWV0ZXJzLmludGVudCB8fCBcImRpc3BsYXlcIjtcbiAgICBjb25zdCByb290SHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocm9vdC5uYW1lKTtcblxuICAgIGlmIChyb290LmF0dHJpYnV0ZXMpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgIGh0bWw6IHJvb3RIdG1sLFxuICAgICAgICBlbGVtZW50OiByb290LFxuICAgICAgICBpbnRlbnQsXG4gICAgICAgIGxpbmtTZXJ2aWNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFjayA9IFtbcm9vdCwgLTEsIHJvb3RIdG1sXV07XG4gICAgY29uc3Qgcm9vdERpdiA9IHBhcmFtZXRlcnMuZGl2O1xuICAgIHJvb3REaXYuYXBwZW5kKHJvb3RIdG1sKTtcblxuICAgIGlmIChwYXJhbWV0ZXJzLnZpZXdwb3J0KSB7XG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSBgbWF0cml4KCR7cGFyYW1ldGVycy52aWV3cG9ydC50cmFuc2Zvcm0uam9pbihcIixcIil9KWA7XG4gICAgICByb290RGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG5cbiAgICBpZiAoaW50ZW50ICE9PSBcInJpY2hUZXh0XCIpIHtcbiAgICAgIHJvb3REaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgXCJ4ZmFMYXllciB4ZmFGb250XCIpO1xuICAgIH1cblxuICAgIGNvbnN0IHRleHREaXZzID0gW107XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgW3BhcmVudCwgaSwgaHRtbF0gPSBzdGFjay5hdCgtMSk7XG5cbiAgICAgIGlmIChpICsgMSA9PT0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuWysrc3RhY2suYXQoLTEpWzFdXTtcblxuICAgICAgaWYgKGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWVcbiAgICAgIH0gPSBjaGlsZDtcblxuICAgICAgaWYgKG5hbWUgPT09IFwiI3RleHRcIikge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQudmFsdWUpO1xuICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICBodG1sLmFwcGVuZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCBjaGlsZEh0bWw7XG5cbiAgICAgIGlmIChjaGlsZD8uYXR0cmlidXRlcz8ueG1sbnMpIHtcbiAgICAgICAgY2hpbGRIdG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKGNoaWxkLmF0dHJpYnV0ZXMueG1sbnMsIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGRIdG1sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaHRtbC5hcHBlbmQoY2hpbGRIdG1sKTtcblxuICAgICAgaWYgKGNoaWxkLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICBodG1sOiBjaGlsZEh0bWwsXG4gICAgICAgICAgZWxlbWVudDogY2hpbGQsXG4gICAgICAgICAgc3RvcmFnZSxcbiAgICAgICAgICBpbnRlbnQsXG4gICAgICAgICAgbGlua1NlcnZpY2VcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGlsZC5jaGlsZHJlbiAmJiBjaGlsZC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0YWNrLnB1c2goW2NoaWxkLCAtMSwgY2hpbGRIdG1sXSk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLnZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjaGlsZC52YWx1ZSk7XG5cbiAgICAgICAgaWYgKF94ZmFfdGV4dC5YZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZEh0bWwuYXBwZW5kKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgZWwgb2Ygcm9vdERpdi5xdWVyeVNlbGVjdG9yQWxsKFwiLnhmYU5vbkludGVyYWN0aXZlIGlucHV0LCAueGZhTm9uSW50ZXJhY3RpdmUgdGV4dGFyZWFcIikpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShcInJlYWRPbmx5XCIsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0ZXh0RGl2c1xuICAgIH07XG4gIH1cblxuICBzdGF0aWMgdXBkYXRlKHBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBgbWF0cml4KCR7cGFyYW1ldGVycy52aWV3cG9ydC50cmFuc2Zvcm0uam9pbihcIixcIil9KWA7XG4gICAgcGFyYW1ldGVycy5kaXYuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIHBhcmFtZXRlcnMuZGl2LmhpZGRlbiA9IGZhbHNlO1xuICB9XG5cbn1cblxuZXhwb3J0cy5YZmFMYXllciA9IFhmYUxheWVyO1xuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlRleHRMYXllclJlbmRlclRhc2sgPSB2b2lkIDA7XG5leHBvcnRzLnJlbmRlclRleHRMYXllciA9IHJlbmRlclRleHRMYXllcjtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcblxudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg4KTtcblxuY29uc3QgTUFYX1RFWFRfRElWU19UT19SRU5ERVIgPSAxMDAwMDA7XG5jb25zdCBERUZBVUxUX0ZPTlRfU0laRSA9IDMwO1xuY29uc3QgREVGQVVMVF9GT05UX0FTQ0VOVCA9IDAuODtcbmNvbnN0IGFzY2VudENhY2hlID0gbmV3IE1hcCgpO1xuY29uc3QgQWxsV2hpdGVzcGFjZVJlZ2V4cCA9IC9eXFxzKyQvZztcblxuZnVuY3Rpb24gZ2V0QXNjZW50KGZvbnRGYW1pbHksIGN0eCkge1xuICBjb25zdCBjYWNoZWRBc2NlbnQgPSBhc2NlbnRDYWNoZS5nZXQoZm9udEZhbWlseSk7XG5cbiAgaWYgKGNhY2hlZEFzY2VudCkge1xuICAgIHJldHVybiBjYWNoZWRBc2NlbnQ7XG4gIH1cblxuICBjdHguc2F2ZSgpO1xuICBjdHguZm9udCA9IGAke0RFRkFVTFRfRk9OVF9TSVpFfXB4ICR7Zm9udEZhbWlseX1gO1xuICBjb25zdCBtZXRyaWNzID0gY3R4Lm1lYXN1cmVUZXh0KFwiXCIpO1xuICBsZXQgYXNjZW50ID0gbWV0cmljcy5mb250Qm91bmRpbmdCb3hBc2NlbnQ7XG4gIGxldCBkZXNjZW50ID0gTWF0aC5hYnMobWV0cmljcy5mb250Qm91bmRpbmdCb3hEZXNjZW50KTtcblxuICBpZiAoYXNjZW50KSB7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICBjb25zdCByYXRpbyA9IGFzY2VudCAvIChhc2NlbnQgKyBkZXNjZW50KTtcbiAgICBhc2NlbnRDYWNoZS5zZXQoZm9udEZhbWlseSwgcmF0aW8pO1xuICAgIHJldHVybiByYXRpbztcbiAgfVxuXG4gIGN0eC5zdHJva2VTdHlsZSA9IFwicmVkXCI7XG4gIGN0eC5jbGVhclJlY3QoMCwgMCwgREVGQVVMVF9GT05UX1NJWkUsIERFRkFVTFRfRk9OVF9TSVpFKTtcbiAgY3R4LnN0cm9rZVRleHQoXCJnXCIsIDAsIDApO1xuICBsZXQgcGl4ZWxzID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBERUZBVUxUX0ZPTlRfU0laRSwgREVGQVVMVF9GT05UX1NJWkUpLmRhdGE7XG4gIGRlc2NlbnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSBwaXhlbHMubGVuZ3RoIC0gMSAtIDM7IGkgPj0gMDsgaSAtPSA0KSB7XG4gICAgaWYgKHBpeGVsc1tpXSA+IDApIHtcbiAgICAgIGRlc2NlbnQgPSBNYXRoLmNlaWwoaSAvIDQgLyBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBjdHguY2xlYXJSZWN0KDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSk7XG4gIGN0eC5zdHJva2VUZXh0KFwiQVwiLCAwLCBERUZBVUxUX0ZPTlRfU0laRSk7XG4gIHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgREVGQVVMVF9GT05UX1NJWkUsIERFRkFVTFRfRk9OVF9TSVpFKS5kYXRhO1xuICBhc2NlbnQgPSAwO1xuXG4gIGZvciAobGV0IGkgPSAwLCBpaSA9IHBpeGVscy5sZW5ndGg7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgaWYgKHBpeGVsc1tpXSA+IDApIHtcbiAgICAgIGFzY2VudCA9IERFRkFVTFRfRk9OVF9TSVpFIC0gTWF0aC5mbG9vcihpIC8gNCAvIERFRkFVTFRfRk9OVF9TSVpFKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5yZXN0b3JlKCk7XG5cbiAgaWYgKGFzY2VudCkge1xuICAgIGNvbnN0IHJhdGlvID0gYXNjZW50IC8gKGFzY2VudCArIGRlc2NlbnQpO1xuICAgIGFzY2VudENhY2hlLnNldChmb250RmFtaWx5LCByYXRpbyk7XG4gICAgcmV0dXJuIHJhdGlvO1xuICB9XG5cbiAgYXNjZW50Q2FjaGUuc2V0KGZvbnRGYW1pbHksIERFRkFVTFRfRk9OVF9BU0NFTlQpO1xuICByZXR1cm4gREVGQVVMVF9GT05UX0FTQ0VOVDtcbn1cblxuZnVuY3Rpb24gYXBwZW5kVGV4dCh0YXNrLCBnZW9tLCBzdHlsZXMsIGN0eCkge1xuICBjb25zdCB0ZXh0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gIGNvbnN0IHRleHREaXZQcm9wZXJ0aWVzID0gdGFzay5fZW5oYW5jZVRleHRTZWxlY3Rpb24gPyB7XG4gICAgYW5nbGU6IDAsXG4gICAgY2FudmFzV2lkdGg6IDAsXG4gICAgaGFzVGV4dDogZ2VvbS5zdHIgIT09IFwiXCIsXG4gICAgaGFzRU9MOiBnZW9tLmhhc0VPTCxcbiAgICBvcmlnaW5hbFRyYW5zZm9ybTogbnVsbCxcbiAgICBwYWRkaW5nQm90dG9tOiAwLFxuICAgIHBhZGRpbmdMZWZ0OiAwLFxuICAgIHBhZGRpbmdSaWdodDogMCxcbiAgICBwYWRkaW5nVG9wOiAwLFxuICAgIHNjYWxlOiAxLFxuICAgIGZvbnRTaXplOiAwXG4gIH0gOiB7XG4gICAgYW5nbGU6IDAsXG4gICAgY2FudmFzV2lkdGg6IDAsXG4gICAgaGFzVGV4dDogZ2VvbS5zdHIgIT09IFwiXCIsXG4gICAgaGFzRU9MOiBnZW9tLmhhc0VPTCxcbiAgICBmb250U2l6ZTogMFxuICB9O1xuXG4gIHRhc2suX3RleHREaXZzLnB1c2godGV4dERpdik7XG5cbiAgY29uc3QgdHggPSBfdXRpbC5VdGlsLnRyYW5zZm9ybSh0YXNrLl92aWV3cG9ydC50cmFuc2Zvcm0sIGdlb20udHJhbnNmb3JtKTtcblxuICBsZXQgYW5nbGUgPSBNYXRoLmF0YW4yKHR4WzFdLCB0eFswXSk7XG4gIGNvbnN0IHN0eWxlID0gc3R5bGVzW2dlb20uZm9udE5hbWVdO1xuXG4gIGlmIChzdHlsZS52ZXJ0aWNhbCkge1xuICAgIGFuZ2xlICs9IE1hdGguUEkgLyAyO1xuICB9XG5cbiAgY29uc3QgZm9udEhlaWdodCA9IE1hdGguaHlwb3QodHhbMl0sIHR4WzNdKTtcbiAgY29uc3QgZm9udEFzY2VudCA9IGZvbnRIZWlnaHQgKiBnZXRBc2NlbnQoc3R5bGUuZm9udEZhbWlseSwgY3R4KTtcbiAgbGV0IGxlZnQsIHRvcDtcblxuICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICBsZWZ0ID0gdHhbNF07XG4gICAgdG9wID0gdHhbNV0gLSBmb250QXNjZW50O1xuICB9IGVsc2Uge1xuICAgIGxlZnQgPSB0eFs0XSArIGZvbnRBc2NlbnQgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgdG9wID0gdHhbNV0gLSBmb250QXNjZW50ICogTWF0aC5jb3MoYW5nbGUpO1xuICB9XG5cbiAgdGV4dERpdi5zdHlsZS5sZWZ0ID0gYCR7bGVmdH1weGA7XG4gIHRleHREaXYuc3R5bGUudG9wID0gYCR7dG9wfXB4YDtcbiAgdGV4dERpdi5zdHlsZS5mb250U2l6ZSA9IGAke2ZvbnRIZWlnaHR9cHhgO1xuICB0ZXh0RGl2LnN0eWxlLmZvbnRGYW1pbHkgPSBzdHlsZS5mb250RmFtaWx5O1xuICB0ZXh0RGl2UHJvcGVydGllcy5mb250U2l6ZSA9IGZvbnRIZWlnaHQ7XG4gIHRleHREaXYuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgdGV4dERpdi50ZXh0Q29udGVudCA9IGdlb20uc3RyO1xuICB0ZXh0RGl2LmRpciA9IGdlb20uZGlyO1xuXG4gIGlmICh0YXNrLl9mb250SW5zcGVjdG9yRW5hYmxlZCkge1xuICAgIHRleHREaXYuZGF0YXNldC5mb250TmFtZSA9IGdlb20uZm9udE5hbWU7XG4gIH1cblxuICBpZiAoYW5nbGUgIT09IDApIHtcbiAgICB0ZXh0RGl2UHJvcGVydGllcy5hbmdsZSA9IGFuZ2xlICogKDE4MCAvIE1hdGguUEkpO1xuICB9XG5cbiAgbGV0IHNob3VsZFNjYWxlVGV4dCA9IGZhbHNlO1xuXG4gIGlmIChnZW9tLnN0ci5sZW5ndGggPiAxIHx8IHRhc2suX2VuaGFuY2VUZXh0U2VsZWN0aW9uICYmIEFsbFdoaXRlc3BhY2VSZWdleHAudGVzdChnZW9tLnN0cikpIHtcbiAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGdlb20uc3RyICE9PSBcIiBcIiAmJiBnZW9tLnRyYW5zZm9ybVswXSAhPT0gZ2VvbS50cmFuc2Zvcm1bM10pIHtcbiAgICBjb25zdCBhYnNTY2FsZVggPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVswXSksXG4gICAgICAgICAgYWJzU2NhbGVZID0gTWF0aC5hYnMoZ2VvbS50cmFuc2Zvcm1bM10pO1xuXG4gICAgaWYgKGFic1NjYWxlWCAhPT0gYWJzU2NhbGVZICYmIE1hdGgubWF4KGFic1NjYWxlWCwgYWJzU2NhbGVZKSAvIE1hdGgubWluKGFic1NjYWxlWCwgYWJzU2NhbGVZKSA+IDEuNSkge1xuICAgICAgc2hvdWxkU2NhbGVUZXh0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2hvdWxkU2NhbGVUZXh0KSB7XG4gICAgaWYgKHN0eWxlLnZlcnRpY2FsKSB7XG4gICAgICB0ZXh0RGl2UHJvcGVydGllcy5jYW52YXNXaWR0aCA9IGdlb20uaGVpZ2h0ICogdGFzay5fdmlld3BvcnQuc2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRleHREaXZQcm9wZXJ0aWVzLmNhbnZhc1dpZHRoID0gZ2VvbS53aWR0aCAqIHRhc2suX3ZpZXdwb3J0LnNjYWxlO1xuICAgIH1cbiAgfVxuXG4gIHRhc2suX3RleHREaXZQcm9wZXJ0aWVzLnNldCh0ZXh0RGl2LCB0ZXh0RGl2UHJvcGVydGllcyk7XG5cbiAgaWYgKHRhc2suX3RleHRDb250ZW50U3RyZWFtKSB7XG4gICAgdGFzay5fbGF5b3V0VGV4dCh0ZXh0RGl2KTtcbiAgfVxuXG4gIGlmICh0YXNrLl9lbmhhbmNlVGV4dFNlbGVjdGlvbiAmJiB0ZXh0RGl2UHJvcGVydGllcy5oYXNUZXh0KSB7XG4gICAgbGV0IGFuZ2xlQ29zID0gMSxcbiAgICAgICAgYW5nbGVTaW4gPSAwO1xuXG4gICAgaWYgKGFuZ2xlICE9PSAwKSB7XG4gICAgICBhbmdsZUNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgIGFuZ2xlU2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGRpdldpZHRoID0gKHN0eWxlLnZlcnRpY2FsID8gZ2VvbS5oZWlnaHQgOiBnZW9tLndpZHRoKSAqIHRhc2suX3ZpZXdwb3J0LnNjYWxlO1xuICAgIGNvbnN0IGRpdkhlaWdodCA9IGZvbnRIZWlnaHQ7XG4gICAgbGV0IG0sIGI7XG5cbiAgICBpZiAoYW5nbGUgIT09IDApIHtcbiAgICAgIG0gPSBbYW5nbGVDb3MsIGFuZ2xlU2luLCAtYW5nbGVTaW4sIGFuZ2xlQ29zLCBsZWZ0LCB0b3BdO1xuICAgICAgYiA9IF91dGlsLlV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIGRpdldpZHRoLCBkaXZIZWlnaHRdLCBtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYiA9IFtsZWZ0LCB0b3AsIGxlZnQgKyBkaXZXaWR0aCwgdG9wICsgZGl2SGVpZ2h0XTtcbiAgICB9XG5cbiAgICB0YXNrLl9ib3VuZHMucHVzaCh7XG4gICAgICBsZWZ0OiBiWzBdLFxuICAgICAgdG9wOiBiWzFdLFxuICAgICAgcmlnaHQ6IGJbMl0sXG4gICAgICBib3R0b206IGJbM10sXG4gICAgICBkaXY6IHRleHREaXYsXG4gICAgICBzaXplOiBbZGl2V2lkdGgsIGRpdkhlaWdodF0sXG4gICAgICBtXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyKHRhc2spIHtcbiAgaWYgKHRhc2suX2NhbmNlbGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgdGV4dERpdnMgPSB0YXNrLl90ZXh0RGl2cztcbiAgY29uc3QgY2FwYWJpbGl0eSA9IHRhc2suX2NhcGFiaWxpdHk7XG4gIGNvbnN0IHRleHREaXZzTGVuZ3RoID0gdGV4dERpdnMubGVuZ3RoO1xuXG4gIGlmICh0ZXh0RGl2c0xlbmd0aCA+IE1BWF9URVhUX0RJVlNfVE9fUkVOREVSKSB7XG4gICAgdGFzay5fcmVuZGVyaW5nRG9uZSA9IHRydWU7XG4gICAgY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCF0YXNrLl90ZXh0Q29udGVudFN0cmVhbSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dERpdnNMZW5ndGg7IGkrKykge1xuICAgICAgdGFzay5fbGF5b3V0VGV4dCh0ZXh0RGl2c1tpXSk7XG4gICAgfVxuICB9XG5cbiAgdGFzay5fcmVuZGVyaW5nRG9uZSA9IHRydWU7XG4gIGNhcGFiaWxpdHkucmVzb2x2ZSgpO1xufVxuXG5mdW5jdGlvbiBmaW5kUG9zaXRpdmVNaW4odHMsIG9mZnNldCwgY291bnQpIHtcbiAgbGV0IHJlc3VsdCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgY29uc3QgdCA9IHRzW29mZnNldCsrXTtcblxuICAgIGlmICh0ID4gMCkge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gTWF0aC5taW4odCwgcmVzdWx0KSA6IHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZXhwYW5kKHRhc2spIHtcbiAgY29uc3QgYm91bmRzID0gdGFzay5fYm91bmRzO1xuICBjb25zdCB2aWV3cG9ydCA9IHRhc2suX3ZpZXdwb3J0O1xuICBjb25zdCBleHBhbmRlZCA9IGV4cGFuZEJvdW5kcyh2aWV3cG9ydC53aWR0aCwgdmlld3BvcnQuaGVpZ2h0LCBib3VuZHMpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwYW5kZWQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBkaXYgPSBib3VuZHNbaV0uZGl2O1xuXG4gICAgY29uc3QgZGl2UHJvcGVydGllcyA9IHRhc2suX3RleHREaXZQcm9wZXJ0aWVzLmdldChkaXYpO1xuXG4gICAgaWYgKGRpdlByb3BlcnRpZXMuYW5nbGUgPT09IDApIHtcbiAgICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ0xlZnQgPSBib3VuZHNbaV0ubGVmdCAtIGV4cGFuZGVkW2ldLmxlZnQ7XG4gICAgICBkaXZQcm9wZXJ0aWVzLnBhZGRpbmdUb3AgPSBib3VuZHNbaV0udG9wIC0gZXhwYW5kZWRbaV0udG9wO1xuICAgICAgZGl2UHJvcGVydGllcy5wYWRkaW5nUmlnaHQgPSBleHBhbmRlZFtpXS5yaWdodCAtIGJvdW5kc1tpXS5yaWdodDtcbiAgICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ0JvdHRvbSA9IGV4cGFuZGVkW2ldLmJvdHRvbSAtIGJvdW5kc1tpXS5ib3R0b207XG5cbiAgICAgIHRhc2suX3RleHREaXZQcm9wZXJ0aWVzLnNldChkaXYsIGRpdlByb3BlcnRpZXMpO1xuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBlID0gZXhwYW5kZWRbaV0sXG4gICAgICAgICAgYiA9IGJvdW5kc1tpXTtcbiAgICBjb25zdCBtID0gYi5tLFxuICAgICAgICAgIGMgPSBtWzBdLFxuICAgICAgICAgIHMgPSBtWzFdO1xuICAgIGNvbnN0IHBvaW50cyA9IFtbMCwgMF0sIFswLCBiLnNpemVbMV1dLCBbYi5zaXplWzBdLCAwXSwgYi5zaXplXTtcbiAgICBjb25zdCB0cyA9IG5ldyBGbG9hdDY0QXJyYXkoNjQpO1xuXG4gICAgZm9yIChsZXQgaiA9IDAsIGpqID0gcG9pbnRzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgIGNvbnN0IHQgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKHBvaW50c1tqXSwgbSk7XG5cbiAgICAgIHRzW2ogKyAwXSA9IGMgJiYgKGUubGVmdCAtIHRbMF0pIC8gYztcbiAgICAgIHRzW2ogKyA0XSA9IHMgJiYgKGUudG9wIC0gdFsxXSkgLyBzO1xuICAgICAgdHNbaiArIDhdID0gYyAmJiAoZS5yaWdodCAtIHRbMF0pIC8gYztcbiAgICAgIHRzW2ogKyAxMl0gPSBzICYmIChlLmJvdHRvbSAtIHRbMV0pIC8gcztcbiAgICAgIHRzW2ogKyAxNl0gPSBzICYmIChlLmxlZnQgLSB0WzBdKSAvIC1zO1xuICAgICAgdHNbaiArIDIwXSA9IGMgJiYgKGUudG9wIC0gdFsxXSkgLyBjO1xuICAgICAgdHNbaiArIDI0XSA9IHMgJiYgKGUucmlnaHQgLSB0WzBdKSAvIC1zO1xuICAgICAgdHNbaiArIDI4XSA9IGMgJiYgKGUuYm90dG9tIC0gdFsxXSkgLyBjO1xuICAgICAgdHNbaiArIDMyXSA9IGMgJiYgKGUubGVmdCAtIHRbMF0pIC8gLWM7XG4gICAgICB0c1tqICsgMzZdID0gcyAmJiAoZS50b3AgLSB0WzFdKSAvIC1zO1xuICAgICAgdHNbaiArIDQwXSA9IGMgJiYgKGUucmlnaHQgLSB0WzBdKSAvIC1jO1xuICAgICAgdHNbaiArIDQ0XSA9IHMgJiYgKGUuYm90dG9tIC0gdFsxXSkgLyAtcztcbiAgICAgIHRzW2ogKyA0OF0gPSBzICYmIChlLmxlZnQgLSB0WzBdKSAvIHM7XG4gICAgICB0c1tqICsgNTJdID0gYyAmJiAoZS50b3AgLSB0WzFdKSAvIC1jO1xuICAgICAgdHNbaiArIDU2XSA9IHMgJiYgKGUucmlnaHQgLSB0WzBdKSAvIHM7XG4gICAgICB0c1tqICsgNjBdID0gYyAmJiAoZS5ib3R0b20gLSB0WzFdKSAvIC1jO1xuICAgIH1cblxuICAgIGNvbnN0IGJveFNjYWxlID0gMSArIE1hdGgubWluKE1hdGguYWJzKGMpLCBNYXRoLmFicyhzKSk7XG4gICAgZGl2UHJvcGVydGllcy5wYWRkaW5nTGVmdCA9IGZpbmRQb3NpdGl2ZU1pbih0cywgMzIsIDE2KSAvIGJveFNjYWxlO1xuICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ1RvcCA9IGZpbmRQb3NpdGl2ZU1pbih0cywgNDgsIDE2KSAvIGJveFNjYWxlO1xuICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ1JpZ2h0ID0gZmluZFBvc2l0aXZlTWluKHRzLCAwLCAxNikgLyBib3hTY2FsZTtcbiAgICBkaXZQcm9wZXJ0aWVzLnBhZGRpbmdCb3R0b20gPSBmaW5kUG9zaXRpdmVNaW4odHMsIDE2LCAxNikgLyBib3hTY2FsZTtcblxuICAgIHRhc2suX3RleHREaXZQcm9wZXJ0aWVzLnNldChkaXYsIGRpdlByb3BlcnRpZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4cGFuZEJvdW5kcyh3aWR0aCwgaGVpZ2h0LCBib3hlcykge1xuICBjb25zdCBib3VuZHMgPSBib3hlcy5tYXAoZnVuY3Rpb24gKGJveCwgaSkge1xuICAgIHJldHVybiB7XG4gICAgICB4MTogYm94LmxlZnQsXG4gICAgICB5MTogYm94LnRvcCxcbiAgICAgIHgyOiBib3gucmlnaHQsXG4gICAgICB5MjogYm94LmJvdHRvbSxcbiAgICAgIGluZGV4OiBpLFxuICAgICAgeDFOZXc6IHVuZGVmaW5lZCxcbiAgICAgIHgyTmV3OiB1bmRlZmluZWRcbiAgICB9O1xuICB9KTtcbiAgZXhwYW5kQm91bmRzTFRSKHdpZHRoLCBib3VuZHMpO1xuICBjb25zdCBleHBhbmRlZCA9IG5ldyBBcnJheShib3hlcy5sZW5ndGgpO1xuXG4gIGZvciAoY29uc3QgYiBvZiBib3VuZHMpIHtcbiAgICBjb25zdCBpID0gYi5pbmRleDtcbiAgICBleHBhbmRlZFtpXSA9IHtcbiAgICAgIGxlZnQ6IGIueDFOZXcsXG4gICAgICB0b3A6IDAsXG4gICAgICByaWdodDogYi54Mk5ldyxcbiAgICAgIGJvdHRvbTogMFxuICAgIH07XG4gIH1cblxuICBib3hlcy5tYXAoZnVuY3Rpb24gKGJveCwgaSkge1xuICAgIGNvbnN0IGUgPSBleHBhbmRlZFtpXSxcbiAgICAgICAgICBiID0gYm91bmRzW2ldO1xuICAgIGIueDEgPSBib3gudG9wO1xuICAgIGIueTEgPSB3aWR0aCAtIGUucmlnaHQ7XG4gICAgYi54MiA9IGJveC5ib3R0b207XG4gICAgYi55MiA9IHdpZHRoIC0gZS5sZWZ0O1xuICAgIGIuaW5kZXggPSBpO1xuICAgIGIueDFOZXcgPSB1bmRlZmluZWQ7XG4gICAgYi54Mk5ldyA9IHVuZGVmaW5lZDtcbiAgfSk7XG4gIGV4cGFuZEJvdW5kc0xUUihoZWlnaHQsIGJvdW5kcyk7XG5cbiAgZm9yIChjb25zdCBiIG9mIGJvdW5kcykge1xuICAgIGNvbnN0IGkgPSBiLmluZGV4O1xuICAgIGV4cGFuZGVkW2ldLnRvcCA9IGIueDFOZXc7XG4gICAgZXhwYW5kZWRbaV0uYm90dG9tID0gYi54Mk5ldztcbiAgfVxuXG4gIHJldHVybiBleHBhbmRlZDtcbn1cblxuZnVuY3Rpb24gZXhwYW5kQm91bmRzTFRSKHdpZHRoLCBib3VuZHMpIHtcbiAgYm91bmRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS54MSAtIGIueDEgfHwgYS5pbmRleCAtIGIuaW5kZXg7XG4gIH0pO1xuICBjb25zdCBmYWtlQm91bmRhcnkgPSB7XG4gICAgeDE6IC1JbmZpbml0eSxcbiAgICB5MTogLUluZmluaXR5LFxuICAgIHgyOiAwLFxuICAgIHkyOiBJbmZpbml0eSxcbiAgICBpbmRleDogLTEsXG4gICAgeDFOZXc6IDAsXG4gICAgeDJOZXc6IDBcbiAgfTtcbiAgY29uc3QgaG9yaXpvbiA9IFt7XG4gICAgc3RhcnQ6IC1JbmZpbml0eSxcbiAgICBlbmQ6IEluZmluaXR5LFxuICAgIGJvdW5kYXJ5OiBmYWtlQm91bmRhcnlcbiAgfV07XG5cbiAgZm9yIChjb25zdCBib3VuZGFyeSBvZiBib3VuZHMpIHtcbiAgICBsZXQgaSA9IDA7XG5cbiAgICB3aGlsZSAoaSA8IGhvcml6b24ubGVuZ3RoICYmIGhvcml6b25baV0uZW5kIDw9IGJvdW5kYXJ5LnkxKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgbGV0IGogPSBob3Jpem9uLmxlbmd0aCAtIDE7XG5cbiAgICB3aGlsZSAoaiA+PSAwICYmIGhvcml6b25bal0uc3RhcnQgPj0gYm91bmRhcnkueTIpIHtcbiAgICAgIGotLTtcbiAgICB9XG5cbiAgICBsZXQgaG9yaXpvblBhcnQsIGFmZmVjdGVkQm91bmRhcnk7XG4gICAgbGV0IHEsXG4gICAgICAgIGssXG4gICAgICAgIG1heFhOZXcgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHEgPSBpOyBxIDw9IGo7IHErKykge1xuICAgICAgaG9yaXpvblBhcnQgPSBob3Jpem9uW3FdO1xuICAgICAgYWZmZWN0ZWRCb3VuZGFyeSA9IGhvcml6b25QYXJ0LmJvdW5kYXJ5O1xuICAgICAgbGV0IHhOZXc7XG5cbiAgICAgIGlmIChhZmZlY3RlZEJvdW5kYXJ5LngyID4gYm91bmRhcnkueDEpIHtcbiAgICAgICAgeE5ldyA9IGFmZmVjdGVkQm91bmRhcnkuaW5kZXggPiBib3VuZGFyeS5pbmRleCA/IGFmZmVjdGVkQm91bmRhcnkueDFOZXcgOiBib3VuZGFyeS54MTtcbiAgICAgIH0gZWxzZSBpZiAoYWZmZWN0ZWRCb3VuZGFyeS54Mk5ldyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHhOZXcgPSAoYWZmZWN0ZWRCb3VuZGFyeS54MiArIGJvdW5kYXJ5LngxKSAvIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4TmV3ID0gYWZmZWN0ZWRCb3VuZGFyeS54Mk5ldztcbiAgICAgIH1cblxuICAgICAgaWYgKHhOZXcgPiBtYXhYTmV3KSB7XG4gICAgICAgIG1heFhOZXcgPSB4TmV3O1xuICAgICAgfVxuICAgIH1cblxuICAgIGJvdW5kYXJ5LngxTmV3ID0gbWF4WE5ldztcblxuICAgIGZvciAocSA9IGk7IHEgPD0gajsgcSsrKSB7XG4gICAgICBob3Jpem9uUGFydCA9IGhvcml6b25bcV07XG4gICAgICBhZmZlY3RlZEJvdW5kYXJ5ID0gaG9yaXpvblBhcnQuYm91bmRhcnk7XG5cbiAgICAgIGlmIChhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFmZmVjdGVkQm91bmRhcnkueDIgPiBib3VuZGFyeS54MSkge1xuICAgICAgICAgIGlmIChhZmZlY3RlZEJvdW5kYXJ5LmluZGV4ID4gYm91bmRhcnkuaW5kZXgpIHtcbiAgICAgICAgICAgIGFmZmVjdGVkQm91bmRhcnkueDJOZXcgPSBhZmZlY3RlZEJvdW5kYXJ5LngyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID0gbWF4WE5ldztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID4gbWF4WE5ldykge1xuICAgICAgICBhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID0gTWF0aC5tYXgobWF4WE5ldywgYWZmZWN0ZWRCb3VuZGFyeS54Mik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbmdlZEhvcml6b24gPSBbXTtcbiAgICBsZXQgbGFzdEJvdW5kYXJ5ID0gbnVsbDtcblxuICAgIGZvciAocSA9IGk7IHEgPD0gajsgcSsrKSB7XG4gICAgICBob3Jpem9uUGFydCA9IGhvcml6b25bcV07XG4gICAgICBhZmZlY3RlZEJvdW5kYXJ5ID0gaG9yaXpvblBhcnQuYm91bmRhcnk7XG4gICAgICBjb25zdCB1c2VCb3VuZGFyeSA9IGFmZmVjdGVkQm91bmRhcnkueDIgPiBib3VuZGFyeS54MiA/IGFmZmVjdGVkQm91bmRhcnkgOiBib3VuZGFyeTtcblxuICAgICAgaWYgKGxhc3RCb3VuZGFyeSA9PT0gdXNlQm91bmRhcnkpIHtcbiAgICAgICAgY2hhbmdlZEhvcml6b24uYXQoLTEpLmVuZCA9IGhvcml6b25QYXJ0LmVuZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoYW5nZWRIb3Jpem9uLnB1c2goe1xuICAgICAgICAgIHN0YXJ0OiBob3Jpem9uUGFydC5zdGFydCxcbiAgICAgICAgICBlbmQ6IGhvcml6b25QYXJ0LmVuZCxcbiAgICAgICAgICBib3VuZGFyeTogdXNlQm91bmRhcnlcbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RCb3VuZGFyeSA9IHVzZUJvdW5kYXJ5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChob3Jpem9uW2ldLnN0YXJ0IDwgYm91bmRhcnkueTEpIHtcbiAgICAgIGNoYW5nZWRIb3Jpem9uWzBdLnN0YXJ0ID0gYm91bmRhcnkueTE7XG4gICAgICBjaGFuZ2VkSG9yaXpvbi51bnNoaWZ0KHtcbiAgICAgICAgc3RhcnQ6IGhvcml6b25baV0uc3RhcnQsXG4gICAgICAgIGVuZDogYm91bmRhcnkueTEsXG4gICAgICAgIGJvdW5kYXJ5OiBob3Jpem9uW2ldLmJvdW5kYXJ5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoYm91bmRhcnkueTIgPCBob3Jpem9uW2pdLmVuZCkge1xuICAgICAgY2hhbmdlZEhvcml6b24uYXQoLTEpLmVuZCA9IGJvdW5kYXJ5LnkyO1xuICAgICAgY2hhbmdlZEhvcml6b24ucHVzaCh7XG4gICAgICAgIHN0YXJ0OiBib3VuZGFyeS55MixcbiAgICAgICAgZW5kOiBob3Jpem9uW2pdLmVuZCxcbiAgICAgICAgYm91bmRhcnk6IGhvcml6b25bal0uYm91bmRhcnlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAocSA9IGk7IHEgPD0gajsgcSsrKSB7XG4gICAgICBob3Jpem9uUGFydCA9IGhvcml6b25bcV07XG4gICAgICBhZmZlY3RlZEJvdW5kYXJ5ID0gaG9yaXpvblBhcnQuYm91bmRhcnk7XG5cbiAgICAgIGlmIChhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGxldCB1c2VkID0gZmFsc2U7XG5cbiAgICAgIGZvciAoayA9IGkgLSAxOyAhdXNlZCAmJiBrID49IDAgJiYgaG9yaXpvbltrXS5zdGFydCA+PSBhZmZlY3RlZEJvdW5kYXJ5LnkxOyBrLS0pIHtcbiAgICAgICAgdXNlZCA9IGhvcml6b25ba10uYm91bmRhcnkgPT09IGFmZmVjdGVkQm91bmRhcnk7XG4gICAgICB9XG5cbiAgICAgIGZvciAoayA9IGogKyAxOyAhdXNlZCAmJiBrIDwgaG9yaXpvbi5sZW5ndGggJiYgaG9yaXpvbltrXS5lbmQgPD0gYWZmZWN0ZWRCb3VuZGFyeS55MjsgaysrKSB7XG4gICAgICAgIHVzZWQgPSBob3Jpem9uW2tdLmJvdW5kYXJ5ID09PSBhZmZlY3RlZEJvdW5kYXJ5O1xuICAgICAgfVxuXG4gICAgICBmb3IgKGsgPSAwOyAhdXNlZCAmJiBrIDwgY2hhbmdlZEhvcml6b24ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdXNlZCA9IGNoYW5nZWRIb3Jpem9uW2tdLmJvdW5kYXJ5ID09PSBhZmZlY3RlZEJvdW5kYXJ5O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXVzZWQpIHtcbiAgICAgICAgYWZmZWN0ZWRCb3VuZGFyeS54Mk5ldyA9IG1heFhOZXc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5hcHBseShob3Jpem9uLCBbaSwgaiAtIGkgKyAxLCAuLi5jaGFuZ2VkSG9yaXpvbl0pO1xuICB9XG5cbiAgZm9yIChjb25zdCBob3Jpem9uUGFydCBvZiBob3Jpem9uKSB7XG4gICAgY29uc3QgYWZmZWN0ZWRCb3VuZGFyeSA9IGhvcml6b25QYXJ0LmJvdW5kYXJ5O1xuXG4gICAgaWYgKGFmZmVjdGVkQm91bmRhcnkueDJOZXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYWZmZWN0ZWRCb3VuZGFyeS54Mk5ldyA9IE1hdGgubWF4KHdpZHRoLCBhZmZlY3RlZEJvdW5kYXJ5LngyKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgVGV4dExheWVyUmVuZGVyVGFzayB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICB0ZXh0Q29udGVudCxcbiAgICB0ZXh0Q29udGVudFN0cmVhbSxcbiAgICBjb250YWluZXIsXG4gICAgdmlld3BvcnQsXG4gICAgdGV4dERpdnMsXG4gICAgdGV4dENvbnRlbnRJdGVtc1N0cixcbiAgICBlbmhhbmNlVGV4dFNlbGVjdGlvblxuICB9KSB7XG4gICAgaWYgKGVuaGFuY2VUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoXCJUaGUgYGVuaGFuY2VUZXh0U2VsZWN0aW9uYCBmdW5jdGlvbmFsaXR5IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl90ZXh0Q29udGVudCA9IHRleHRDb250ZW50O1xuICAgIHRoaXMuX3RleHRDb250ZW50U3RyZWFtID0gdGV4dENvbnRlbnRTdHJlYW07XG4gICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuX2RvY3VtZW50ID0gY29udGFpbmVyLm93bmVyRG9jdW1lbnQ7XG4gICAgdGhpcy5fdmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICB0aGlzLl90ZXh0RGl2cyA9IHRleHREaXZzIHx8IFtdO1xuICAgIHRoaXMuX3RleHRDb250ZW50SXRlbXNTdHIgPSB0ZXh0Q29udGVudEl0ZW1zU3RyIHx8IFtdO1xuICAgIHRoaXMuX2VuaGFuY2VUZXh0U2VsZWN0aW9uID0gISFlbmhhbmNlVGV4dFNlbGVjdGlvbjtcbiAgICB0aGlzLl9mb250SW5zcGVjdG9yRW5hYmxlZCA9ICEhZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yPy5lbmFibGVkO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbGF5b3V0VGV4dExhc3RGb250U2l6ZSA9IG51bGw7XG4gICAgdGhpcy5fbGF5b3V0VGV4dExhc3RGb250RmFtaWx5ID0gbnVsbDtcbiAgICB0aGlzLl9sYXlvdXRUZXh0Q3R4ID0gbnVsbDtcbiAgICB0aGlzLl90ZXh0RGl2UHJvcGVydGllcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5fcmVuZGVyaW5nRG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX2NhbmNlbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICB0aGlzLl9yZW5kZXJUaW1lciA9IG51bGw7XG4gICAgdGhpcy5fYm91bmRzID0gW107XG4gICAgdGhpcy5fZGV2aWNlUGl4ZWxSYXRpbyA9IGdsb2JhbFRoaXMuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgdGhpcy5fY2FwYWJpbGl0eS5wcm9taXNlLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9lbmhhbmNlVGV4dFNlbGVjdGlvbikge1xuICAgICAgICB0aGlzLl90ZXh0RGl2UHJvcGVydGllcyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9sYXlvdXRUZXh0Q3R4KSB7XG4gICAgICAgIHRoaXMuX2xheW91dFRleHRDdHguY2FudmFzLndpZHRoID0gMDtcbiAgICAgICAgdGhpcy5fbGF5b3V0VGV4dEN0eC5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fbGF5b3V0VGV4dEN0eCA9IG51bGw7XG4gICAgICB9XG4gICAgfSkuY2F0Y2goKCkgPT4ge30pO1xuICB9XG5cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLl9jYW5jZWxlZCA9IHRydWU7XG5cbiAgICBpZiAodGhpcy5fcmVhZGVyKSB7XG4gICAgICB0aGlzLl9yZWFkZXIuY2FuY2VsKG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihcIlRleHRMYXllciB0YXNrIGNhbmNlbGxlZC5cIikpLmNhdGNoKCgpID0+IHt9KTtcblxuICAgICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVuZGVyVGltZXIgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZW5kZXJUaW1lcik7XG4gICAgICB0aGlzLl9yZW5kZXJUaW1lciA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fY2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiVGV4dExheWVyIHRhc2sgY2FuY2VsbGVkLlwiKSk7XG4gIH1cblxuICBfcHJvY2Vzc0l0ZW1zKGl0ZW1zLCBzdHlsZUNhY2hlKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaXRlbXNbaV0uc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGl0ZW1zW2ldLnR5cGUgPT09IFwiYmVnaW5NYXJrZWRDb250ZW50UHJvcHNcIiB8fCBpdGVtc1tpXS50eXBlID09PSBcImJlZ2luTWFya2VkQ29udGVudFwiKSB7XG4gICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuXG4gICAgICAgICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXJrZWRDb250ZW50XCIpO1xuXG4gICAgICAgICAgaWYgKGl0ZW1zW2ldLmlkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIuc2V0QXR0cmlidXRlKFwiaWRcIiwgYCR7aXRlbXNbaV0uaWR9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFyZW50LmFwcGVuZCh0aGlzLl9jb250YWluZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKGl0ZW1zW2ldLnR5cGUgPT09IFwiZW5kTWFya2VkQ29udGVudFwiKSB7XG4gICAgICAgICAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyLnBhcmVudE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdGV4dENvbnRlbnRJdGVtc1N0ci5wdXNoKGl0ZW1zW2ldLnN0cik7XG5cbiAgICAgIGFwcGVuZFRleHQodGhpcywgaXRlbXNbaV0sIHN0eWxlQ2FjaGUsIHRoaXMuX2xheW91dFRleHRDdHgpO1xuICAgIH1cbiAgfVxuXG4gIF9sYXlvdXRUZXh0KHRleHREaXYpIHtcbiAgICBjb25zdCB0ZXh0RGl2UHJvcGVydGllcyA9IHRoaXMuX3RleHREaXZQcm9wZXJ0aWVzLmdldCh0ZXh0RGl2KTtcblxuICAgIGxldCB0cmFuc2Zvcm0gPSBcIlwiO1xuXG4gICAgaWYgKHRleHREaXZQcm9wZXJ0aWVzLmNhbnZhc1dpZHRoICE9PSAwICYmIHRleHREaXZQcm9wZXJ0aWVzLmhhc1RleHQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZm9udEZhbWlseVxuICAgICAgfSA9IHRleHREaXYuc3R5bGU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZvbnRTaXplXG4gICAgICB9ID0gdGV4dERpdlByb3BlcnRpZXM7XG5cbiAgICAgIGlmIChmb250U2l6ZSAhPT0gdGhpcy5fbGF5b3V0VGV4dExhc3RGb250U2l6ZSB8fCBmb250RmFtaWx5ICE9PSB0aGlzLl9sYXlvdXRUZXh0TGFzdEZvbnRGYW1pbHkpIHtcbiAgICAgICAgdGhpcy5fbGF5b3V0VGV4dEN0eC5mb250ID0gYCR7Zm9udFNpemUgKiB0aGlzLl9kZXZpY2VQaXhlbFJhdGlvfXB4ICR7Zm9udEZhbWlseX1gO1xuICAgICAgICB0aGlzLl9sYXlvdXRUZXh0TGFzdEZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgIHRoaXMuX2xheW91dFRleHRMYXN0Rm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgd2lkdGhcbiAgICAgIH0gPSB0aGlzLl9sYXlvdXRUZXh0Q3R4Lm1lYXN1cmVUZXh0KHRleHREaXYudGV4dENvbnRlbnQpO1xuXG4gICAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHNjYWxlID0gdGhpcy5fZGV2aWNlUGl4ZWxSYXRpbyAqIHRleHREaXZQcm9wZXJ0aWVzLmNhbnZhc1dpZHRoIC8gd2lkdGg7XG5cbiAgICAgICAgaWYgKHRoaXMuX2VuaGFuY2VUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgdGV4dERpdlByb3BlcnRpZXMuc2NhbGUgPSBzY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zZm9ybSA9IGBzY2FsZVgoJHtzY2FsZX0pYDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuYW5nbGUgIT09IDApIHtcbiAgICAgIHRyYW5zZm9ybSA9IGByb3RhdGUoJHt0ZXh0RGl2UHJvcGVydGllcy5hbmdsZX1kZWcpICR7dHJhbnNmb3JtfWA7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zZm9ybS5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodGhpcy5fZW5oYW5jZVRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgdGV4dERpdlByb3BlcnRpZXMub3JpZ2luYWxUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICB9XG5cbiAgICAgIHRleHREaXYuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH1cblxuICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5oYXNUZXh0KSB7XG4gICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kKHRleHREaXYpO1xuICAgIH1cblxuICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5oYXNFT0wpIHtcbiAgICAgIGNvbnN0IGJyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xuICAgICAgYnIuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcblxuICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZChicik7XG4gICAgfVxuICB9XG5cbiAgX3JlbmRlcih0aW1lb3V0ID0gMCkge1xuICAgIGNvbnN0IGNhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgbGV0IHN0eWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblxuICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggPSBERUZBVUxUX0ZPTlRfU0laRTtcbiAgICB0aGlzLl9sYXlvdXRUZXh0Q3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogZmFsc2VcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLl90ZXh0Q29udGVudCkge1xuICAgICAgY29uc3QgdGV4dEl0ZW1zID0gdGhpcy5fdGV4dENvbnRlbnQuaXRlbXM7XG4gICAgICBjb25zdCB0ZXh0U3R5bGVzID0gdGhpcy5fdGV4dENvbnRlbnQuc3R5bGVzO1xuXG4gICAgICB0aGlzLl9wcm9jZXNzSXRlbXModGV4dEl0ZW1zLCB0ZXh0U3R5bGVzKTtcblxuICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl90ZXh0Q29udGVudFN0cmVhbSkge1xuICAgICAgY29uc3QgcHVtcCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fcmVhZGVyLnJlYWQoKS50aGVuKCh7XG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZG9uZVxuICAgICAgICB9KSA9PiB7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3R5bGVDYWNoZSwgdmFsdWUuc3R5bGVzKTtcblxuICAgICAgICAgIHRoaXMuX3Byb2Nlc3NJdGVtcyh2YWx1ZS5pdGVtcywgc3R5bGVDYWNoZSk7XG5cbiAgICAgICAgICBwdW1wKCk7XG4gICAgICAgIH0sIGNhcGFiaWxpdHkucmVqZWN0KTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3JlYWRlciA9IHRoaXMuX3RleHRDb250ZW50U3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgcHVtcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05laXRoZXIgXCJ0ZXh0Q29udGVudFwiIG5vciBcInRleHRDb250ZW50U3RyZWFtXCIgcGFyYW1ldGVycyBzcGVjaWZpZWQuJyk7XG4gICAgfVxuXG4gICAgY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgc3R5bGVDYWNoZSA9IG51bGw7XG5cbiAgICAgIGlmICghdGltZW91dCkge1xuICAgICAgICByZW5kZXIodGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yZW5kZXJUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHJlbmRlcih0aGlzKTtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJUaW1lciA9IG51bGw7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuX2NhcGFiaWxpdHkucmVqZWN0KTtcbiAgfVxuXG4gIGV4cGFuZFRleHREaXZzKGV4cGFuZERpdnMgPSBmYWxzZSkge1xuICAgIGlmICghdGhpcy5fZW5oYW5jZVRleHRTZWxlY3Rpb24gfHwgIXRoaXMuX3JlbmRlcmluZ0RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYm91bmRzICE9PSBudWxsKSB7XG4gICAgICBleHBhbmQodGhpcyk7XG4gICAgICB0aGlzLl9ib3VuZHMgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zZm9ybUJ1ZiA9IFtdLFxuICAgICAgICAgIHBhZGRpbmdCdWYgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHRoaXMuX3RleHREaXZzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGNvbnN0IGRpdiA9IHRoaXMuX3RleHREaXZzW2ldO1xuXG4gICAgICBjb25zdCBkaXZQcm9wcyA9IHRoaXMuX3RleHREaXZQcm9wZXJ0aWVzLmdldChkaXYpO1xuXG4gICAgICBpZiAoIWRpdlByb3BzLmhhc1RleHQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChleHBhbmREaXZzKSB7XG4gICAgICAgIHRyYW5zZm9ybUJ1Zi5sZW5ndGggPSAwO1xuICAgICAgICBwYWRkaW5nQnVmLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgaWYgKGRpdlByb3BzLm9yaWdpbmFsVHJhbnNmb3JtKSB7XG4gICAgICAgICAgdHJhbnNmb3JtQnVmLnB1c2goZGl2UHJvcHMub3JpZ2luYWxUcmFuc2Zvcm0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpdlByb3BzLnBhZGRpbmdUb3AgPiAwKSB7XG4gICAgICAgICAgcGFkZGluZ0J1Zi5wdXNoKGAke2RpdlByb3BzLnBhZGRpbmdUb3B9cHhgKTtcbiAgICAgICAgICB0cmFuc2Zvcm1CdWYucHVzaChgdHJhbnNsYXRlWSgkey1kaXZQcm9wcy5wYWRkaW5nVG9wfXB4KWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhZGRpbmdCdWYucHVzaCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXZQcm9wcy5wYWRkaW5nUmlnaHQgPiAwKSB7XG4gICAgICAgICAgcGFkZGluZ0J1Zi5wdXNoKGAke2RpdlByb3BzLnBhZGRpbmdSaWdodCAvIGRpdlByb3BzLnNjYWxlfXB4YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkZGluZ0J1Zi5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRpdlByb3BzLnBhZGRpbmdCb3R0b20gPiAwKSB7XG4gICAgICAgICAgcGFkZGluZ0J1Zi5wdXNoKGAke2RpdlByb3BzLnBhZGRpbmdCb3R0b219cHhgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWRkaW5nQnVmLnB1c2goMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGl2UHJvcHMucGFkZGluZ0xlZnQgPiAwKSB7XG4gICAgICAgICAgcGFkZGluZ0J1Zi5wdXNoKGAke2RpdlByb3BzLnBhZGRpbmdMZWZ0IC8gZGl2UHJvcHMuc2NhbGV9cHhgKTtcbiAgICAgICAgICB0cmFuc2Zvcm1CdWYucHVzaChgdHJhbnNsYXRlWCgkey1kaXZQcm9wcy5wYWRkaW5nTGVmdCAvIGRpdlByb3BzLnNjYWxlfXB4KWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhZGRpbmdCdWYucHVzaCgwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpdi5zdHlsZS5wYWRkaW5nID0gcGFkZGluZ0J1Zi5qb2luKFwiIFwiKTtcblxuICAgICAgICBpZiAodHJhbnNmb3JtQnVmLmxlbmd0aCkge1xuICAgICAgICAgIGRpdi5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1CdWYuam9pbihcIiBcIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpdi5zdHlsZS5wYWRkaW5nID0gbnVsbDtcbiAgICAgICAgZGl2LnN0eWxlLnRyYW5zZm9ybSA9IGRpdlByb3BzLm9yaWdpbmFsVHJhbnNmb3JtO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydHMuVGV4dExheWVyUmVuZGVyVGFzayA9IFRleHRMYXllclJlbmRlclRhc2s7XG5cbmZ1bmN0aW9uIHJlbmRlclRleHRMYXllcihyZW5kZXJQYXJhbWV0ZXJzKSB7XG4gIGNvbnN0IHRhc2sgPSBuZXcgVGV4dExheWVyUmVuZGVyVGFzayh7XG4gICAgdGV4dENvbnRlbnQ6IHJlbmRlclBhcmFtZXRlcnMudGV4dENvbnRlbnQsXG4gICAgdGV4dENvbnRlbnRTdHJlYW06IHJlbmRlclBhcmFtZXRlcnMudGV4dENvbnRlbnRTdHJlYW0sXG4gICAgY29udGFpbmVyOiByZW5kZXJQYXJhbWV0ZXJzLmNvbnRhaW5lcixcbiAgICB2aWV3cG9ydDogcmVuZGVyUGFyYW1ldGVycy52aWV3cG9ydCxcbiAgICB0ZXh0RGl2czogcmVuZGVyUGFyYW1ldGVycy50ZXh0RGl2cyxcbiAgICB0ZXh0Q29udGVudEl0ZW1zU3RyOiByZW5kZXJQYXJhbWV0ZXJzLnRleHRDb250ZW50SXRlbXNTdHIsXG4gICAgZW5oYW5jZVRleHRTZWxlY3Rpb246IHJlbmRlclBhcmFtZXRlcnMuZW5oYW5jZVRleHRTZWxlY3Rpb25cbiAgfSk7XG5cbiAgdGFzay5fcmVuZGVyKHJlbmRlclBhcmFtZXRlcnMudGltZW91dCk7XG5cbiAgcmV0dXJuIHRhc2s7XG59XG5cbi8qKiovIH0pLFxuLyogMzEgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuU1ZHR3JhcGhpY3MgPSB2b2lkIDA7XG5cbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oOCk7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5cbnZhciBfaXNfbm9kZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMyk7XG5cbmxldCBTVkdHcmFwaGljcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIk5vdCBpbXBsZW1lbnRlZDogU1ZHR3JhcGhpY3NcIik7XG4gIH1cblxufTtcbmV4cG9ydHMuU1ZHR3JhcGhpY3MgPSBTVkdHcmFwaGljcztcbntcbiAgY29uc3QgU1ZHX0RFRkFVTFRTID0ge1xuICAgIGZvbnRTdHlsZTogXCJub3JtYWxcIixcbiAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxuICAgIGZpbGxDb2xvcjogXCIjMDAwMDAwXCJcbiAgfTtcbiAgY29uc3QgWE1MX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIjtcbiAgY29uc3QgWExJTktfTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIjtcbiAgY29uc3QgTElORV9DQVBfU1RZTEVTID0gW1wiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCJdO1xuICBjb25zdCBMSU5FX0pPSU5fU1RZTEVTID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuXG4gIGNvbnN0IGNyZWF0ZU9iamVjdFVSTCA9IGZ1bmN0aW9uIChkYXRhLCBjb250ZW50VHlwZSA9IFwiXCIsIGZvcmNlRGF0YVNjaGVtYSA9IGZhbHNlKSB7XG4gICAgaWYgKFVSTC5jcmVhdGVPYmplY3RVUkwgJiYgdHlwZW9mIEJsb2IgIT09IFwidW5kZWZpbmVkXCIgJiYgIWZvcmNlRGF0YVNjaGVtYSkge1xuICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2RhdGFdLCB7XG4gICAgICAgIHR5cGU6IGNvbnRlbnRUeXBlXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgY29uc3QgZGlnaXRzID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPVwiO1xuICAgIGxldCBidWZmZXIgPSBgZGF0YToke2NvbnRlbnRUeXBlfTtiYXNlNjQsYDtcblxuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGRhdGEubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgICAgY29uc3QgYjEgPSBkYXRhW2ldICYgMHhmZjtcbiAgICAgIGNvbnN0IGIyID0gZGF0YVtpICsgMV0gJiAweGZmO1xuICAgICAgY29uc3QgYjMgPSBkYXRhW2kgKyAyXSAmIDB4ZmY7XG4gICAgICBjb25zdCBkMSA9IGIxID4+IDIsXG4gICAgICAgICAgICBkMiA9IChiMSAmIDMpIDw8IDQgfCBiMiA+PiA0O1xuICAgICAgY29uc3QgZDMgPSBpICsgMSA8IGlpID8gKGIyICYgMHhmKSA8PCAyIHwgYjMgPj4gNiA6IDY0O1xuICAgICAgY29uc3QgZDQgPSBpICsgMiA8IGlpID8gYjMgJiAweDNmIDogNjQ7XG4gICAgICBidWZmZXIgKz0gZGlnaXRzW2QxXSArIGRpZ2l0c1tkMl0gKyBkaWdpdHNbZDNdICsgZGlnaXRzW2Q0XTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIGNvbnN0IGNvbnZlcnRJbWdEYXRhVG9QbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgUE5HX0hFQURFUiA9IG5ldyBVaW50OEFycmF5KFsweDg5LCAweDUwLCAweDRlLCAweDQ3LCAweDBkLCAweDBhLCAweDFhLCAweDBhXSk7XG4gICAgY29uc3QgQ0hVTktfV1JBUFBFUl9TSVpFID0gMTI7XG4gICAgY29uc3QgY3JjVGFibGUgPSBuZXcgSW50MzJBcnJheSgyNTYpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgbGV0IGMgPSBpO1xuXG4gICAgICBmb3IgKGxldCBoID0gMDsgaCA8IDg7IGgrKykge1xuICAgICAgICBpZiAoYyAmIDEpIHtcbiAgICAgICAgICBjID0gMHhlZGI4ODMyMCBeIGMgPj4gMSAmIDB4N2ZmZmZmZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYyA9IGMgPj4gMSAmIDB4N2ZmZmZmZmY7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3JjVGFibGVbaV0gPSBjO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyYzMyKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIGxldCBjcmMgPSAtMTtcblxuICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IChjcmMgXiBkYXRhW2ldKSAmIDB4ZmY7XG4gICAgICAgIGNvbnN0IGIgPSBjcmNUYWJsZVthXTtcbiAgICAgICAgY3JjID0gY3JjID4+PiA4IF4gYjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyYyBeIC0xO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdyaXRlUG5nQ2h1bmsodHlwZSwgYm9keSwgZGF0YSwgb2Zmc2V0KSB7XG4gICAgICBsZXQgcCA9IG9mZnNldDtcbiAgICAgIGNvbnN0IGxlbiA9IGJvZHkubGVuZ3RoO1xuICAgICAgZGF0YVtwXSA9IGxlbiA+PiAyNCAmIDB4ZmY7XG4gICAgICBkYXRhW3AgKyAxXSA9IGxlbiA+PiAxNiAmIDB4ZmY7XG4gICAgICBkYXRhW3AgKyAyXSA9IGxlbiA+PiA4ICYgMHhmZjtcbiAgICAgIGRhdGFbcCArIDNdID0gbGVuICYgMHhmZjtcbiAgICAgIHAgKz0gNDtcbiAgICAgIGRhdGFbcF0gPSB0eXBlLmNoYXJDb2RlQXQoMCkgJiAweGZmO1xuICAgICAgZGF0YVtwICsgMV0gPSB0eXBlLmNoYXJDb2RlQXQoMSkgJiAweGZmO1xuICAgICAgZGF0YVtwICsgMl0gPSB0eXBlLmNoYXJDb2RlQXQoMikgJiAweGZmO1xuICAgICAgZGF0YVtwICsgM10gPSB0eXBlLmNoYXJDb2RlQXQoMykgJiAweGZmO1xuICAgICAgcCArPSA0O1xuICAgICAgZGF0YS5zZXQoYm9keSwgcCk7XG4gICAgICBwICs9IGJvZHkubGVuZ3RoO1xuICAgICAgY29uc3QgY3JjID0gY3JjMzIoZGF0YSwgb2Zmc2V0ICsgNCwgcCk7XG4gICAgICBkYXRhW3BdID0gY3JjID4+IDI0ICYgMHhmZjtcbiAgICAgIGRhdGFbcCArIDFdID0gY3JjID4+IDE2ICYgMHhmZjtcbiAgICAgIGRhdGFbcCArIDJdID0gY3JjID4+IDggJiAweGZmO1xuICAgICAgZGF0YVtwICsgM10gPSBjcmMgJiAweGZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkbGVyMzIoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgbGV0IGEgPSAxO1xuICAgICAgbGV0IGIgPSAwO1xuXG4gICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgICBhID0gKGEgKyAoZGF0YVtpXSAmIDB4ZmYpKSAlIDY1NTIxO1xuICAgICAgICBiID0gKGIgKyBhKSAlIDY1NTIxO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYiA8PCAxNiB8IGE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVmbGF0ZVN5bmMobGl0ZXJhbHMpIHtcbiAgICAgIGlmICghX2lzX25vZGUuaXNOb2RlSlMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmxhdGVTeW5jVW5jb21wcmVzc2VkKGxpdGVyYWxzKTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGlucHV0O1xuXG4gICAgICAgIGlmIChwYXJzZUludChwcm9jZXNzLnZlcnNpb25zLm5vZGUpID49IDgpIHtcbiAgICAgICAgICBpbnB1dCA9IGxpdGVyYWxzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucHV0ID0gQnVmZmVyLmZyb20obGl0ZXJhbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gcmVxdWlyZShcInpsaWJcIikuZGVmbGF0ZVN5bmMoaW5wdXQsIHtcbiAgICAgICAgICBsZXZlbDogOVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IG91dHB1dCA6IG5ldyBVaW50OEFycmF5KG91dHB1dCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShcIk5vdCBjb21wcmVzc2luZyBQTkcgYmVjYXVzZSB6bGliLmRlZmxhdGVTeW5jIGlzIHVuYXZhaWxhYmxlOiBcIiArIGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmbGF0ZVN5bmNVbmNvbXByZXNzZWQobGl0ZXJhbHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmxhdGVTeW5jVW5jb21wcmVzc2VkKGxpdGVyYWxzKSB7XG4gICAgICBsZXQgbGVuID0gbGl0ZXJhbHMubGVuZ3RoO1xuICAgICAgY29uc3QgbWF4QmxvY2tMZW5ndGggPSAweGZmZmY7XG4gICAgICBjb25zdCBkZWZsYXRlQmxvY2tzID0gTWF0aC5jZWlsKGxlbiAvIG1heEJsb2NrTGVuZ3RoKTtcbiAgICAgIGNvbnN0IGlkYXQgPSBuZXcgVWludDhBcnJheSgyICsgbGVuICsgZGVmbGF0ZUJsb2NrcyAqIDUgKyA0KTtcbiAgICAgIGxldCBwaSA9IDA7XG4gICAgICBpZGF0W3BpKytdID0gMHg3ODtcbiAgICAgIGlkYXRbcGkrK10gPSAweDljO1xuICAgICAgbGV0IHBvcyA9IDA7XG5cbiAgICAgIHdoaWxlIChsZW4gPiBtYXhCbG9ja0xlbmd0aCkge1xuICAgICAgICBpZGF0W3BpKytdID0gMHgwMDtcbiAgICAgICAgaWRhdFtwaSsrXSA9IDB4ZmY7XG4gICAgICAgIGlkYXRbcGkrK10gPSAweGZmO1xuICAgICAgICBpZGF0W3BpKytdID0gMHgwMDtcbiAgICAgICAgaWRhdFtwaSsrXSA9IDB4MDA7XG4gICAgICAgIGlkYXQuc2V0KGxpdGVyYWxzLnN1YmFycmF5KHBvcywgcG9zICsgbWF4QmxvY2tMZW5ndGgpLCBwaSk7XG4gICAgICAgIHBpICs9IG1heEJsb2NrTGVuZ3RoO1xuICAgICAgICBwb3MgKz0gbWF4QmxvY2tMZW5ndGg7XG4gICAgICAgIGxlbiAtPSBtYXhCbG9ja0xlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWRhdFtwaSsrXSA9IDB4MDE7XG4gICAgICBpZGF0W3BpKytdID0gbGVuICYgMHhmZjtcbiAgICAgIGlkYXRbcGkrK10gPSBsZW4gPj4gOCAmIDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gfmxlbiAmIDB4ZmZmZiAmIDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gKH5sZW4gJiAweGZmZmYpID4+IDggJiAweGZmO1xuICAgICAgaWRhdC5zZXQobGl0ZXJhbHMuc3ViYXJyYXkocG9zKSwgcGkpO1xuICAgICAgcGkgKz0gbGl0ZXJhbHMubGVuZ3RoIC0gcG9zO1xuICAgICAgY29uc3QgYWRsZXIgPSBhZGxlcjMyKGxpdGVyYWxzLCAwLCBsaXRlcmFscy5sZW5ndGgpO1xuICAgICAgaWRhdFtwaSsrXSA9IGFkbGVyID4+IDI0ICYgMHhmZjtcbiAgICAgIGlkYXRbcGkrK10gPSBhZGxlciA+PiAxNiAmIDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gYWRsZXIgPj4gOCAmIDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gYWRsZXIgJiAweGZmO1xuICAgICAgcmV0dXJuIGlkYXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5jb2RlKGltZ0RhdGEsIGtpbmQsIGZvcmNlRGF0YVNjaGVtYSwgaXNNYXNrKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIGxldCBiaXREZXB0aCwgY29sb3JUeXBlLCBsaW5lU2l6ZTtcbiAgICAgIGNvbnN0IGJ5dGVzID0gaW1nRGF0YS5kYXRhO1xuXG4gICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgY2FzZSBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFA6XG4gICAgICAgICAgY29sb3JUeXBlID0gMDtcbiAgICAgICAgICBiaXREZXB0aCA9IDE7XG4gICAgICAgICAgbGluZVNpemUgPSB3aWR0aCArIDcgPj4gMztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIF91dGlsLkltYWdlS2luZC5SR0JfMjRCUFA6XG4gICAgICAgICAgY29sb3JUeXBlID0gMjtcbiAgICAgICAgICBiaXREZXB0aCA9IDg7XG4gICAgICAgICAgbGluZVNpemUgPSB3aWR0aCAqIDM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5JbWFnZUtpbmQuUkdCQV8zMkJQUDpcbiAgICAgICAgICBjb2xvclR5cGUgPSA2O1xuICAgICAgICAgIGJpdERlcHRoID0gODtcbiAgICAgICAgICBsaW5lU2l6ZSA9IHdpZHRoICogNDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0XCIpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsaXRlcmFscyA9IG5ldyBVaW50OEFycmF5KCgxICsgbGluZVNpemUpICogaGVpZ2h0KTtcbiAgICAgIGxldCBvZmZzZXRMaXRlcmFscyA9IDAsXG4gICAgICAgICAgb2Zmc2V0Qnl0ZXMgPSAwO1xuXG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICAgIGxpdGVyYWxzW29mZnNldExpdGVyYWxzKytdID0gMDtcbiAgICAgICAgbGl0ZXJhbHMuc2V0KGJ5dGVzLnN1YmFycmF5KG9mZnNldEJ5dGVzLCBvZmZzZXRCeXRlcyArIGxpbmVTaXplKSwgb2Zmc2V0TGl0ZXJhbHMpO1xuICAgICAgICBvZmZzZXRCeXRlcyArPSBsaW5lU2l6ZTtcbiAgICAgICAgb2Zmc2V0TGl0ZXJhbHMgKz0gbGluZVNpemU7XG4gICAgICB9XG5cbiAgICAgIGlmIChraW5kID09PSBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFAgJiYgaXNNYXNrKSB7XG4gICAgICAgIG9mZnNldExpdGVyYWxzID0gMDtcblxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgb2Zmc2V0TGl0ZXJhbHMrKztcblxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZVNpemU7IGkrKykge1xuICAgICAgICAgICAgbGl0ZXJhbHNbb2Zmc2V0TGl0ZXJhbHMrK10gXj0gMHhmZjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaWhkciA9IG5ldyBVaW50OEFycmF5KFt3aWR0aCA+PiAyNCAmIDB4ZmYsIHdpZHRoID4+IDE2ICYgMHhmZiwgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZiwgaGVpZ2h0ID4+IDI0ICYgMHhmZiwgaGVpZ2h0ID4+IDE2ICYgMHhmZiwgaGVpZ2h0ID4+IDggJiAweGZmLCBoZWlnaHQgJiAweGZmLCBiaXREZXB0aCwgY29sb3JUeXBlLCAweDAwLCAweDAwLCAweDAwXSk7XG4gICAgICBjb25zdCBpZGF0ID0gZGVmbGF0ZVN5bmMobGl0ZXJhbHMpO1xuICAgICAgY29uc3QgcG5nTGVuZ3RoID0gUE5HX0hFQURFUi5sZW5ndGggKyBDSFVOS19XUkFQUEVSX1NJWkUgKiAzICsgaWhkci5sZW5ndGggKyBpZGF0Lmxlbmd0aDtcbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShwbmdMZW5ndGgpO1xuICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICBkYXRhLnNldChQTkdfSEVBREVSLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IFBOR19IRUFERVIubGVuZ3RoO1xuICAgICAgd3JpdGVQbmdDaHVuayhcIklIRFJcIiwgaWhkciwgZGF0YSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBDSFVOS19XUkFQUEVSX1NJWkUgKyBpaGRyLmxlbmd0aDtcbiAgICAgIHdyaXRlUG5nQ2h1bmsoXCJJREFUQVwiLCBpZGF0LCBkYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IENIVU5LX1dSQVBQRVJfU0laRSArIGlkYXQubGVuZ3RoO1xuICAgICAgd3JpdGVQbmdDaHVuayhcIklFTkRcIiwgbmV3IFVpbnQ4QXJyYXkoMCksIGRhdGEsIG9mZnNldCk7XG4gICAgICByZXR1cm4gY3JlYXRlT2JqZWN0VVJMKGRhdGEsIFwiaW1hZ2UvcG5nXCIsIGZvcmNlRGF0YVNjaGVtYSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvbnZlcnRJbWdEYXRhVG9QbmcoaW1nRGF0YSwgZm9yY2VEYXRhU2NoZW1hLCBpc01hc2spIHtcbiAgICAgIGNvbnN0IGtpbmQgPSBpbWdEYXRhLmtpbmQgPT09IHVuZGVmaW5lZCA/IF91dGlsLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUCA6IGltZ0RhdGEua2luZDtcbiAgICAgIHJldHVybiBlbmNvZGUoaW1nRGF0YSwga2luZCwgZm9yY2VEYXRhU2NoZW1hLCBpc01hc2spO1xuICAgIH07XG4gIH0oKTtcblxuICBjbGFzcyBTVkdFeHRyYVN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuZm9udFNpemVTY2FsZSA9IDE7XG4gICAgICB0aGlzLmZvbnRXZWlnaHQgPSBTVkdfREVGQVVMVFMuZm9udFdlaWdodDtcbiAgICAgIHRoaXMuZm9udFNpemUgPSAwO1xuICAgICAgdGhpcy50ZXh0TWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgICAgdGhpcy5mb250TWF0cml4ID0gX3V0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgICB0aGlzLmxlYWRpbmcgPSAwO1xuICAgICAgdGhpcy50ZXh0UmVuZGVyaW5nTW9kZSA9IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEw7XG4gICAgICB0aGlzLnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgICB0aGlzLnggPSAwO1xuICAgICAgdGhpcy55ID0gMDtcbiAgICAgIHRoaXMubGluZVggPSAwO1xuICAgICAgdGhpcy5saW5lWSA9IDA7XG4gICAgICB0aGlzLmNoYXJTcGFjaW5nID0gMDtcbiAgICAgIHRoaXMud29yZFNwYWNpbmcgPSAwO1xuICAgICAgdGhpcy50ZXh0SFNjYWxlID0gMTtcbiAgICAgIHRoaXMudGV4dFJpc2UgPSAwO1xuICAgICAgdGhpcy5maWxsQ29sb3IgPSBTVkdfREVGQVVMVFMuZmlsbENvbG9yO1xuICAgICAgdGhpcy5zdHJva2VDb2xvciA9IFwiIzAwMDAwMFwiO1xuICAgICAgdGhpcy5maWxsQWxwaGEgPSAxO1xuICAgICAgdGhpcy5zdHJva2VBbHBoYSA9IDE7XG4gICAgICB0aGlzLmxpbmVXaWR0aCA9IDE7XG4gICAgICB0aGlzLmxpbmVKb2luID0gXCJcIjtcbiAgICAgIHRoaXMubGluZUNhcCA9IFwiXCI7XG4gICAgICB0aGlzLm1pdGVyTGltaXQgPSAwO1xuICAgICAgdGhpcy5kYXNoQXJyYXkgPSBbXTtcbiAgICAgIHRoaXMuZGFzaFBoYXNlID0gMDtcbiAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gW107XG4gICAgICB0aGlzLmFjdGl2ZUNsaXBVcmwgPSBudWxsO1xuICAgICAgdGhpcy5jbGlwR3JvdXAgPSBudWxsO1xuICAgICAgdGhpcy5tYXNrSWQgPSBcIlwiO1xuICAgIH1cblxuICAgIGNsb25lKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudFBvaW50KHgsIHkpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgIH1cblxuICB9XG5cbiAgZnVuY3Rpb24gb3BMaXN0VG9UcmVlKG9wTGlzdCkge1xuICAgIGxldCBvcFRyZWUgPSBbXTtcbiAgICBjb25zdCB0bXAgPSBbXTtcblxuICAgIGZvciAoY29uc3Qgb3BMaXN0RWxlbWVudCBvZiBvcExpc3QpIHtcbiAgICAgIGlmIChvcExpc3RFbGVtZW50LmZuID09PSBcInNhdmVcIikge1xuICAgICAgICBvcFRyZWUucHVzaCh7XG4gICAgICAgICAgZm5JZDogOTIsXG4gICAgICAgICAgZm46IFwiZ3JvdXBcIixcbiAgICAgICAgICBpdGVtczogW11cbiAgICAgICAgfSk7XG4gICAgICAgIHRtcC5wdXNoKG9wVHJlZSk7XG4gICAgICAgIG9wVHJlZSA9IG9wVHJlZS5hdCgtMSkuaXRlbXM7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAob3BMaXN0RWxlbWVudC5mbiA9PT0gXCJyZXN0b3JlXCIpIHtcbiAgICAgICAgb3BUcmVlID0gdG1wLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3BUcmVlLnB1c2gob3BMaXN0RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9wVHJlZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBmKHZhbHVlKSB7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICBjb25zdCBzID0gdmFsdWUudG9GaXhlZCgxMCk7XG4gICAgbGV0IGkgPSBzLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAoc1tpXSAhPT0gXCIwXCIpIHtcbiAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIGktLTtcbiAgICB9IHdoaWxlIChzW2ldID09PSBcIjBcIik7XG5cbiAgICByZXR1cm4gcy5zdWJzdHJpbmcoMCwgc1tpXSA9PT0gXCIuXCIgPyBpIDogaSArIDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG0obSkge1xuICAgIGlmIChtWzRdID09PSAwICYmIG1bNV0gPT09IDApIHtcbiAgICAgIGlmIChtWzFdID09PSAwICYmIG1bMl0gPT09IDApIHtcbiAgICAgICAgaWYgKG1bMF0gPT09IDEgJiYgbVszXSA9PT0gMSkge1xuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGBzY2FsZSgke3BmKG1bMF0pfSAke3BmKG1bM10pfSlgO1xuICAgICAgfVxuXG4gICAgICBpZiAobVswXSA9PT0gbVszXSAmJiBtWzFdID09PSAtbVsyXSkge1xuICAgICAgICBjb25zdCBhID0gTWF0aC5hY29zKG1bMF0pICogMTgwIC8gTWF0aC5QSTtcbiAgICAgICAgcmV0dXJuIGByb3RhdGUoJHtwZihhKX0pYDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG1bMF0gPT09IDEgJiYgbVsxXSA9PT0gMCAmJiBtWzJdID09PSAwICYmIG1bM10gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGB0cmFuc2xhdGUoJHtwZihtWzRdKX0gJHtwZihtWzVdKX0pYDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYG1hdHJpeCgke3BmKG1bMF0pfSAke3BmKG1bMV0pfSAke3BmKG1bMl0pfSAke3BmKG1bM10pfSAke3BmKG1bNF0pfSBgICsgYCR7cGYobVs1XSl9KWA7XG4gIH1cblxuICBsZXQgY2xpcENvdW50ID0gMDtcbiAgbGV0IG1hc2tDb3VudCA9IDA7XG4gIGxldCBzaGFkaW5nQ291bnQgPSAwO1xuICBleHBvcnRzLlNWR0dyYXBoaWNzID0gU1ZHR3JhcGhpY3MgPSBjbGFzcyB7XG4gICAgY29uc3RydWN0b3IoY29tbW9uT2Jqcywgb2JqcywgZm9yY2VEYXRhU2NoZW1hID0gZmFsc2UpIHtcbiAgICAgICgwLCBfZGlzcGxheV91dGlscy5kZXByZWNhdGVkKShcIlRoZSBTVkcgYmFjay1lbmQgaXMgbm8gbG9uZ2VyIG1haW50YWluZWQgYW5kICptYXkqIGJlIHJlbW92ZWQgaW4gdGhlIGZ1dHVyZS5cIik7XG4gICAgICB0aGlzLnN2Z0ZhY3RvcnkgPSBuZXcgX2Rpc3BsYXlfdXRpbHMuRE9NU1ZHRmFjdG9yeSgpO1xuICAgICAgdGhpcy5jdXJyZW50ID0gbmV3IFNWR0V4dHJhU3RhdGUoKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgICAgdGhpcy50cmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgICAgdGhpcy5leHRyYVN0YWNrID0gW107XG4gICAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gZmFsc2U7XG4gICAgICB0aGlzLmVtYmVkRm9udHMgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW1iZWRkZWRGb250cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLmNzc1N0eWxlID0gbnVsbDtcbiAgICAgIHRoaXMuZm9yY2VEYXRhU2NoZW1hID0gISFmb3JjZURhdGFTY2hlbWE7XG4gICAgICB0aGlzLl9vcGVyYXRvcklkTWFwcGluZyA9IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IG9wIGluIF91dGlsLk9QUykge1xuICAgICAgICB0aGlzLl9vcGVyYXRvcklkTWFwcGluZ1tfdXRpbC5PUFNbb3BdXSA9IG9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNhdmUoKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybVN0YWNrLnB1c2godGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgY29uc3Qgb2xkID0gdGhpcy5jdXJyZW50O1xuICAgICAgdGhpcy5leHRyYVN0YWNrLnB1c2gob2xkKTtcbiAgICAgIHRoaXMuY3VycmVudCA9IG9sZC5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJlc3RvcmUoKSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IHRoaXMudHJhbnNmb3JtU3RhY2sucG9wKCk7XG4gICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmV4dHJhU3RhY2sucG9wKCk7XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICAgIHRoaXMudGdycCA9IG51bGw7XG4gICAgfVxuXG4gICAgZ3JvdXAoaXRlbXMpIHtcbiAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgdGhpcy5leGVjdXRlT3BUcmVlKGl0ZW1zKTtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cblxuICAgIGxvYWREZXBlbmRlbmNpZXMob3BlcmF0b3JMaXN0KSB7XG4gICAgICBjb25zdCBmbkFycmF5ID0gb3BlcmF0b3JMaXN0LmZuQXJyYXk7XG4gICAgICBjb25zdCBhcmdzQXJyYXkgPSBvcGVyYXRvckxpc3QuYXJnc0FycmF5O1xuXG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmbkFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgaWYgKGZuQXJyYXlbaV0gIT09IF91dGlsLk9QUy5kZXBlbmRlbmN5KSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IG9iaiBvZiBhcmdzQXJyYXlbaV0pIHtcbiAgICAgICAgICBjb25zdCBvYmpzUG9vbCA9IG9iai5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMgOiB0aGlzLm9ianM7XG4gICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgb2Jqc1Bvb2wuZ2V0KG9iaiwgcmVzb2x2ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmRlcGVuZGVuY2llcy5wdXNoKHByb21pc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLmN1cnJlbnQuZGVwZW5kZW5jaWVzKTtcbiAgICB9XG5cbiAgICB0cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgY29uc3QgdHJhbnNmb3JtTWF0cml4ID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBfdXRpbC5VdGlsLnRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybU1hdHJpeCwgdHJhbnNmb3JtTWF0cml4KTtcbiAgICAgIHRoaXMudGdycCA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0U1ZHKG9wZXJhdG9yTGlzdCwgdmlld3BvcnQpIHtcbiAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcblxuICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IHRoaXMuX2luaXRpYWxpemUodmlld3BvcnQpO1xuXG4gICAgICByZXR1cm4gdGhpcy5sb2FkRGVwZW5kZW5jaWVzKG9wZXJhdG9yTGlzdCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgICAgICB0aGlzLmV4ZWN1dGVPcFRyZWUodGhpcy5jb252ZXJ0T3BMaXN0KG9wZXJhdG9yTGlzdCkpO1xuICAgICAgICByZXR1cm4gc3ZnRWxlbWVudDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnZlcnRPcExpc3Qob3BlcmF0b3JMaXN0KSB7XG4gICAgICBjb25zdCBvcGVyYXRvcklkTWFwcGluZyA9IHRoaXMuX29wZXJhdG9ySWRNYXBwaW5nO1xuICAgICAgY29uc3QgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcbiAgICAgIGNvbnN0IGZuQXJyYXkgPSBvcGVyYXRvckxpc3QuZm5BcnJheTtcbiAgICAgIGNvbnN0IG9wTGlzdCA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmbkFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgY29uc3QgZm5JZCA9IGZuQXJyYXlbaV07XG4gICAgICAgIG9wTGlzdC5wdXNoKHtcbiAgICAgICAgICBmbklkLFxuICAgICAgICAgIGZuOiBvcGVyYXRvcklkTWFwcGluZ1tmbklkXSxcbiAgICAgICAgICBhcmdzOiBhcmdzQXJyYXlbaV1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcExpc3RUb1RyZWUob3BMaXN0KTtcbiAgICB9XG5cbiAgICBleGVjdXRlT3BUcmVlKG9wVHJlZSkge1xuICAgICAgZm9yIChjb25zdCBvcFRyZWVFbGVtZW50IG9mIG9wVHJlZSkge1xuICAgICAgICBjb25zdCBmbiA9IG9wVHJlZUVsZW1lbnQuZm47XG4gICAgICAgIGNvbnN0IGZuSWQgPSBvcFRyZWVFbGVtZW50LmZuSWQ7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBvcFRyZWVFbGVtZW50LmFyZ3M7XG5cbiAgICAgICAgc3dpdGNoIChmbklkIHwgMCkge1xuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmJlZ2luVGV4dDpcbiAgICAgICAgICAgIHRoaXMuYmVnaW5UZXh0KCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmRlcGVuZGVuY3k6XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldExlYWRpbmc6XG4gICAgICAgICAgICB0aGlzLnNldExlYWRpbmcoYXJncyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldExlYWRpbmdNb3ZlVGV4dDpcbiAgICAgICAgICAgIHRoaXMuc2V0TGVhZGluZ01vdmVUZXh0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRGb250OlxuICAgICAgICAgICAgdGhpcy5zZXRGb250KGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zaG93VGV4dDpcbiAgICAgICAgICAgIHRoaXMuc2hvd1RleHQoYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNob3dTcGFjZWRUZXh0OlxuICAgICAgICAgICAgdGhpcy5zaG93VGV4dChhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW5kVGV4dDpcbiAgICAgICAgICAgIHRoaXMuZW5kVGV4dCgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5tb3ZlVGV4dDpcbiAgICAgICAgICAgIHRoaXMubW92ZVRleHQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldENoYXJTcGFjaW5nOlxuICAgICAgICAgICAgdGhpcy5zZXRDaGFyU3BhY2luZyhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0V29yZFNwYWNpbmc6XG4gICAgICAgICAgICB0aGlzLnNldFdvcmRTcGFjaW5nKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRIU2NhbGU6XG4gICAgICAgICAgICB0aGlzLnNldEhTY2FsZShhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0VGV4dE1hdHJpeDpcbiAgICAgICAgICAgIHRoaXMuc2V0VGV4dE1hdHJpeChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0VGV4dFJpc2U6XG4gICAgICAgICAgICB0aGlzLnNldFRleHRSaXNlKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRUZXh0UmVuZGVyaW5nTW9kZTpcbiAgICAgICAgICAgIHRoaXMuc2V0VGV4dFJlbmRlcmluZ01vZGUoYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldExpbmVXaWR0aDpcbiAgICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMaW5lSm9pbjpcbiAgICAgICAgICAgIHRoaXMuc2V0TGluZUpvaW4oYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldExpbmVDYXA6XG4gICAgICAgICAgICB0aGlzLnNldExpbmVDYXAoYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldE1pdGVyTGltaXQ6XG4gICAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQoYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEZpbGxSR0JDb2xvcjpcbiAgICAgICAgICAgIHRoaXMuc2V0RmlsbFJHQkNvbG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRTdHJva2VSR0JDb2xvcjpcbiAgICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlUkdCQ29sb3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFN0cm9rZUNvbG9yTjpcbiAgICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlQ29sb3JOKGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRGaWxsQ29sb3JOOlxuICAgICAgICAgICAgdGhpcy5zZXRGaWxsQ29sb3JOKGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zaGFkaW5nRmlsbDpcbiAgICAgICAgICAgIHRoaXMuc2hhZGluZ0ZpbGwoYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldERhc2g6XG4gICAgICAgICAgICB0aGlzLnNldERhc2goYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFJlbmRlcmluZ0ludGVudDpcbiAgICAgICAgICAgIHRoaXMuc2V0UmVuZGVyaW5nSW50ZW50KGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRGbGF0bmVzczpcbiAgICAgICAgICAgIHRoaXMuc2V0RmxhdG5lc3MoYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEdTdGF0ZTpcbiAgICAgICAgICAgIHRoaXMuc2V0R1N0YXRlKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5maWxsOlxuICAgICAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmVvRmlsbDpcbiAgICAgICAgICAgIHRoaXMuZW9GaWxsKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnN0cm9rZTpcbiAgICAgICAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmZpbGxTdHJva2U6XG4gICAgICAgICAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW9GaWxsU3Ryb2tlOlxuICAgICAgICAgICAgdGhpcy5lb0ZpbGxTdHJva2UoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xpcDpcbiAgICAgICAgICAgIHRoaXMuY2xpcChcIm5vbnplcm9cIik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmVvQ2xpcDpcbiAgICAgICAgICAgIHRoaXMuY2xpcChcImV2ZW5vZGRcIik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50U29saWRDb2xvckltYWdlTWFzazpcbiAgICAgICAgICAgIHRoaXMucGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50SW1hZ2VYT2JqZWN0OlxuICAgICAgICAgICAgdGhpcy5wYWludEltYWdlWE9iamVjdChhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3Q6XG4gICAgICAgICAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludEltYWdlTWFza1hPYmplY3Q6XG4gICAgICAgICAgICB0aGlzLnBhaW50SW1hZ2VNYXNrWE9iamVjdChhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRGb3JtWE9iamVjdEJlZ2luOlxuICAgICAgICAgICAgdGhpcy5wYWludEZvcm1YT2JqZWN0QmVnaW4oYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50Rm9ybVhPYmplY3RFbmQ6XG4gICAgICAgICAgICB0aGlzLnBhaW50Rm9ybVhPYmplY3RFbmQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VQYXRoOlxuICAgICAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VTdHJva2U6XG4gICAgICAgICAgICB0aGlzLmNsb3NlU3Ryb2tlKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlRmlsbFN0cm9rZTpcbiAgICAgICAgICAgIHRoaXMuY2xvc2VGaWxsU3Ryb2tlKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlRU9GaWxsU3Ryb2tlOlxuICAgICAgICAgICAgdGhpcy5jbG9zZUVPRmlsbFN0cm9rZSgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5uZXh0TGluZTpcbiAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMudHJhbnNmb3JtOlxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmNvbnN0cnVjdFBhdGg6XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdFBhdGgoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmVuZFBhdGg6XG4gICAgICAgICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA5MjpcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAob3BUcmVlRWxlbWVudC5pdGVtcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoYFVuaW1wbGVtZW50ZWQgb3BlcmF0b3IgJHtmbn1gKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0V29yZFNwYWNpbmcod29yZFNwYWNpbmcpIHtcbiAgICAgIHRoaXMuY3VycmVudC53b3JkU3BhY2luZyA9IHdvcmRTcGFjaW5nO1xuICAgIH1cblxuICAgIHNldENoYXJTcGFjaW5nKGNoYXJTcGFjaW5nKSB7XG4gICAgICB0aGlzLmN1cnJlbnQuY2hhclNwYWNpbmcgPSBjaGFyU3BhY2luZztcbiAgICB9XG5cbiAgICBuZXh0TGluZSgpIHtcbiAgICAgIHRoaXMubW92ZVRleHQoMCwgdGhpcy5jdXJyZW50LmxlYWRpbmcpO1xuICAgIH1cblxuICAgIHNldFRleHRNYXRyaXgoYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgIGN1cnJlbnQudGV4dE1hdHJpeCA9IGN1cnJlbnQubGluZU1hdHJpeCA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgICAgIGN1cnJlbnQueCA9IGN1cnJlbnQubGluZVggPSAwO1xuICAgICAgY3VycmVudC55ID0gY3VycmVudC5saW5lWSA9IDA7XG4gICAgICBjdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICAgIGN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICAgICAgY3VycmVudC50c3BhbiA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRzcGFuXCIpO1xuICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtZmFtaWx5XCIsIGN1cnJlbnQuZm9udEZhbWlseSk7XG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1zaXplXCIsIGAke3BmKGN1cnJlbnQuZm9udFNpemUpfXB4YCk7XG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtY3VycmVudC55KSk7XG4gICAgICBjdXJyZW50LnR4dEVsZW1lbnQgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0ZXh0XCIpO1xuICAgICAgY3VycmVudC50eHRFbGVtZW50LmFwcGVuZChjdXJyZW50LnRzcGFuKTtcbiAgICB9XG5cbiAgICBiZWdpblRleHQoKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgY3VycmVudC54ID0gY3VycmVudC5saW5lWCA9IDA7XG4gICAgICBjdXJyZW50LnkgPSBjdXJyZW50LmxpbmVZID0gMDtcbiAgICAgIGN1cnJlbnQudGV4dE1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICAgIGN1cnJlbnQubGluZU1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICAgIGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICAgIGN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICAgIGN1cnJlbnQudHh0RWxlbWVudCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRleHRcIik7XG4gICAgICBjdXJyZW50LnR4dGdycCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgICBjdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICAgIGN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICAgIH1cblxuICAgIG1vdmVUZXh0KHgsIHkpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICBjdXJyZW50LnggPSBjdXJyZW50LmxpbmVYICs9IHg7XG4gICAgICBjdXJyZW50LnkgPSBjdXJyZW50LmxpbmVZICs9IHk7XG4gICAgICBjdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICAgIGN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICAgICAgY3VycmVudC50c3BhbiA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRzcGFuXCIpO1xuICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtZmFtaWx5XCIsIGN1cnJlbnQuZm9udEZhbWlseSk7XG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1zaXplXCIsIGAke3BmKGN1cnJlbnQuZm9udFNpemUpfXB4YCk7XG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtY3VycmVudC55KSk7XG4gICAgfVxuXG4gICAgc2hvd1RleHQoZ2x5cGhzKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcblxuICAgICAgaWYgKGZvbnRTaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZm9udFNpemVTY2FsZSA9IGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICAgIGNvbnN0IGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICAgIGNvbnN0IHdvcmRTcGFjaW5nID0gY3VycmVudC53b3JkU3BhY2luZztcbiAgICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICAgIGNvbnN0IHZlcnRpY2FsID0gZm9udC52ZXJ0aWNhbDtcbiAgICAgIGNvbnN0IHNwYWNpbmdEaXIgPSB2ZXJ0aWNhbCA/IDEgOiAtMTtcbiAgICAgIGNvbnN0IGRlZmF1bHRWTWV0cmljcyA9IGZvbnQuZGVmYXVsdFZNZXRyaWNzO1xuICAgICAgY29uc3Qgd2lkdGhBZHZhbmNlU2NhbGUgPSBmb250U2l6ZSAqIGN1cnJlbnQuZm9udE1hdHJpeFswXTtcbiAgICAgIGxldCB4ID0gMDtcblxuICAgICAgZm9yIChjb25zdCBnbHlwaCBvZiBnbHlwaHMpIHtcbiAgICAgICAgaWYgKGdseXBoID09PSBudWxsKSB7XG4gICAgICAgICAgeCArPSBmb250RGlyZWN0aW9uICogd29yZFNwYWNpbmc7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGdseXBoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgeCArPSBzcGFjaW5nRGlyICogZ2x5cGggKiBmb250U2l6ZSAvIDEwMDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICAgIGNvbnN0IGNoYXJhY3RlciA9IGdseXBoLmZvbnRDaGFyO1xuICAgICAgICBsZXQgc2NhbGVkWCwgc2NhbGVkWTtcbiAgICAgICAgbGV0IHdpZHRoID0gZ2x5cGgud2lkdGg7XG5cbiAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgbGV0IHZ4O1xuICAgICAgICAgIGNvbnN0IHZtZXRyaWMgPSBnbHlwaC52bWV0cmljIHx8IGRlZmF1bHRWTWV0cmljcztcbiAgICAgICAgICB2eCA9IGdseXBoLnZtZXRyaWMgPyB2bWV0cmljWzFdIDogd2lkdGggKiAwLjU7XG4gICAgICAgICAgdnggPSAtdnggKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgICBjb25zdCB2eSA9IHZtZXRyaWNbMl0gKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgICB3aWR0aCA9IHZtZXRyaWMgPyAtdm1ldHJpY1swXSA6IHdpZHRoO1xuICAgICAgICAgIHNjYWxlZFggPSB2eCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgc2NhbGVkWSA9ICh4ICsgdnkpIC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2FsZWRYID0geCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgc2NhbGVkWSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ2x5cGguaXNJbkZvbnQgfHwgZm9udC5taXNzaW5nRmlsZSkge1xuICAgICAgICAgIGN1cnJlbnQueGNvb3Jkcy5wdXNoKGN1cnJlbnQueCArIHNjYWxlZFgpO1xuXG4gICAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgICBjdXJyZW50Lnljb29yZHMucHVzaCgtY3VycmVudC55ICsgc2NhbGVkWSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VycmVudC50c3Bhbi50ZXh0Q29udGVudCArPSBjaGFyYWN0ZXI7XG4gICAgICAgIH0gZWxzZSB7fVxuXG4gICAgICAgIGxldCBjaGFyV2lkdGg7XG5cbiAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgY2hhcldpZHRoID0gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSAtIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNoYXJXaWR0aCA9IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgKyBzcGFjaW5nICogZm9udERpcmVjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHggKz0gY2hhcldpZHRoO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBjdXJyZW50Lnhjb29yZHMubWFwKHBmKS5qb2luKFwiIFwiKSk7XG5cbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBjdXJyZW50Lnljb29yZHMubWFwKHBmKS5qb2luKFwiIFwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtY3VycmVudC55KSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBjdXJyZW50LnkgLT0geDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQueCArPSB4ICogdGV4dEhTY2FsZTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtZmFtaWx5XCIsIGN1cnJlbnQuZm9udEZhbWlseSk7XG4gICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1zaXplXCIsIGAke3BmKGN1cnJlbnQuZm9udFNpemUpfXB4YCk7XG5cbiAgICAgIGlmIChjdXJyZW50LmZvbnRTdHlsZSAhPT0gU1ZHX0RFRkFVTFRTLmZvbnRTdHlsZSkge1xuICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1zdHlsZVwiLCBjdXJyZW50LmZvbnRTdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdXJyZW50LmZvbnRXZWlnaHQgIT09IFNWR19ERUZBVUxUUy5mb250V2VpZ2h0KSB7XG4gICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXdlaWdodFwiLCBjdXJyZW50LmZvbnRXZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgJiBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuXG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGlmIChjdXJyZW50LmZpbGxDb2xvciAhPT0gU1ZHX0RFRkFVTFRTLmZpbGxDb2xvcikge1xuICAgICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIGN1cnJlbnQuZmlsbENvbG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50LmZpbGxBbHBoYSA8IDEpIHtcbiAgICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1vcGFjaXR5XCIsIGN1cnJlbnQuZmlsbEFscGhhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5BRERfVE9fUEFUSCkge1xuICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY29uc3QgbGluZVdpZHRoU2NhbGUgPSAxIC8gKGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlIHx8IDEpO1xuXG4gICAgICAgIHRoaXMuX3NldFN0cm9rZUF0dHJpYnV0ZXMoY3VycmVudC50c3BhbiwgbGluZVdpZHRoU2NhbGUpO1xuICAgICAgfVxuXG4gICAgICBsZXQgdGV4dE1hdHJpeCA9IGN1cnJlbnQudGV4dE1hdHJpeDtcblxuICAgICAgaWYgKGN1cnJlbnQudGV4dFJpc2UgIT09IDApIHtcbiAgICAgICAgdGV4dE1hdHJpeCA9IHRleHRNYXRyaXguc2xpY2UoKTtcbiAgICAgICAgdGV4dE1hdHJpeFs1XSArPSBjdXJyZW50LnRleHRSaXNlO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50LnR4dEVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0cmFuc2Zvcm1cIiwgYCR7cG0odGV4dE1hdHJpeCl9IHNjYWxlKCR7cGYodGV4dEhTY2FsZSl9LCAtMSlgKTtcbiAgICAgIGN1cnJlbnQudHh0RWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhYTUxfTlMsIFwieG1sOnNwYWNlXCIsIFwicHJlc2VydmVcIik7XG4gICAgICBjdXJyZW50LnR4dEVsZW1lbnQuYXBwZW5kKGN1cnJlbnQudHNwYW4pO1xuICAgICAgY3VycmVudC50eHRncnAuYXBwZW5kKGN1cnJlbnQudHh0RWxlbWVudCk7XG5cbiAgICAgIHRoaXMuX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkuYXBwZW5kKGN1cnJlbnQudHh0RWxlbWVudCk7XG4gICAgfVxuXG4gICAgc2V0TGVhZGluZ01vdmVUZXh0KHgsIHkpIHtcbiAgICAgIHRoaXMuc2V0TGVhZGluZygteSk7XG4gICAgICB0aGlzLm1vdmVUZXh0KHgsIHkpO1xuICAgIH1cblxuICAgIGFkZEZvbnRTdHlsZShmb250T2JqKSB7XG4gICAgICBpZiAoIWZvbnRPYmouZGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRGb250U3R5bGU6IE5vIGZvbnQgZGF0YSBhdmFpbGFibGUsIFwiICsgJ2Vuc3VyZSB0aGF0IHRoZSBcImZvbnRFeHRyYVByb3BlcnRpZXNcIiBBUEkgcGFyYW1ldGVyIGlzIHNldC4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmNzc1N0eWxlKSB7XG4gICAgICAgIHRoaXMuY3NzU3R5bGUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpzdHlsZVwiKTtcbiAgICAgICAgdGhpcy5jc3NTdHlsZS5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInR5cGVcIiwgXCJ0ZXh0L2Nzc1wiKTtcbiAgICAgICAgdGhpcy5kZWZzLmFwcGVuZCh0aGlzLmNzc1N0eWxlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXJsID0gY3JlYXRlT2JqZWN0VVJMKGZvbnRPYmouZGF0YSwgZm9udE9iai5taW1ldHlwZSwgdGhpcy5mb3JjZURhdGFTY2hlbWEpO1xuICAgICAgdGhpcy5jc3NTdHlsZS50ZXh0Q29udGVudCArPSBgQGZvbnQtZmFjZSB7IGZvbnQtZmFtaWx5OiBcIiR7Zm9udE9iai5sb2FkZWROYW1lfVwiO2AgKyBgIHNyYzogdXJsKCR7dXJsfSk7IH1cXG5gO1xuICAgIH1cblxuICAgIHNldEZvbnQoZGV0YWlscykge1xuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgIGNvbnN0IGZvbnRPYmogPSB0aGlzLmNvbW1vbk9ianMuZ2V0KGRldGFpbHNbMF0pO1xuICAgICAgbGV0IHNpemUgPSBkZXRhaWxzWzFdO1xuICAgICAgY3VycmVudC5mb250ID0gZm9udE9iajtcblxuICAgICAgaWYgKHRoaXMuZW1iZWRGb250cyAmJiAhZm9udE9iai5taXNzaW5nRmlsZSAmJiAhdGhpcy5lbWJlZGRlZEZvbnRzW2ZvbnRPYmoubG9hZGVkTmFtZV0pIHtcbiAgICAgICAgdGhpcy5hZGRGb250U3R5bGUoZm9udE9iaik7XG4gICAgICAgIHRoaXMuZW1iZWRkZWRGb250c1tmb250T2JqLmxvYWRlZE5hbWVdID0gZm9udE9iajtcbiAgICAgIH1cblxuICAgICAgY3VycmVudC5mb250TWF0cml4ID0gZm9udE9iai5mb250TWF0cml4IHx8IF91dGlsLkZPTlRfSURFTlRJVFlfTUFUUklYO1xuICAgICAgbGV0IGJvbGQgPSBcIm5vcm1hbFwiO1xuXG4gICAgICBpZiAoZm9udE9iai5ibGFjaykge1xuICAgICAgICBib2xkID0gXCI5MDBcIjtcbiAgICAgIH0gZWxzZSBpZiAoZm9udE9iai5ib2xkKSB7XG4gICAgICAgIGJvbGQgPSBcImJvbGRcIjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXRhbGljID0gZm9udE9iai5pdGFsaWMgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIjtcblxuICAgICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICAgIHNpemUgPSAtc2l6ZTtcbiAgICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAxO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50LmZvbnRTaXplID0gc2l6ZTtcbiAgICAgIGN1cnJlbnQuZm9udEZhbWlseSA9IGZvbnRPYmoubG9hZGVkTmFtZTtcbiAgICAgIGN1cnJlbnQuZm9udFdlaWdodCA9IGJvbGQ7XG4gICAgICBjdXJyZW50LmZvbnRTdHlsZSA9IGl0YWxpYztcbiAgICAgIGN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHBmKC1jdXJyZW50LnkpKTtcbiAgICAgIGN1cnJlbnQueGNvb3JkcyA9IFtdO1xuICAgICAgY3VycmVudC55Y29vcmRzID0gW107XG4gICAgfVxuXG4gICAgZW5kVGV4dCgpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEhfRkxBRyAmJiBjdXJyZW50LnR4dEVsZW1lbnQ/Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICBjdXJyZW50LmVsZW1lbnQgPSBjdXJyZW50LnR4dEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY2xpcChcIm5vbnplcm9cIik7XG4gICAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldExpbmVXaWR0aCh3aWR0aCkge1xuICAgICAgaWYgKHdpZHRoID4gMCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQubGluZVdpZHRoID0gd2lkdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0TGluZUNhcChzdHlsZSkge1xuICAgICAgdGhpcy5jdXJyZW50LmxpbmVDYXAgPSBMSU5FX0NBUF9TVFlMRVNbc3R5bGVdO1xuICAgIH1cblxuICAgIHNldExpbmVKb2luKHN0eWxlKSB7XG4gICAgICB0aGlzLmN1cnJlbnQubGluZUpvaW4gPSBMSU5FX0pPSU5fU1RZTEVTW3N0eWxlXTtcbiAgICB9XG5cbiAgICBzZXRNaXRlckxpbWl0KGxpbWl0KSB7XG4gICAgICB0aGlzLmN1cnJlbnQubWl0ZXJMaW1pdCA9IGxpbWl0O1xuICAgIH1cblxuICAgIHNldFN0cm9rZUFscGhhKHN0cm9rZUFscGhhKSB7XG4gICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGEgPSBzdHJva2VBbHBoYTtcbiAgICB9XG5cbiAgICBzZXRTdHJva2VSR0JDb2xvcihyLCBnLCBiKSB7XG4gICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgICB9XG5cbiAgICBzZXRGaWxsQWxwaGEoZmlsbEFscGhhKSB7XG4gICAgICB0aGlzLmN1cnJlbnQuZmlsbEFscGhhID0gZmlsbEFscGhhO1xuICAgIH1cblxuICAgIHNldEZpbGxSR0JDb2xvcihyLCBnLCBiKSB7XG4gICAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IociwgZywgYik7XG4gICAgICB0aGlzLmN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICAgIHRoaXMuY3VycmVudC54Y29vcmRzID0gW107XG4gICAgICB0aGlzLmN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICAgIH1cblxuICAgIHNldFN0cm9rZUNvbG9yTihhcmdzKSB7XG4gICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSB0aGlzLl9tYWtlQ29sb3JOX1BhdHRlcm4oYXJncyk7XG4gICAgfVxuXG4gICAgc2V0RmlsbENvbG9yTihhcmdzKSB7XG4gICAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gdGhpcy5fbWFrZUNvbG9yTl9QYXR0ZXJuKGFyZ3MpO1xuICAgIH1cblxuICAgIHNoYWRpbmdGaWxsKGFyZ3MpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy52aWV3cG9ydC53aWR0aDtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMudmlld3BvcnQuaGVpZ2h0O1xuXG4gICAgICBjb25zdCBpbnYgPSBfdXRpbC5VdGlsLmludmVyc2VUcmFuc2Zvcm0odGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuXG4gICAgICBjb25zdCBibCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oWzAsIDBdLCBpbnYpO1xuXG4gICAgICBjb25zdCBiciA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oWzAsIGhlaWdodF0sIGludik7XG5cbiAgICAgIGNvbnN0IHVsID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbd2lkdGgsIDBdLCBpbnYpO1xuXG4gICAgICBjb25zdCB1ciA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3dpZHRoLCBoZWlnaHRdLCBpbnYpO1xuXG4gICAgICBjb25zdCB4MCA9IE1hdGgubWluKGJsWzBdLCBiclswXSwgdWxbMF0sIHVyWzBdKTtcbiAgICAgIGNvbnN0IHkwID0gTWF0aC5taW4oYmxbMV0sIGJyWzFdLCB1bFsxXSwgdXJbMV0pO1xuICAgICAgY29uc3QgeDEgPSBNYXRoLm1heChibFswXSwgYnJbMF0sIHVsWzBdLCB1clswXSk7XG4gICAgICBjb25zdCB5MSA9IE1hdGgubWF4KGJsWzFdLCBiclsxXSwgdWxbMV0sIHVyWzFdKTtcbiAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgeDApO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgeTApO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHgxIC0geDApO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCB5MSAtIHkwKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIHRoaXMuX21ha2VTaGFkaW5nUGF0dGVybihhcmdzKSk7XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnQuZmlsbEFscGhhIDwgMSkge1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1vcGFjaXR5XCIsIHRoaXMuY3VycmVudC5maWxsQWxwaGEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChyZWN0KTtcbiAgICB9XG5cbiAgICBfbWFrZUNvbG9yTl9QYXR0ZXJuKGFyZ3MpIHtcbiAgICAgIGlmIChhcmdzWzBdID09PSBcIlRpbGluZ1BhdHRlcm5cIikge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFrZVRpbGluZ1BhdHRlcm4oYXJncyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9tYWtlU2hhZGluZ1BhdHRlcm4oYXJncyk7XG4gICAgfVxuXG4gICAgX21ha2VUaWxpbmdQYXR0ZXJuKGFyZ3MpIHtcbiAgICAgIGNvbnN0IGNvbG9yID0gYXJnc1sxXTtcbiAgICAgIGNvbnN0IG9wZXJhdG9yTGlzdCA9IGFyZ3NbMl07XG4gICAgICBjb25zdCBtYXRyaXggPSBhcmdzWzNdIHx8IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSBhcmdzWzRdO1xuICAgICAgY29uc3QgeHN0ZXAgPSBhcmdzWzVdO1xuICAgICAgY29uc3QgeXN0ZXAgPSBhcmdzWzZdO1xuICAgICAgY29uc3QgcGFpbnRUeXBlID0gYXJnc1s3XTtcbiAgICAgIGNvbnN0IHRpbGluZ0lkID0gYHNoYWRpbmcke3NoYWRpbmdDb3VudCsrfWA7XG5cbiAgICAgIGNvbnN0IFt0eDAsIHR5MCwgdHgxLCB0eTFdID0gX3V0aWwuVXRpbC5ub3JtYWxpemVSZWN0KFsuLi5fdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt4MCwgeTBdLCBtYXRyaXgpLCAuLi5fdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt4MSwgeTFdLCBtYXRyaXgpXSk7XG5cbiAgICAgIGNvbnN0IFt4c2NhbGUsIHlzY2FsZV0gPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG1hdHJpeCk7XG5cbiAgICAgIGNvbnN0IHR4c3RlcCA9IHhzdGVwICogeHNjYWxlO1xuICAgICAgY29uc3QgdHlzdGVwID0geXN0ZXAgKiB5c2NhbGU7XG4gICAgICBjb25zdCB0aWxpbmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpwYXR0ZXJuXCIpO1xuICAgICAgdGlsaW5nLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaWRcIiwgdGlsaW5nSWQpO1xuICAgICAgdGlsaW5nLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwicGF0dGVyblVuaXRzXCIsIFwidXNlclNwYWNlT25Vc2VcIik7XG4gICAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCB0eHN0ZXApO1xuICAgICAgdGlsaW5nLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHR5c3RlcCk7XG4gICAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIGAke3R4MH1gKTtcbiAgICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgYCR7dHkwfWApO1xuICAgICAgY29uc3Qgc3ZnID0gdGhpcy5zdmc7XG4gICAgICBjb25zdCB0cmFuc2Zvcm1NYXRyaXggPSB0aGlzLnRyYW5zZm9ybU1hdHJpeDtcbiAgICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgICBjb25zdCBzdHJva2VDb2xvciA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvcjtcbiAgICAgIGNvbnN0IGJib3ggPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHR4MSAtIHR4MCwgdHkxIC0gdHkwKTtcbiAgICAgIHRoaXMuc3ZnID0gYmJveDtcbiAgICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gbWF0cml4O1xuXG4gICAgICBpZiAocGFpbnRUeXBlID09PSAyKSB7XG4gICAgICAgIGNvbnN0IGNzc0NvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4uY29sb3IpO1xuXG4gICAgICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gY3NzQ29sb3I7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXhlY3V0ZU9wVHJlZSh0aGlzLmNvbnZlcnRPcExpc3Qob3BlcmF0b3JMaXN0KSk7XG4gICAgICB0aGlzLnN2ZyA9IHN2ZztcbiAgICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gdHJhbnNmb3JtTWF0cml4O1xuICAgICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IGZpbGxDb2xvcjtcbiAgICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IHN0cm9rZUNvbG9yO1xuICAgICAgdGlsaW5nLmFwcGVuZChiYm94LmNoaWxkTm9kZXNbMF0pO1xuICAgICAgdGhpcy5kZWZzLmFwcGVuZCh0aWxpbmcpO1xuICAgICAgcmV0dXJuIGB1cmwoIyR7dGlsaW5nSWR9KWA7XG4gICAgfVxuXG4gICAgX21ha2VTaGFkaW5nUGF0dGVybihhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgYXJncyA9IHRoaXMub2Jqcy5nZXQoYXJncyk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoYXJnc1swXSkge1xuICAgICAgICBjYXNlIFwiUmFkaWFsQXhpYWxcIjpcbiAgICAgICAgICBjb25zdCBzaGFkaW5nSWQgPSBgc2hhZGluZyR7c2hhZGluZ0NvdW50Kyt9YDtcbiAgICAgICAgICBjb25zdCBjb2xvclN0b3BzID0gYXJnc1szXTtcbiAgICAgICAgICBsZXQgZ3JhZGllbnQ7XG5cbiAgICAgICAgICBzd2l0Y2ggKGFyZ3NbMV0pIHtcbiAgICAgICAgICAgIGNhc2UgXCJheGlhbFwiOlxuICAgICAgICAgICAgICBjb25zdCBwb2ludDAgPSBhcmdzWzRdO1xuICAgICAgICAgICAgICBjb25zdCBwb2ludDEgPSBhcmdzWzVdO1xuICAgICAgICAgICAgICBncmFkaWVudCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmxpbmVhckdyYWRpZW50XCIpO1xuICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIHNoYWRpbmdJZCk7XG4gICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZ3JhZGllbnRVbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpO1xuICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIngxXCIsIHBvaW50MFswXSk7XG4gICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieTFcIiwgcG9pbnQwWzFdKTtcbiAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4MlwiLCBwb2ludDFbMF0pO1xuICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInkyXCIsIHBvaW50MVsxXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIFwicmFkaWFsXCI6XG4gICAgICAgICAgICAgIGNvbnN0IGZvY2FsUG9pbnQgPSBhcmdzWzRdO1xuICAgICAgICAgICAgICBjb25zdCBjaXJjbGVQb2ludCA9IGFyZ3NbNV07XG4gICAgICAgICAgICAgIGNvbnN0IGZvY2FsUmFkaXVzID0gYXJnc1s2XTtcbiAgICAgICAgICAgICAgY29uc3QgY2lyY2xlUmFkaXVzID0gYXJnc1s3XTtcbiAgICAgICAgICAgICAgZ3JhZGllbnQgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyYWRpYWxHcmFkaWVudFwiKTtcbiAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCBzaGFkaW5nSWQpO1xuICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImdyYWRpZW50VW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKTtcbiAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjeFwiLCBjaXJjbGVQb2ludFswXSk7XG4gICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3lcIiwgY2lyY2xlUG9pbnRbMV0pO1xuICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInJcIiwgY2lyY2xlUmFkaXVzKTtcbiAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmeFwiLCBmb2NhbFBvaW50WzBdKTtcbiAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmeVwiLCBmb2NhbFBvaW50WzFdKTtcbiAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmclwiLCBmb2NhbFJhZGl1cyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gUmFkaWFsQXhpYWwgdHlwZTogJHthcmdzWzFdfWApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoY29uc3QgY29sb3JTdG9wIG9mIGNvbG9yU3RvcHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3AgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpzdG9wXCIpO1xuICAgICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIm9mZnNldFwiLCBjb2xvclN0b3BbMF0pO1xuICAgICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0b3AtY29sb3JcIiwgY29sb3JTdG9wWzFdKTtcbiAgICAgICAgICAgIGdyYWRpZW50LmFwcGVuZChzdG9wKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmRlZnMuYXBwZW5kKGdyYWRpZW50KTtcbiAgICAgICAgICByZXR1cm4gYHVybCgjJHtzaGFkaW5nSWR9KWA7XG5cbiAgICAgICAgY2FzZSBcIk1lc2hcIjpcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJVbmltcGxlbWVudGVkIHBhdHRlcm4gTWVzaFwiKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICBjYXNlIFwiRHVtbXlcIjpcbiAgICAgICAgICByZXR1cm4gXCJob3RwaW5rXCI7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gSVIgdHlwZTogJHthcmdzWzBdfWApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldERhc2goZGFzaEFycmF5LCBkYXNoUGhhc2UpIHtcbiAgICAgIHRoaXMuY3VycmVudC5kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG4gICAgICB0aGlzLmN1cnJlbnQuZGFzaFBoYXNlID0gZGFzaFBoYXNlO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdFBhdGgob3BzLCBhcmdzKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgbGV0IHggPSBjdXJyZW50LngsXG4gICAgICAgICAgeSA9IGN1cnJlbnQueTtcbiAgICAgIGxldCBkID0gW107XG4gICAgICBsZXQgaiA9IDA7XG5cbiAgICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICAgIHN3aXRjaCAob3AgfCAwKSB7XG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMucmVjdGFuZ2xlOlxuICAgICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgIGNvbnN0IHh3ID0geCArIHdpZHRoO1xuICAgICAgICAgICAgY29uc3QgeWggPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgICAgZC5wdXNoKFwiTVwiLCBwZih4KSwgcGYoeSksIFwiTFwiLCBwZih4dyksIHBmKHkpLCBcIkxcIiwgcGYoeHcpLCBwZih5aCksIFwiTFwiLCBwZih4KSwgcGYoeWgpLCBcIlpcIik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLm1vdmVUbzpcbiAgICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgZC5wdXNoKFwiTVwiLCBwZih4KSwgcGYoeSkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5saW5lVG86XG4gICAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgIGQucHVzaChcIkxcIiwgcGYoeCksIHBmKHkpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzpcbiAgICAgICAgICAgIHggPSBhcmdzW2ogKyA0XTtcbiAgICAgICAgICAgIHkgPSBhcmdzW2ogKyA1XTtcbiAgICAgICAgICAgIGQucHVzaChcIkNcIiwgcGYoYXJnc1tqXSksIHBmKGFyZ3NbaiArIDFdKSwgcGYoYXJnc1tqICsgMl0pLCBwZihhcmdzW2ogKyAzXSksIHBmKHgpLCBwZih5KSk7XG4gICAgICAgICAgICBqICs9IDY7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmN1cnZlVG8yOlxuICAgICAgICAgICAgZC5wdXNoKFwiQ1wiLCBwZih4KSwgcGYoeSksIHBmKGFyZ3Nbal0pLCBwZihhcmdzW2ogKyAxXSksIHBmKGFyZ3NbaiArIDJdKSwgcGYoYXJnc1tqICsgM10pKTtcbiAgICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICAgIHkgPSBhcmdzW2ogKyAzXTtcbiAgICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzM6XG4gICAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgICB5ID0gYXJnc1tqICsgM107XG4gICAgICAgICAgICBkLnB1c2goXCJDXCIsIHBmKGFyZ3Nbal0pLCBwZihhcmdzW2ogKyAxXSksIHBmKHgpLCBwZih5KSwgcGYoeCksIHBmKHkpKTtcbiAgICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VQYXRoOlxuICAgICAgICAgICAgZC5wdXNoKFwiWlwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGQgPSBkLmpvaW4oXCIgXCIpO1xuXG4gICAgICBpZiAoY3VycmVudC5wYXRoICYmIG9wcy5sZW5ndGggPiAwICYmIG9wc1swXSAhPT0gX3V0aWwuT1BTLnJlY3RhbmdsZSAmJiBvcHNbMF0gIT09IF91dGlsLk9QUy5tb3ZlVG8pIHtcbiAgICAgICAgZCA9IGN1cnJlbnQucGF0aC5nZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRcIikgKyBkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudC5wYXRoID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cGF0aFwiKTtcblxuICAgICAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChjdXJyZW50LnBhdGgpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50LnBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIsIGQpO1xuICAgICAgY3VycmVudC5wYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICBjdXJyZW50LmVsZW1lbnQgPSBjdXJyZW50LnBhdGg7XG4gICAgICBjdXJyZW50LnNldEN1cnJlbnRQb2ludCh4LCB5KTtcbiAgICB9XG5cbiAgICBlbmRQYXRoKCkge1xuICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgIGN1cnJlbnQucGF0aCA9IG51bGw7XG5cbiAgICAgIGlmICghdGhpcy5wZW5kaW5nQ2xpcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghY3VycmVudC5lbGVtZW50KSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNsaXBJZCA9IGBjbGlwcGF0aCR7Y2xpcENvdW50Kyt9YDtcbiAgICAgIGNvbnN0IGNsaXBQYXRoID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Y2xpcFBhdGhcIik7XG4gICAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIGNsaXBJZCk7XG4gICAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBwbSh0aGlzLnRyYW5zZm9ybU1hdHJpeCkpO1xuICAgICAgY29uc3QgY2xpcEVsZW1lbnQgPSBjdXJyZW50LmVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuXG4gICAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCA9PT0gXCJldmVub2RkXCIpIHtcbiAgICAgICAgY2xpcEVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGlwLXJ1bGVcIiwgXCJldmVub2RkXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xpcEVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGlwLXJ1bGVcIiwgXCJub256ZXJvXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICAgIGNsaXBQYXRoLmFwcGVuZChjbGlwRWxlbWVudCk7XG4gICAgICB0aGlzLmRlZnMuYXBwZW5kKGNsaXBQYXRoKTtcblxuICAgICAgaWYgKGN1cnJlbnQuYWN0aXZlQ2xpcFVybCkge1xuICAgICAgICBjdXJyZW50LmNsaXBHcm91cCA9IG51bGw7XG5cbiAgICAgICAgZm9yIChjb25zdCBwcmV2IG9mIHRoaXMuZXh0cmFTdGFjaykge1xuICAgICAgICAgIHByZXYuY2xpcEdyb3VwID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xpcC1wYXRoXCIsIGN1cnJlbnQuYWN0aXZlQ2xpcFVybCk7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQuYWN0aXZlQ2xpcFVybCA9IGB1cmwoIyR7Y2xpcElkfSlgO1xuICAgICAgdGhpcy50Z3JwID0gbnVsbDtcbiAgICB9XG5cbiAgICBjbGlwKHR5cGUpIHtcbiAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSB0eXBlO1xuICAgIH1cblxuICAgIGNsb3NlUGF0aCgpIHtcbiAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChjdXJyZW50LnBhdGgpIHtcbiAgICAgICAgY29uc3QgZCA9IGAke2N1cnJlbnQucGF0aC5nZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRcIil9WmA7XG4gICAgICAgIGN1cnJlbnQucGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRcIiwgZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2V0TGVhZGluZyhsZWFkaW5nKSB7XG4gICAgICB0aGlzLmN1cnJlbnQubGVhZGluZyA9IC1sZWFkaW5nO1xuICAgIH1cblxuICAgIHNldFRleHRSaXNlKHRleHRSaXNlKSB7XG4gICAgICB0aGlzLmN1cnJlbnQudGV4dFJpc2UgPSB0ZXh0UmlzZTtcbiAgICB9XG5cbiAgICBzZXRUZXh0UmVuZGVyaW5nTW9kZSh0ZXh0UmVuZGVyaW5nTW9kZSkge1xuICAgICAgdGhpcy5jdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID0gdGV4dFJlbmRlcmluZ01vZGU7XG4gICAgfVxuXG4gICAgc2V0SFNjYWxlKHNjYWxlKSB7XG4gICAgICB0aGlzLmN1cnJlbnQudGV4dEhTY2FsZSA9IHNjYWxlIC8gMTAwO1xuICAgIH1cblxuICAgIHNldFJlbmRlcmluZ0ludGVudChpbnRlbnQpIHt9XG5cbiAgICBzZXRGbGF0bmVzcyhmbGF0bmVzcykge31cblxuICAgIHNldEdTdGF0ZShzdGF0ZXMpIHtcbiAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHN0YXRlcykge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgXCJMV1wiOlxuICAgICAgICAgICAgdGhpcy5zZXRMaW5lV2lkdGgodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiTENcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0TGluZUNhcCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJMSlwiOlxuICAgICAgICAgICAgdGhpcy5zZXRMaW5lSm9pbih2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJNTFwiOlxuICAgICAgICAgICAgdGhpcy5zZXRNaXRlckxpbWl0KHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0RGFzaCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiUklcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0UmVuZGVyaW5nSW50ZW50KHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIkZMXCI6XG4gICAgICAgICAgICB0aGlzLnNldEZsYXRuZXNzKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0Rm9udCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJDQVwiOlxuICAgICAgICAgICAgdGhpcy5zZXRTdHJva2VBbHBoYSh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJjYVwiOlxuICAgICAgICAgICAgdGhpcy5zZXRGaWxsQWxwaGEodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBVbmltcGxlbWVudGVkIGdyYXBoaWMgc3RhdGUgb3BlcmF0b3IgJHtrZXl9YCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZpbGwoKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuXG4gICAgICBpZiAoY3VycmVudC5lbGVtZW50KSB7XG4gICAgICAgIGN1cnJlbnQuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgY3VycmVudC5maWxsQ29sb3IpO1xuICAgICAgICBjdXJyZW50LmVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLW9wYWNpdHlcIiwgY3VycmVudC5maWxsQWxwaGEpO1xuICAgICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdHJva2UoKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuXG4gICAgICBpZiAoY3VycmVudC5lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX3NldFN0cm9rZUF0dHJpYnV0ZXMoY3VycmVudC5lbGVtZW50KTtcblxuICAgICAgICBjdXJyZW50LmVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3NldFN0cm9rZUF0dHJpYnV0ZXMoZWxlbWVudCwgbGluZVdpZHRoU2NhbGUgPSAxKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgbGV0IGRhc2hBcnJheSA9IGN1cnJlbnQuZGFzaEFycmF5O1xuXG4gICAgICBpZiAobGluZVdpZHRoU2NhbGUgIT09IDEgJiYgZGFzaEFycmF5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgZGFzaEFycmF5ID0gZGFzaEFycmF5Lm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gbGluZVdpZHRoU2NhbGUgKiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2VcIiwgY3VycmVudC5zdHJva2VDb2xvcik7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLW9wYWNpdHlcIiwgY3VycmVudC5zdHJva2VBbHBoYSk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLW1pdGVybGltaXRcIiwgcGYoY3VycmVudC5taXRlckxpbWl0KSk7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLWxpbmVjYXBcIiwgY3VycmVudC5saW5lQ2FwKTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2UtbGluZWpvaW5cIiwgY3VycmVudC5saW5lSm9pbik7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLXdpZHRoXCIsIHBmKGxpbmVXaWR0aFNjYWxlICogY3VycmVudC5saW5lV2lkdGgpICsgXCJweFwiKTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2UtZGFzaGFycmF5XCIsIGRhc2hBcnJheS5tYXAocGYpLmpvaW4oXCIgXCIpKTtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2UtZGFzaG9mZnNldFwiLCBwZihsaW5lV2lkdGhTY2FsZSAqIGN1cnJlbnQuZGFzaFBoYXNlKSArIFwicHhcIik7XG4gICAgfVxuXG4gICAgZW9GaWxsKCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudC5lbGVtZW50KSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1ydWxlXCIsIFwiZXZlbm9kZFwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5maWxsKCk7XG4gICAgfVxuXG4gICAgZmlsbFN0cm9rZSgpIHtcbiAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICB0aGlzLmZpbGwoKTtcbiAgICB9XG5cbiAgICBlb0ZpbGxTdHJva2UoKSB7XG4gICAgICBpZiAodGhpcy5jdXJyZW50LmVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50LmVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLXJ1bGVcIiwgXCJldmVub2RkXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgICB9XG5cbiAgICBjbG9zZVN0cm9rZSgpIHtcbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgICB0aGlzLnN0cm9rZSgpO1xuICAgIH1cblxuICAgIGNsb3NlRmlsbFN0cm9rZSgpIHtcbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgICB9XG5cbiAgICBjbG9zZUVPRmlsbFN0cm9rZSgpIHtcbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgICB0aGlzLmVvRmlsbFN0cm9rZSgpO1xuICAgIH1cblxuICAgIHBhaW50U29saWRDb2xvckltYWdlTWFzaygpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgXCIwXCIpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgXCIwXCIpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIFwiMXB4XCIpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBcIjFweFwiKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIHRoaXMuY3VycmVudC5maWxsQ29sb3IpO1xuXG4gICAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChyZWN0KTtcbiAgICB9XG5cbiAgICBwYWludEltYWdlWE9iamVjdChvYmpJZCkge1xuICAgICAgY29uc3QgaW1nRGF0YSA9IG9iaklkLnN0YXJ0c1dpdGgoXCJnX1wiKSA/IHRoaXMuY29tbW9uT2Jqcy5nZXQob2JqSWQpIDogdGhpcy5vYmpzLmdldChvYmpJZCk7XG5cbiAgICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoYERlcGVuZGVudCBpbWFnZSB3aXRoIG9iamVjdCBJRCAke29iaklkfSBpcyBub3QgcmVhZHkgeWV0YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhKTtcbiAgICB9XG5cbiAgICBwYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhLCBtYXNrKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIGNvbnN0IGltZ1NyYyA9IGNvbnZlcnRJbWdEYXRhVG9QbmcoaW1nRGF0YSwgdGhpcy5mb3JjZURhdGFTY2hlbWEsICEhbWFzayk7XG4gICAgICBjb25zdCBjbGlwcmVjdCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgXCIwXCIpO1xuICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIFwiMFwiKTtcbiAgICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgcGYod2lkdGgpKTtcbiAgICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHBmKGhlaWdodCkpO1xuICAgICAgdGhpcy5jdXJyZW50LmVsZW1lbnQgPSBjbGlwcmVjdDtcbiAgICAgIHRoaXMuY2xpcChcIm5vbnplcm9cIik7XG4gICAgICBjb25zdCBpbWdFbCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmltYWdlXCIpO1xuICAgICAgaW1nRWwuc2V0QXR0cmlidXRlTlMoWExJTktfTlMsIFwieGxpbms6aHJlZlwiLCBpbWdTcmMpO1xuICAgICAgaW1nRWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIFwiMFwiKTtcbiAgICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtaGVpZ2h0KSk7XG4gICAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHBmKHdpZHRoKSArIFwicHhcIik7XG4gICAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBwZihoZWlnaHQpICsgXCJweFwiKTtcbiAgICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIGBzY2FsZSgke3BmKDEgLyB3aWR0aCl9ICR7cGYoLTEgLyBoZWlnaHQpfSlgKTtcblxuICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgbWFzay5hcHBlbmQoaW1nRWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmQoaW1nRWwpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhaW50SW1hZ2VNYXNrWE9iamVjdChpbWdEYXRhKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgY29uc3Qgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgICBjb25zdCBmaWxsQ29sb3IgPSBjdXJyZW50LmZpbGxDb2xvcjtcbiAgICAgIGN1cnJlbnQubWFza0lkID0gYG1hc2ske21hc2tDb3VudCsrfWA7XG4gICAgICBjb25zdCBtYXNrID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6bWFza1wiKTtcbiAgICAgIG1hc2suc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCBjdXJyZW50Lm1hc2tJZCk7XG4gICAgICBjb25zdCByZWN0ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIFwiMFwiKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIFwiMFwiKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBwZih3aWR0aCkpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBwZihoZWlnaHQpKTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIGZpbGxDb2xvcik7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwibWFza1wiLCBgdXJsKCMke2N1cnJlbnQubWFza0lkfSlgKTtcbiAgICAgIHRoaXMuZGVmcy5hcHBlbmQobWFzayk7XG5cbiAgICAgIHRoaXMuX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkuYXBwZW5kKHJlY3QpO1xuXG4gICAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEsIG1hc2spO1xuICAgIH1cblxuICAgIHBhaW50Rm9ybVhPYmplY3RCZWdpbihtYXRyaXgsIGJib3gpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG1hdHJpeCkgJiYgbWF0cml4Lmxlbmd0aCA9PT0gNikge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybShtYXRyaXhbMF0sIG1hdHJpeFsxXSwgbWF0cml4WzJdLCBtYXRyaXhbM10sIG1hdHJpeFs0XSwgbWF0cml4WzVdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJib3gpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gICAgICAgIGNvbnN0IGNsaXByZWN0ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIGJib3hbMF0pO1xuICAgICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgYmJveFsxXSk7XG4gICAgICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgcGYod2lkdGgpKTtcbiAgICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgcGYoaGVpZ2h0KSk7XG4gICAgICAgIHRoaXMuY3VycmVudC5lbGVtZW50ID0gY2xpcHJlY3Q7XG4gICAgICAgIHRoaXMuY2xpcChcIm5vbnplcm9cIik7XG4gICAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhaW50Rm9ybVhPYmplY3RFbmQoKSB7fVxuXG4gICAgX2luaXRpYWxpemUodmlld3BvcnQpIHtcbiAgICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUodmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodCk7XG4gICAgICBjb25zdCBkZWZpbml0aW9ucyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmRlZnNcIik7XG4gICAgICBzdmcuYXBwZW5kKGRlZmluaXRpb25zKTtcbiAgICAgIHRoaXMuZGVmcyA9IGRlZmluaXRpb25zO1xuICAgICAgY29uc3Qgcm9vdEdyb3VwID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Z1wiKTtcbiAgICAgIHJvb3RHcm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBwbSh2aWV3cG9ydC50cmFuc2Zvcm0pKTtcbiAgICAgIHN2Zy5hcHBlbmQocm9vdEdyb3VwKTtcbiAgICAgIHRoaXMuc3ZnID0gcm9vdEdyb3VwO1xuICAgICAgcmV0dXJuIHN2ZztcbiAgICB9XG5cbiAgICBfZW5zdXJlQ2xpcEdyb3VwKCkge1xuICAgICAgaWYgKCF0aGlzLmN1cnJlbnQuY2xpcEdyb3VwKSB7XG4gICAgICAgIGNvbnN0IGNsaXBHcm91cCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgICAgIGNsaXBHcm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcGF0aFwiLCB0aGlzLmN1cnJlbnQuYWN0aXZlQ2xpcFVybCk7XG4gICAgICAgIHRoaXMuc3ZnLmFwcGVuZChjbGlwR3JvdXApO1xuICAgICAgICB0aGlzLmN1cnJlbnQuY2xpcEdyb3VwID0gY2xpcEdyb3VwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jdXJyZW50LmNsaXBHcm91cDtcbiAgICB9XG5cbiAgICBfZW5zdXJlVHJhbnNmb3JtR3JvdXAoKSB7XG4gICAgICBpZiAoIXRoaXMudGdycCkge1xuICAgICAgICB0aGlzLnRncnAgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpnXCIpO1xuICAgICAgICB0aGlzLnRncnAuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0cmFuc2Zvcm1cIiwgcG0odGhpcy50cmFuc2Zvcm1NYXRyaXgpKTtcblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50LmFjdGl2ZUNsaXBVcmwpIHtcbiAgICAgICAgICB0aGlzLl9lbnN1cmVDbGlwR3JvdXAoKS5hcHBlbmQodGhpcy50Z3JwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN2Zy5hcHBlbmQodGhpcy50Z3JwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy50Z3JwO1xuICAgIH1cblxuICB9O1xufVxuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlBERk5vZGVTdHJlYW0gPSB2b2lkIDA7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5cbnZhciBfbmV0d29ya191dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMzMpO1xuXG47XG5cbmNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuXG5jb25zdCBodHRwID0gcmVxdWlyZShcImh0dHBcIik7XG5cbmNvbnN0IGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpO1xuXG5jb25zdCB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xuXG5jb25zdCBmaWxlVXJpUmVnZXggPSAvXmZpbGU6XFwvXFwvXFwvW2EtekEtWl06XFwvLztcblxuZnVuY3Rpb24gcGFyc2VVcmwoc291cmNlVXJsKSB7XG4gIGNvbnN0IHBhcnNlZFVybCA9IHVybC5wYXJzZShzb3VyY2VVcmwpO1xuXG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIiB8fCBwYXJzZWRVcmwuaG9zdCkge1xuICAgIHJldHVybiBwYXJzZWRVcmw7XG4gIH1cblxuICBpZiAoL15bYS16XTpbL1xcXFxdL2kudGVzdChzb3VyY2VVcmwpKSB7XG4gICAgcmV0dXJuIHVybC5wYXJzZShgZmlsZTovLy8ke3NvdXJjZVVybH1gKTtcbiAgfVxuXG4gIGlmICghcGFyc2VkVXJsLmhvc3QpIHtcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSBcImZpbGU6XCI7XG4gIH1cblxuICByZXR1cm4gcGFyc2VkVXJsO1xufVxuXG5jbGFzcyBQREZOb2RlU3RyZWFtIHtcbiAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy51cmwgPSBwYXJzZVVybChzb3VyY2UudXJsKTtcbiAgICB0aGlzLmlzSHR0cCA9IHRoaXMudXJsLnByb3RvY29sID09PSBcImh0dHA6XCIgfHwgdGhpcy51cmwucHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gICAgdGhpcy5pc0ZzVXJsID0gdGhpcy51cmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIjtcbiAgICB0aGlzLmh0dHBIZWFkZXJzID0gdGhpcy5pc0h0dHAgJiYgc291cmNlLmh0dHBIZWFkZXJzIHx8IHt9O1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cblxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuXG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5vZGVTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzLmlzRnNVcmwgPyBuZXcgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlcih0aGlzKSA6IG5ldyBQREZOb2RlU3RyZWFtRnVsbFJlYWRlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cblxuICBnZXRSYW5nZVJlYWRlcihzdGFydCwgZW5kKSB7XG4gICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGNvbnN0IHJhbmdlUmVhZGVyID0gdGhpcy5pc0ZzVXJsID8gbmV3IFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyKHRoaXMsIHN0YXJ0LCBlbmQpIDogbmV3IFBERk5vZGVTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBzdGFydCwgZW5kKTtcblxuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyYW5nZVJlYWRlcik7XG5cbiAgICByZXR1cm4gcmFuZ2VSZWFkZXI7XG4gIH1cblxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICBpZiAodGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIpIHtcbiAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnRzLlBERk5vZGVTdHJlYW0gPSBQREZOb2RlU3RyZWFtO1xuXG5jbGFzcyBCYXNlRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3VybCA9IHN0cmVhbS51cmw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcblxuICAgIGlmICghdGhpcy5fcmFuZ2VDaHVua1NpemUgJiYgIXRoaXMuX2Rpc2FibGVSYW5nZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICB9XG5cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuXG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cblxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuXG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG5cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuXG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcblxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuXG4gICAgY29uc3QgY2h1bmsgPSB0aGlzLl9yZWFkYWJsZVN0cmVhbS5yZWFkKCk7XG5cbiAgICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZCgpO1xuICAgIH1cblxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5sZW5ndGg7XG5cbiAgICBpZiAodGhpcy5vblByb2dyZXNzKSB7XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgICAgdG90YWw6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kocmVhc29uKTtcbiAgfVxuXG4gIF9lcnJvcihyZWFzb24pIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcblxuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuXG4gIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVTdHJlYW07XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG5cbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgIH0pO1xuXG4gICAgaWYgKCF0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCAmJiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9lcnJvcihuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24oXCJzdHJlYW1pbmcgaXMgZGlzYWJsZWRcIikpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveSh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgQmFzZVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fdXJsID0gc3RyZWFtLnVybDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgfVxuXG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cblxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG5cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cblxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuXG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsubGVuZ3RoO1xuXG4gICAgaWYgKHRoaXMub25Qcm9ncmVzcykge1xuICAgICAgdGhpcy5vblByb2dyZXNzKHtcbiAgICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGNodW5rKS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kocmVhc29uKTtcbiAgfVxuXG4gIF9lcnJvcihyZWFzb24pIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcblxuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuXG4gIF9zZXRSZWFkYWJsZVN0cmVhbShyZWFkYWJsZVN0cmVhbSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gcmVhZGFibGVTdHJlYW07XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCAoKSA9PiB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gICAgcmVhZGFibGVTdHJlYW0ub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG5cbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gIH1cblxufVxuXG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0T3B0aW9ucyhwYXJzZWRVcmwsIGhlYWRlcnMpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogcGFyc2VkVXJsLnByb3RvY29sLFxuICAgIGF1dGg6IHBhcnNlZFVybC5hdXRoLFxuICAgIGhvc3Q6IHBhcnNlZFVybC5ob3N0bmFtZSxcbiAgICBwb3J0OiBwYXJzZWRVcmwucG9ydCxcbiAgICBwYXRoOiBwYXJzZWRVcmwucGF0aCxcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVyc1xuICB9O1xufVxuXG5jbGFzcyBQREZOb2RlU3RyZWFtRnVsbFJlYWRlciBleHRlbmRzIEJhc2VGdWxsUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgc3VwZXIoc3RyZWFtKTtcblxuICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gcmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKGBNaXNzaW5nIFBERiBcIiR7dGhpcy5fdXJsfVwiLmApO1xuICAgICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuXG4gICAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG5cbiAgICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlKTtcblxuICAgICAgY29uc3QgZ2V0UmVzcG9uc2VIZWFkZXIgPSBuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmhlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICAgIH0gPSAoMCwgX25ldHdvcmtfdXRpbHMudmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMpKHtcbiAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXIsXG4gICAgICAgIGlzSHR0cDogc3RyZWFtLmlzSHR0cCxcbiAgICAgICAgcmFuZ2VDaHVua1NpemU6IHRoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gYWxsb3dSYW5nZVJlcXVlc3RzO1xuICAgICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgICAgdGhpcy5fZmlsZW5hbWUgPSAoMCwgX25ldHdvcmtfdXRpbHMuZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcikoZ2V0UmVzcG9uc2VIZWFkZXIpO1xuICAgIH07XG5cbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcblxuICAgIGlmICh0aGlzLl91cmwucHJvdG9jb2wgPT09IFwiaHR0cDpcIikge1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IGh0dHAucmVxdWVzdChjcmVhdGVSZXF1ZXN0T3B0aW9ucyh0aGlzLl91cmwsIHN0cmVhbS5odHRwSGVhZGVycyksIGhhbmRsZVJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IGh0dHBzLnJlcXVlc3QoY3JlYXRlUmVxdWVzdE9wdGlvbnModGhpcy5fdXJsLCBzdHJlYW0uaHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdC5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcblxuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9yZXF1ZXN0LmVuZCgpO1xuICB9XG5cbn1cblxuY2xhc3MgUERGTm9kZVN0cmVhbVJhbmdlUmVhZGVyIGV4dGVuZHMgQmFzZVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBzdGFydCwgZW5kKSB7XG4gICAgc3VwZXIoc3RyZWFtKTtcbiAgICB0aGlzLl9odHRwSGVhZGVycyA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBzdHJlYW0uaHR0cEhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc3RyZWFtLmh0dHBIZWFkZXJzW3Byb3BlcnR5XTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faHR0cEhlYWRlcnNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5faHR0cEhlYWRlcnMuUmFuZ2UgPSBgYnl0ZXM9JHtzdGFydH0tJHtlbmQgLSAxfWA7XG5cbiAgICBjb25zdCBoYW5kbGVSZXNwb25zZSA9IHJlc3BvbnNlID0+IHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbihgTWlzc2luZyBQREYgXCIke3RoaXMuX3VybH1cIi5gKTtcbiAgICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShyZXNwb25zZSk7XG4gICAgfTtcblxuICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuX3VybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiKSB7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gaHR0cC5yZXF1ZXN0KGNyZWF0ZVJlcXVlc3RPcHRpb25zKHRoaXMuX3VybCwgdGhpcy5faHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KGNyZWF0ZVJlcXVlc3RPcHRpb25zKHRoaXMuX3VybCwgdGhpcy5faHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdC5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICB9KTtcblxuICAgIHRoaXMuX3JlcXVlc3QuZW5kKCk7XG4gIH1cblxufVxuXG5jbGFzcyBQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyIGV4dGVuZHMgQmFzZUZ1bGxSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuICAgIGxldCBwYXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMuX3VybC5wYXRoKTtcblxuICAgIGlmIChmaWxlVXJpUmVnZXgudGVzdCh0aGlzLl91cmwuaHJlZikpIHtcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC8vLCBcIlwiKTtcbiAgICB9XG5cbiAgICBmcy5sc3RhdChwYXRoLCAoZXJyb3IsIHN0YXQpID0+IHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgIGVycm9yID0gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24oYE1pc3NpbmcgUERGIFwiJHtwYXRofVwiLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBlcnJvcjtcblxuICAgICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN0YXQuc2l6ZTtcblxuICAgICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0oZnMuY3JlYXRlUmVhZFN0cmVhbShwYXRoKSk7XG5cbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgfVxuXG59XG5cbmNsYXNzIFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyIGV4dGVuZHMgQmFzZVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBzdGFydCwgZW5kKSB7XG4gICAgc3VwZXIoc3RyZWFtKTtcbiAgICBsZXQgcGF0aCA9IGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLl91cmwucGF0aCk7XG5cbiAgICBpZiAoZmlsZVVyaVJlZ2V4LnRlc3QodGhpcy5fdXJsLmhyZWYpKSB7XG4gICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwvLywgXCJcIik7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0oZnMuY3JlYXRlUmVhZFN0cmVhbShwYXRoLCB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZDogZW5kIC0gMVxuICAgIH0pKTtcbiAgfVxuXG59XG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvciA9IGNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3I7XG5leHBvcnRzLmV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIgPSBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyO1xuZXhwb3J0cy52YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyA9IHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzO1xuZXhwb3J0cy52YWxpZGF0ZVJlc3BvbnNlU3RhdHVzID0gdmFsaWRhdGVSZXNwb25zZVN0YXR1cztcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcblxudmFyIF9jb250ZW50X2Rpc3Bvc2l0aW9uID0gX193X3BkZmpzX3JlcXVpcmVfXygzNCk7XG5cbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oOCk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKHtcbiAgZ2V0UmVzcG9uc2VIZWFkZXIsXG4gIGlzSHR0cCxcbiAgcmFuZ2VDaHVua1NpemUsXG4gIGRpc2FibGVSYW5nZVxufSkge1xuICBjb25zdCByZXR1cm5WYWx1ZXMgPSB7XG4gICAgYWxsb3dSYW5nZVJlcXVlc3RzOiBmYWxzZSxcbiAgICBzdWdnZXN0ZWRMZW5ndGg6IHVuZGVmaW5lZFxuICB9O1xuICBjb25zdCBsZW5ndGggPSBwYXJzZUludChnZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtTGVuZ3RoXCIpLCAxMCk7XG5cbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG5cbiAgcmV0dXJuVmFsdWVzLnN1Z2dlc3RlZExlbmd0aCA9IGxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDw9IDIgKiByYW5nZUNodW5rU2l6ZSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cblxuICBpZiAoZGlzYWJsZVJhbmdlIHx8ICFpc0h0dHApIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG5cbiAgaWYgKGdldFJlc3BvbnNlSGVhZGVyKFwiQWNjZXB0LVJhbmdlc1wiKSAhPT0gXCJieXRlc1wiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuXG4gIGNvbnN0IGNvbnRlbnRFbmNvZGluZyA9IGdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1FbmNvZGluZ1wiKSB8fCBcImlkZW50aXR5XCI7XG5cbiAgaWYgKGNvbnRlbnRFbmNvZGluZyAhPT0gXCJpZGVudGl0eVwiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuXG4gIHJldHVyblZhbHVlcy5hbGxvd1JhbmdlUmVxdWVzdHMgPSB0cnVlO1xuICByZXR1cm4gcmV0dXJuVmFsdWVzO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKGdldFJlc3BvbnNlSGVhZGVyKSB7XG4gIGNvbnN0IGNvbnRlbnREaXNwb3NpdGlvbiA9IGdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1EaXNwb3NpdGlvblwiKTtcblxuICBpZiAoY29udGVudERpc3Bvc2l0aW9uKSB7XG4gICAgbGV0IGZpbGVuYW1lID0gKDAsIF9jb250ZW50X2Rpc3Bvc2l0aW9uLmdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcikoY29udGVudERpc3Bvc2l0aW9uKTtcblxuICAgIGlmIChmaWxlbmFtZS5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbGVuYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KGZpbGVuYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7fVxuICAgIH1cblxuICAgIGlmICgoMCwgX2Rpc3BsYXlfdXRpbHMuaXNQZGZGaWxlKShmaWxlbmFtZSkpIHtcbiAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcihzdGF0dXMsIHVybCkge1xuICBpZiAoc3RhdHVzID09PSA0MDQgfHwgc3RhdHVzID09PSAwICYmIHVybC5zdGFydHNXaXRoKFwiZmlsZTpcIikpIHtcbiAgICByZXR1cm4gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24oJ01pc3NpbmcgUERGIFwiJyArIHVybCArICdcIi4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZSAoJHtzdGF0dXN9KSB3aGlsZSByZXRyaWV2aW5nIFBERiBcIiR7dXJsfVwiLmAsIHN0YXR1cyk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmVzcG9uc2VTdGF0dXMoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IDIwMCB8fCBzdGF0dXMgPT09IDIwNjtcbn1cblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5nZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIgPSBnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXI7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5cbmZ1bmN0aW9uIGdldEZpbGVuYW1lRnJvbUNvbnRlbnREaXNwb3NpdGlvbkhlYWRlcihjb250ZW50RGlzcG9zaXRpb24pIHtcbiAgbGV0IG5lZWRzRW5jb2RpbmdGaXh1cCA9IHRydWU7XG4gIGxldCB0bXAgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcXFxcKlwiLCBcImlcIikuZXhlYyhjb250ZW50RGlzcG9zaXRpb24pO1xuXG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG4gICAgbGV0IGZpbGVuYW1lID0gcmZjMjYxNnVucXVvdGUodG1wKTtcbiAgICBmaWxlbmFtZSA9IHVuZXNjYXBlKGZpbGVuYW1lKTtcbiAgICBmaWxlbmFtZSA9IHJmYzU5ODdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZShmaWxlbmFtZSk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG5cbiAgdG1wID0gcmZjMjIzMWdldHBhcmFtKGNvbnRlbnREaXNwb3NpdGlvbik7XG5cbiAgaWYgKHRtcCkge1xuICAgIGNvbnN0IGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZSh0bXApO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuXG4gIHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVwiLCBcImlcIikuZXhlYyhjb250ZW50RGlzcG9zaXRpb24pO1xuXG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG4gICAgbGV0IGZpbGVuYW1lID0gcmZjMjYxNnVucXVvdGUodG1wKTtcbiAgICBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvUGFyYW1SZWdFeHAoYXR0cmlidXRlUGF0dGVybiwgZmxhZ3MpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/Ol58OylcXFxccypcIiArIGF0dHJpYnV0ZVBhdHRlcm4gKyBcIlxcXFxzKj1cXFxccypcIiArIFwiKFwiICsgJ1teXCI7XFxcXHNdW147XFxcXHNdKicgKyBcInxcIiArICdcIig/OlteXCJcXFxcXFxcXF18XFxcXFxcXFxcIj8pK1wiPycgKyBcIilcIiwgZmxhZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpIHtcbiAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgIGlmICghL15bXFx4MDAtXFx4RkZdKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZywge1xuICAgICAgICAgIGZhdGFsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBidWZmZXIgPSAoMCwgX3V0aWwuc3RyaW5nVG9CeXRlcykodmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IGRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgIG5lZWRzRW5jb2RpbmdGaXh1cCA9IGZhbHNlO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBmaXh1cEVuY29kaW5nKHZhbHVlKSB7XG4gICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCAmJiAvW1xceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdGV4dGRlY29kZShcInV0Zi04XCIsIHZhbHVlKTtcblxuICAgICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCkge1xuICAgICAgICB2YWx1ZSA9IHRleHRkZWNvZGUoXCJpc28tODg1OS0xXCIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiByZmMyMjMxZ2V0cGFyYW0oY29udGVudERpc3Bvc2l0aW9uU3RyKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGxldCBtYXRjaDtcbiAgICBjb25zdCBpdGVyID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXFxcXCooKD8hMFxcXFxkKVxcXFxkKykoXFxcXCo/KVwiLCBcImlnXCIpO1xuXG4gICAgd2hpbGUgKChtYXRjaCA9IGl0ZXIuZXhlYyhjb250ZW50RGlzcG9zaXRpb25TdHIpKSAhPT0gbnVsbCkge1xuICAgICAgbGV0IFssIG4sIHF1b3QsIHBhcnRdID0gbWF0Y2g7XG4gICAgICBuID0gcGFyc2VJbnQobiwgMTApO1xuXG4gICAgICBpZiAobiBpbiBtYXRjaGVzKSB7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbWF0Y2hlc1tuXSA9IFtxdW90LCBwYXJ0XTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBtYXRjaGVzLmxlbmd0aDsgKytuKSB7XG4gICAgICBpZiAoIShuIGluIG1hdGNoZXMpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBsZXQgW3F1b3QsIHBhcnRdID0gbWF0Y2hlc1tuXTtcbiAgICAgIHBhcnQgPSByZmMyNjE2dW5xdW90ZShwYXJ0KTtcblxuICAgICAgaWYgKHF1b3QpIHtcbiAgICAgICAgcGFydCA9IHVuZXNjYXBlKHBhcnQpO1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgcGFydCA9IHJmYzU5ODdkZWNvZGUocGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJmYzI2MTZ1bnF1b3RlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ1wiJykpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gdmFsdWUuc2xpY2UoMSkuc3BsaXQoJ1xcXFxcIicpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHF1b3RpbmRleCA9IHBhcnRzW2ldLmluZGV4T2YoJ1wiJyk7XG5cbiAgICAgICAgaWYgKHF1b3RpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBwYXJ0c1tpXSA9IHBhcnRzW2ldLnNsaWNlKDAsIHF1b3RpbmRleCk7XG4gICAgICAgICAgcGFydHMubGVuZ3RoID0gaSArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJ0c1tpXSA9IHBhcnRzW2ldLnJlcGxhY2UoL1xcXFwoLikvZywgXCIkMVwiKTtcbiAgICAgIH1cblxuICAgICAgdmFsdWUgPSBwYXJ0cy5qb2luKCdcIicpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJmYzU5ODdkZWNvZGUoZXh0dmFsdWUpIHtcbiAgICBjb25zdCBlbmNvZGluZ2VuZCA9IGV4dHZhbHVlLmluZGV4T2YoXCInXCIpO1xuXG4gICAgaWYgKGVuY29kaW5nZW5kID09PSAtMSkge1xuICAgICAgcmV0dXJuIGV4dHZhbHVlO1xuICAgIH1cblxuICAgIGNvbnN0IGVuY29kaW5nID0gZXh0dmFsdWUuc2xpY2UoMCwgZW5jb2RpbmdlbmQpO1xuICAgIGNvbnN0IGxhbmd2YWx1ZSA9IGV4dHZhbHVlLnNsaWNlKGVuY29kaW5nZW5kICsgMSk7XG4gICAgY29uc3QgdmFsdWUgPSBsYW5ndmFsdWUucmVwbGFjZSgvXlteJ10qJy8sIFwiXCIpO1xuICAgIHJldHVybiB0ZXh0ZGVjb2RlKGVuY29kaW5nLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZmMyMDQ3ZGVjb2RlKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5zdGFydHNXaXRoKFwiPT9cIikgfHwgL1tcXHgwMC1cXHgxOVxceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvPVxcPyhbXFx3LV0qKVxcPyhbUXFCYl0pXFw/KCg/OlteP118XFw/KD8hPSkpKilcXD89L2csIGZ1bmN0aW9uIChtYXRjaGVzLCBjaGFyc2V0LCBlbmNvZGluZywgdGV4dCkge1xuICAgICAgaWYgKGVuY29kaW5nID09PSBcInFcIiB8fCBlbmNvZGluZyA9PT0gXCJRXCIpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXy9nLCBcIiBcIik7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLz0oWzAtOWEtZkEtRl17Mn0pL2csIGZ1bmN0aW9uIChtYXRjaCwgaGV4KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4LCAxNikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRleHRkZWNvZGUoY2hhcnNldCwgdGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRleHQgPSBhdG9iKHRleHQpO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgcmV0dXJuIHRleHRkZWNvZGUoY2hhcnNldCwgdGV4dCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gXCJcIjtcbn1cblxuLyoqKi8gfSksXG4vKiAzNSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5QREZOZXR3b3JrU3RyZWFtID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG52YXIgX25ldHdvcmtfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMzKTtcblxuO1xuY29uc3QgT0tfUkVTUE9OU0UgPSAyMDA7XG5jb25zdCBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UgPSAyMDY7XG5cbmZ1bmN0aW9uIGdldEFycmF5QnVmZmVyKHhocikge1xuICBjb25zdCBkYXRhID0geGhyLnJlc3BvbnNlO1xuXG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgY29uc3QgYXJyYXkgPSAoMCwgX3V0aWwuc3RyaW5nVG9CeXRlcykoZGF0YSk7XG4gIHJldHVybiBhcnJheS5idWZmZXI7XG59XG5cbmNsYXNzIE5ldHdvcmtNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IodXJsLCBhcmdzID0ge30pIHtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLmlzSHR0cCA9IC9eaHR0cHM/Oi9pLnRlc3QodXJsKTtcbiAgICB0aGlzLmh0dHBIZWFkZXJzID0gdGhpcy5pc0h0dHAgJiYgYXJncy5odHRwSGVhZGVycyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMud2l0aENyZWRlbnRpYWxzID0gYXJncy53aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG5cbiAgICB0aGlzLmdldFhociA9IGFyZ3MuZ2V0WGhyIHx8IGZ1bmN0aW9uIE5ldHdvcmtNYW5hZ2VyX2dldFhocigpIHtcbiAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jdXJyWGhySWQgPSAwO1xuICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgfVxuXG4gIHJlcXVlc3RSYW5nZShiZWdpbiwgZW5kLCBsaXN0ZW5lcnMpIHtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgYmVnaW4sXG4gICAgICBlbmRcbiAgICB9O1xuXG4gICAgZm9yIChjb25zdCBwcm9wIGluIGxpc3RlbmVycykge1xuICAgICAgYXJnc1twcm9wXSA9IGxpc3RlbmVyc1twcm9wXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGFyZ3MpO1xuICB9XG5cbiAgcmVxdWVzdEZ1bGwobGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChsaXN0ZW5lcnMpO1xuICB9XG5cbiAgcmVxdWVzdChhcmdzKSB7XG4gICAgY29uc3QgeGhyID0gdGhpcy5nZXRYaHIoKTtcbiAgICBjb25zdCB4aHJJZCA9IHRoaXMuY3VyclhocklkKys7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0gPSB7XG4gICAgICB4aHJcbiAgICB9O1xuICAgIHhoci5vcGVuKFwiR0VUXCIsIHRoaXMudXJsKTtcbiAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdGhpcy53aXRoQ3JlZGVudGlhbHM7XG5cbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHRoaXMuaHR0cEhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5odHRwSGVhZGVyc1twcm9wZXJ0eV07XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNIdHRwICYmIFwiYmVnaW5cIiBpbiBhcmdzICYmIFwiZW5kXCIgaW4gYXJncykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLCBgYnl0ZXM9JHthcmdzLmJlZ2lufS0ke2FyZ3MuZW5kIC0gMX1gKTtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9IE9LX1JFU1BPTlNFO1xuICAgIH1cblxuICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG5cbiAgICBpZiAoYXJncy5vbkVycm9yKSB7XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgYXJncy5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5vblByb2dyZXNzLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkID0gYXJncy5vbkhlYWRlcnNSZWNlaXZlZDtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUgPSBhcmdzLm9uRG9uZTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yID0gYXJncy5vbkVycm9yO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3MgPSBhcmdzLm9uUHJvZ3Jlc3M7XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gICAgcmV0dXJuIHhocklkO1xuICB9XG5cbiAgb25Qcm9ncmVzcyh4aHJJZCwgZXZ0KSB7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG5cbiAgICBpZiAoIXBlbmRpbmdSZXF1ZXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGVuZGluZ1JlcXVlc3Qub25Qcm9ncmVzcz8uKGV2dCk7XG4gIH1cblxuICBvblN0YXRlQ2hhbmdlKHhocklkLCBldnQpIHtcbiAgICBjb25zdCBwZW5kaW5nUmVxdWVzdCA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcblxuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB4aHIgPSBwZW5kaW5nUmVxdWVzdC54aHI7XG5cbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPj0gMiAmJiBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCkge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQoKTtcbiAgICAgIGRlbGV0ZSBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZDtcbiAgICB9XG5cbiAgICBpZiAoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoISh4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBkZWxldGUgdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuXG4gICAgaWYgKHhoci5zdGF0dXMgPT09IDAgJiYgdGhpcy5pc0h0dHApIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3I/Lih4aHIuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB4aHJTdGF0dXMgPSB4aHIuc3RhdHVzIHx8IE9LX1JFU1BPTlNFO1xuICAgIGNvbnN0IG9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgPSB4aHJTdGF0dXMgPT09IE9LX1JFU1BPTlNFICYmIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0U7XG5cbiAgICBpZiAoIW9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgJiYgeGhyU3RhdHVzICE9PSBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cykge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcj8uKHhoci5zdGF0dXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNodW5rID0gZ2V0QXJyYXlCdWZmZXIoeGhyKTtcblxuICAgIGlmICh4aHJTdGF0dXMgPT09IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRSkge1xuICAgICAgY29uc3QgcmFuZ2VIZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVJhbmdlXCIpO1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IC9ieXRlcyAoXFxkKyktKFxcZCspXFwvKFxcZCspLy5leGVjKHJhbmdlSGVhZGVyKTtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgIGJlZ2luOiBwYXJzZUludChtYXRjaGVzWzFdLCAxMCksXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUoe1xuICAgICAgICBiZWdpbjogMCxcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yPy4oeGhyLnN0YXR1cyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UmVxdWVzdFhocih4aHJJZCkge1xuICAgIHJldHVybiB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0ueGhyO1xuICB9XG5cbiAgaXNQZW5kaW5nUmVxdWVzdCh4aHJJZCkge1xuICAgIHJldHVybiB4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cztcbiAgfVxuXG4gIGFib3J0UmVxdWVzdCh4aHJJZCkge1xuICAgIGNvbnN0IHhociA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICB4aHIuYWJvcnQoKTtcbiAgfVxuXG59XG5cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW0ge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fbWFuYWdlciA9IG5ldyBOZXR3b3JrTWFuYWdlcihzb3VyY2UudXJsLCB7XG4gICAgICBodHRwSGVhZGVyczogc291cmNlLmh0dHBIZWFkZXJzLFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiBzb3VyY2Uud2l0aENyZWRlbnRpYWxzXG4gICAgfSk7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuXG4gIF9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZChyZWFkZXIpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5pbmRleE9mKHJlYWRlcik7XG5cbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH1cblxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgICgwLCBfdXRpbC5hc3NlcnQpKCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZOZXR3b3JrU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbmV3IFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlcih0aGlzLl9tYW5hZ2VyLCB0aGlzLl9zb3VyY2UpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuXG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlcih0aGlzLl9tYW5hZ2VyLCBiZWdpbiwgZW5kKTtcbiAgICByZWFkZXIub25DbG9zZWQgPSB0aGlzLl9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJlYWRlcik7XG5cbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG5cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuXG4gICAgZm9yIChjb25zdCByZWFkZXIgb2YgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydHMuUERGTmV0d29ya1N0cmVhbSA9IFBERk5ldHdvcmtTdHJlYW07XG5cbmNsYXNzIFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIHNvdXJjZSkge1xuICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBvbkhlYWRlcnNSZWNlaXZlZDogdGhpcy5fb25IZWFkZXJzUmVjZWl2ZWQuYmluZCh0aGlzKSxcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9O1xuICAgIHRoaXMuX3VybCA9IHNvdXJjZS51cmw7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdEZ1bGwoYXJncyk7XG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuXG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhY2hlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG5cbiAgX29uSGVhZGVyc1JlY2VpdmVkKCkge1xuICAgIGNvbnN0IGZ1bGxSZXF1ZXN0WGhySWQgPSB0aGlzLl9mdWxsUmVxdWVzdElkO1xuXG4gICAgY29uc3QgZnVsbFJlcXVlc3RYaHIgPSB0aGlzLl9tYW5hZ2VyLmdldFJlcXVlc3RYaHIoZnVsbFJlcXVlc3RYaHJJZCk7XG5cbiAgICBjb25zdCBnZXRSZXNwb25zZUhlYWRlciA9IG5hbWUgPT4ge1xuICAgICAgcmV0dXJuIGZ1bGxSZXF1ZXN0WGhyLmdldFJlc3BvbnNlSGVhZGVyKG5hbWUpO1xuICAgIH07XG5cbiAgICBjb25zdCB7XG4gICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICB9ID0gKDAsIF9uZXR3b3JrX3V0aWxzLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKSh7XG4gICAgICBnZXRSZXNwb25zZUhlYWRlcixcbiAgICAgIGlzSHR0cDogdGhpcy5fbWFuYWdlci5pc0h0dHAsXG4gICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgIH0pO1xuXG4gICAgaWYgKGFsbG93UmFuZ2VSZXF1ZXN0cykge1xuICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gKDAsIF9uZXR3b3JrX3V0aWxzLmV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIpKGdldFJlc3BvbnNlSGVhZGVyKTtcblxuICAgIGlmICh0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdChmdWxsUmVxdWVzdFhocklkKTtcbiAgICB9XG5cbiAgICB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgfVxuXG4gIF9vbkRvbmUoZGF0YSkge1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IHRoaXMuX3JlcXVlc3RzLnNoaWZ0KCk7XG5cbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IGRhdGEuY2h1bmssXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZWRDaHVua3MucHVzaChkYXRhLmNodW5rKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICB9XG5cbiAgX29uRXJyb3Ioc3RhdHVzKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSAoMCwgX25ldHdvcmtfdXRpbHMuY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcikoc3RhdHVzLCB0aGlzLl91cmwpO1xuXG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuXG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVqZWN0KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2NhY2hlZENodW5rcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgdG90YWw6IGV2dC5sZW5ndGhDb21wdXRhYmxlID8gZXZ0LnRvdGFsIDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGZpbGVuYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgfVxuXG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkO1xuICB9XG5cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuXG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICB9XG5cbiAgZ2V0IGhlYWRlcnNSZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG5cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9jYWNoZWRDaHVua3Muc2hpZnQoKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcblxuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuXG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cblxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG5cbiAgICB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuXG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG5cbiAgICBpZiAodGhpcy5fbWFuYWdlci5pc1BlbmRpbmdSZXF1ZXN0KHRoaXMuX2Z1bGxSZXF1ZXN0SWQpKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdCh0aGlzLl9mdWxsUmVxdWVzdElkKTtcbiAgICB9XG5cbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gIH1cblxufVxuXG5jbGFzcyBQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyIHtcbiAgY29uc3RydWN0b3IobWFuYWdlciwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX21hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBvbkRvbmU6IHRoaXMuX29uRG9uZS5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25Qcm9ncmVzczogdGhpcy5fb25Qcm9ncmVzcy5iaW5kKHRoaXMpXG4gICAgfTtcbiAgICB0aGlzLl91cmwgPSBtYW5hZ2VyLnVybDtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgPSBtYW5hZ2VyLnJlcXVlc3RSYW5nZShiZWdpbiwgZW5kLCBhcmdzKTtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLm9uQ2xvc2VkID0gbnVsbDtcbiAgfVxuXG4gIF9jbG9zZSgpIHtcbiAgICB0aGlzLm9uQ2xvc2VkPy4odGhpcyk7XG4gIH1cblxuICBfb25Eb25lKGRhdGEpIHtcbiAgICBjb25zdCBjaHVuayA9IGRhdGEuY2h1bms7XG5cbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuXG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgfVxuXG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG5cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcblxuICAgIHRoaXMuX2Nsb3NlKCk7XG4gIH1cblxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9ICgwLCBfbmV0d29ya191dGlscy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKShzdGF0dXMsIHRoaXMuX3VybCk7XG5cbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICB9XG5cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgaWYgKCF0aGlzLmlzU3RyZWFtaW5nU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmsgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuXG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG5cbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuXG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuXG4gICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpO1xuICAgIH1cblxuICAgIHRoaXMuX2Nsb3NlKCk7XG4gIH1cblxufVxuXG4vKioqLyB9KSxcbi8qIDM2ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlBERkZldGNoU3RyZWFtID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG52YXIgX25ldHdvcmtfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMzKTtcblxuO1xuXG5mdW5jdGlvbiBjcmVhdGVGZXRjaE9wdGlvbnMoaGVhZGVycywgd2l0aENyZWRlbnRpYWxzLCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVycyxcbiAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgY3JlZGVudGlhbHM6IHdpdGhDcmVkZW50aWFscyA/IFwiaW5jbHVkZVwiIDogXCJzYW1lLW9yaWdpblwiLFxuICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhlYWRlcnMoaHR0cEhlYWRlcnMpIHtcbiAgY29uc3QgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG5cbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBodHRwSGVhZGVycykge1xuICAgIGNvbnN0IHZhbHVlID0gaHR0cEhlYWRlcnNbcHJvcGVydHldO1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaGVhZGVycy5hcHBlbmQocHJvcGVydHksIHZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiBoZWFkZXJzO1xufVxuXG5jbGFzcyBQREZGZXRjaFN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuaXNIdHRwID0gL15odHRwcz86L2kudGVzdChzb3VyY2UudXJsKTtcbiAgICB0aGlzLmh0dHBIZWFkZXJzID0gdGhpcy5pc0h0dHAgJiYgc291cmNlLmh0dHBIZWFkZXJzIHx8IHt9O1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cblxuICBnZXQgX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/Ll9sb2FkZWQgPz8gMDtcbiAgfVxuXG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERkZldGNoU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbmV3IFBERkZldGNoU3RyZWFtUmVhZGVyKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgfVxuXG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAoZW5kIDw9IHRoaXMuX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFBERkZldGNoU3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgYmVnaW4sIGVuZCk7XG5cbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnB1c2gocmVhZGVyKTtcblxuICAgIHJldHVybiByZWFkZXI7XG4gIH1cblxuICBjYW5jZWxBbGxSZXF1ZXN0cyhyZWFzb24pIHtcbiAgICBpZiAodGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIpIHtcbiAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cblxufVxuXG5leHBvcnRzLlBERkZldGNoU3RyZWFtID0gUERGRmV0Y2hTdHJlYW07XG5cbmNsYXNzIFBERkZldGNoU3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG5cbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9oZWFkZXJzID0gY3JlYXRlSGVhZGVycyh0aGlzLl9zdHJlYW0uaHR0cEhlYWRlcnMpO1xuICAgIGNvbnN0IHVybCA9IHNvdXJjZS51cmw7XG4gICAgZmV0Y2godXJsLCBjcmVhdGVGZXRjaE9wdGlvbnModGhpcy5faGVhZGVycywgdGhpcy5fd2l0aENyZWRlbnRpYWxzLCB0aGlzLl9hYm9ydENvbnRyb2xsZXIpKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIGlmICghKDAsIF9uZXR3b3JrX3V0aWxzLnZhbGlkYXRlUmVzcG9uc2VTdGF0dXMpKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgKDAsIF9uZXR3b3JrX3V0aWxzLmNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IpKHJlc3BvbnNlLnN0YXR1cywgdXJsKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcblxuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuXG4gICAgICBjb25zdCBnZXRSZXNwb25zZUhlYWRlciA9IG5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVycy5nZXQobmFtZSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyxcbiAgICAgICAgc3VnZ2VzdGVkTGVuZ3RoXG4gICAgICB9ID0gKDAsIF9uZXR3b3JrX3V0aWxzLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKSh7XG4gICAgICAgIGdldFJlc3BvbnNlSGVhZGVyLFxuICAgICAgICBpc0h0dHA6IHRoaXMuX3N0cmVhbS5pc0h0dHAsXG4gICAgICAgIHJhbmdlQ2h1bmtTaXplOiB0aGlzLl9yYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgZGlzYWJsZVJhbmdlOiB0aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGFsbG93UmFuZ2VSZXF1ZXN0cztcbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgdGhpcy5fY29udGVudExlbmd0aDtcbiAgICAgIHRoaXMuX2ZpbGVuYW1lID0gKDAsIF9uZXR3b3JrX3V0aWxzLmV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIpKGdldFJlc3BvbnNlSGVhZGVyKTtcblxuICAgICAgaWYgKCF0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCAmJiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihcIlN0cmVhbWluZyBpcyBkaXNhYmxlZC5cIikpO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuXG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cblxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG5cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cblxuICBnZXQgaXNSYW5nZVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgfVxuXG4gIGdldCBpc1N0cmVhbWluZ1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gIH1cblxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBkb25lXG4gICAgfSA9IGF3YWl0IHRoaXMuX3JlYWRlci5yZWFkKCk7XG5cbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5fbG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cbiAgICBpZiAodGhpcy5vblByb2dyZXNzKSB7XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgICAgdG90YWw6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHZhbHVlKS5idWZmZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBidWZmZXIsXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRlcikge1xuICAgICAgdGhpcy5fcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgIH1cblxuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICB9XG5cbn1cblxuY2xhc3MgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSwgYmVnaW4sIGVuZCkge1xuICAgIHRoaXMuX3N0cmVhbSA9IHN0cmVhbTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLl9oZWFkZXJzID0gY3JlYXRlSGVhZGVycyh0aGlzLl9zdHJlYW0uaHR0cEhlYWRlcnMpO1xuXG4gICAgdGhpcy5faGVhZGVycy5hcHBlbmQoXCJSYW5nZVwiLCBgYnl0ZXM9JHtiZWdpbn0tJHtlbmQgLSAxfWApO1xuXG4gICAgY29uc3QgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyh0aGlzLl9oZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKCEoMCwgX25ldHdvcmtfdXRpbHMudmFsaWRhdGVSZXNwb25zZVN0YXR1cykocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICB0aHJvdyAoMCwgX25ldHdvcmtfdXRpbHMuY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcikocmVzcG9uc2Uuc3RhdHVzLCB1cmwpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG5cbiAgICAgIHRoaXMuX3JlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgfSkuY2F0Y2godGhpcy5fcmVhZENhcGFiaWxpdHkucmVqZWN0KTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG5cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuXG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGRvbmVcbiAgICB9ID0gYXdhaXQgdGhpcy5fcmVhZGVyLnJlYWQoKTtcblxuICAgIGlmIChkb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZG9uZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLl9sb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcblxuICAgIGlmICh0aGlzLm9uUHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMub25Qcm9ncmVzcyh7XG4gICAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBidWZmZXIgPSBuZXcgVWludDhBcnJheSh2YWx1ZSkuYnVmZmVyO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICB9XG5cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIGlmICh0aGlzLl9yZWFkZXIpIHtcbiAgICAgIHRoaXMuX3JlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG5cbiAgICB0aGlzLl9hYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgfVxuXG59XG5cbi8qKiovIH0pXG4vKioqKioqLyBcdF0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dfcGRmanNfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGlzb2xhdGVkIGFnYWluc3Qgb3RoZXIgbW9kdWxlcyBpbiB0aGUgY2h1bmsuXG4oKCkgPT4ge1xudmFyIGV4cG9ydHMgPSBfX3dlYnBhY2tfZXhwb3J0c19fO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFubm90YXRpb25FZGl0b3JMYXllclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Fubm90YXRpb25fZWRpdG9yX2xheWVyLkFubm90YXRpb25FZGl0b3JMYXllcjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbm5vdGF0aW9uRWRpdG9yVHlwZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXJcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF90b29scy5Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbm5vdGF0aW9uTGF5ZXJcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hbm5vdGF0aW9uX2xheWVyLkFubm90YXRpb25MYXllcjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5ub3RhdGlvbk1vZGVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkFubm90YXRpb25Nb2RlO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDTWFwQ29tcHJlc3Npb25UeXBlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5DTWFwQ29tcHJlc3Npb25UeXBlO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHbG9iYWxXb3JrZXJPcHRpb25zXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfd29ya2VyX29wdGlvbnMuR2xvYmFsV29ya2VyT3B0aW9ucztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW52YWxpZFBERkV4Y2VwdGlvblwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuSW52YWxpZFBERkV4Y2VwdGlvbjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9vcGJhY2tQb3J0XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLkxvb3BiYWNrUG9ydDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT1BTXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5PUFM7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBERkRhdGFSYW5nZVRyYW5zcG9ydFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FwaS5QREZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBERkRhdGVTdHJpbmdcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLlBERkRhdGVTdHJpbmc7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBERldvcmtlclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2FwaS5QREZXb3JrZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhc3N3b3JkUmVzcG9uc2VzXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5QYXNzd29yZFJlc3BvbnNlcztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGVybWlzc2lvbkZsYWdcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLlBlcm1pc3Npb25GbGFnO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQaXhlbHNQZXJJbmNoXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5QaXhlbHNQZXJJbmNoO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb25cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU1ZHR3JhcGhpY3NcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9zdmcuU1ZHR3JhcGhpY3M7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVOU1VQUE9SVEVEX0ZFQVRVUkVTXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5VTlNVUFBPUlRFRF9GRUFUVVJFUztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb247XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlV0aWxcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLlV0aWw7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZlcmJvc2l0eUxldmVsXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5WZXJib3NpdHlMZXZlbDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiWGZhTGF5ZXJcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF94ZmFfbGF5ZXIuWGZhTGF5ZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImJ1aWxkXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLmJ1aWxkO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjcmVhdGVQcm9taXNlQ2FwYWJpbGl0eVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHk7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVZhbGlkQWJzb2x1dGVVcmxcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLmNyZWF0ZVZhbGlkQWJzb2x1dGVVcmw7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldERvY3VtZW50XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLmdldERvY3VtZW50O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRGaWxlbmFtZUZyb21VcmxcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmdldEZpbGVuYW1lRnJvbVVybDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UGRmRmlsZW5hbWVGcm9tVXJsXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5nZXRQZGZGaWxlbmFtZUZyb21Vcmw7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFhmYVBhZ2VWaWV3cG9ydFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuZ2V0WGZhUGFnZVZpZXdwb3J0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc1BkZkZpbGVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmlzUGRmRmlsZTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibG9hZFNjcmlwdFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMubG9hZFNjcmlwdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicmVuZGVyVGV4dExheWVyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdGV4dF9sYXllci5yZW5kZXJUZXh0TGF5ZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNoYWRvd1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuc2hhZG93O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJzaW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLnZlcnNpb247XG4gIH1cbn0pKTtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcblxudmFyIF9hcGkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xuXG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgpO1xuXG52YXIgX2Fubm90YXRpb25fZWRpdG9yX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygyMik7XG5cbnZhciBfdG9vbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcpO1xuXG52YXIgX2Fubm90YXRpb25fbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI3KTtcblxudmFyIF93b3JrZXJfb3B0aW9ucyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUpO1xuXG52YXIgX2lzX25vZGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMpO1xuXG52YXIgX3RleHRfbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMwKTtcblxudmFyIF9zdmcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMxKTtcblxudmFyIF94ZmFfbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI5KTtcblxuY29uc3QgcGRmanNWZXJzaW9uID0gJzIuMTYuMTA1JztcbmNvbnN0IHBkZmpzQnVpbGQgPSAnMTcyY2NkYmU1JztcbntcbiAgaWYgKF9pc19ub2RlLmlzTm9kZUpTKSB7XG4gICAgY29uc3Qge1xuICAgICAgUERGTm9kZVN0cmVhbVxuICAgIH0gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMyKTtcblxuICAgICgwLCBfYXBpLnNldFBERk5ldHdvcmtTdHJlYW1GYWN0b3J5KShwYXJhbXMgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQREZOb2RlU3RyZWFtKHBhcmFtcyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qge1xuICAgICAgUERGTmV0d29ya1N0cmVhbVxuICAgIH0gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM1KTtcblxuICAgIGNvbnN0IHtcbiAgICAgIFBERkZldGNoU3RyZWFtXG4gICAgfSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzYpO1xuXG4gICAgKDAsIF9hcGkuc2V0UERGTmV0d29ya1N0cmVhbUZhY3RvcnkpKHBhcmFtcyA9PiB7XG4gICAgICBpZiAoKDAsIF9kaXNwbGF5X3V0aWxzLmlzVmFsaWRGZXRjaFVybCkocGFyYW1zLnVybCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQREZGZXRjaFN0cmVhbShwYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFBERk5ldHdvcmtTdHJlYW0ocGFyYW1zKTtcbiAgICB9KTtcbiAgfVxufVxufSkoKTtcblxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX2V4cG9ydHNfXztcbi8qKioqKiovIH0pKClcbjtcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGRmLmpzLm1hcCIsImNvbnN0IENhbnZhcyA9IHJlcXVpcmUoJy4vbGliL2NhbnZhcycpXG5jb25zdCBJbWFnZSA9IHJlcXVpcmUoJy4vbGliL2ltYWdlJylcbmNvbnN0IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IHJlcXVpcmUoJy4vbGliL2NvbnRleHQyZCcpXG5jb25zdCBDYW52YXNQYXR0ZXJuID0gcmVxdWlyZSgnLi9saWIvcGF0dGVybicpXG5jb25zdCBwYXJzZUZvbnQgPSByZXF1aXJlKCcuL2xpYi9wYXJzZS1mb250JylcbmNvbnN0IHBhY2thZ2VKc29uID0gcmVxdWlyZSgnLi9wYWNrYWdlLmpzb24nKVxuY29uc3QgYmluZGluZ3MgPSByZXF1aXJlKCcuL2xpYi9iaW5kaW5ncycpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IFBOR1N0cmVhbSA9IHJlcXVpcmUoJy4vbGliL3BuZ3N0cmVhbScpXG5jb25zdCBQREZTdHJlYW0gPSByZXF1aXJlKCcuL2xpYi9wZGZzdHJlYW0nKVxuY29uc3QgSlBFR1N0cmVhbSA9IHJlcXVpcmUoJy4vbGliL2pwZWdzdHJlYW0nKVxuY29uc3QgeyBET01Qb2ludCwgRE9NTWF0cml4IH0gPSByZXF1aXJlKCcuL2xpYi9ET01NYXRyaXgnKVxuXG5mdW5jdGlvbiBjcmVhdGVDYW52YXMgKHdpZHRoLCBoZWlnaHQsIHR5cGUpIHtcbiAgcmV0dXJuIG5ldyBDYW52YXMod2lkdGgsIGhlaWdodCwgdHlwZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW1hZ2VEYXRhIChhcnJheSwgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gbmV3IGJpbmRpbmdzLkltYWdlRGF0YShhcnJheSwgd2lkdGgsIGhlaWdodClcbn1cblxuZnVuY3Rpb24gbG9hZEltYWdlIChzcmMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpXG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwICgpIHtcbiAgICAgIGltYWdlLm9ubG9hZCA9IG51bGxcbiAgICAgIGltYWdlLm9uZXJyb3IgPSBudWxsXG4gICAgfVxuXG4gICAgaW1hZ2Uub25sb2FkID0gKCkgPT4geyBjbGVhbnVwKCk7IHJlc29sdmUoaW1hZ2UpIH1cbiAgICBpbWFnZS5vbmVycm9yID0gKGVycikgPT4geyBjbGVhbnVwKCk7IHJlamVjdChlcnIpIH1cblxuICAgIGltYWdlLnNyYyA9IHNyY1xuICB9KVxufVxuXG4vKipcbiAqIFJlc29sdmUgcGF0aHMgZm9yIHJlZ2lzdGVyRm9udC4gTXVzdCBiZSBjYWxsZWQgKmJlZm9yZSogY3JlYXRpbmcgYSBDYW52YXNcbiAqIGluc3RhbmNlLlxuICogQHBhcmFtIHNyYyB7c3RyaW5nfSBQYXRoIHRvIGZvbnQgZmlsZS5cbiAqIEBwYXJhbSBmb250RmFjZSB7e2ZhbWlseTogc3RyaW5nLCB3ZWlnaHQ/OiBzdHJpbmcsIHN0eWxlPzogc3RyaW5nfX0gT2JqZWN0XG4gKiBzcGVjaWZ5aW5nIGZvbnQgaW5mb3JtYXRpb24uIGB3ZWlnaHRgIGFuZCBgc3R5bGVgIGRlZmF1bHQgdG8gYFwibm9ybWFsXCJgLlxuICovXG5mdW5jdGlvbiByZWdpc3RlckZvbnQgKHNyYywgZm9udEZhY2UpIHtcbiAgLy8gVE9ETyB0aGlzIGRvZXNuJ3QgbmVlZCB0byBiZSBvbiBDYW52YXM7IGl0IHNob3VsZCBqdXN0IGJlIGEgc3RhdGljIG1ldGhvZFxuICAvLyBvZiBgYmluZGluZ3NgLlxuICByZXR1cm4gQ2FudmFzLl9yZWdpc3RlckZvbnQoZnMucmVhbHBhdGhTeW5jKHNyYyksIGZvbnRGYWNlKVxufVxuXG4vKipcbiAqIFVubG9hZCBhbGwgZm9udHMgZnJvbSBwYW5nbyB0byBmcmVlIHVwIG1lbW9yeVxuICovXG5mdW5jdGlvbiBkZXJlZ2lzdGVyQWxsRm9udHMgKCkge1xuICByZXR1cm4gQ2FudmFzLl9kZXJlZ2lzdGVyQWxsRm9udHMoKVxufVxuXG5leHBvcnRzLkNhbnZhcyA9IENhbnZhc1xuZXhwb3J0cy5Db250ZXh0MmQgPSBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgLy8gTGVnYWN5L2NvbXBhdCBleHBvcnRcbmV4cG9ydHMuQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEID0gQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXG5leHBvcnRzLkNhbnZhc0dyYWRpZW50ID0gYmluZGluZ3MuQ2FudmFzR3JhZGllbnRcbmV4cG9ydHMuQ2FudmFzUGF0dGVybiA9IENhbnZhc1BhdHRlcm5cbmV4cG9ydHMuSW1hZ2UgPSBJbWFnZVxuZXhwb3J0cy5JbWFnZURhdGEgPSBiaW5kaW5ncy5JbWFnZURhdGFcbmV4cG9ydHMuUE5HU3RyZWFtID0gUE5HU3RyZWFtXG5leHBvcnRzLlBERlN0cmVhbSA9IFBERlN0cmVhbVxuZXhwb3J0cy5KUEVHU3RyZWFtID0gSlBFR1N0cmVhbVxuZXhwb3J0cy5ET01NYXRyaXggPSBET01NYXRyaXhcbmV4cG9ydHMuRE9NUG9pbnQgPSBET01Qb2ludFxuXG5leHBvcnRzLnJlZ2lzdGVyRm9udCA9IHJlZ2lzdGVyRm9udFxuZXhwb3J0cy5kZXJlZ2lzdGVyQWxsRm9udHMgPSBkZXJlZ2lzdGVyQWxsRm9udHNcbmV4cG9ydHMucGFyc2VGb250ID0gcGFyc2VGb250XG5cbmV4cG9ydHMuY3JlYXRlQ2FudmFzID0gY3JlYXRlQ2FudmFzXG5leHBvcnRzLmNyZWF0ZUltYWdlRGF0YSA9IGNyZWF0ZUltYWdlRGF0YVxuZXhwb3J0cy5sb2FkSW1hZ2UgPSBsb2FkSW1hZ2VcblxuZXhwb3J0cy5iYWNrZW5kcyA9IGJpbmRpbmdzLkJhY2tlbmRzXG5cbi8qKiBMaWJyYXJ5IHZlcnNpb24uICovXG5leHBvcnRzLnZlcnNpb24gPSBwYWNrYWdlSnNvbi52ZXJzaW9uXG4vKiogQ2Fpcm8gdmVyc2lvbi4gKi9cbmV4cG9ydHMuY2Fpcm9WZXJzaW9uID0gYmluZGluZ3MuY2Fpcm9WZXJzaW9uXG4vKioganBlZ2xpYiB2ZXJzaW9uLiAqL1xuZXhwb3J0cy5qcGVnVmVyc2lvbiA9IGJpbmRpbmdzLmpwZWdWZXJzaW9uXG4vKiogZ2lmX2xpYiB2ZXJzaW9uLiAqL1xuZXhwb3J0cy5naWZWZXJzaW9uID0gYmluZGluZ3MuZ2lmVmVyc2lvbiA/IGJpbmRpbmdzLmdpZlZlcnNpb24ucmVwbGFjZSgvW14uXFxkXS9nLCAnJykgOiB1bmRlZmluZWRcbi8qKiBmcmVldHlwZSB2ZXJzaW9uLiAqL1xuZXhwb3J0cy5mcmVldHlwZVZlcnNpb24gPSBiaW5kaW5ncy5mcmVldHlwZVZlcnNpb25cbi8qKiByc3ZnIHZlcnNpb24uICovXG5leHBvcnRzLnJzdmdWZXJzaW9uID0gYmluZGluZ3MucnN2Z1ZlcnNpb25cbi8qKiBwYW5nbyB2ZXJzaW9uLiAqL1xuZXhwb3J0cy5wYW5nb1ZlcnNpb24gPSBiaW5kaW5ncy5wYW5nb1ZlcnNpb25cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiFcbiAqIENhbnZhc1xuICogQ29weXJpZ2h0IChjKSAyMDEwIExlYXJuQm9vc3QgPHRqQGxlYXJuYm9vc3QuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuY29uc3QgYmluZGluZ3MgPSByZXF1aXJlKCcuL2JpbmRpbmdzJylcbmNvbnN0IENhbnZhcyA9IG1vZHVsZS5leHBvcnRzID0gYmluZGluZ3MuQ2FudmFzXG5jb25zdCBDb250ZXh0MmQgPSByZXF1aXJlKCcuL2NvbnRleHQyZCcpXG5jb25zdCBQTkdTdHJlYW0gPSByZXF1aXJlKCcuL3BuZ3N0cmVhbScpXG5jb25zdCBQREZTdHJlYW0gPSByZXF1aXJlKCcuL3BkZnN0cmVhbScpXG5jb25zdCBKUEVHU3RyZWFtID0gcmVxdWlyZSgnLi9qcGVnc3RyZWFtJylcbmNvbnN0IEZPUk1BVFMgPSBbJ2ltYWdlL3BuZycsICdpbWFnZS9qcGVnJ11cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJylcblxuLy8gVE9ETyB8fCBpcyBmb3IgTm9kZS5qcyBwcmUtdjYuNi4wXG5DYW52YXMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b20gfHwgJ2luc3BlY3QnXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGBbQ2FudmFzICR7dGhpcy53aWR0aH14JHt0aGlzLmhlaWdodH1dYFxufVxuXG5DYW52YXMucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dFR5cGUsIGNvbnRleHRBdHRyaWJ1dGVzKSB7XG4gIGlmIChjb250ZXh0VHlwZSA9PSAnMmQnKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fY29udGV4dDJkIHx8ICh0aGlzLl9jb250ZXh0MmQgPSBuZXcgQ29udGV4dDJkKHRoaXMsIGNvbnRleHRBdHRyaWJ1dGVzKSlcbiAgICB0aGlzLmNvbnRleHQgPSBjdHhcbiAgICBjdHguY2FudmFzID0gdGhpc1xuICAgIHJldHVybiBjdHhcbiAgfVxufVxuXG5DYW52YXMucHJvdG90eXBlLnBuZ1N0cmVhbSA9XG5DYW52YXMucHJvdG90eXBlLmNyZWF0ZVBOR1N0cmVhbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgUE5HU3RyZWFtKHRoaXMsIG9wdGlvbnMpXG59XG5cbkNhbnZhcy5wcm90b3R5cGUucGRmU3RyZWFtID1cbkNhbnZhcy5wcm90b3R5cGUuY3JlYXRlUERGU3RyZWFtID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBQREZTdHJlYW0odGhpcywgb3B0aW9ucylcbn1cblxuQ2FudmFzLnByb3RvdHlwZS5qcGVnU3RyZWFtID1cbkNhbnZhcy5wcm90b3R5cGUuY3JlYXRlSlBFR1N0cmVhbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgSlBFR1N0cmVhbSh0aGlzLCBvcHRpb25zKVxufVxuXG5DYW52YXMucHJvdG90eXBlLnRvRGF0YVVSTCA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzKSB7XG4gIC8vIHZhbGlkIGFyZyBwYXR0ZXJucyAoYXJncyAtPiBbdHlwZSwgb3B0cywgZm5dKTpcbiAgLy8gW10gLT4gWydpbWFnZS9wbmcnLCBudWxsLCBudWxsXVxuICAvLyBbcXVhbF0gLT4gWydpbWFnZS9wbmcnLCBudWxsLCBudWxsXVxuICAvLyBbdW5kZWZpbmVkXSAtPiBbJ2ltYWdlL3BuZycsIG51bGwsIG51bGxdXG4gIC8vIFsnaW1hZ2UvcG5nJ10gLT4gWydpbWFnZS9wbmcnLCBudWxsLCBudWxsXVxuICAvLyBbJ2ltYWdlL3BuZycsIHF1YWxdIC0+IFsnaW1hZ2UvcG5nJywgbnVsbCwgbnVsbF1cbiAgLy8gW2ZuXSAtPiBbJ2ltYWdlL3BuZycsIG51bGwsIGZuXVxuICAvLyBbdHlwZSwgZm5dIC0+IFt0eXBlLCBudWxsLCBmbl1cbiAgLy8gW3VuZGVmaW5lZCwgZm5dIC0+IFsnaW1hZ2UvcG5nJywgbnVsbCwgZm5dXG4gIC8vIFsnaW1hZ2UvcG5nJywgcXVhbCwgZm5dIC0+IFsnaW1hZ2UvcG5nJywgbnVsbCwgZm5dXG4gIC8vIFsnaW1hZ2UvanBlZycsIGZuXSAtPiBbJ2ltYWdlL2pwZWcnLCBudWxsLCBmbl1cbiAgLy8gWydpbWFnZS9qcGVnJywgb3B0cywgZm5dIC0+IFsnaW1hZ2UvanBlZycsIG9wdHMsIGZuXVxuICAvLyBbJ2ltYWdlL2pwZWcnLCBxdWFsLCBmbl0gLT4gWydpbWFnZS9qcGVnJywge3F1YWxpdHk6IHF1YWx9LCBmbl1cbiAgLy8gWydpbWFnZS9qcGVnJywgdW5kZWZpbmVkLCBmbl0gLT4gWydpbWFnZS9qcGVnJywgbnVsbCwgZm5dXG4gIC8vIFsnaW1hZ2UvanBlZyddIC0+IFsnaW1hZ2UvanBlZycsIG51bGwsIGZuXVxuICAvLyBbJ2ltYWdlL2pwZWcnLCBvcHRzXSAtPiBbJ2ltYWdlL2pwZWcnLCBvcHRzLCBmbl1cbiAgLy8gWydpbWFnZS9qcGVnJywgcXVhbF0gLT4gWydpbWFnZS9qcGVnJywge3F1YWxpdHk6IHF1YWx9LCBmbl1cblxuICBsZXQgdHlwZSA9ICdpbWFnZS9wbmcnXG4gIGxldCBvcHRzID0ge31cbiAgbGV0IGZuXG5cbiAgaWYgKHR5cGVvZiBhMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGZuID0gYTFcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGExID09PSAnc3RyaW5nJyAmJiBGT1JNQVRTLmluY2x1ZGVzKGExLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICB0eXBlID0gYTEudG9Mb3dlckNhc2UoKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgYTIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGZuID0gYTJcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBhMiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgb3B0cyA9IGEyXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhMiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgb3B0cyA9IHsgcXVhbGl0eTogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYTIpKSB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgYTMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm4gPSBhM1xuICAgICAgfSBlbHNlIGlmICh1bmRlZmluZWQgIT09IGEzKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7dHlwZW9mIGEzfSBpcyBub3QgYSBmdW5jdGlvbmApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMud2lkdGggPT09IDAgfHwgdGhpcy5oZWlnaHQgPT09IDApIHtcbiAgICAvLyBQZXIgc3BlYywgaWYgdGhlIGJpdG1hcCBoYXMgbm8gcGl4ZWxzLCByZXR1cm4gdGhpcyBzdHJpbmc6XG4gICAgY29uc3Qgc3RyID0gJ2RhdGE6LCdcbiAgICBpZiAoZm4pIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gZm4obnVsbCwgc3RyKSlcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3RyXG4gICAgfVxuICB9XG5cbiAgaWYgKGZuKSB7XG4gICAgdGhpcy50b0J1ZmZlcigoZXJyLCBidWYpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBmbihlcnIpXG4gICAgICBmbihudWxsLCBgZGF0YToke3R5cGV9O2Jhc2U2NCwke2J1Zi50b1N0cmluZygnYmFzZTY0Jyl9YClcbiAgICB9LCB0eXBlLCBvcHRzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBgZGF0YToke3R5cGV9O2Jhc2U2NCwke3RoaXMudG9CdWZmZXIodHlwZSwgb3B0cykudG9TdHJpbmcoJ2Jhc2U2NCcpfWBcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJpbmRpbmdzID0gcmVxdWlyZSgnLi4vYnVpbGQvUmVsZWFzZS9jYW52YXMubm9kZScpXG5cbm1vZHVsZS5leHBvcnRzID0gYmluZGluZ3NcblxuYmluZGluZ3MuSW1hZ2VEYXRhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICdbb2JqZWN0IEltYWdlRGF0YV0nXG59XG5cbmJpbmRpbmdzLkNhbnZhc0dyYWRpZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSdcbn1cbiIsIlxudHJ5IHtcbiAgcHJvY2Vzcy5kbG9wZW4obW9kdWxlLCBfX2Rpcm5hbWUgKyByZXF1aXJlKFwicGF0aFwiKS5zZXAgKyBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiMjRjODY0YTQ0MTZkNzk4ZDFmMDZmOTQ2YzhhZjcwZjkubm9kZVwiKTtcbn0gY2F0Y2ggKGVycm9yKSB7XG4gIHRocm93IG5ldyBFcnJvcignbm9kZS1sb2FkZXI6XFxuJyArIGVycm9yKTtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiFcbiAqIENhbnZhcyAtIENvbnRleHQyZFxuICogQ29weXJpZ2h0IChjKSAyMDEwIExlYXJuQm9vc3QgPHRqQGxlYXJuYm9vc3QuY29tPlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuY29uc3QgYmluZGluZ3MgPSByZXF1aXJlKCcuL2JpbmRpbmdzJylcbmNvbnN0IHBhcnNlRm9udCA9IHJlcXVpcmUoJy4vcGFyc2UtZm9udCcpXG5jb25zdCB7IERPTU1hdHJpeCB9ID0gcmVxdWlyZSgnLi9ET01NYXRyaXgnKVxuXG5iaW5kaW5ncy5DYW52YXNSZW5kZXJpbmdDb250ZXh0MmRJbml0KERPTU1hdHJpeCwgcGFyc2VGb250KVxubW9kdWxlLmV4cG9ydHMgPSBiaW5kaW5ncy5DYW52YXNSZW5kZXJpbmdDb250ZXh0MmRcbiIsIid1c2Ugc3RyaWN0J1xuXG4vKipcbiAqIEZvbnQgUmVnRXhwIGhlbHBlcnMuXG4gKi9cblxuY29uc3Qgd2VpZ2h0cyA9ICdib2xkfGJvbGRlcnxsaWdodGVyfFsxLTldMDAnXG5jb25zdCBzdHlsZXMgPSAnaXRhbGljfG9ibGlxdWUnXG5jb25zdCB2YXJpYW50cyA9ICdzbWFsbC1jYXBzJ1xuY29uc3Qgc3RyZXRjaGVzID0gJ3VsdHJhLWNvbmRlbnNlZHxleHRyYS1jb25kZW5zZWR8Y29uZGVuc2VkfHNlbWktY29uZGVuc2VkfHNlbWktZXhwYW5kZWR8ZXhwYW5kZWR8ZXh0cmEtZXhwYW5kZWR8dWx0cmEtZXhwYW5kZWQnXG5jb25zdCB1bml0cyA9ICdweHxwdHxwY3xpbnxjbXxtbXwlfGVtfGV4fGNofHJlbXxxJ1xuY29uc3Qgc3RyaW5nID0gJ1xcJyhbXlxcJ10rKVxcJ3xcIihbXlwiXSspXCJ8W1xcXFx3XFxcXHMtXSsnXG5cbi8vIFsgWyA84oCYZm9udC1zdHlsZeKAmT4gfHwgPGZvbnQtdmFyaWFudC1jc3MyMT4gfHwgPOKAmGZvbnQtd2VpZ2h04oCZPiB8fCA84oCYZm9udC1zdHJldGNo4oCZPiBdP1xuLy8gICAgPOKAmGZvbnQtc2l6ZeKAmT4gWyAvIDzigJhsaW5lLWhlaWdodOKAmT4gXT8gPOKAmGZvbnQtZmFtaWx54oCZPiBdXG4vLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLWZvbnRzLTMvI2ZvbnQtcHJvcFxuY29uc3Qgd2VpZ2h0UmUgPSBuZXcgUmVnRXhwKGAoJHt3ZWlnaHRzfSkgK2AsICdpJylcbmNvbnN0IHN0eWxlUmUgPSBuZXcgUmVnRXhwKGAoJHtzdHlsZXN9KSArYCwgJ2knKVxuY29uc3QgdmFyaWFudFJlID0gbmV3IFJlZ0V4cChgKCR7dmFyaWFudHN9KSArYCwgJ2knKVxuY29uc3Qgc3RyZXRjaFJlID0gbmV3IFJlZ0V4cChgKCR7c3RyZXRjaGVzfSkgK2AsICdpJylcbmNvbnN0IHNpemVGYW1pbHlSZSA9IG5ldyBSZWdFeHAoXG4gIGAoW1xcXFxkXFxcXC5dKykoJHt1bml0c30pICooKD86JHtzdHJpbmd9KSggKiwgKig/OiR7c3RyaW5nfSkpKilgKVxuXG4vKipcbiAqIENhY2hlIGZvbnQgcGFyc2luZy5cbiAqL1xuXG5jb25zdCBjYWNoZSA9IHt9XG5cbmNvbnN0IGRlZmF1bHRIZWlnaHQgPSAxNiAvLyBwdCwgY29tbW9uIGJyb3dzZXIgZGVmYXVsdFxuXG4vKipcbiAqIFBhcnNlIGZvbnQgYHN0cmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBQYXJzZWQgZm9udC4gYHNpemVgIGlzIGluIGRldmljZSB1bml0cy4gYHVuaXRgIGlzIHRoZSB1bml0XG4gKiAgIGFwcGVhcmluZyBpbiB0aGUgaW5wdXQgc3RyaW5nLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBzdHIgPT4ge1xuICAvLyBDYWNoZWRcbiAgaWYgKGNhY2hlW3N0cl0pIHJldHVybiBjYWNoZVtzdHJdXG5cbiAgLy8gVHJ5IGZvciByZXF1aXJlZCBwcm9wZXJ0aWVzIGZpcnN0LlxuICBjb25zdCBzaXplRmFtaWx5ID0gc2l6ZUZhbWlseVJlLmV4ZWMoc3RyKVxuICBpZiAoIXNpemVGYW1pbHkpIHJldHVybiAvLyBpbnZhbGlkXG5cbiAgLy8gRGVmYXVsdCB2YWx1ZXMgYW5kIHJlcXVpcmVkIHByb3BlcnRpZXNcbiAgY29uc3QgZm9udCA9IHtcbiAgICB3ZWlnaHQ6ICdub3JtYWwnLFxuICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICBzdHJldGNoOiAnbm9ybWFsJyxcbiAgICB2YXJpYW50OiAnbm9ybWFsJyxcbiAgICBzaXplOiBwYXJzZUZsb2F0KHNpemVGYW1pbHlbMV0pLFxuICAgIHVuaXQ6IHNpemVGYW1pbHlbMl0sXG4gICAgZmFtaWx5OiBzaXplRmFtaWx5WzNdLnJlcGxhY2UoL1tcIiddL2csICcnKS5yZXBsYWNlKC8gKiwgKi9nLCAnLCcpXG4gIH1cblxuICAvLyBPcHRpb25hbCwgdW5vcmRlcmVkIHByb3BlcnRpZXMuXG4gIGxldCB3ZWlnaHQsIHN0eWxlLCB2YXJpYW50LCBzdHJldGNoXG4gIC8vIFN0b3Agc2VhcmNoIGF0IGBzaXplRmFtaWx5LmluZGV4YFxuICBjb25zdCBzdWJzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIHNpemVGYW1pbHkuaW5kZXgpXG4gIGlmICgod2VpZ2h0ID0gd2VpZ2h0UmUuZXhlYyhzdWJzdHIpKSkgZm9udC53ZWlnaHQgPSB3ZWlnaHRbMV1cbiAgaWYgKChzdHlsZSA9IHN0eWxlUmUuZXhlYyhzdWJzdHIpKSkgZm9udC5zdHlsZSA9IHN0eWxlWzFdXG4gIGlmICgodmFyaWFudCA9IHZhcmlhbnRSZS5leGVjKHN1YnN0cikpKSBmb250LnZhcmlhbnQgPSB2YXJpYW50WzFdXG4gIGlmICgoc3RyZXRjaCA9IHN0cmV0Y2hSZS5leGVjKHN1YnN0cikpKSBmb250LnN0cmV0Y2ggPSBzdHJldGNoWzFdXG5cbiAgLy8gQ29udmVydCB0byBkZXZpY2UgdW5pdHMuIChgZm9udC51bml0YCBpcyB0aGUgb3JpZ2luYWwgdW5pdClcbiAgLy8gVE9ETzogY2gsIGV4XG4gIHN3aXRjaCAoZm9udC51bml0KSB7XG4gICAgY2FzZSAncHQnOlxuICAgICAgZm9udC5zaXplIC89IDAuNzVcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncGMnOlxuICAgICAgZm9udC5zaXplICo9IDE2XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2luJzpcbiAgICAgIGZvbnQuc2l6ZSAqPSA5NlxuICAgICAgYnJlYWtcbiAgICBjYXNlICdjbSc6XG4gICAgICBmb250LnNpemUgKj0gOTYuMCAvIDIuNTRcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnbW0nOlxuICAgICAgZm9udC5zaXplICo9IDk2LjAgLyAyNS40XG4gICAgICBicmVha1xuICAgIGNhc2UgJyUnOlxuICAgICAgLy8gVE9ETyBkaXNhYmxlZCBiZWNhdXNlIGV4aXN0aW5nIHVuaXQgdGVzdHMgYXNzdW1lIDEwMFxuICAgICAgLy8gZm9udC5zaXplICo9IGRlZmF1bHRIZWlnaHQgLyAxMDAgLyAwLjc1XG4gICAgICBicmVha1xuICAgIGNhc2UgJ2VtJzpcbiAgICBjYXNlICdyZW0nOlxuICAgICAgZm9udC5zaXplICo9IGRlZmF1bHRIZWlnaHQgLyAwLjc1XG4gICAgICBicmVha1xuICAgIGNhc2UgJ3EnOlxuICAgICAgZm9udC5zaXplICo9IDk2IC8gMjUuNCAvIDRcbiAgICAgIGJyZWFrXG4gIH1cblxuICByZXR1cm4gKGNhY2hlW3N0cl0gPSBmb250KVxufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHV0aWwgPSByZXF1aXJlKCd1dGlsJylcblxuLy8gRE9NTWF0cml4IHBlciBodHRwczovL2RyYWZ0cy5meHRmLm9yZy9nZW9tZXRyeS8jRE9NTWF0cml4XG5cbmNsYXNzIERPTVBvaW50IHtcbiAgY29uc3RydWN0b3IgKHgsIHksIHosIHcpIHtcbiAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT09IG51bGwpIHtcbiAgICAgIHcgPSB4LndcbiAgICAgIHogPSB4LnpcbiAgICAgIHkgPSB4LnlcbiAgICAgIHggPSB4LnhcbiAgICB9XG4gICAgdGhpcy54ID0gdHlwZW9mIHggPT09ICdudW1iZXInID8geCA6IDBcbiAgICB0aGlzLnkgPSB0eXBlb2YgeSA9PT0gJ251bWJlcicgPyB5IDogMFxuICAgIHRoaXMueiA9IHR5cGVvZiB6ID09PSAnbnVtYmVyJyA/IHogOiAwXG4gICAgdGhpcy53ID0gdHlwZW9mIHcgPT09ICdudW1iZXInID8gdyA6IDFcbiAgfVxufVxuXG4vLyBDb25zdGFudHMgdG8gaW5kZXggaW50byBfdmFsdWVzIChjb2wtbWFqb3IpXG5jb25zdCBNMTEgPSAwOyBjb25zdCBNMTIgPSAxOyBjb25zdCBNMTMgPSAyOyBjb25zdCBNMTQgPSAzXG5jb25zdCBNMjEgPSA0OyBjb25zdCBNMjIgPSA1OyBjb25zdCBNMjMgPSA2OyBjb25zdCBNMjQgPSA3XG5jb25zdCBNMzEgPSA4OyBjb25zdCBNMzIgPSA5OyBjb25zdCBNMzMgPSAxMDsgY29uc3QgTTM0ID0gMTFcbmNvbnN0IE00MSA9IDEyOyBjb25zdCBNNDIgPSAxMzsgY29uc3QgTTQzID0gMTQ7IGNvbnN0IE00NCA9IDE1XG5cbmNvbnN0IERFR1JFRV9QRVJfUkFEID0gMTgwIC8gTWF0aC5QSVxuY29uc3QgUkFEX1BFUl9ERUdSRUUgPSBNYXRoLlBJIC8gMTgwXG5cbmZ1bmN0aW9uIHBhcnNlTWF0cml4IChpbml0KSB7XG4gIGxldCBwYXJzZWQgPSBpbml0LnJlcGxhY2UoJ21hdHJpeCgnLCAnJylcbiAgcGFyc2VkID0gcGFyc2VkLnNwbGl0KCcsJywgNykgLy8gNiArIDEgdG8gaGFuZGxlIHRvbyBtYW55IHBhcmFtc1xuICBpZiAocGFyc2VkLmxlbmd0aCAhPT0gNikgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgJHtpbml0fWApXG4gIHBhcnNlZCA9IHBhcnNlZC5tYXAocGFyc2VGbG9hdClcbiAgcmV0dXJuIFtcbiAgICBwYXJzZWRbMF0sIHBhcnNlZFsxXSwgMCwgMCxcbiAgICBwYXJzZWRbMl0sIHBhcnNlZFszXSwgMCwgMCxcbiAgICAwLCAwLCAxLCAwLFxuICAgIHBhcnNlZFs0XSwgcGFyc2VkWzVdLCAwLCAxXG4gIF1cbn1cblxuZnVuY3Rpb24gcGFyc2VNYXRyaXgzZCAoaW5pdCkge1xuICBsZXQgcGFyc2VkID0gaW5pdC5yZXBsYWNlKCdtYXRyaXgzZCgnLCAnJylcbiAgcGFyc2VkID0gcGFyc2VkLnNwbGl0KCcsJywgMTcpIC8vIDE2ICsgMSB0byBoYW5kbGUgdG9vIG1hbnkgcGFyYW1zXG4gIGlmIChwYXJzZWQubGVuZ3RoICE9PSAxNikgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2UgJHtpbml0fWApXG4gIHJldHVybiBwYXJzZWQubWFwKHBhcnNlRmxvYXQpXG59XG5cbmZ1bmN0aW9uIHBhcnNlVHJhbnNmb3JtICh0Zm9ybSkge1xuICBjb25zdCB0eXBlID0gdGZvcm0uc3BsaXQoJygnLCAxKVswXVxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdtYXRyaXgnOlxuICAgICAgcmV0dXJuIHBhcnNlTWF0cml4KHRmb3JtKVxuICAgIGNhc2UgJ21hdHJpeDNkJzpcbiAgICAgIHJldHVybiBwYXJzZU1hdHJpeDNkKHRmb3JtKVxuICAgIC8vIFRPRE8gVGhpcyBpcyBzdXBwb3NlZCB0byBzdXBwb3J0IGFueSBDU1MgdHJhbnNmb3JtIHZhbHVlLlxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dHlwZX0gcGFyc2luZyBub3QgaW1wbGVtZW50ZWRgKVxuICB9XG59XG5cbmNsYXNzIERPTU1hdHJpeCB7XG4gIGNvbnN0cnVjdG9yIChpbml0KSB7XG4gICAgdGhpcy5faXMyRCA9IHRydWVcbiAgICB0aGlzLl92YWx1ZXMgPSBuZXcgRmxvYXQ2NEFycmF5KFtcbiAgICAgIDEsIDAsIDAsIDAsXG4gICAgICAwLCAxLCAwLCAwLFxuICAgICAgMCwgMCwgMSwgMCxcbiAgICAgIDAsIDAsIDAsIDFcbiAgICBdKVxuXG4gICAgbGV0IGlcblxuICAgIGlmICh0eXBlb2YgaW5pdCA9PT0gJ3N0cmluZycpIHsgLy8gcGFyc2UgQ1NTIHRyYW5zZm9ybUxpc3RcbiAgICAgIGlmIChpbml0ID09PSAnJykgcmV0dXJuIC8vIGRlZmF1bHQgaWRlbnRpdHkgbWF0cml4XG4gICAgICBjb25zdCB0Zm9ybXMgPSBpbml0LnNwbGl0KC9cXClcXHMrLywgMjApLm1hcChwYXJzZVRyYW5zZm9ybSlcbiAgICAgIGlmICh0Zm9ybXMubGVuZ3RoID09PSAwKSByZXR1cm5cbiAgICAgIGluaXQgPSB0Zm9ybXNbMF1cbiAgICAgIGZvciAoaSA9IDE7IGkgPCB0Zm9ybXMubGVuZ3RoOyBpKyspIGluaXQgPSBtdWx0aXBseSh0Zm9ybXNbaV0sIGluaXQpXG4gICAgfVxuXG4gICAgaSA9IDBcbiAgICBpZiAoaW5pdCAmJiBpbml0Lmxlbmd0aCA9PT0gNikge1xuICAgICAgc2V0TnVtYmVyMkQodGhpcywgTTExLCBpbml0W2krK10pXG4gICAgICBzZXROdW1iZXIyRCh0aGlzLCBNMTIsIGluaXRbaSsrXSlcbiAgICAgIHNldE51bWJlcjJEKHRoaXMsIE0yMSwgaW5pdFtpKytdKVxuICAgICAgc2V0TnVtYmVyMkQodGhpcywgTTIyLCBpbml0W2krK10pXG4gICAgICBzZXROdW1iZXIyRCh0aGlzLCBNNDEsIGluaXRbaSsrXSlcbiAgICAgIHNldE51bWJlcjJEKHRoaXMsIE00MiwgaW5pdFtpKytdKVxuICAgIH0gZWxzZSBpZiAoaW5pdCAmJiBpbml0Lmxlbmd0aCA9PT0gMTYpIHtcbiAgICAgIHNldE51bWJlcjJEKHRoaXMsIE0xMSwgaW5pdFtpKytdKVxuICAgICAgc2V0TnVtYmVyMkQodGhpcywgTTEyLCBpbml0W2krK10pXG4gICAgICBzZXROdW1iZXIzRCh0aGlzLCBNMTMsIGluaXRbaSsrXSlcbiAgICAgIHNldE51bWJlcjNEKHRoaXMsIE0xNCwgaW5pdFtpKytdKVxuICAgICAgc2V0TnVtYmVyMkQodGhpcywgTTIxLCBpbml0W2krK10pXG4gICAgICBzZXROdW1iZXIyRCh0aGlzLCBNMjIsIGluaXRbaSsrXSlcbiAgICAgIHNldE51bWJlcjNEKHRoaXMsIE0yMywgaW5pdFtpKytdKVxuICAgICAgc2V0TnVtYmVyM0QodGhpcywgTTI0LCBpbml0W2krK10pXG4gICAgICBzZXROdW1iZXIzRCh0aGlzLCBNMzEsIGluaXRbaSsrXSlcbiAgICAgIHNldE51bWJlcjNEKHRoaXMsIE0zMiwgaW5pdFtpKytdKVxuICAgICAgc2V0TnVtYmVyM0QodGhpcywgTTMzLCBpbml0W2krK10pXG4gICAgICBzZXROdW1iZXIzRCh0aGlzLCBNMzQsIGluaXRbaSsrXSlcbiAgICAgIHNldE51bWJlcjJEKHRoaXMsIE00MSwgaW5pdFtpKytdKVxuICAgICAgc2V0TnVtYmVyMkQodGhpcywgTTQyLCBpbml0W2krK10pXG4gICAgICBzZXROdW1iZXIzRCh0aGlzLCBNNDMsIGluaXRbaSsrXSlcbiAgICAgIHNldE51bWJlcjNEKHRoaXMsIE00NCwgaW5pdFtpXSlcbiAgICB9IGVsc2UgaWYgKGluaXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgc3RyaW5nIG9yIGFycmF5LicpXG4gICAgfVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLmlzMkRcbiAgICAgID8gYG1hdHJpeCgke3RoaXMuYX0sICR7dGhpcy5ifSwgJHt0aGlzLmN9LCAke3RoaXMuZH0sICR7dGhpcy5lfSwgJHt0aGlzLmZ9KWBcbiAgICAgIDogYG1hdHJpeDNkKCR7dGhpcy5fdmFsdWVzLmpvaW4oJywgJyl9KWBcbiAgfVxuXG4gIG11bHRpcGx5IChvdGhlcikge1xuICAgIHJldHVybiBuZXdJbnN0YW5jZSh0aGlzLl92YWx1ZXMpLm11bHRpcGx5U2VsZihvdGhlcilcbiAgfVxuXG4gIG11bHRpcGx5U2VsZiAob3RoZXIpIHtcbiAgICB0aGlzLl92YWx1ZXMgPSBtdWx0aXBseShvdGhlci5fdmFsdWVzLCB0aGlzLl92YWx1ZXMpXG4gICAgaWYgKCFvdGhlci5pczJEKSB0aGlzLl9pczJEID0gZmFsc2VcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJlTXVsdGlwbHlTZWxmIChvdGhlcikge1xuICAgIHRoaXMuX3ZhbHVlcyA9IG11bHRpcGx5KHRoaXMuX3ZhbHVlcywgb3RoZXIuX3ZhbHVlcylcbiAgICBpZiAoIW90aGVyLmlzMkQpIHRoaXMuX2lzMkQgPSBmYWxzZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0cmFuc2xhdGUgKHR4LCB0eSwgdHopIHtcbiAgICByZXR1cm4gbmV3SW5zdGFuY2UodGhpcy5fdmFsdWVzKS50cmFuc2xhdGVTZWxmKHR4LCB0eSwgdHopXG4gIH1cblxuICB0cmFuc2xhdGVTZWxmICh0eCwgdHksIHR6KSB7XG4gICAgaWYgKHR5cGVvZiB0eCAhPT0gJ251bWJlcicpIHR4ID0gMFxuICAgIGlmICh0eXBlb2YgdHkgIT09ICdudW1iZXInKSB0eSA9IDBcbiAgICBpZiAodHlwZW9mIHR6ICE9PSAnbnVtYmVyJykgdHogPSAwXG4gICAgdGhpcy5fdmFsdWVzID0gbXVsdGlwbHkoW1xuICAgICAgMSwgMCwgMCwgMCxcbiAgICAgIDAsIDEsIDAsIDAsXG4gICAgICAwLCAwLCAxLCAwLFxuICAgICAgdHgsIHR5LCB0eiwgMVxuICAgIF0sIHRoaXMuX3ZhbHVlcylcbiAgICBpZiAodHogIT09IDApIHRoaXMuX2lzMkQgPSBmYWxzZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzY2FsZSAoc2NhbGVYLCBzY2FsZVksIHNjYWxlWiwgb3JpZ2luWCwgb3JpZ2luWSwgb3JpZ2luWikge1xuICAgIHJldHVybiBuZXdJbnN0YW5jZSh0aGlzLl92YWx1ZXMpLnNjYWxlU2VsZihzY2FsZVgsIHNjYWxlWSwgc2NhbGVaLCBvcmlnaW5YLCBvcmlnaW5ZLCBvcmlnaW5aKVxuICB9XG5cbiAgc2NhbGUzZCAoc2NhbGUsIG9yaWdpblgsIG9yaWdpblksIG9yaWdpblopIHtcbiAgICByZXR1cm4gbmV3SW5zdGFuY2UodGhpcy5fdmFsdWVzKS5zY2FsZTNkU2VsZihzY2FsZSwgb3JpZ2luWCwgb3JpZ2luWSwgb3JpZ2luWilcbiAgfVxuXG4gIHNjYWxlM2RTZWxmIChzY2FsZSwgb3JpZ2luWCwgb3JpZ2luWSwgb3JpZ2luWikge1xuICAgIHJldHVybiB0aGlzLnNjYWxlU2VsZihzY2FsZSwgc2NhbGUsIHNjYWxlLCBvcmlnaW5YLCBvcmlnaW5ZLCBvcmlnaW5aKVxuICB9XG5cbiAgc2NhbGVTZWxmIChzY2FsZVgsIHNjYWxlWSwgc2NhbGVaLCBvcmlnaW5YLCBvcmlnaW5ZLCBvcmlnaW5aKSB7XG4gICAgLy8gTm90IHJlZHVuZGFudCB3aXRoIHRyYW5zbGF0ZSdzIGNoZWNrcyBiZWNhdXNlIHdlIG5lZWQgdG8gbmVnYXRlIHRoZSB2YWx1ZXMgbGF0ZXIuXG4gICAgaWYgKHR5cGVvZiBvcmlnaW5YICE9PSAnbnVtYmVyJykgb3JpZ2luWCA9IDBcbiAgICBpZiAodHlwZW9mIG9yaWdpblkgIT09ICdudW1iZXInKSBvcmlnaW5ZID0gMFxuICAgIGlmICh0eXBlb2Ygb3JpZ2luWiAhPT0gJ251bWJlcicpIG9yaWdpblogPSAwXG4gICAgdGhpcy50cmFuc2xhdGVTZWxmKG9yaWdpblgsIG9yaWdpblksIG9yaWdpblopXG4gICAgaWYgKHR5cGVvZiBzY2FsZVggIT09ICdudW1iZXInKSBzY2FsZVggPSAxXG4gICAgaWYgKHR5cGVvZiBzY2FsZVkgIT09ICdudW1iZXInKSBzY2FsZVkgPSBzY2FsZVhcbiAgICBpZiAodHlwZW9mIHNjYWxlWiAhPT0gJ251bWJlcicpIHNjYWxlWiA9IDFcbiAgICB0aGlzLl92YWx1ZXMgPSBtdWx0aXBseShbXG4gICAgICBzY2FsZVgsIDAsIDAsIDAsXG4gICAgICAwLCBzY2FsZVksIDAsIDAsXG4gICAgICAwLCAwLCBzY2FsZVosIDAsXG4gICAgICAwLCAwLCAwLCAxXG4gICAgXSwgdGhpcy5fdmFsdWVzKVxuICAgIHRoaXMudHJhbnNsYXRlU2VsZigtb3JpZ2luWCwgLW9yaWdpblksIC1vcmlnaW5aKVxuICAgIGlmIChzY2FsZVogIT09IDEgfHwgb3JpZ2luWiAhPT0gMCkgdGhpcy5faXMyRCA9IGZhbHNlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHJvdGF0ZUZyb21WZWN0b3IgKHgsIHkpIHtcbiAgICByZXR1cm4gbmV3SW5zdGFuY2UodGhpcy5fdmFsdWVzKS5yb3RhdGVGcm9tVmVjdG9yU2VsZih4LCB5KVxuICB9XG5cbiAgcm90YXRlRnJvbVZlY3RvclNlbGYgKHgsIHkpIHtcbiAgICBpZiAodHlwZW9mIHggIT09ICdudW1iZXInKSB4ID0gMFxuICAgIGlmICh0eXBlb2YgeSAhPT0gJ251bWJlcicpIHkgPSAwXG4gICAgY29uc3QgdGhldGEgPSAoeCA9PT0gMCAmJiB5ID09PSAwKSA/IDAgOiBNYXRoLmF0YW4yKHksIHgpICogREVHUkVFX1BFUl9SQURcbiAgICByZXR1cm4gdGhpcy5yb3RhdGVTZWxmKHRoZXRhKVxuICB9XG5cbiAgcm90YXRlIChyb3RYLCByb3RZLCByb3RaKSB7XG4gICAgcmV0dXJuIG5ld0luc3RhbmNlKHRoaXMuX3ZhbHVlcykucm90YXRlU2VsZihyb3RYLCByb3RZLCByb3RaKVxuICB9XG5cbiAgcm90YXRlU2VsZiAocm90WCwgcm90WSwgcm90Wikge1xuICAgIGlmIChyb3RZID09PSB1bmRlZmluZWQgJiYgcm90WiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByb3RaID0gcm90WFxuICAgICAgcm90WCA9IHJvdFkgPSAwXG4gICAgfVxuICAgIGlmICh0eXBlb2Ygcm90WSAhPT0gJ251bWJlcicpIHJvdFkgPSAwXG4gICAgaWYgKHR5cGVvZiByb3RaICE9PSAnbnVtYmVyJykgcm90WiA9IDBcbiAgICBpZiAocm90WCAhPT0gMCB8fCByb3RZICE9PSAwKSB0aGlzLl9pczJEID0gZmFsc2VcbiAgICByb3RYICo9IFJBRF9QRVJfREVHUkVFXG4gICAgcm90WSAqPSBSQURfUEVSX0RFR1JFRVxuICAgIHJvdFogKj0gUkFEX1BFUl9ERUdSRUVcbiAgICBsZXQgYywgc1xuICAgIGMgPSBNYXRoLmNvcyhyb3RaKVxuICAgIHMgPSBNYXRoLnNpbihyb3RaKVxuICAgIHRoaXMuX3ZhbHVlcyA9IG11bHRpcGx5KFtcbiAgICAgIGMsIHMsIDAsIDAsXG4gICAgICAtcywgYywgMCwgMCxcbiAgICAgIDAsIDAsIDEsIDAsXG4gICAgICAwLCAwLCAwLCAxXG4gICAgXSwgdGhpcy5fdmFsdWVzKVxuICAgIGMgPSBNYXRoLmNvcyhyb3RZKVxuICAgIHMgPSBNYXRoLnNpbihyb3RZKVxuICAgIHRoaXMuX3ZhbHVlcyA9IG11bHRpcGx5KFtcbiAgICAgIGMsIDAsIC1zLCAwLFxuICAgICAgMCwgMSwgMCwgMCxcbiAgICAgIHMsIDAsIGMsIDAsXG4gICAgICAwLCAwLCAwLCAxXG4gICAgXSwgdGhpcy5fdmFsdWVzKVxuICAgIGMgPSBNYXRoLmNvcyhyb3RYKVxuICAgIHMgPSBNYXRoLnNpbihyb3RYKVxuICAgIHRoaXMuX3ZhbHVlcyA9IG11bHRpcGx5KFtcbiAgICAgIDEsIDAsIDAsIDAsXG4gICAgICAwLCBjLCBzLCAwLFxuICAgICAgMCwgLXMsIGMsIDAsXG4gICAgICAwLCAwLCAwLCAxXG4gICAgXSwgdGhpcy5fdmFsdWVzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICByb3RhdGVBeGlzQW5nbGUgKHgsIHksIHosIGFuZ2xlKSB7XG4gICAgcmV0dXJuIG5ld0luc3RhbmNlKHRoaXMuX3ZhbHVlcykucm90YXRlQXhpc0FuZ2xlU2VsZih4LCB5LCB6LCBhbmdsZSlcbiAgfVxuXG4gIHJvdGF0ZUF4aXNBbmdsZVNlbGYgKHgsIHksIHosIGFuZ2xlKSB7XG4gICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykgeCA9IDBcbiAgICBpZiAodHlwZW9mIHkgIT09ICdudW1iZXInKSB5ID0gMFxuICAgIGlmICh0eXBlb2YgeiAhPT0gJ251bWJlcicpIHogPSAwXG4gICAgLy8gTm9ybWFsaXplIGF4aXNcbiAgICBjb25zdCBsZW5ndGggPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KVxuICAgIGlmIChsZW5ndGggPT09IDApIHJldHVybiB0aGlzXG4gICAgaWYgKGxlbmd0aCAhPT0gMSkge1xuICAgICAgeCAvPSBsZW5ndGhcbiAgICAgIHkgLz0gbGVuZ3RoXG4gICAgICB6IC89IGxlbmd0aFxuICAgIH1cbiAgICBhbmdsZSAqPSBSQURfUEVSX0RFR1JFRVxuICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhhbmdsZSlcbiAgICBjb25zdCBzID0gTWF0aC5zaW4oYW5nbGUpXG4gICAgY29uc3QgdCA9IDEgLSBjXG4gICAgY29uc3QgdHggPSB0ICogeFxuICAgIGNvbnN0IHR5ID0gdCAqIHlcbiAgICAvLyBOQjogVGhpcyBpcyB0aGUgZ2VuZXJpYyB0cmFuc2Zvcm0uIElmIHRoZSBheGlzIGlzIGEgbWFqb3IgYXhpcywgdGhlcmUgYXJlXG4gICAgLy8gZmFzdGVyIHRyYW5zZm9ybXMuXG4gICAgdGhpcy5fdmFsdWVzID0gbXVsdGlwbHkoW1xuICAgICAgdHggKiB4ICsgYywgdHggKiB5ICsgcyAqIHosIHR4ICogeiAtIHMgKiB5LCAwLFxuICAgICAgdHggKiB5IC0gcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiArIHMgKiB4LCAwLFxuICAgICAgdHggKiB6ICsgcyAqIHksIHR5ICogeiAtIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxuICAgICAgMCwgMCwgMCwgMVxuICAgIF0sIHRoaXMuX3ZhbHVlcylcbiAgICBpZiAoeCAhPT0gMCB8fCB5ICE9PSAwKSB0aGlzLl9pczJEID0gZmFsc2VcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc2tld1ggKHN4KSB7XG4gICAgcmV0dXJuIG5ld0luc3RhbmNlKHRoaXMuX3ZhbHVlcykuc2tld1hTZWxmKHN4KVxuICB9XG5cbiAgc2tld1hTZWxmIChzeCkge1xuICAgIGlmICh0eXBlb2Ygc3ggIT09ICdudW1iZXInKSByZXR1cm4gdGhpc1xuICAgIGNvbnN0IHQgPSBNYXRoLnRhbihzeCAqIFJBRF9QRVJfREVHUkVFKVxuICAgIHRoaXMuX3ZhbHVlcyA9IG11bHRpcGx5KFtcbiAgICAgIDEsIDAsIDAsIDAsXG4gICAgICB0LCAxLCAwLCAwLFxuICAgICAgMCwgMCwgMSwgMCxcbiAgICAgIDAsIDAsIDAsIDFcbiAgICBdLCB0aGlzLl92YWx1ZXMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHNrZXdZIChzeSkge1xuICAgIHJldHVybiBuZXdJbnN0YW5jZSh0aGlzLl92YWx1ZXMpLnNrZXdZU2VsZihzeSlcbiAgfVxuXG4gIHNrZXdZU2VsZiAoc3kpIHtcbiAgICBpZiAodHlwZW9mIHN5ICE9PSAnbnVtYmVyJykgcmV0dXJuIHRoaXNcbiAgICBjb25zdCB0ID0gTWF0aC50YW4oc3kgKiBSQURfUEVSX0RFR1JFRSlcbiAgICB0aGlzLl92YWx1ZXMgPSBtdWx0aXBseShbXG4gICAgICAxLCB0LCAwLCAwLFxuICAgICAgMCwgMSwgMCwgMCxcbiAgICAgIDAsIDAsIDEsIDAsXG4gICAgICAwLCAwLCAwLCAxXG4gICAgXSwgdGhpcy5fdmFsdWVzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBmbGlwWCAoKSB7XG4gICAgcmV0dXJuIG5ld0luc3RhbmNlKG11bHRpcGx5KFtcbiAgICAgIC0xLCAwLCAwLCAwLFxuICAgICAgMCwgMSwgMCwgMCxcbiAgICAgIDAsIDAsIDEsIDAsXG4gICAgICAwLCAwLCAwLCAxXG4gICAgXSwgdGhpcy5fdmFsdWVzKSlcbiAgfVxuXG4gIGZsaXBZICgpIHtcbiAgICByZXR1cm4gbmV3SW5zdGFuY2UobXVsdGlwbHkoW1xuICAgICAgMSwgMCwgMCwgMCxcbiAgICAgIDAsIC0xLCAwLCAwLFxuICAgICAgMCwgMCwgMSwgMCxcbiAgICAgIDAsIDAsIDAsIDFcbiAgICBdLCB0aGlzLl92YWx1ZXMpKVxuICB9XG5cbiAgaW52ZXJzZSAoKSB7XG4gICAgcmV0dXJuIG5ld0luc3RhbmNlKHRoaXMuX3ZhbHVlcykuaW52ZXJ0U2VsZigpXG4gIH1cblxuICBpbnZlcnRTZWxmICgpIHtcbiAgICBjb25zdCBtID0gdGhpcy5fdmFsdWVzXG4gICAgY29uc3QgaW52ID0gbS5tYXAodiA9PiAwKVxuXG4gICAgaW52WzBdID0gbVs1XSAqIG1bMTBdICogbVsxNV0gLVxuICAgICAgICAgICAgbVs1XSAqIG1bMTFdICogbVsxNF0gLVxuICAgICAgICAgICAgbVs5XSAqIG1bNl0gKiBtWzE1XSArXG4gICAgICAgICAgICBtWzldICogbVs3XSAqIG1bMTRdICtcbiAgICAgICAgICAgIG1bMTNdICogbVs2XSAqIG1bMTFdIC1cbiAgICAgICAgICAgIG1bMTNdICogbVs3XSAqIG1bMTBdXG5cbiAgICBpbnZbNF0gPSAtbVs0XSAqIG1bMTBdICogbVsxNV0gK1xuICAgICAgICAgICAgbVs0XSAqIG1bMTFdICogbVsxNF0gK1xuICAgICAgICAgICAgbVs4XSAqIG1bNl0gKiBtWzE1XSAtXG4gICAgICAgICAgICBtWzhdICogbVs3XSAqIG1bMTRdIC1cbiAgICAgICAgICAgIG1bMTJdICogbVs2XSAqIG1bMTFdICtcbiAgICAgICAgICAgIG1bMTJdICogbVs3XSAqIG1bMTBdXG5cbiAgICBpbnZbOF0gPSBtWzRdICogbVs5XSAqIG1bMTVdIC1cbiAgICAgICAgICAgIG1bNF0gKiBtWzExXSAqIG1bMTNdIC1cbiAgICAgICAgICAgIG1bOF0gKiBtWzVdICogbVsxNV0gK1xuICAgICAgICAgICAgbVs4XSAqIG1bN10gKiBtWzEzXSArXG4gICAgICAgICAgICBtWzEyXSAqIG1bNV0gKiBtWzExXSAtXG4gICAgICAgICAgICBtWzEyXSAqIG1bN10gKiBtWzldXG5cbiAgICBpbnZbMTJdID0gLW1bNF0gKiBtWzldICogbVsxNF0gK1xuICAgICAgICAgICAgbVs0XSAqIG1bMTBdICogbVsxM10gK1xuICAgICAgICAgICAgbVs4XSAqIG1bNV0gKiBtWzE0XSAtXG4gICAgICAgICAgICBtWzhdICogbVs2XSAqIG1bMTNdIC1cbiAgICAgICAgICAgIG1bMTJdICogbVs1XSAqIG1bMTBdICtcbiAgICAgICAgICAgIG1bMTJdICogbVs2XSAqIG1bOV1cblxuICAgIC8vIElmIHRoZSBkZXRlcm1pbmFudCBpcyB6ZXJvLCB0aGlzIG1hdHJpeCBjYW5ub3QgYmUgaW52ZXJ0ZWQsIGFuZCBhbGxcbiAgICAvLyB2YWx1ZXMgc2hvdWxkIGJlIHNldCB0byBOYU4sIHdpdGggdGhlIGlzMkQgZmxhZyBzZXQgdG8gZmFsc2UuXG5cbiAgICBjb25zdCBkZXQgPSBtWzBdICogaW52WzBdICsgbVsxXSAqIGludls0XSArIG1bMl0gKiBpbnZbOF0gKyBtWzNdICogaW52WzEyXVxuXG4gICAgaWYgKGRldCA9PT0gMCkge1xuICAgICAgdGhpcy5fdmFsdWVzID0gbS5tYXAodiA9PiBOYU4pXG4gICAgICB0aGlzLl9pczJEID0gZmFsc2VcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgaW52WzFdID0gLW1bMV0gKiBtWzEwXSAqIG1bMTVdICtcbiAgICAgICAgICAgIG1bMV0gKiBtWzExXSAqIG1bMTRdICtcbiAgICAgICAgICAgIG1bOV0gKiBtWzJdICogbVsxNV0gLVxuICAgICAgICAgICAgbVs5XSAqIG1bM10gKiBtWzE0XSAtXG4gICAgICAgICAgICBtWzEzXSAqIG1bMl0gKiBtWzExXSArXG4gICAgICAgICAgICBtWzEzXSAqIG1bM10gKiBtWzEwXVxuXG4gICAgaW52WzVdID0gbVswXSAqIG1bMTBdICogbVsxNV0gLVxuICAgICAgICAgICAgbVswXSAqIG1bMTFdICogbVsxNF0gLVxuICAgICAgICAgICAgbVs4XSAqIG1bMl0gKiBtWzE1XSArXG4gICAgICAgICAgICBtWzhdICogbVszXSAqIG1bMTRdICtcbiAgICAgICAgICAgIG1bMTJdICogbVsyXSAqIG1bMTFdIC1cbiAgICAgICAgICAgIG1bMTJdICogbVszXSAqIG1bMTBdXG5cbiAgICBpbnZbOV0gPSAtbVswXSAqIG1bOV0gKiBtWzE1XSArXG4gICAgICAgICAgICBtWzBdICogbVsxMV0gKiBtWzEzXSArXG4gICAgICAgICAgICBtWzhdICogbVsxXSAqIG1bMTVdIC1cbiAgICAgICAgICAgIG1bOF0gKiBtWzNdICogbVsxM10gLVxuICAgICAgICAgICAgbVsxMl0gKiBtWzFdICogbVsxMV0gK1xuICAgICAgICAgICAgbVsxMl0gKiBtWzNdICogbVs5XVxuXG4gICAgaW52WzEzXSA9IG1bMF0gKiBtWzldICogbVsxNF0gLVxuICAgICAgICAgICAgbVswXSAqIG1bMTBdICogbVsxM10gLVxuICAgICAgICAgICAgbVs4XSAqIG1bMV0gKiBtWzE0XSArXG4gICAgICAgICAgICBtWzhdICogbVsyXSAqIG1bMTNdICtcbiAgICAgICAgICAgIG1bMTJdICogbVsxXSAqIG1bMTBdIC1cbiAgICAgICAgICAgIG1bMTJdICogbVsyXSAqIG1bOV1cblxuICAgIGludlsyXSA9IG1bMV0gKiBtWzZdICogbVsxNV0gLVxuICAgICAgICAgICAgbVsxXSAqIG1bN10gKiBtWzE0XSAtXG4gICAgICAgICAgICBtWzVdICogbVsyXSAqIG1bMTVdICtcbiAgICAgICAgICAgIG1bNV0gKiBtWzNdICogbVsxNF0gK1xuICAgICAgICAgICAgbVsxM10gKiBtWzJdICogbVs3XSAtXG4gICAgICAgICAgICBtWzEzXSAqIG1bM10gKiBtWzZdXG5cbiAgICBpbnZbNl0gPSAtbVswXSAqIG1bNl0gKiBtWzE1XSArXG4gICAgICAgICAgICBtWzBdICogbVs3XSAqIG1bMTRdICtcbiAgICAgICAgICAgIG1bNF0gKiBtWzJdICogbVsxNV0gLVxuICAgICAgICAgICAgbVs0XSAqIG1bM10gKiBtWzE0XSAtXG4gICAgICAgICAgICBtWzEyXSAqIG1bMl0gKiBtWzddICtcbiAgICAgICAgICAgIG1bMTJdICogbVszXSAqIG1bNl1cblxuICAgIGludlsxMF0gPSBtWzBdICogbVs1XSAqIG1bMTVdIC1cbiAgICAgICAgICAgIG1bMF0gKiBtWzddICogbVsxM10gLVxuICAgICAgICAgICAgbVs0XSAqIG1bMV0gKiBtWzE1XSArXG4gICAgICAgICAgICBtWzRdICogbVszXSAqIG1bMTNdICtcbiAgICAgICAgICAgIG1bMTJdICogbVsxXSAqIG1bN10gLVxuICAgICAgICAgICAgbVsxMl0gKiBtWzNdICogbVs1XVxuXG4gICAgaW52WzE0XSA9IC1tWzBdICogbVs1XSAqIG1bMTRdICtcbiAgICAgICAgICAgIG1bMF0gKiBtWzZdICogbVsxM10gK1xuICAgICAgICAgICAgbVs0XSAqIG1bMV0gKiBtWzE0XSAtXG4gICAgICAgICAgICBtWzRdICogbVsyXSAqIG1bMTNdIC1cbiAgICAgICAgICAgIG1bMTJdICogbVsxXSAqIG1bNl0gK1xuICAgICAgICAgICAgbVsxMl0gKiBtWzJdICogbVs1XVxuXG4gICAgaW52WzNdID0gLW1bMV0gKiBtWzZdICogbVsxMV0gK1xuICAgICAgICAgICAgbVsxXSAqIG1bN10gKiBtWzEwXSArXG4gICAgICAgICAgICBtWzVdICogbVsyXSAqIG1bMTFdIC1cbiAgICAgICAgICAgIG1bNV0gKiBtWzNdICogbVsxMF0gLVxuICAgICAgICAgICAgbVs5XSAqIG1bMl0gKiBtWzddICtcbiAgICAgICAgICAgIG1bOV0gKiBtWzNdICogbVs2XVxuXG4gICAgaW52WzddID0gbVswXSAqIG1bNl0gKiBtWzExXSAtXG4gICAgICAgICAgICBtWzBdICogbVs3XSAqIG1bMTBdIC1cbiAgICAgICAgICAgIG1bNF0gKiBtWzJdICogbVsxMV0gK1xuICAgICAgICAgICAgbVs0XSAqIG1bM10gKiBtWzEwXSArXG4gICAgICAgICAgICBtWzhdICogbVsyXSAqIG1bN10gLVxuICAgICAgICAgICAgbVs4XSAqIG1bM10gKiBtWzZdXG5cbiAgICBpbnZbMTFdID0gLW1bMF0gKiBtWzVdICogbVsxMV0gK1xuICAgICAgICAgICAgbVswXSAqIG1bN10gKiBtWzldICtcbiAgICAgICAgICAgIG1bNF0gKiBtWzFdICogbVsxMV0gLVxuICAgICAgICAgICAgbVs0XSAqIG1bM10gKiBtWzldIC1cbiAgICAgICAgICAgIG1bOF0gKiBtWzFdICogbVs3XSArXG4gICAgICAgICAgICBtWzhdICogbVszXSAqIG1bNV1cblxuICAgIGludlsxNV0gPSBtWzBdICogbVs1XSAqIG1bMTBdIC1cbiAgICAgICAgICAgIG1bMF0gKiBtWzZdICogbVs5XSAtXG4gICAgICAgICAgICBtWzRdICogbVsxXSAqIG1bMTBdICtcbiAgICAgICAgICAgIG1bNF0gKiBtWzJdICogbVs5XSArXG4gICAgICAgICAgICBtWzhdICogbVsxXSAqIG1bNl0gLVxuICAgICAgICAgICAgbVs4XSAqIG1bMl0gKiBtWzVdXG5cbiAgICBpbnYuZm9yRWFjaCgodiwgaSkgPT4geyBpbnZbaV0gPSB2IC8gZGV0IH0pXG4gICAgdGhpcy5fdmFsdWVzID0gaW52XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHNldE1hdHJpeFZhbHVlICh0cmFuc2Zvcm1MaXN0KSB7XG4gICAgY29uc3QgdGVtcCA9IG5ldyBET01NYXRyaXgodHJhbnNmb3JtTGlzdClcbiAgICB0aGlzLl92YWx1ZXMgPSB0ZW1wLl92YWx1ZXNcbiAgICB0aGlzLl9pczJEID0gdGVtcC5faXMyRFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB0cmFuc2Zvcm1Qb2ludCAocG9pbnQpIHtcbiAgICBwb2ludCA9IG5ldyBET01Qb2ludChwb2ludClcbiAgICBjb25zdCB4ID0gcG9pbnQueFxuICAgIGNvbnN0IHkgPSBwb2ludC55XG4gICAgY29uc3QgeiA9IHBvaW50LnpcbiAgICBjb25zdCB3ID0gcG9pbnQud1xuICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMuX3ZhbHVlc1xuICAgIGNvbnN0IG54ID0gdmFsdWVzW00xMV0gKiB4ICsgdmFsdWVzW00yMV0gKiB5ICsgdmFsdWVzW00zMV0gKiB6ICsgdmFsdWVzW000MV0gKiB3XG4gICAgY29uc3QgbnkgPSB2YWx1ZXNbTTEyXSAqIHggKyB2YWx1ZXNbTTIyXSAqIHkgKyB2YWx1ZXNbTTMyXSAqIHogKyB2YWx1ZXNbTTQyXSAqIHdcbiAgICBjb25zdCBueiA9IHZhbHVlc1tNMTNdICogeCArIHZhbHVlc1tNMjNdICogeSArIHZhbHVlc1tNMzNdICogeiArIHZhbHVlc1tNNDNdICogd1xuICAgIGNvbnN0IG53ID0gdmFsdWVzW00xNF0gKiB4ICsgdmFsdWVzW00yNF0gKiB5ICsgdmFsdWVzW00zNF0gKiB6ICsgdmFsdWVzW000NF0gKiB3XG4gICAgcmV0dXJuIG5ldyBET01Qb2ludChueCwgbnksIG56LCBudylcbiAgfVxuXG4gIHRvRmxvYXQzMkFycmF5ICgpIHtcbiAgICByZXR1cm4gRmxvYXQzMkFycmF5LmZyb20odGhpcy5fdmFsdWVzKVxuICB9XG5cbiAgdG9GbG9hdDY0QXJyYXkgKCkge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZXMuc2xpY2UoMClcbiAgfVxuXG4gIHN0YXRpYyBmcm9tTWF0cml4IChpbml0KSB7XG4gICAgaWYgKCEoaW5pdCBpbnN0YW5jZW9mIERPTU1hdHJpeCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIERPTU1hdHJpeCcpXG4gICAgcmV0dXJuIG5ldyBET01NYXRyaXgoaW5pdC5fdmFsdWVzKVxuICB9XG5cbiAgc3RhdGljIGZyb21GbG9hdDMyQXJyYXkgKGluaXQpIHtcbiAgICBpZiAoIShpbml0IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgRmxvYXQzMkFycmF5JylcbiAgICByZXR1cm4gbmV3IERPTU1hdHJpeChpbml0KVxuICB9XG5cbiAgc3RhdGljIGZyb21GbG9hdDY0QXJyYXkgKGluaXQpIHtcbiAgICBpZiAoIShpbml0IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgRmxvYXQ2NEFycmF5JylcbiAgICByZXR1cm4gbmV3IERPTU1hdHJpeChpbml0KVxuICB9XG5cbiAgW3V0aWwuaW5zcGVjdC5jdXN0b20gfHwgJ2luc3BlY3QnXSAoZGVwdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoZGVwdGggPCAwKSByZXR1cm4gJ1tET01NYXRyaXhdJ1xuXG4gICAgcmV0dXJuIGBET01NYXRyaXggW1xuICAgICAgYTogJHt0aGlzLmF9XG4gICAgICBiOiAke3RoaXMuYn1cbiAgICAgIGM6ICR7dGhpcy5jfVxuICAgICAgZDogJHt0aGlzLmR9XG4gICAgICBlOiAke3RoaXMuZX1cbiAgICAgIGY6ICR7dGhpcy5mfVxuICAgICAgbTExOiAke3RoaXMubTExfVxuICAgICAgbTEyOiAke3RoaXMubTEyfVxuICAgICAgbTEzOiAke3RoaXMubTEzfVxuICAgICAgbTE0OiAke3RoaXMubTE0fVxuICAgICAgbTIxOiAke3RoaXMubTIxfVxuICAgICAgbTIyOiAke3RoaXMubTIyfVxuICAgICAgbTIzOiAke3RoaXMubTIzfVxuICAgICAgbTIzOiAke3RoaXMubTIzfVxuICAgICAgbTMxOiAke3RoaXMubTMxfVxuICAgICAgbTMyOiAke3RoaXMubTMyfVxuICAgICAgbTMzOiAke3RoaXMubTMzfVxuICAgICAgbTM0OiAke3RoaXMubTM0fVxuICAgICAgbTQxOiAke3RoaXMubTQxfVxuICAgICAgbTQyOiAke3RoaXMubTQyfVxuICAgICAgbTQzOiAke3RoaXMubTQzfVxuICAgICAgbTQ0OiAke3RoaXMubTQ0fVxuICAgICAgaXMyRDogJHt0aGlzLmlzMkR9XG4gICAgICBpc0lkZW50aXR5OiAke3RoaXMuaXNJZGVudGl0eX0gXWBcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyB0aGF0IGB2YWx1ZWAgaXMgYSBudW1iZXIgYW5kIHNldHMgdGhlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBzZXROdW1iZXIyRCAocmVjZWl2ZXIsIGluZGV4LCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgbnVtYmVyJylcbiAgcmV0dXJuIChyZWNlaXZlci5fdmFsdWVzW2luZGV4XSA9IHZhbHVlKVxufVxuXG4vKipcbiAqIENoZWNrcyB0aGF0IGB2YWx1ZWAgaXMgYSBudW1iZXIsIHNldHMgYF9pczJEID0gZmFsc2VgIGlmIG5lY2Vzc2FyeSBhbmQgc2V0c1xuICogdGhlIHZhbHVlLlxuICovXG5mdW5jdGlvbiBzZXROdW1iZXIzRCAocmVjZWl2ZXIsIGluZGV4LCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgbnVtYmVyJylcbiAgaWYgKGluZGV4ID09PSBNMzMgfHwgaW5kZXggPT09IE00NCkge1xuICAgIGlmICh2YWx1ZSAhPT0gMSkgcmVjZWl2ZXIuX2lzMkQgPSBmYWxzZVxuICB9IGVsc2UgaWYgKHZhbHVlICE9PSAwKSByZWNlaXZlci5faXMyRCA9IGZhbHNlXG4gIHJldHVybiAocmVjZWl2ZXIuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZSlcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRE9NTWF0cml4LnByb3RvdHlwZSwge1xuICBtMTE6IHsgZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlc1tNMTFdIH0sIHNldCAodikgeyByZXR1cm4gc2V0TnVtYmVyMkQodGhpcywgTTExLCB2KSB9IH0sXG4gIG0xMjogeyBnZXQgKCkgeyByZXR1cm4gdGhpcy5fdmFsdWVzW00xMl0gfSwgc2V0ICh2KSB7IHJldHVybiBzZXROdW1iZXIyRCh0aGlzLCBNMTIsIHYpIH0gfSxcbiAgbTEzOiB7IGdldCAoKSB7IHJldHVybiB0aGlzLl92YWx1ZXNbTTEzXSB9LCBzZXQgKHYpIHsgcmV0dXJuIHNldE51bWJlcjNEKHRoaXMsIE0xMywgdikgfSB9LFxuICBtMTQ6IHsgZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlc1tNMTRdIH0sIHNldCAodikgeyByZXR1cm4gc2V0TnVtYmVyM0QodGhpcywgTTE0LCB2KSB9IH0sXG4gIG0yMTogeyBnZXQgKCkgeyByZXR1cm4gdGhpcy5fdmFsdWVzW00yMV0gfSwgc2V0ICh2KSB7IHJldHVybiBzZXROdW1iZXIyRCh0aGlzLCBNMjEsIHYpIH0gfSxcbiAgbTIyOiB7IGdldCAoKSB7IHJldHVybiB0aGlzLl92YWx1ZXNbTTIyXSB9LCBzZXQgKHYpIHsgcmV0dXJuIHNldE51bWJlcjJEKHRoaXMsIE0yMiwgdikgfSB9LFxuICBtMjM6IHsgZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlc1tNMjNdIH0sIHNldCAodikgeyByZXR1cm4gc2V0TnVtYmVyM0QodGhpcywgTTIzLCB2KSB9IH0sXG4gIG0yNDogeyBnZXQgKCkgeyByZXR1cm4gdGhpcy5fdmFsdWVzW00yNF0gfSwgc2V0ICh2KSB7IHJldHVybiBzZXROdW1iZXIzRCh0aGlzLCBNMjQsIHYpIH0gfSxcbiAgbTMxOiB7IGdldCAoKSB7IHJldHVybiB0aGlzLl92YWx1ZXNbTTMxXSB9LCBzZXQgKHYpIHsgcmV0dXJuIHNldE51bWJlcjNEKHRoaXMsIE0zMSwgdikgfSB9LFxuICBtMzI6IHsgZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlc1tNMzJdIH0sIHNldCAodikgeyByZXR1cm4gc2V0TnVtYmVyM0QodGhpcywgTTMyLCB2KSB9IH0sXG4gIG0zMzogeyBnZXQgKCkgeyByZXR1cm4gdGhpcy5fdmFsdWVzW00zM10gfSwgc2V0ICh2KSB7IHJldHVybiBzZXROdW1iZXIzRCh0aGlzLCBNMzMsIHYpIH0gfSxcbiAgbTM0OiB7IGdldCAoKSB7IHJldHVybiB0aGlzLl92YWx1ZXNbTTM0XSB9LCBzZXQgKHYpIHsgcmV0dXJuIHNldE51bWJlcjNEKHRoaXMsIE0zNCwgdikgfSB9LFxuICBtNDE6IHsgZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlc1tNNDFdIH0sIHNldCAodikgeyByZXR1cm4gc2V0TnVtYmVyMkQodGhpcywgTTQxLCB2KSB9IH0sXG4gIG00MjogeyBnZXQgKCkgeyByZXR1cm4gdGhpcy5fdmFsdWVzW000Ml0gfSwgc2V0ICh2KSB7IHJldHVybiBzZXROdW1iZXIyRCh0aGlzLCBNNDIsIHYpIH0gfSxcbiAgbTQzOiB7IGdldCAoKSB7IHJldHVybiB0aGlzLl92YWx1ZXNbTTQzXSB9LCBzZXQgKHYpIHsgcmV0dXJuIHNldE51bWJlcjNEKHRoaXMsIE00MywgdikgfSB9LFxuICBtNDQ6IHsgZ2V0ICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlc1tNNDRdIH0sIHNldCAodikgeyByZXR1cm4gc2V0TnVtYmVyM0QodGhpcywgTTQ0LCB2KSB9IH0sXG5cbiAgYTogeyBnZXQgKCkgeyByZXR1cm4gdGhpcy5tMTEgfSwgc2V0ICh2KSB7IHJldHVybiAodGhpcy5tMTEgPSB2KSB9IH0sXG4gIGI6IHsgZ2V0ICgpIHsgcmV0dXJuIHRoaXMubTEyIH0sIHNldCAodikgeyByZXR1cm4gKHRoaXMubTEyID0gdikgfSB9LFxuICBjOiB7IGdldCAoKSB7IHJldHVybiB0aGlzLm0yMSB9LCBzZXQgKHYpIHsgcmV0dXJuICh0aGlzLm0yMSA9IHYpIH0gfSxcbiAgZDogeyBnZXQgKCkgeyByZXR1cm4gdGhpcy5tMjIgfSwgc2V0ICh2KSB7IHJldHVybiAodGhpcy5tMjIgPSB2KSB9IH0sXG4gIGU6IHsgZ2V0ICgpIHsgcmV0dXJuIHRoaXMubTQxIH0sIHNldCAodikgeyByZXR1cm4gKHRoaXMubTQxID0gdikgfSB9LFxuICBmOiB7IGdldCAoKSB7IHJldHVybiB0aGlzLm00MiB9LCBzZXQgKHYpIHsgcmV0dXJuICh0aGlzLm00MiA9IHYpIH0gfSxcblxuICBpczJEOiB7IGdldCAoKSB7IHJldHVybiB0aGlzLl9pczJEIH0gfSwgLy8gcmVhZC1vbmx5XG5cbiAgaXNJZGVudGl0eToge1xuICAgIGdldCAoKSB7XG4gICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLl92YWx1ZXNcbiAgICAgIHJldHVybiAodmFsdWVzW00xMV0gPT09IDEgJiYgdmFsdWVzW00xMl0gPT09IDAgJiYgdmFsdWVzW00xM10gPT09IDAgJiYgdmFsdWVzW00xNF0gPT09IDAgJiZcbiAgICAgICAgICAgICB2YWx1ZXNbTTIxXSA9PT0gMCAmJiB2YWx1ZXNbTTIyXSA9PT0gMSAmJiB2YWx1ZXNbTTIzXSA9PT0gMCAmJiB2YWx1ZXNbTTI0XSA9PT0gMCAmJlxuICAgICAgICAgICAgIHZhbHVlc1tNMzFdID09PSAwICYmIHZhbHVlc1tNMzJdID09PSAwICYmIHZhbHVlc1tNMzNdID09PSAxICYmIHZhbHVlc1tNMzRdID09PSAwICYmXG4gICAgICAgICAgICAgdmFsdWVzW000MV0gPT09IDAgJiYgdmFsdWVzW000Ml0gPT09IDAgJiYgdmFsdWVzW000M10gPT09IDAgJiYgdmFsdWVzW000NF0gPT09IDEpXG4gICAgfVxuICB9XG59KVxuXG4vKipcbiAqIEluc3RhbnRpYXRlcyBhIERPTU1hdHJpeCwgYnlwYXNzaW5nIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIEBwYXJhbSB7RmxvYXQ2NEFycmF5fSB2YWx1ZXMgVmFsdWUgdG8gYXNzaWduIHRvIGBfdmFsdWVzYC4gVGhpcyBpcyBhc3NpZ25lZFxuICogICB3aXRob3V0IGNvcHlpbmcgKG9rYXkgYmVjYXVzZSBhbGwgdXNhZ2VzIGFyZSBmb2xsb3dlZCBieSBhICBtdWx0aXBseSkuXG4gKi9cbmZ1bmN0aW9uIG5ld0luc3RhbmNlICh2YWx1ZXMpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBPYmplY3QuY3JlYXRlKERPTU1hdHJpeC5wcm90b3R5cGUpXG4gIGluc3RhbmNlLmNvbnN0cnVjdG9yID0gRE9NTWF0cml4XG4gIGluc3RhbmNlLl9pczJEID0gdHJ1ZVxuICBpbnN0YW5jZS5fdmFsdWVzID0gdmFsdWVzXG4gIHJldHVybiBpbnN0YW5jZVxufVxuXG5mdW5jdGlvbiBtdWx0aXBseSAoQSwgQikge1xuICBjb25zdCBkZXN0ID0gbmV3IEZsb2F0NjRBcnJheSgxNilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgbGV0IHN1bSA9IDBcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgNDsgaysrKSB7XG4gICAgICAgIHN1bSArPSBBW2kgKiA0ICsga10gKiBCW2sgKiA0ICsgal1cbiAgICAgIH1cbiAgICAgIGRlc3RbaSAqIDQgKyBqXSA9IHN1bVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgRE9NTWF0cml4LCBET01Qb2ludCB9XG4iLCIndXNlIHN0cmljdCdcblxuLyohXG4gKiBDYW52YXMgLSBQTkdTdHJlYW1cbiAqIENvcHlyaWdodCAoYykgMjAxMCBMZWFybkJvb3N0IDx0akBsZWFybmJvb3N0LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbmNvbnN0IHsgUmVhZGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmNsYXNzIFBOR1N0cmVhbSBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKGNhbnZhcywgb3B0aW9ucykge1xuICAgIHN1cGVyKClcblxuICAgIGlmIChvcHRpb25zICYmXG4gICAgICBvcHRpb25zLnBhbGV0dGUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSAmJlxuICAgICAgb3B0aW9ucy5wYWxldHRlLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGFsZXR0ZSBsZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQuJylcbiAgICB9XG4gICAgdGhpcy5jYW52YXMgPSBjYW52YXNcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIH1cblxuICBfcmVhZCAoKSB7XG4gICAgLy8gRm9yIG5vdyB3ZSdyZSBub3QgY29udHJvbGxpbmcgdGhlIGMrKyBjb2RlJ3MgZGF0YSBlbWlzc2lvbiwgc28gd2Ugb25seVxuICAgIC8vIGNhbGwgY2FudmFzLnN0cmVhbVBOR1N5bmMgb25jZSBhbmQgbGV0IGl0IGVtaXQgZGF0YSBhdCB3aWxsLlxuICAgIHRoaXMuX3JlYWQgPSBub29wXG5cbiAgICB0aGlzLmNhbnZhcy5zdHJlYW1QTkdTeW5jKChlcnIsIGNodW5rLCBsZW4pID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycilcbiAgICAgIH0gZWxzZSBpZiAobGVuKSB7XG4gICAgICAgIHRoaXMucHVzaChjaHVuaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucHVzaChudWxsKVxuICAgICAgfVxuICAgIH0sIHRoaXMub3B0aW9ucylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBOR1N0cmVhbVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwic3RyZWFtXCIpOyIsIid1c2Ugc3RyaWN0J1xuXG4vKiFcbiAqIENhbnZhcyAtIFBERlN0cmVhbVxuICovXG5cbmNvbnN0IHsgUmVhZGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmNsYXNzIFBERlN0cmVhbSBleHRlbmRzIFJlYWRhYmxlIHtcbiAgY29uc3RydWN0b3IgKGNhbnZhcywgb3B0aW9ucykge1xuICAgIHN1cGVyKClcblxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB9XG5cbiAgX3JlYWQgKCkge1xuICAgIC8vIEZvciBub3cgd2UncmUgbm90IGNvbnRyb2xsaW5nIHRoZSBjKysgY29kZSdzIGRhdGEgZW1pc3Npb24sIHNvIHdlIG9ubHlcbiAgICAvLyBjYWxsIGNhbnZhcy5zdHJlYW1QREZTeW5jIG9uY2UgYW5kIGxldCBpdCBlbWl0IGRhdGEgYXQgd2lsbC5cbiAgICB0aGlzLl9yZWFkID0gbm9vcFxuXG4gICAgdGhpcy5jYW52YXMuc3RyZWFtUERGU3luYygoZXJyLCBjaHVuaywgbGVuKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpXG4gICAgICB9IGVsc2UgaWYgKGxlbikge1xuICAgICAgICB0aGlzLnB1c2goY2h1bmspXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnB1c2gobnVsbClcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9wdGlvbnMpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQREZTdHJlYW1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiFcbiAqIENhbnZhcyAtIEpQRUdTdHJlYW1cbiAqIENvcHlyaWdodCAoYykgMjAxMCBMZWFybkJvb3N0IDx0akBsZWFybmJvb3N0LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbmNvbnN0IHsgUmVhZGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmNsYXNzIEpQRUdTdHJlYW0gZXh0ZW5kcyBSZWFkYWJsZSB7XG4gIGNvbnN0cnVjdG9yIChjYW52YXMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG5cbiAgICBpZiAoY2FudmFzLnN0cmVhbUpQRUdTeW5jID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbm9kZS1jYW52YXMgd2FzIGJ1aWx0IHdpdGhvdXQgSlBFRyBzdXBwb3J0LicpXG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzXG4gIH1cblxuICBfcmVhZCAoKSB7XG4gICAgLy8gRm9yIG5vdyB3ZSdyZSBub3QgY29udHJvbGxpbmcgdGhlIGMrKyBjb2RlJ3MgZGF0YSBlbWlzc2lvbiwgc28gd2Ugb25seVxuICAgIC8vIGNhbGwgY2FudmFzLnN0cmVhbUpQRUdTeW5jIG9uY2UgYW5kIGxldCBpdCBlbWl0IGRhdGEgYXQgd2lsbC5cbiAgICB0aGlzLl9yZWFkID0gbm9vcFxuXG4gICAgdGhpcy5jYW52YXMuc3RyZWFtSlBFR1N5bmModGhpcy5vcHRpb25zLCAoZXJyLCBjaHVuaykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgfSBlbHNlIGlmIChjaHVuaykge1xuICAgICAgICB0aGlzLnB1c2goY2h1bmspXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnB1c2gobnVsbClcbiAgICAgIH1cbiAgICB9KVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpQRUdTdHJlYW1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiFcbiAqIENhbnZhcyAtIEltYWdlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgTGVhcm5Cb29zdCA8dGpAbGVhcm5ib29zdC5jb20+XG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxuY29uc3QgYmluZGluZ3MgPSByZXF1aXJlKCcuL2JpbmRpbmdzJylcbmNvbnN0IEltYWdlID0gbW9kdWxlLmV4cG9ydHMgPSBiaW5kaW5ncy5JbWFnZVxuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuXG4vLyBMYXppbHkgbG9hZGVkIHNpbXBsZS1nZXRcbmxldCBnZXRcblxuY29uc3QgeyBHZXRTb3VyY2UsIFNldFNvdXJjZSB9ID0gYmluZGluZ3NcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEltYWdlLnByb3RvdHlwZSwgJ3NyYycsIHtcbiAgLyoqXG4gICAqIHNyYyBzZXR0ZXIuIFZhbGlkIHZhbHVlczpcbiAgICogICogYGRhdGE6YCBVUklcbiAgICogICogTG9jYWwgZmlsZSBwYXRoXG4gICAqICAqIEhUVFAgb3IgSFRUUFMgVVJMXG4gICAqICAqIEJ1ZmZlciBjb250YWluaW5nIGltYWdlIGRhdGEgKGkuZS4gbm90IGEgYGRhdGE6YCBVUkkgc3RvcmVkIGluIGEgQnVmZmVyKVxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ3xCdWZmZXJ9IHZhbCBmaWxlbmFtZSwgYnVmZmVyLCBkYXRhIFVSSSwgVVJMXG4gICAqIEBhcGkgcHVibGljXG4gICAqL1xuICBzZXQgKHZhbCkge1xuICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKC9eXFxzKmRhdGE6Ly50ZXN0KHZhbCkpIHsgLy8gZGF0YTogVVJJXG4gICAgICAgIGNvbnN0IGNvbW1hSSA9IHZhbC5pbmRleE9mKCcsJylcbiAgICAgICAgLy8gJ2Jhc2U2NCcgbXVzdCBjb21lIGJlZm9yZSB0aGUgY29tbWFcbiAgICAgICAgY29uc3QgaXNCYXNlNjQgPSB2YWwubGFzdEluZGV4T2YoJ2Jhc2U2NCcsIGNvbW1hSSkgIT09IC0xXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB2YWwuc2xpY2UoY29tbWFJICsgMSlcbiAgICAgICAgc2V0U291cmNlKHRoaXMsIEJ1ZmZlci5mcm9tKGNvbnRlbnQsIGlzQmFzZTY0ID8gJ2Jhc2U2NCcgOiAndXRmOCcpLCB2YWwpXG4gICAgICB9IGVsc2UgaWYgKC9eXFxzKmh0dHBzPzpcXC9cXC8vLnRlc3QodmFsKSkgeyAvLyByZW1vdGUgVVJMXG4gICAgICAgIGNvbnN0IG9uZXJyb3IgPSBlcnIgPT4ge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vbmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IoZXJyKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWdldCkgZ2V0ID0gcmVxdWlyZSgnc2ltcGxlLWdldCcpXG5cbiAgICAgICAgZ2V0LmNvbmNhdCh7XG4gICAgICAgICAgdXJsOiB2YWwsXG4gICAgICAgICAgaGVhZGVyczogeyAnVXNlci1BZ2VudCc6ICdNb3ppbGxhLzUuMCAoWDExOyBMaW51eCB4ODZfNjQpIEFwcGxlV2ViS2l0LzUzNy4zNiAoS0hUTUwsIGxpa2UgR2Vja28pIENocm9tZS8xMDIuMC4wLjAgU2FmYXJpLzUzNy4zNicgfVxuICAgICAgICB9LCAoZXJyLCByZXMsIGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gb25lcnJvcihlcnIpXG5cbiAgICAgICAgICBpZiAocmVzLnN0YXR1c0NvZGUgPCAyMDAgfHwgcmVzLnN0YXR1c0NvZGUgPj0gMzAwKSB7XG4gICAgICAgICAgICByZXR1cm4gb25lcnJvcihuZXcgRXJyb3IoYFNlcnZlciByZXNwb25kZWQgd2l0aCAke3Jlcy5zdGF0dXNDb2RlfWApKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldFNvdXJjZSh0aGlzLCBkYXRhKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHsgLy8gbG9jYWwgZmlsZSBwYXRoIGFzc3VtZWRcbiAgICAgICAgc2V0U291cmNlKHRoaXMsIHZhbClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgICBzZXRTb3VyY2UodGhpcywgdmFsKVxuICAgIH1cbiAgfSxcblxuICBnZXQgKCkge1xuICAgIC8vIFRPRE8gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvbm9kZS1jYW52YXMvaXNzdWVzLzExOFxuICAgIHJldHVybiBnZXRTb3VyY2UodGhpcylcbiAgfSxcblxuICBjb25maWd1cmFibGU6IHRydWVcbn0pXG5cbi8vIFRPRE8gfHwgaXMgZm9yIE5vZGUuanMgcHJlLXY2LjYuMFxuSW1hZ2UucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b20gfHwgJ2luc3BlY3QnXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICdbSW1hZ2UnICtcbiAgICAodGhpcy5jb21wbGV0ZSA/ICc6JyArIHRoaXMud2lkdGggKyAneCcgKyB0aGlzLmhlaWdodCA6ICcnKSArXG4gICAgKHRoaXMuc3JjID8gJyAnICsgdGhpcy5zcmMgOiAnJykgK1xuICAgICh0aGlzLmNvbXBsZXRlID8gJyBjb21wbGV0ZScgOiAnJykgK1xuICAgICddJ1xufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2UgKGltZykge1xuICByZXR1cm4gaW1nLl9vcmlnaW5hbFNvdXJjZSB8fCBHZXRTb3VyY2UuY2FsbChpbWcpXG59XG5cbmZ1bmN0aW9uIHNldFNvdXJjZSAoaW1nLCBzcmMsIG9yaWdTcmMpIHtcbiAgU2V0U291cmNlLmNhbGwoaW1nLCBzcmMpXG4gIGltZy5fb3JpZ2luYWxTb3VyY2UgPSBvcmlnU3JjXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNpbXBsZUdldFxuXG5jb25zdCBjb25jYXQgPSByZXF1aXJlKCdzaW1wbGUtY29uY2F0JylcbmNvbnN0IGRlY29tcHJlc3NSZXNwb25zZSA9IHJlcXVpcmUoJ2RlY29tcHJlc3MtcmVzcG9uc2UnKSAvLyBleGNsdWRlZCBmcm9tIGJyb3dzZXIgYnVpbGRcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJylcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKVxuY29uc3Qgb25jZSA9IHJlcXVpcmUoJ29uY2UnKVxuY29uc3QgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpXG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKVxuXG5jb25zdCBpc1N0cmVhbSA9IG8gPT4gbyAhPT0gbnVsbCAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG8ucGlwZSA9PT0gJ2Z1bmN0aW9uJ1xuXG5mdW5jdGlvbiBzaW1wbGVHZXQgKG9wdHMsIGNiKSB7XG4gIG9wdHMgPSBPYmplY3QuYXNzaWduKHsgbWF4UmVkaXJlY3RzOiAxMCB9LCB0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycgPyB7IHVybDogb3B0cyB9IDogb3B0cylcbiAgY2IgPSBvbmNlKGNiKVxuXG4gIGlmIChvcHRzLnVybCkge1xuICAgIGNvbnN0IHsgaG9zdG5hbWUsIHBvcnQsIHByb3RvY29sLCBhdXRoLCBwYXRoIH0gPSB1cmwucGFyc2Uob3B0cy51cmwpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm9kZS9uby1kZXByZWNhdGVkLWFwaVxuICAgIGRlbGV0ZSBvcHRzLnVybFxuICAgIGlmICghaG9zdG5hbWUgJiYgIXBvcnQgJiYgIXByb3RvY29sICYmICFhdXRoKSBvcHRzLnBhdGggPSBwYXRoIC8vIFJlbGF0aXZlIHJlZGlyZWN0XG4gICAgZWxzZSBPYmplY3QuYXNzaWduKG9wdHMsIHsgaG9zdG5hbWUsIHBvcnQsIHByb3RvY29sLCBhdXRoLCBwYXRoIH0pIC8vIEFic29sdXRlIHJlZGlyZWN0XG4gIH1cblxuICBjb25zdCBoZWFkZXJzID0geyAnYWNjZXB0LWVuY29kaW5nJzogJ2d6aXAsIGRlZmxhdGUnIH1cbiAgaWYgKG9wdHMuaGVhZGVycykgT2JqZWN0LmtleXMob3B0cy5oZWFkZXJzKS5mb3JFYWNoKGsgPT4gKGhlYWRlcnNbay50b0xvd2VyQ2FzZSgpXSA9IG9wdHMuaGVhZGVyc1trXSkpXG4gIG9wdHMuaGVhZGVycyA9IGhlYWRlcnNcblxuICBsZXQgYm9keVxuICBpZiAob3B0cy5ib2R5KSB7XG4gICAgYm9keSA9IG9wdHMuanNvbiAmJiAhaXNTdHJlYW0ob3B0cy5ib2R5KSA/IEpTT04uc3RyaW5naWZ5KG9wdHMuYm9keSkgOiBvcHRzLmJvZHlcbiAgfSBlbHNlIGlmIChvcHRzLmZvcm0pIHtcbiAgICBib2R5ID0gdHlwZW9mIG9wdHMuZm9ybSA9PT0gJ3N0cmluZycgPyBvcHRzLmZvcm0gOiBxdWVyeXN0cmluZy5zdHJpbmdpZnkob3B0cy5mb3JtKVxuICAgIG9wdHMuaGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICB9XG5cbiAgaWYgKGJvZHkpIHtcbiAgICBpZiAoIW9wdHMubWV0aG9kKSBvcHRzLm1ldGhvZCA9ICdQT1NUJ1xuICAgIGlmICghaXNTdHJlYW0oYm9keSkpIG9wdHMuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXSA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGJvZHkpXG4gICAgaWYgKG9wdHMuanNvbiAmJiAhb3B0cy5mb3JtKSBvcHRzLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nXG4gIH1cbiAgZGVsZXRlIG9wdHMuYm9keTsgZGVsZXRlIG9wdHMuZm9ybVxuXG4gIGlmIChvcHRzLmpzb24pIG9wdHMuaGVhZGVycy5hY2NlcHQgPSAnYXBwbGljYXRpb24vanNvbidcbiAgaWYgKG9wdHMubWV0aG9kKSBvcHRzLm1ldGhvZCA9IG9wdHMubWV0aG9kLnRvVXBwZXJDYXNlKClcblxuICBjb25zdCBvcmlnaW5hbEhvc3QgPSBvcHRzLmhvc3RuYW1lIC8vIGhvc3RuYW1lIGJlZm9yZSBwb3RlbnRpYWwgcmVkaXJlY3RcbiAgY29uc3QgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sID09PSAnaHR0cHM6JyA/IGh0dHBzIDogaHR0cCAvLyBTdXBwb3J0IGh0dHAvaHR0cHMgdXJsc1xuICBjb25zdCByZXEgPSBwcm90b2NvbC5yZXF1ZXN0KG9wdHMsIHJlcyA9PiB7XG4gICAgaWYgKG9wdHMuZm9sbG93UmVkaXJlY3RzICE9PSBmYWxzZSAmJiByZXMuc3RhdHVzQ29kZSA+PSAzMDAgJiYgcmVzLnN0YXR1c0NvZGUgPCA0MDAgJiYgcmVzLmhlYWRlcnMubG9jYXRpb24pIHtcbiAgICAgIG9wdHMudXJsID0gcmVzLmhlYWRlcnMubG9jYXRpb24gLy8gRm9sbG93IDN4eCByZWRpcmVjdHNcbiAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuaG9zdCAvLyBEaXNjYXJkIGBob3N0YCBoZWFkZXIgb24gcmVkaXJlY3QgKHNlZSAjMzIpXG4gICAgICByZXMucmVzdW1lKCkgLy8gRGlzY2FyZCByZXNwb25zZVxuXG4gICAgICBjb25zdCByZWRpcmVjdEhvc3QgPSB1cmwucGFyc2Uob3B0cy51cmwpLmhvc3RuYW1lIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm9kZS9uby1kZXByZWNhdGVkLWFwaVxuICAgICAgLy8gSWYgcmVkaXJlY3RlZCBob3N0IGlzIGRpZmZlcmVudCB0aGFuIG9yaWdpbmFsIGhvc3QsIGRyb3AgaGVhZGVycyB0byBwcmV2ZW50IGNvb2tpZSBsZWFrICgjNzMpXG4gICAgICBpZiAocmVkaXJlY3RIb3N0ICE9PSBudWxsICYmIHJlZGlyZWN0SG9zdCAhPT0gb3JpZ2luYWxIb3N0KSB7XG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuY29va2llXG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuYXV0aG9yaXphdGlvblxuICAgICAgfVxuXG4gICAgICBpZiAob3B0cy5tZXRob2QgPT09ICdQT1NUJyAmJiBbMzAxLCAzMDJdLmluY2x1ZGVzKHJlcy5zdGF0dXNDb2RlKSkge1xuICAgICAgICBvcHRzLm1ldGhvZCA9ICdHRVQnIC8vIE9uIDMwMS8zMDIgcmVkaXJlY3QsIGNoYW5nZSBQT1NUIHRvIEdFVCAoc2VlICMzNSlcbiAgICAgICAgZGVsZXRlIG9wdHMuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTsgZGVsZXRlIG9wdHMuaGVhZGVyc1snY29udGVudC10eXBlJ11cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdHMubWF4UmVkaXJlY3RzLS0gPT09IDApIHJldHVybiBjYihuZXcgRXJyb3IoJ3RvbyBtYW55IHJlZGlyZWN0cycpKVxuICAgICAgZWxzZSByZXR1cm4gc2ltcGxlR2V0KG9wdHMsIGNiKVxuICAgIH1cblxuICAgIGNvbnN0IHRyeVVuemlwID0gdHlwZW9mIGRlY29tcHJlc3NSZXNwb25zZSA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRzLm1ldGhvZCAhPT0gJ0hFQUQnXG4gICAgY2IobnVsbCwgdHJ5VW56aXAgPyBkZWNvbXByZXNzUmVzcG9uc2UocmVzKSA6IHJlcylcbiAgfSlcbiAgcmVxLm9uKCd0aW1lb3V0JywgKCkgPT4ge1xuICAgIHJlcS5hYm9ydCgpXG4gICAgY2IobmV3IEVycm9yKCdSZXF1ZXN0IHRpbWVkIG91dCcpKVxuICB9KVxuICByZXEub24oJ2Vycm9yJywgY2IpXG5cbiAgaWYgKGlzU3RyZWFtKGJvZHkpKSBib2R5Lm9uKCdlcnJvcicsIGNiKS5waXBlKHJlcSlcbiAgZWxzZSByZXEuZW5kKGJvZHkpXG5cbiAgcmV0dXJuIHJlcVxufVxuXG5zaW1wbGVHZXQuY29uY2F0ID0gKG9wdHMsIGNiKSA9PiB7XG4gIHJldHVybiBzaW1wbGVHZXQob3B0cywgKGVyciwgcmVzKSA9PiB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25jYXQocmVzLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgaWYgKG9wdHMuanNvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEudG9TdHJpbmcoKSlcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKGVyciwgcmVzLCBkYXRhKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjYihudWxsLCByZXMsIGRhdGEpXG4gICAgfSlcbiAgfSlcbn1cblxuO1snZ2V0JywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJywgJ2hlYWQnLCAnZGVsZXRlJ10uZm9yRWFjaChtZXRob2QgPT4ge1xuICBzaW1wbGVHZXRbbWV0aG9kXSA9IChvcHRzLCBjYikgPT4ge1xuICAgIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpIG9wdHMgPSB7IHVybDogb3B0cyB9XG4gICAgcmV0dXJuIHNpbXBsZUdldChPYmplY3QuYXNzaWduKHsgbWV0aG9kOiBtZXRob2QudG9VcHBlckNhc2UoKSB9LCBvcHRzKSwgY2IpXG4gIH1cbn0pXG4iLCIvKiEgc2ltcGxlLWNvbmNhdC4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyZWFtLCBjYikge1xuICB2YXIgY2h1bmtzID0gW11cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgY2h1bmtzLnB1c2goY2h1bmspXG4gIH0pXG4gIHN0cmVhbS5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNiKSBjYihudWxsLCBCdWZmZXIuY29uY2F0KGNodW5rcykpXG4gICAgY2IgPSBudWxsXG4gIH0pXG4gIHN0cmVhbS5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoY2IpIGNiKGVycilcbiAgICBjYiA9IG51bGxcbiAgfSlcbn1cbiIsIid1c2Ugc3RyaWN0JztcbmNvbnN0IHtQYXNzVGhyb3VnaDogUGFzc1Rocm91Z2hTdHJlYW19ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB6bGliID0gcmVxdWlyZSgnemxpYicpO1xuY29uc3QgbWltaWNSZXNwb25zZSA9IHJlcXVpcmUoJ21pbWljLXJlc3BvbnNlJyk7XG5cbmNvbnN0IGRlY29tcHJlc3NSZXNwb25zZSA9IHJlc3BvbnNlID0+IHtcblx0Y29uc3QgY29udGVudEVuY29kaW5nID0gKHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXSB8fCAnJykudG9Mb3dlckNhc2UoKTtcblxuXHRpZiAoIVsnZ3ppcCcsICdkZWZsYXRlJywgJ2JyJ10uaW5jbHVkZXMoY29udGVudEVuY29kaW5nKSkge1xuXHRcdHJldHVybiByZXNwb25zZTtcblx0fVxuXG5cdGNvbnN0IGlzQnJvdGxpID0gY29udGVudEVuY29kaW5nID09PSAnYnInO1xuXHRpZiAoaXNCcm90bGkgJiYgdHlwZW9mIHpsaWIuY3JlYXRlQnJvdGxpRGVjb21wcmVzcyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiByZXNwb25zZTtcblx0fVxuXG5cdGNvbnN0IGRlY29tcHJlc3MgPSBpc0Jyb3RsaSA/IHpsaWIuY3JlYXRlQnJvdGxpRGVjb21wcmVzcygpIDogemxpYi5jcmVhdGVVbnppcCgpO1xuXHRjb25zdCBzdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2hTdHJlYW0oKTtcblxuXHRtaW1pY1Jlc3BvbnNlKHJlc3BvbnNlLCBzdHJlYW0pO1xuXG5cdGRlY29tcHJlc3Mub24oJ2Vycm9yJywgZXJyb3IgPT4ge1xuXHRcdC8vIElnbm9yZSBlbXB0eSByZXNwb25zZVxuXHRcdGlmIChlcnJvci5jb2RlID09PSAnWl9CVUZfRVJST1InKSB7XG5cdFx0XHRzdHJlYW0uZW5kKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0c3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuXHR9KTtcblxuXHRyZXNwb25zZS5waXBlKGRlY29tcHJlc3MpLnBpcGUoc3RyZWFtKTtcblxuXHRyZXR1cm4gc3RyZWFtO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWNvbXByZXNzUmVzcG9uc2U7XG4vLyBUT0RPOiByZW1vdmUgdGhpcyBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZGVjb21wcmVzc1Jlc3BvbnNlO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiemxpYlwiKTsiLCIndXNlIHN0cmljdCc7XG5cbi8vIFdlIGRlZmluZSB0aGVzZSBtYW51YWxseSB0byBlbnN1cmUgdGhleSdyZSBhbHdheXMgY29waWVkXG4vLyBldmVuIGlmIHRoZXkgd291bGQgbW92ZSB1cCB0aGUgcHJvdG90eXBlIGNoYWluXG4vLyBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX2NsYXNzX2h0dHBfaW5jb21pbmdtZXNzYWdlXG5jb25zdCBrbm93blByb3BlcnRpZXMgPSBbXG5cdCdhYm9ydGVkJyxcblx0J2NvbXBsZXRlJyxcblx0J2Rlc3Ryb3knLFxuXHQnaGVhZGVycycsXG5cdCdodHRwVmVyc2lvbicsXG5cdCdodHRwVmVyc2lvbk1pbm9yJyxcblx0J2h0dHBWZXJzaW9uTWFqb3InLFxuXHQnbWV0aG9kJyxcblx0J3Jhd0hlYWRlcnMnLFxuXHQncmF3VHJhaWxlcnMnLFxuXHQnc2V0VGltZW91dCcsXG5cdCdzb2NrZXQnLFxuXHQnc3RhdHVzQ29kZScsXG5cdCdzdGF0dXNNZXNzYWdlJyxcblx0J3RyYWlsZXJzJyxcblx0J3VybCdcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZyb21TdHJlYW0sIHRvU3RyZWFtKSA9PiB7XG5cdGNvbnN0IGZyb21Qcm9wZXJ0aWVzID0gbmV3IFNldChPYmplY3Qua2V5cyhmcm9tU3RyZWFtKS5jb25jYXQoa25vd25Qcm9wZXJ0aWVzKSk7XG5cblx0Zm9yIChjb25zdCBwcm9wZXJ0eSBvZiBmcm9tUHJvcGVydGllcykge1xuXHRcdC8vIERvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBwcm9wZXJ0aWVzLlxuXHRcdGlmIChwcm9wZXJ0eSBpbiB0b1N0cmVhbSkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0dG9TdHJlYW1bcHJvcGVydHldID0gdHlwZW9mIGZyb21TdHJlYW1bcHJvcGVydHldID09PSAnZnVuY3Rpb24nID8gZnJvbVN0cmVhbVtwcm9wZXJ0eV0uYmluZChmcm9tU3RyZWFtKSA6IGZyb21TdHJlYW1bcHJvcGVydHldO1xuXHR9XG5cblx0cmV0dXJuIHRvU3RyZWFtO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImh0dHBcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiaHR0cHNcIik7IiwidmFyIHdyYXBweSA9IHJlcXVpcmUoJ3dyYXBweScpXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBweShvbmNlKVxubW9kdWxlLmV4cG9ydHMuc3RyaWN0ID0gd3JhcHB5KG9uY2VTdHJpY3QpXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZVN0cmljdCcsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2VTdHJpY3QodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKSByZXR1cm4gZi52YWx1ZVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cblxuZnVuY3Rpb24gb25jZVN0cmljdCAoZm4pIHtcbiAgdmFyIGYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGYuY2FsbGVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGYub25jZUVycm9yKVxuICAgIGYuY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmLnZhbHVlID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG4gIHZhciBuYW1lID0gZm4ubmFtZSB8fCAnRnVuY3Rpb24gd3JhcHBlZCB3aXRoIGBvbmNlYCdcbiAgZi5vbmNlRXJyb3IgPSBuYW1lICsgXCIgc2hvdWxkbid0IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZVwiXG4gIGYuY2FsbGVkID0gZmFsc2VcbiAgcmV0dXJuIGZcbn1cbiIsIi8vIFJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHdyYXBwZWQgY2FsbGJhY2tcbi8vIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHNob3VsZCBkbyBzb21lIHN0dWZmLCBhbmQgcmV0dXJuIGFcbi8vIHByZXN1bWFibHkgZGlmZmVyZW50IGNhbGxiYWNrIGZ1bmN0aW9uLlxuLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgb3duIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkLCBzbyB0aGF0XG4vLyBkZWNvcmF0aW9ucyBhbmQgc3VjaCBhcmUgbm90IGxvc3QgYWxvbmcgdGhlIHdheS5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5XG5mdW5jdGlvbiB3cmFwcHkgKGZuLCBjYikge1xuICBpZiAoZm4gJiYgY2IpIHJldHVybiB3cmFwcHkoZm4pKGNiKVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmVlZCB3cmFwcGVyIGZ1bmN0aW9uJylcblxuICBPYmplY3Qua2V5cyhmbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHdyYXBwZXJba10gPSBmbltrXVxuICB9KVxuXG4gIHJldHVybiB3cmFwcGVyXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICB2YXIgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdXG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgJiYgcmV0ICE9PSBjYikge1xuICAgICAgT2JqZWN0LmtleXMoY2IpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0W2tdID0gY2Jba11cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwidXJsXCIpOyIsIid1c2Ugc3RyaWN0J1xuXG4vKiFcbiAqIENhbnZhcyAtIENhbnZhc1BhdHRlcm5cbiAqIENvcHlyaWdodCAoYykgMjAxMCBMZWFybkJvb3N0IDx0akBsZWFybmJvb3N0LmNvbT5cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbmNvbnN0IGJpbmRpbmdzID0gcmVxdWlyZSgnLi9iaW5kaW5ncycpXG5jb25zdCB7IERPTU1hdHJpeCB9ID0gcmVxdWlyZSgnLi9ET01NYXRyaXgnKVxuXG5iaW5kaW5ncy5DYW52YXNQYXR0ZXJuSW5pdChET01NYXRyaXgpXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmRpbmdzLkNhbnZhc1BhdHRlcm5cblxuYmluZGluZ3MuQ2FudmFzUGF0dGVybi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiAnW29iamVjdCBDYW52YXNQYXR0ZXJuXSdcbn1cbiIsImltcG9ydCB7IEltYWdlTWFwLCBpRGljdGlvbmFyeSB9IGZyb20gXCJAbWFwcGluZ3NcIjtcbmltcG9ydCBzaGFycCBmcm9tIFwic2hhcnBcIjtcblxuZXhwb3J0IGVudW0gRXh0ZW5zaW9uIHtcbiAgICBqcGcgPSAnanBnJyxcbiAgICBwbmcgPSAncG5nJyxcbiAgICB3ZWJwID0gJ3dlYnAnLFxufVxuXG4vKipcbiAqIFNhdmUgaW1hZ2VzIHRvIGFuIG91dHB1dCBmb2xkZXJcbiAqIEBwYXJhbSBvdXRwdXRGb2xkZXIgLSBMb2NhdGlvbiB0byBzYXZlIHRoZSBpbWFnZXNcbiAqIEBwYXJhbSBpbWFnZXMgLSBMaXN0IG9mIGltYWdlcyB0byBzYXZlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcmludEFsbEltYWdlcyhvdXRwdXRGb2xkZXI6IHN0cmluZywgaW1hZ2VzOiBJbWFnZU1hcFtdLCBleHRlbnNpb246IEV4dGVuc2lvbikge1xuICAgIGltYWdlcy5mb3JFYWNoKGFzeW5jIChpbWFnZTogSW1hZ2VNYXApID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IG91dHB1dEZvbGRlciArIGAvJHtpbWFnZS5uYW1lfS4ke2V4dGVuc2lvbi52YWx1ZU9mKCl9YDtcbiAgICAgICAgYXdhaXQgc2F2ZVdlYlBJbWFnZShpbWFnZSwgZmlsZSk7XG4gICAgfSk7XG59XG5cbi8vIFxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlSk5vZGVJbWFnZXMocHJlZml4OiBzdHJpbmcsIGV4dE1vZHM6IHN0cmluZ1tdLCBkaWN0aW9uYXJ5OiBpRGljdGlvbmFyeSwgaW1hZ2VzOiBJbWFnZU1hcFtdKSB7XG4gICAgY29uc3QgcmUxID0gL1sgXS9naTtcbiAgICBjb25zdCByZTIgPSAvW1xcV10vZ2k7XG4gICAgY29uc3QgcmUzID0gL1tfXS9naTtcbiAgICBPYmplY3QuZW50cmllcyhkaWN0aW9uYXJ5KS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcblxuICAgICAgICAvLyBsZXQgZmlsZXMgPSBleHRNb2QubWFwKHggPT4gYCR7b3V0cHV0Rm9sZGVyfS8ke2pzb25LZXkudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHJlMSwgJ18nKS5yZXBsYWNlKHJlMiwgJycpLnJlcGxhY2UocmUzLCAnLScpfS4ke3h9LndlYnBgKTtcbiAgICAgICAgZXh0TW9kcy5mb3JFYWNoKGFzeW5jIHggPT4ge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBmaWxlXG4gICAgICAgICAgICBjb25zdCBmaWxlID0gYCR7cHJlZml4fS8ke2tleS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UocmUxLCAnXycpLnJlcGxhY2UocmUyLCAnJykucmVwbGFjZShyZTMsICctJyl9LiR7eH0ud2VicGA7XG4gICAgICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIHRva2VuXG4gICAgICAgICAgICBpZiAoeCA9PT0gJ3Rva2VuJyAmJiB2YWx1ZS5pY29uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZSA9IGltYWdlcy5maW5kKHkgPT4geS5uYW1lID09PSB2YWx1ZS5pY29uKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIC0gcHV0IGl0IGluIGEgY2lyY2xlIGJhbm5lclxuICAgICAgICAgICAgICAgIGF3YWl0IHNhdmVXZWJQSW1hZ2UoaW1hZ2UsIGZpbGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZSA9IGltYWdlcy5maW5kKHkgPT4geS5uYW1lID09PSB2YWx1ZS5vcmlnKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBzYXZlV2ViUEltYWdlKGltYWdlLCBmaWxlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2F2ZVdlYlBJbWFnZShpbWFnZTogSW1hZ2VNYXAgfCB1bmRlZmluZWQsIGZpbGU6IHN0cmluZykge1xuICAgIGlmIChpbWFnZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgICAgICBjb25zdCBjaGFubmVscyA9IGltYWdlLmNoYW5uZWxzKCk7XG4gICAgICAgIGF3YWl0IHNoYXJwKGltYWdlLmRhdGEsIHtcbiAgICAgICAgICAgIHJhdzogeyB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscyB9XG4gICAgICAgIH0pLnRvRmlsZShmaWxlKTtcbiAgICAgICAgY29uc29sZS5sb2coYEltYWdlIHNhdmVkICR7ZmlsZX1gKTtcbiAgICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJzaGFycFwiKTsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHRsb2FkZWQ6IGZhbHNlLFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcblx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCJ2YXIgd2VicGFja1F1ZXVlcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbChcIndlYnBhY2sgcXVldWVzXCIpIDogXCJfX3dlYnBhY2tfcXVldWVzX19cIjtcbnZhciB3ZWJwYWNrRXhwb3J0cyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbChcIndlYnBhY2sgZXhwb3J0c1wiKSA6IFwiX193ZWJwYWNrX2V4cG9ydHNfX1wiO1xudmFyIHdlYnBhY2tFcnJvciA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbChcIndlYnBhY2sgZXJyb3JcIikgOiBcIl9fd2VicGFja19lcnJvcl9fXCI7XG52YXIgcmVzb2x2ZVF1ZXVlID0gKHF1ZXVlKSA9PiB7XG5cdGlmKHF1ZXVlICYmIHF1ZXVlLmQgPCAxKSB7XG5cdFx0cXVldWUuZCA9IDE7XG5cdFx0cXVldWUuZm9yRWFjaCgoZm4pID0+IChmbi5yLS0pKTtcblx0XHRxdWV1ZS5mb3JFYWNoKChmbikgPT4gKGZuLnItLSA/IGZuLnIrKyA6IGZuKCkpKTtcblx0fVxufVxudmFyIHdyYXBEZXBzID0gKGRlcHMpID0+IChkZXBzLm1hcCgoZGVwKSA9PiB7XG5cdGlmKGRlcCAhPT0gbnVsbCAmJiB0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiKSB7XG5cdFx0aWYoZGVwW3dlYnBhY2tRdWV1ZXNdKSByZXR1cm4gZGVwO1xuXHRcdGlmKGRlcC50aGVuKSB7XG5cdFx0XHR2YXIgcXVldWUgPSBbXTtcblx0XHRcdHF1ZXVlLmQgPSAwO1xuXHRcdFx0ZGVwLnRoZW4oKHIpID0+IHtcblx0XHRcdFx0b2JqW3dlYnBhY2tFeHBvcnRzXSA9IHI7XG5cdFx0XHRcdHJlc29sdmVRdWV1ZShxdWV1ZSk7XG5cdFx0XHR9LCAoZSkgPT4ge1xuXHRcdFx0XHRvYmpbd2VicGFja0Vycm9yXSA9IGU7XG5cdFx0XHRcdHJlc29sdmVRdWV1ZShxdWV1ZSk7XG5cdFx0XHR9KTtcblx0XHRcdHZhciBvYmogPSB7fTtcblx0XHRcdG9ialt3ZWJwYWNrUXVldWVzXSA9IChmbikgPT4gKGZuKHF1ZXVlKSk7XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH1cblx0fVxuXHR2YXIgcmV0ID0ge307XG5cdHJldFt3ZWJwYWNrUXVldWVzXSA9IHggPT4ge307XG5cdHJldFt3ZWJwYWNrRXhwb3J0c10gPSBkZXA7XG5cdHJldHVybiByZXQ7XG59KSk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmEgPSAobW9kdWxlLCBib2R5LCBoYXNBd2FpdCkgPT4ge1xuXHR2YXIgcXVldWU7XG5cdGhhc0F3YWl0ICYmICgocXVldWUgPSBbXSkuZCA9IC0xKTtcblx0dmFyIGRlcFF1ZXVlcyA9IG5ldyBTZXQoKTtcblx0dmFyIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cztcblx0dmFyIGN1cnJlbnREZXBzO1xuXHR2YXIgb3V0ZXJSZXNvbHZlO1xuXHR2YXIgcmVqZWN0O1xuXHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWopID0+IHtcblx0XHRyZWplY3QgPSByZWo7XG5cdFx0b3V0ZXJSZXNvbHZlID0gcmVzb2x2ZTtcblx0fSk7XG5cdHByb21pc2Vbd2VicGFja0V4cG9ydHNdID0gZXhwb3J0cztcblx0cHJvbWlzZVt3ZWJwYWNrUXVldWVzXSA9IChmbikgPT4gKHF1ZXVlICYmIGZuKHF1ZXVlKSwgZGVwUXVldWVzLmZvckVhY2goZm4pLCBwcm9taXNlW1wiY2F0Y2hcIl0oeCA9PiB7fSkpO1xuXHRtb2R1bGUuZXhwb3J0cyA9IHByb21pc2U7XG5cdGJvZHkoKGRlcHMpID0+IHtcblx0XHRjdXJyZW50RGVwcyA9IHdyYXBEZXBzKGRlcHMpO1xuXHRcdHZhciBmbjtcblx0XHR2YXIgZ2V0UmVzdWx0ID0gKCkgPT4gKGN1cnJlbnREZXBzLm1hcCgoZCkgPT4ge1xuXHRcdFx0aWYoZFt3ZWJwYWNrRXJyb3JdKSB0aHJvdyBkW3dlYnBhY2tFcnJvcl07XG5cdFx0XHRyZXR1cm4gZFt3ZWJwYWNrRXhwb3J0c107XG5cdFx0fSkpXG5cdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuXHRcdFx0Zm4gPSAoKSA9PiAocmVzb2x2ZShnZXRSZXN1bHQpKTtcblx0XHRcdGZuLnIgPSAwO1xuXHRcdFx0dmFyIGZuUXVldWUgPSAocSkgPT4gKHEgIT09IHF1ZXVlICYmICFkZXBRdWV1ZXMuaGFzKHEpICYmIChkZXBRdWV1ZXMuYWRkKHEpLCBxICYmICFxLmQgJiYgKGZuLnIrKywgcS5wdXNoKGZuKSkpKTtcblx0XHRcdGN1cnJlbnREZXBzLm1hcCgoZGVwKSA9PiAoZGVwW3dlYnBhY2tRdWV1ZXNdKGZuUXVldWUpKSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGZuLnIgPyBwcm9taXNlIDogZ2V0UmVzdWx0KCk7XG5cdH0sIChlcnIpID0+ICgoZXJyID8gcmVqZWN0KHByb21pc2Vbd2VicGFja0Vycm9yXSA9IGVycikgOiBvdXRlclJlc29sdmUoZXhwb3J0cykpLCByZXNvbHZlUXVldWUocXVldWUpKSk7XG5cdHF1ZXVlICYmIHF1ZXVlLmQgPCAwICYmIChxdWV1ZS5kID0gMCk7XG59OyIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubm1kID0gKG1vZHVsZSkgPT4ge1xuXHRtb2R1bGUucGF0aHMgPSBbXTtcblx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRyZXR1cm4gbW9kdWxlO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiOyIsIiIsIi8vIHN0YXJ0dXBcbi8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLy8gVGhpcyBlbnRyeSBtb2R1bGUgdXNlZCAnbW9kdWxlJyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4iLCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=